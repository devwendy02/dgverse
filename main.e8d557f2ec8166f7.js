(self.webpackChunkapp_dogeverse = self.webpackChunkapp_dogeverse || []).push([
    [179], {
        56936: function(et, I, T) {
            "use strict";
            var F = this && this.__importDefault || function(Ae) {
                return Ae && Ae.__esModule ? Ae : {
                    default: Ae
                }
            };
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.map = I.array = I.rustEnum = I.str = I.vecU8 = I.tagged = I.vec = I.bool = I.option = I.publicKey = I.i256 = I.u256 = I.i128 = I.u128 = I.i64 = I.u64 = I.struct = I.f64 = I.f32 = I.i32 = I.u32 = I.i16 = I.u16 = I.i8 = I.u8 = void 0;
            const K = T(45815),
                q = T(45151),
                ne = F(T(62662));
            var S = T(45815);
            Object.defineProperty(I, "u8", {
                enumerable: !0,
                get: function() {
                    return S.u8
                }
            }), Object.defineProperty(I, "i8", {
                enumerable: !0,
                get: function() {
                    return S.s8
                }
            }), Object.defineProperty(I, "u16", {
                enumerable: !0,
                get: function() {
                    return S.u16
                }
            }), Object.defineProperty(I, "i16", {
                enumerable: !0,
                get: function() {
                    return S.s16
                }
            }), Object.defineProperty(I, "u32", {
                enumerable: !0,
                get: function() {
                    return S.u32
                }
            }), Object.defineProperty(I, "i32", {
                enumerable: !0,
                get: function() {
                    return S.s32
                }
            }), Object.defineProperty(I, "f32", {
                enumerable: !0,
                get: function() {
                    return S.f32
                }
            }), Object.defineProperty(I, "f64", {
                enumerable: !0,
                get: function() {
                    return S.f64
                }
            }), Object.defineProperty(I, "struct", {
                enumerable: !0,
                get: function() {
                    return S.struct
                }
            });
            class j extends K.Layout {
                constructor(Ie, $, f) {
                    super(Ie, f), this.blob = (0, K.blob)(Ie), this.signed = $
                }
                decode(Ie, $ = 0) {
                    const f = new ne.default(this.blob.decode(Ie, $), 10, "le");
                    return this.signed ? f.fromTwos(8 * this.span).clone() : f
                }
                encode(Ie, $, f = 0) {
                    return this.signed && (Ie = Ie.toTwos(8 * this.span)), this.blob.encode(Ie.toArrayLike(Buffer, "le", this.span), $, f)
                }
            }

            function C(Ae) {
                return new j(8, !1, Ae)
            }
            I.u64 = C, I.i64 = function z(Ae) {
                return new j(8, !0, Ae)
            }, I.u128 = function H(Ae) {
                return new j(16, !1, Ae)
            }, I.i128 = function Y(Ae) {
                return new j(16, !0, Ae)
            }, I.u256 = function Z(Ae) {
                return new j(32, !1, Ae)
            }, I.i256 = function le(Ae) {
                return new j(32, !0, Ae)
            };
            class re extends K.Layout {
                constructor(Ie, $, f, v) {
                    super(Ie.span, v), this.layout = Ie, this.decoder = $, this.encoder = f
                }
                decode(Ie, $) {
                    return this.decoder(this.layout.decode(Ie, $))
                }
                encode(Ie, $, f) {
                    return this.layout.encode(this.encoder(Ie), $, f)
                }
                getSpan(Ie, $) {
                    return this.layout.getSpan(Ie, $)
                }
            }
            I.publicKey = function de(Ae) {
                return new re((0, K.blob)(32), Ie => new q.PublicKey(Ie), Ie => Ie.toBuffer(), Ae)
            };
            class Se extends K.Layout {
                constructor(Ie, $) {
                    super(-1, $), this.layout = Ie, this.discriminator = (0, K.u8)()
                }
                encode(Ie, $, f = 0) {
                    return null == Ie ? this.discriminator.encode(0, $, f) : (this.discriminator.encode(1, $, f), this.layout.encode(Ie, $, f + 1) + 1)
                }
                decode(Ie, $ = 0) {
                    const f = this.discriminator.decode(Ie, $);
                    if (0 === f) return null;
                    if (1 === f) return this.layout.decode(Ie, $ + 1);
                    throw new Error("Invalid option " + this.property)
                }
                getSpan(Ie, $ = 0) {
                    const f = this.discriminator.decode(Ie, $);
                    if (0 === f) return 1;
                    if (1 === f) return this.layout.getSpan(Ie, $ + 1) + 1;
                    throw new Error("Invalid option " + this.property)
                }
            }

            function we(Ae) {
                if (0 === Ae) return !1;
                if (1 === Ae) return !0;
                throw new Error("Invalid bool: " + Ae)
            }

            function ve(Ae) {
                return Ae ? 1 : 0
            }

            function Me(Ae) {
                const Ie = (0, K.u32)("length"),
                    $ = (0, K.struct)([Ie, (0, K.blob)((0, K.offset)(Ie, -Ie.span), "data")]);
                return new re($, ({
                    data: f
                }) => f, f => ({
                    data: f
                }), Ae)
            }
            I.option = function me(Ae, Ie) {
                return new Se(Ae, Ie)
            }, I.bool = function Ce(Ae) {
                return new re((0, K.u8)(), we, ve, Ae)
            }, I.vec = function De(Ae, Ie) {
                const $ = (0, K.u32)("length"),
                    f = (0, K.struct)([$, (0, K.seq)(Ae, (0, K.offset)($, -$.span), "values")]);
                return new re(f, ({
                    values: v
                }) => v, v => ({
                    values: v
                }), Ie)
            }, I.tagged = function ae(Ae, Ie, $) {
                const f = (0, K.struct)([C("tag"), Ie.replicate("data")]);
                return new re(f, function v({
                    tag: M,
                    data: U
                }) {
                    if (!M.eq(Ae)) throw new Error("Invalid tag, expected: " + Ae.toString("hex") + ", got: " + M.toString("hex"));
                    return U
                }, M => ({
                    tag: Ae,
                    data: M
                }), $)
            }, I.vecU8 = Me, I.str = function Le(Ae) {
                return new re(Me(), Ie => Ie.toString("utf-8"), Ie => Buffer.from(Ie, "utf-8"), Ae)
            }, I.rustEnum = function L(Ae, Ie, $) {
                const f = (0, K.union)($ ? ? (0, K.u8)(), Ie);
                return Ae.forEach((v, M) => f.addVariant(M, v, v.property)), f
            }, I.array = function ue(Ae, Ie, $) {
                const f = (0, K.struct)([(0, K.seq)(Ae, Ie, "values")]);
                return new re(f, ({
                    values: v
                }) => v, v => ({
                    values: v
                }), $)
            };
            class Te extends K.Layout {
                constructor(Ie, $, f) {
                    super(Ie.span + $.span, f), this.keyLayout = Ie, this.valueLayout = $
                }
                decode(Ie, $) {
                    return [this.keyLayout.decode(Ie, $ = $ || 0), this.valueLayout.decode(Ie, $ + this.keyLayout.getSpan(Ie, $))]
                }
                encode(Ie, $, f) {
                    const v = this.keyLayout.encode(Ie[0], $, f = f || 0);
                    return v + this.valueLayout.encode(Ie[1], $, f + v)
                }
                getSpan(Ie, $) {
                    return this.keyLayout.getSpan(Ie, $) + this.valueLayout.getSpan(Ie, $)
                }
            }
            I.map = function xe(Ae, Ie, $) {
                const f = (0, K.u32)("length"),
                    v = (0, K.struct)([f, (0, K.seq)(new Te(Ae, Ie), (0, K.offset)(f, -f.span), "values")]);
                return new re(v, ({
                    values: M
                }) => new Map(M), M => ({
                    values: Array.from(M.entries())
                }), $)
            }
        },
        65724: (et, I, T) => {
            "use strict";

            function F(t) {
                return "function" == typeof t
            }

            function K(t) {
                const e = t(i => {
                    Error.call(i), i.stack = (new Error).stack
                });
                return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e
            }
            const q = K(t => function(e) {
                t(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((i,r)=>`${r+1}) ${i.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e
            });

            function ne(t, n) {
                if (t) {
                    const e = t.indexOf(n);
                    0 <= e && t.splice(e, 1)
                }
            }
            class S {
                constructor(n) {
                    this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null
                }
                unsubscribe() {
                    let n;
                    if (!this.closed) {
                        this.closed = !0;
                        const {
                            _parentage: e
                        } = this;
                        if (e)
                            if (this._parentage = null, Array.isArray(e))
                                for (const s of e) s.remove(this);
                            else e.remove(this);
                        const {
                            initialTeardown: i
                        } = this;
                        if (F(i)) try {
                            i()
                        } catch (s) {
                            n = s instanceof q ? s.errors : [s]
                        }
                        const {
                            _finalizers: r
                        } = this;
                        if (r) {
                            this._finalizers = null;
                            for (const s of r) try {
                                z(s)
                            } catch (o) {
                                n = n ? ? [], o instanceof q ? n = [...n, ...o.errors] : n.push(o)
                            }
                        }
                        if (n) throw new q(n)
                    }
                }
                add(n) {
                    var e;
                    if (n && n !== this)
                        if (this.closed) z(n);
                        else {
                            if (n instanceof S) {
                                if (n.closed || n._hasParent(this)) return;
                                n._addParent(this)
                            }(this._finalizers = null !== (e = this._finalizers) && void 0 !== e ? e : []).push(n)
                        }
                }
                _hasParent(n) {
                    const {
                        _parentage: e
                    } = this;
                    return e === n || Array.isArray(e) && e.includes(n)
                }
                _addParent(n) {
                    const {
                        _parentage: e
                    } = this;
                    this._parentage = Array.isArray(e) ? (e.push(n), e) : e ? [e, n] : n
                }
                _removeParent(n) {
                    const {
                        _parentage: e
                    } = this;
                    e === n ? this._parentage = null : Array.isArray(e) && ne(e, n)
                }
                remove(n) {
                    const {
                        _finalizers: e
                    } = this;
                    e && ne(e, n), n instanceof S && n._removeParent(this)
                }
            }
            S.EMPTY = (() => {
                const t = new S;
                return t.closed = !0, t
            })();
            const j = S.EMPTY;

            function C(t) {
                return t instanceof S || t && "closed" in t && F(t.remove) && F(t.add) && F(t.unsubscribe)
            }

            function z(t) {
                F(t) ? t() : t.unsubscribe()
            }
            const H = {
                    onUnhandledError: null,
                    onStoppedNotification: null,
                    Promise: void 0,
                    useDeprecatedSynchronousErrorHandling: !1,
                    useDeprecatedNextContext: !1
                },
                Y = {
                    setTimeout(t, n, ...e) {
                        const {
                            delegate: i
                        } = Y;
                        return i ? .setTimeout ? i.setTimeout(t, n, ...e) : setTimeout(t, n, ...e)
                    },
                    clearTimeout(t) {
                        const {
                            delegate: n
                        } = Y;
                        return (n ? .clearTimeout || clearTimeout)(t)
                    },
                    delegate: void 0
                };

            function Z(t) {
                Y.setTimeout(() => {
                    const {
                        onUnhandledError: n
                    } = H;
                    if (!n) throw t;
                    n(t)
                })
            }

            function le() {}
            const re = me("C", void 0, void 0);

            function me(t, n, e) {
                return {
                    kind: t,
                    value: n,
                    error: e
                }
            }
            let Ce = null;

            function we(t) {
                if (H.useDeprecatedSynchronousErrorHandling) {
                    const n = !Ce;
                    if (n && (Ce = {
                            errorThrown: !1,
                            error: null
                        }), t(), n) {
                        const {
                            errorThrown: e,
                            error: i
                        } = Ce;
                        if (Ce = null, e) throw i
                    }
                } else t()
            }
            class De extends S {
                constructor(n) {
                    super(), this.isStopped = !1, n ? (this.destination = n, C(n) && n.add(this)) : this.destination = Ae
                }
                static create(n, e, i) {
                    return new L(n, e, i)
                }
                next(n) {
                    this.isStopped ? xe(function Se(t) {
                        return me("N", t, void 0)
                    }(n), this) : this._next(n)
                }
                error(n) {
                    this.isStopped ? xe(function de(t) {
                        return me("E", void 0, t)
                    }(n), this) : (this.isStopped = !0, this._error(n))
                }
                complete() {
                    this.isStopped ? xe(re, this) : (this.isStopped = !0, this._complete())
                }
                unsubscribe() {
                    this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null)
                }
                _next(n) {
                    this.destination.next(n)
                }
                _error(n) {
                    try {
                        this.destination.error(n)
                    } finally {
                        this.unsubscribe()
                    }
                }
                _complete() {
                    try {
                        this.destination.complete()
                    } finally {
                        this.unsubscribe()
                    }
                }
            }
            const ae = Function.prototype.bind;

            function Me(t, n) {
                return ae.call(t, n)
            }
            class Le {
                constructor(n) {
                    this.partialObserver = n
                }
                next(n) {
                    const {
                        partialObserver: e
                    } = this;
                    if (e.next) try {
                        e.next(n)
                    } catch (i) {
                        ue(i)
                    }
                }
                error(n) {
                    const {
                        partialObserver: e
                    } = this;
                    if (e.error) try {
                        e.error(n)
                    } catch (i) {
                        ue(i)
                    } else ue(n)
                }
                complete() {
                    const {
                        partialObserver: n
                    } = this;
                    if (n.complete) try {
                        n.complete()
                    } catch (e) {
                        ue(e)
                    }
                }
            }
            class L extends De {
                constructor(n, e, i) {
                    let r;
                    if (super(), F(n) || !n) r = {
                        next: n ? ? void 0,
                        error: e ? ? void 0,
                        complete: i ? ? void 0
                    };
                    else {
                        let s;
                        this && H.useDeprecatedNextContext ? (s = Object.create(n), s.unsubscribe = () => this.unsubscribe(), r = {
                            next: n.next && Me(n.next, s),
                            error: n.error && Me(n.error, s),
                            complete: n.complete && Me(n.complete, s)
                        }) : r = n
                    }
                    this.destination = new Le(r)
                }
            }

            function ue(t) {
                H.useDeprecatedSynchronousErrorHandling ? function ve(t) {
                    H.useDeprecatedSynchronousErrorHandling && Ce && (Ce.errorThrown = !0, Ce.error = t)
                }(t) : Z(t)
            }

            function xe(t, n) {
                const {
                    onStoppedNotification: e
                } = H;
                e && Y.setTimeout(() => e(t, n))
            }
            const Ae = {
                    closed: !0,
                    next: le,
                    error: function Te(t) {
                        throw t
                    },
                    complete: le
                },
                Ie = "function" == typeof Symbol && Symbol.observable || "@@observable";

            function $(t) {
                return t
            }

            function v(t) {
                return 0 === t.length ? $ : 1 === t.length ? t[0] : function(e) {
                    return t.reduce((i, r) => r(i), e)
                }
            }
            let M = (() => {
                class t {
                    constructor(e) {
                        e && (this._subscribe = e)
                    }
                    lift(e) {
                        const i = new t;
                        return i.source = this, i.operator = e, i
                    }
                    subscribe(e, i, r) {
                        const s = function y(t) {
                            return t && t instanceof De || function G(t) {
                                return t && F(t.next) && F(t.error) && F(t.complete)
                            }(t) && C(t)
                        }(e) ? e : new L(e, i, r);
                        return we(() => {
                            const {
                                operator: o,
                                source: a
                            } = this;
                            s.add(o ? o.call(s, a) : a ? this._subscribe(s) : this._trySubscribe(s))
                        }), s
                    }
                    _trySubscribe(e) {
                        try {
                            return this._subscribe(e)
                        } catch (i) {
                            e.error(i)
                        }
                    }
                    forEach(e, i) {
                        return new(i = U(i))((r, s) => {
                            const o = new L({
                                next: a => {
                                    try {
                                        e(a)
                                    } catch (c) {
                                        s(c), o.unsubscribe()
                                    }
                                },
                                error: s,
                                complete: r
                            });
                            this.subscribe(o)
                        })
                    }
                    _subscribe(e) {
                        var i;
                        return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e)
                    }[Ie]() {
                        return this
                    }
                    pipe(...e) {
                        return v(e)(this)
                    }
                    toPromise(e) {
                        return new(e = U(e))((i, r) => {
                            let s;
                            this.subscribe(o => s = o, o => r(o), () => i(s))
                        })
                    }
                }
                return t.create = n => new t(n), t
            })();

            function U(t) {
                var n;
                return null !== (n = t ? ? H.Promise) && void 0 !== n ? n : Promise
            }
            const E = K(t => function() {
                t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
            });
            let A = (() => {
                class t extends M {
                    constructor() {
                        super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null
                    }
                    lift(e) {
                        const i = new b(this, this);
                        return i.operator = e, i
                    }
                    _throwIfClosed() {
                        if (this.closed) throw new E
                    }
                    next(e) {
                        we(() => {
                            if (this._throwIfClosed(), !this.isStopped) {
                                this.currentObservers || (this.currentObservers = Array.from(this.observers));
                                for (const i of this.currentObservers) i.next(e)
                            }
                        })
                    }
                    error(e) {
                        we(() => {
                            if (this._throwIfClosed(), !this.isStopped) {
                                this.hasError = this.isStopped = !0, this.thrownError = e;
                                const {
                                    observers: i
                                } = this;
                                for (; i.length;) i.shift().error(e)
                            }
                        })
                    }
                    complete() {
                        we(() => {
                            if (this._throwIfClosed(), !this.isStopped) {
                                this.isStopped = !0;
                                const {
                                    observers: e
                                } = this;
                                for (; e.length;) e.shift().complete()
                            }
                        })
                    }
                    unsubscribe() {
                        this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
                    }
                    get observed() {
                        var e;
                        return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0
                    }
                    _trySubscribe(e) {
                        return this._throwIfClosed(), super._trySubscribe(e)
                    }
                    _subscribe(e) {
                        return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e)
                    }
                    _innerSubscribe(e) {
                        const {
                            hasError: i,
                            isStopped: r,
                            observers: s
                        } = this;
                        return i || r ? j : (this.currentObservers = null, s.push(e), new S(() => {
                            this.currentObservers = null, ne(s, e)
                        }))
                    }
                    _checkFinalizedStatuses(e) {
                        const {
                            hasError: i,
                            thrownError: r,
                            isStopped: s
                        } = this;
                        i ? e.error(r) : s && e.complete()
                    }
                    asObservable() {
                        const e = new M;
                        return e.source = this, e
                    }
                }
                return t.create = (n, e) => new b(n, e), t
            })();
            class b extends A {
                constructor(n, e) {
                    super(), this.destination = n, this.source = e
                }
                next(n) {
                    var e, i;
                    null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, n)
                }
                error(n) {
                    var e, i;
                    null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, n)
                }
                complete() {
                    var n, e;
                    null === (e = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === e || e.call(n)
                }
                _subscribe(n) {
                    var e, i;
                    return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(n)) && void 0 !== i ? i : j
                }
            }

            function N(t) {
                return F(t ? .lift)
            }

            function R(t) {
                return n => {
                    if (N(n)) return n.lift(function(e) {
                        try {
                            return t(e, this)
                        } catch (i) {
                            this.error(i)
                        }
                    });
                    throw new TypeError("Unable to lift unknown Observable type")
                }
            }

            function Q(t, n, e, i, r) {
                return new Ee(t, n, e, i, r)
            }
            class Ee extends De {
                constructor(n, e, i, r, s, o) {
                    super(n), this.onFinalize = s, this.shouldUnsubscribe = o, this._next = e ? function(a) {
                        try {
                            e(a)
                        } catch (c) {
                            n.error(c)
                        }
                    } : super._next, this._error = r ? function(a) {
                        try {
                            r(a)
                        } catch (c) {
                            n.error(c)
                        } finally {
                            this.unsubscribe()
                        }
                    } : super._error, this._complete = i ? function() {
                        try {
                            i()
                        } catch (a) {
                            n.error(a)
                        } finally {
                            this.unsubscribe()
                        }
                    } : super._complete
                }
                unsubscribe() {
                    var n;
                    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                        const {
                            closed: e
                        } = this;
                        super.unsubscribe(), !e && (null === (n = this.onFinalize) || void 0 === n || n.call(this))
                    }
                }
            }

            function Fe(t, n) {
                return R((e, i) => {
                    let r = 0;
                    e.subscribe(Q(i, s => {
                        i.next(t.call(n, s, r++))
                    }))
                })
            }
            var Ge = T(97582);
            const wt = t => t && "number" == typeof t.length && "function" != typeof t;

            function Vt(t) {
                return F(t ? .then)
            }

            function Mt(t) {
                return F(t[Ie])
            }

            function sn(t) {
                return Symbol.asyncIterator && F(t ? .[Symbol.asyncIterator])
            }

            function ei(t) {
                return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
            }
            const jn = function ai() {
                return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
            }();

            function An(t) {
                return F(t ? .[jn])
            }

            function ui(t) {
                return (0, Ge.__asyncGenerator)(this, arguments, function*() {
                    const e = t.getReader();
                    try {
                        for (;;) {
                            const {
                                value: i,
                                done: r
                            } = yield(0, Ge.__await)(e.read());
                            if (r) return yield(0, Ge.__await)(void 0);
                            yield yield(0, Ge.__await)(i)
                        }
                    } finally {
                        e.releaseLock()
                    }
                })
            }

            function Mi(t) {
                return F(t ? .getReader)
            }

            function ji(t) {
                if (t instanceof M) return t;
                if (null != t) {
                    if (Mt(t)) return function Wn(t) {
                        return new M(n => {
                            const e = t[Ie]();
                            if (F(e.subscribe)) return e.subscribe(n);
                            throw new TypeError("Provided object does not correctly implement Symbol.observable")
                        })
                    }(t);
                    if (wt(t)) return function kn(t) {
                        return new M(n => {
                            for (let e = 0; e < t.length && !n.closed; e++) n.next(t[e]);
                            n.complete()
                        })
                    }(t);
                    if (Vt(t)) return function Bi(t) {
                        return new M(n => {
                            t.then(e => {
                                n.closed || (n.next(e), n.complete())
                            }, e => n.error(e)).then(null, Z)
                        })
                    }(t);
                    if (sn(t)) return en(t);
                    if (An(t)) return function ci(t) {
                        return new M(n => {
                            for (const e of t)
                                if (n.next(e), n.closed) return;
                            n.complete()
                        })
                    }(t);
                    if (Mi(t)) return function Ii(t) {
                        return en(ui(t))
                    }(t)
                }
                throw ei(t)
            }

            function en(t) {
                return new M(n => {
                    (function pe(t, n) {
                        var e, i, r, s;
                        return (0, Ge.__awaiter)(this, void 0, void 0, function*() {
                            try {
                                for (e = (0, Ge.__asyncValues)(t); !(i = yield e.next()).done;)
                                    if (n.next(i.value), n.closed) return
                            } catch (o) {
                                r = {
                                    error: o
                                }
                            } finally {
                                try {
                                    i && !i.done && (s = e.return) && (yield s.call(e))
                                } finally {
                                    if (r) throw r.error
                                }
                            }
                            n.complete()
                        })
                    })(t, n).catch(e => n.error(e))
                })
            }

            function O(t, n, e, i = 0, r = !1) {
                const s = n.schedule(function() {
                    e(), r ? t.add(this.schedule(null, i)) : this.unsubscribe()
                }, i);
                if (t.add(s), !r) return s
            }

            function ke(t, n, e = 1 / 0) {
                return F(n) ? ke((i, r) => Fe((s, o) => n(i, s, r, o))(ji(t(i, r))), e) : ("number" == typeof n && (e = n), R((i, r) => function W(t, n, e, i, r, s, o, a) {
                    const c = [];
                    let u = 0,
                        h = 0,
                        m = !1;
                    const x = () => {
                            m && !c.length && !u && n.complete()
                        },
                        D = te => u < i ? V(te) : c.push(te),
                        V = te => {
                            s && n.next(te), u++;
                            let ee = !1;
                            ji(e(te, h++)).subscribe(Q(n, _e => {
                                r ? .(_e), s ? D(_e) : n.next(_e)
                            }, () => {
                                ee = !0
                            }, void 0, () => {
                                if (ee) try {
                                    for (u--; c.length && u < i;) {
                                        const _e = c.shift();
                                        o ? O(n, o, () => V(_e)) : V(_e)
                                    }
                                    x()
                                } catch (_e) {
                                    n.error(_e)
                                }
                            }))
                        };
                    return t.subscribe(Q(n, D, () => {
                        m = !0, x()
                    })), () => {
                        a ? .()
                    }
                }(i, r, t, e)))
            }

            function je(t = 1 / 0) {
                return ke($, t)
            }
            const Qe = new M(t => t.complete());

            function Kn(t) {
                return t && F(t.schedule)
            }

            function mn(t) {
                return t[t.length - 1]
            }

            function $n(t) {
                return F(mn(t)) ? t.pop() : void 0
            }

            function _n(t) {
                return Kn(mn(t)) ? t.pop() : void 0
            }

            function pi(t, n = 0) {
                return R((e, i) => {
                    e.subscribe(Q(i, r => O(i, t, () => i.next(r), n), () => O(i, t, () => i.complete(), n), r => O(i, t, () => i.error(r), n)))
                })
            }

            function ca(t, n = 0) {
                return R((e, i) => {
                    i.add(t.schedule(() => e.subscribe(i), n))
                })
            }

            function Rn(t, n) {
                if (!t) throw new Error("Iterable cannot be null");
                return new M(e => {
                    O(e, n, () => {
                        const i = t[Symbol.asyncIterator]();
                        O(e, n, () => {
                            i.next().then(r => {
                                r.done ? e.complete() : e.next(r.value)
                            })
                        }, 0, !0)
                    })
                })
            }

            function gn(t, n) {
                return n ? function Ji(t, n) {
                    if (null != t) {
                        if (Mt(t)) return function yi(t, n) {
                            return ji(t).pipe(ca(n), pi(n))
                        }(t, n);
                        if (wt(t)) return function qo(t, n) {
                            return new M(e => {
                                let i = 0;
                                return n.schedule(function() {
                                    i === t.length ? e.complete() : (e.next(t[i++]), e.closed || this.schedule())
                                })
                            })
                        }(t, n);
                        if (Vt(t)) return function hr(t, n) {
                            return ji(t).pipe(ca(n), pi(n))
                        }(t, n);
                        if (sn(t)) return Rn(t, n);
                        if (An(t)) return function yr(t, n) {
                            return new M(e => {
                                let i;
                                return O(e, n, () => {
                                    i = t[jn](), O(e, n, () => {
                                        let r, s;
                                        try {
                                            ({
                                                value: r,
                                                done: s
                                            } = i.next())
                                        } catch (o) {
                                            return void e.error(o)
                                        }
                                        s ? e.complete() : e.next(r)
                                    }, 0, !0)
                                }), () => F(i ? .return) && i.return()
                            })
                        }(t, n);
                        if (Mi(t)) return function Ti(t, n) {
                            return Rn(ui(t), n)
                        }(t, n)
                    }
                    throw ei(t)
                }(t, n) : ji(t)
            }

            function Si(...t) {
                const n = _n(t),
                    e = function Sn(t, n) {
                        return "number" == typeof mn(t) ? t.pop() : n
                    }(t, 1 / 0),
                    i = t;
                return i.length ? 1 === i.length ? ji(i[0]) : je(e)(gn(i, n)) : Qe
            }
            class qn extends A {
                constructor(n) {
                    super(), this._value = n
                }
                get value() {
                    return this.getValue()
                }
                _subscribe(n) {
                    const e = super._subscribe(n);
                    return !e.closed && n.next(this._value), e
                }
                getValue() {
                    const {
                        hasError: n,
                        thrownError: e,
                        _value: i
                    } = this;
                    if (n) throw e;
                    return this._throwIfClosed(), i
                }
                next(n) {
                    super.next(this._value = n)
                }
            }

            function Ve(...t) {
                return gn(t, _n(t))
            }

            function at(t = {}) {
                const {
                    connector: n = (() => new A),
                    resetOnError: e = !0,
                    resetOnComplete: i = !0,
                    resetOnRefCountZero: r = !0
                } = t;
                return s => {
                    let o, a, c, u = 0,
                        h = !1,
                        m = !1;
                    const x = () => {
                            a ? .unsubscribe(), a = void 0
                        },
                        D = () => {
                            x(), o = c = void 0, h = m = !1
                        },
                        V = () => {
                            const te = o;
                            D(), te ? .unsubscribe()
                        };
                    return R((te, ee) => {
                        u++, !m && !h && x();
                        const _e = c = c ? ? n();
                        ee.add(() => {
                            u--, 0 === u && !m && !h && (a = pt(V, r))
                        }), _e.subscribe(ee), !o && u > 0 && (o = new L({
                            next: ye => _e.next(ye),
                            error: ye => {
                                m = !0, x(), a = pt(D, e, ye), _e.error(ye)
                            },
                            complete: () => {
                                h = !0, x(), a = pt(D, i), _e.complete()
                            }
                        }), ji(te).subscribe(o))
                    })(s)
                }
            }

            function pt(t, n, ...e) {
                if (!0 === n) return void t();
                if (!1 === n) return;
                const i = new L({
                    next: () => {
                        i.unsubscribe(), t()
                    }
                });
                return ji(n(...e)).subscribe(i)
            }

            function St(t, n) {
                return R((e, i) => {
                    let r = null,
                        s = 0,
                        o = !1;
                    const a = () => o && !r && i.complete();
                    e.subscribe(Q(i, c => {
                        r ? .unsubscribe();
                        let u = 0;
                        const h = s++;
                        ji(t(c, h)).subscribe(r = Q(i, m => i.next(n ? n(c, m, h, u++) : m), () => {
                            r = null, a()
                        }))
                    }, () => {
                        o = !0, a()
                    }))
                })
            }

            function Nn(t, n) {
                return t === n
            }

            function Ut(t) {
                for (let n in t)
                    if (t[n] === Ut) return n;
                throw Error("Could not find renamed property on target object.")
            }

            function or(t, n) {
                for (const e in n) n.hasOwnProperty(e) && !t.hasOwnProperty(e) && (t[e] = n[e])
            }

            function ti(t) {
                if ("string" == typeof t) return t;
                if (Array.isArray(t)) return "[" + t.map(ti).join(", ") + "]";
                if (null == t) return "" + t;
                if (t.overriddenName) return `${t.overriddenName}`;
                if (t.name) return `${t.name}`;
                const n = t.toString();
                if (null == n) return "" + n;
                const e = n.indexOf("\n");
                return -1 === e ? n : n.substring(0, e)
            }

            function qi(t, n) {
                return null == t || "" === t ? null === n ? "" : n : null == n || "" === n ? t : t + " " + n
            }
            const Xs = Ut({
                __forward_ref__: Ut
            });

            function Xn(t) {
                return t.__forward_ref__ = Xn, t.toString = function() {
                    return ti(this())
                }, t
            }

            function an(t) {
                return As(t) ? t() : t
            }

            function As(t) {
                return "function" == typeof t && t.hasOwnProperty(Xs) && t.__forward_ref__ === Xn
            }

            function wo(t) {
                return t && !!t.\u0275providers
            }
            const Wr = "https://g.co/ng/security#xss";
            class mt extends Error {
                constructor(n, e) {
                    super(function xo(t, n) {
                        return `NG0${Math.abs(t)}${n?": "+n:""}`
                    }(n, e)), this.code = n
                }
            }

            function Zn(t) {
                return "string" == typeof t ? t : null == t ? "" : String(t)
            }

            function Qs(t, n) {
                throw new mt(-201, !1)
            }

            function fs(t, n) {
                null == t && function Mn(t, n, e, i) {
                    throw new Error(`ASSERTION ERROR: ${t}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${n} <=Actual]`))
                }(n, t, null, "!=")
            }

            function Dt(t) {
                return {
                    token: t.token,
                    providedIn: t.providedIn || null,
                    factory: t.factory,
                    value: void 0
                }
            }

            function wi(t) {
                return {
                    providers: t.providers || [],
                    imports: t.imports || []
                }
            }

            function Ac(t) {
                return el(t, lt) || el(t, ot)
            }

            function el(t, n) {
                return t.hasOwnProperty(n) ? t[n] : null
            }

            function kc(t) {
                return t && (t.hasOwnProperty(Ye) || t.hasOwnProperty(Kt)) ? t[Ye] : null
            }
            const lt = Ut({\
                    u0275prov: Ut
                }),
                Ye = Ut({\
                    u0275inj: Ut
                }),
                ot = Ut({
                    ngInjectableDef: Ut
                }),
                Kt = Ut({
                    ngInjectorDef: Ut
                });
            var kt = function(t) {
                return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t
            }(kt || {});
            let Fn;

            function Ei(t) {
                const n = Fn;
                return Fn = t, n
            }

            function ks(t, n, e) {
                const i = Ac(t);
                return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & kt.Optional ? null : void 0 !== n ? n : void Qs(ti(t))
            }
            const Di = globalThis;
            class nn {
                constructor(n, e) {
                    this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = Dt({
                        token: this,
                        providedIn: e.providedIn || "root",
                        factory: e.factory
                    }))
                }
                get multi() {
                    return this
                }
                toString() {
                    return `InjectionToken ${this._desc}`
                }
            }
            const $s = {},
                Ml = "__NG_DI_FLAG__",
                Mc = "ngTempTokenPath",
                vu = /\n/gm,
                He = "__source";
            let La;

            function Ra(t) {
                const n = La;
                return La = t, n
            }

            function Ro(t, n = kt.Default) {
                if (void 0 === La) throw new mt(-203, !1);
                return null === La ? ks(t, void 0, n) : La.get(t, n & kt.Optional ? null : void 0, n)
            }

            function _t(t, n = kt.Default) {
                return (function _r() {
                    return Fn
                }() || Ro)(an(t), n)
            }

            function vn(t, n = kt.Default) {
                return _t(t, sc(n))
            }

            function sc(t) {
                return typeof t > "u" || "number" == typeof t ? t : 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)
            }

            function Pc(t) {
                const n = [];
                for (let e = 0; e < t.length; e++) {
                    const i = an(t[e]);
                    if (Array.isArray(i)) {
                        if (0 === i.length) throw new mt(900, !1);
                        let r, s = kt.Default;
                        for (let o = 0; o < i.length; o++) {
                            const a = i[o],
                                c = is(a);
                            "number" == typeof c ? -1 === c ? r = a.token : s |= c : r = a
                        }
                        n.push(_t(r, s))
                    } else n.push(_t(i))
                }
                return n
            }

            function Is(t, n) {
                return t[Ml] = n, t.prototype[Ml] = n, t
            }

            function is(t) {
                return t[Ml]
            }

            function zs(t) {
                return {
                    toString: t
                }.toString()
            }
            var pa = function(t) {
                    return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t
                }(pa || {}),
                ls = function(t) {
                    return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t
                }(ls || {});
            const xs = {},
                Vn = [],
                tl = Ut({\
                    u0275cmp: Ut
                }),
                gd = Ut({\
                    u0275dir: Ut
                }),
                nl = Ut({\
                    u0275pipe: Ut
                }),
                Ph = Ut({\
                    u0275mod: Ut
                }),
                Ba = Ut({\
                    u0275fac: Ut
                }),
                Pl = Ut({
                    __NG_ELEMENT_ID__: Ut
                }),
                Oh = Ut({
                    __NG_ENV_ID__: Ut
                });

            function yd(t, n, e) {
                let i = t.length;
                for (;;) {
                    const r = t.indexOf(n, e);
                    if (-1 === r) return r;
                    if (0 === r || t.charCodeAt(r - 1) <= 32) {
                        const s = n.length;
                        if (r + s === i || t.charCodeAt(r + s) <= 32) return r
                    }
                    e = r + 1
                }
            }

            function dn(t, n, e) {
                let i = 0;
                for (; i < e.length;) {
                    const r = e[i];
                    if ("number" == typeof r) {
                        if (0 !== r) break;
                        i++;
                        const s = e[i++],
                            o = e[i++],
                            a = e[i++];
                        t.setAttribute(n, o, a, s)
                    } else {
                        const s = r,
                            o = e[++i];
                        _d(s) ? t.setProperty(n, s, o) : t.setAttribute(n, s, o), i++
                    }
                }
                return i
            }

            function Bo(t) {
                return 3 === t || 4 === t || 6 === t
            }

            function _d(t) {
                return 64 === t.charCodeAt(0)
            }

            function il(t, n) {
                if (null !== n && 0 !== n.length)
                    if (null === t || 0 === t.length) t = n.slice();
                    else {
                        let e = -1;
                        for (let i = 0; i < n.length; i++) {
                            const r = n[i];
                            "number" == typeof r ? e = r : 0 === e || Ol(t, e, r, null, -1 === e || 2 === e ? n[++i] : null)
                        }
                    }
                return t
            }

            function Ol(t, n, e, i, r) {
                let s = 0,
                    o = t.length;
                if (-1 === n) o = -1;
                else
                    for (; s < t.length;) {
                        const a = t[s++];
                        if ("number" == typeof a) {
                            if (a === n) {
                                o = -1;
                                break
                            }
                            if (a > n) {
                                o = s - 1;
                                break
                            }
                        }
                    }
                for (; s < t.length;) {
                    const a = t[s];
                    if ("number" == typeof a) break;
                    if (a === e) {
                        if (null === i) return void(null !== r && (t[s + 1] = r));
                        if (i === t[s + 1]) return void(t[s + 2] = r)
                    }
                    s++, null !== i && s++, null !== r && s++
                } - 1 !== o && (t.splice(o, 0, n), s = o + 1), t.splice(s++, 0, e), null !== i && t.splice(s++, 0, i), null !== r && t.splice(s++, 0, r)
            }
            const Ll = "ng-template";

            function Lh(t, n, e) {
                let i = 0,
                    r = !0;
                for (; i < t.length;) {
                    let s = t[i++];
                    if ("string" == typeof s && r) {
                        const o = t[i++];
                        if (e && "class" === s && -1 !== yd(o.toLowerCase(), n, 0)) return !0
                    } else {
                        if (1 === s) {
                            for (; i < t.length && "string" == typeof(s = t[i++]);)
                                if (s.toLowerCase() === n) return !0;
                            return !1
                        }
                        "number" == typeof s && (r = !1)
                    }
                }
                return !1
            }

            function Rh(t) {
                return 4 === t.type && t.value !== Ll
            }

            function Pr(t, n, e) {
                return n === (4 !== t.type || e ? t.value : Ll)
            }

            function Bh(t, n, e) {
                let i = 4;
                const r = t.attrs || [],
                    s = function Yn(t) {
                        for (let n = 0; n < t.length; n++)
                            if (Bo(t[n])) return n;
                        return t.length
                    }(r);
                let o = !1;
                for (let a = 0; a < n.length; a++) {
                    const c = n[a];
                    if ("number" != typeof c) {
                        if (!o)
                            if (4 & i) {
                                if (i = 2 | 1 & i, "" !== c && !Pr(t, c, e) || "" === c && 1 === n.length) {
                                    if (to(i)) return !1;
                                    o = !0
                                }
                            } else {
                                const u = 8 & i ? c : n[++a];
                                if (8 & i && null !== t.attrs) {
                                    if (!Lh(t.attrs, u, e)) {
                                        if (to(i)) return !1;
                                        o = !0
                                    }
                                    continue
                                }
                                const m = fn(8 & i ? "class" : c, r, Rh(t), e);
                                if (-1 === m) {
                                    if (to(i)) return !1;
                                    o = !0;
                                    continue
                                }
                                if ("" !== u) {
                                    let x;
                                    x = m > s ? "" : r[m + 1].toLowerCase();
                                    const D = 8 & i ? x : null;
                                    if (D && -1 !== yd(D, u, 0) || 2 & i && u !== x) {
                                        if (to(i)) return !1;
                                        o = !0
                                    }
                                }
                            }
                    } else {
                        if (!o && !to(i) && !to(c)) return !1;
                        if (o && to(c)) continue;
                        o = !1, i = c | 1 & i
                    }
                }
                return to(i) || o
            }

            function to(t) {
                return 0 == (1 & t)
            }

            function fn(t, n, e, i) {
                if (null === n) return -1;
                let r = 0;
                if (i || !e) {
                    let s = !1;
                    for (; r < n.length;) {
                        const o = n[r];
                        if (o === t) return r;
                        if (3 === o || 6 === o) s = !0;
                        else {
                            if (1 === o || 2 === o) {
                                let a = n[++r];
                                for (;
                                    "string" == typeof a;) a = n[++r];
                                continue
                            }
                            if (4 === o) break;
                            if (0 === o) {
                                r += 4;
                                continue
                            }
                        }
                        r += s ? 1 : 2
                    }
                    return -1
                }
                return function vd(t, n) {
                    let e = t.indexOf(4);
                    if (e > -1)
                        for (e++; e < t.length;) {
                            const i = t[e];
                            if ("number" == typeof i) return -1;
                            if (i === n) return e;
                            e++
                        }
                    return -1
                }(n, t)
            }

            function ct(t, n, e = !1) {
                for (let i = 0; i < n.length; i++)
                    if (Bh(t, n[i], e)) return !0;
                return !1
            }

            function Nh(t, n) {
                e: for (let e = 0; e < n.length; e++) {
                    const i = n[e];
                    if (t.length === i.length) {
                        for (let r = 0; r < t.length; r++)
                            if (t[r] !== i[r]) continue e;
                        return !0
                    }
                }
                return !1
            }

            function bd(t, n) {
                return t ? ":not(" + n.trim() + ")" : n
            }

            function Jt(t) {
                let n = t[0],
                    e = 1,
                    i = 2,
                    r = "",
                    s = !1;
                for (; e < t.length;) {
                    let o = t[e];
                    if ("string" == typeof o)
                        if (2 & i) {
                            const a = t[++e];
                            r += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]"
                        } else 8 & i ? r += "." + o : 4 & i && (r += " " + o);
                    else "" !== r && !to(o) && (n += bd(s, r), r = ""), i = o, s = s || !to(i);
                    e++
                }
                return "" !== r && (n += bd(s, r)), n
            }

            function xn(t) {
                return zs(() => {
                    const n = X(t),
                        e = { ...n,
                            decls: t.decls,
                            vars: t.vars,
                            template: t.template,
                            consts: t.consts || null,
                            ngContentSelectors: t.ngContentSelectors,
                            onPush: t.changeDetection === pa.OnPush,
                            directiveDefs: null,
                            pipeDefs: null,
                            dependencies: n.standalone && t.dependencies || null,
                            getStandaloneInjector: null,
                            signals: t.signals ? ? !1,
                            data: t.data || {},
                            encapsulation: t.encapsulation || ls.Emulated,
                            styles: t.styles || Vn,
                            _: null,
                            schemas: t.schemas || null,
                            tView: null,
                            id: ""
                        };
                    be(e);
                    const i = t.dependencies;
                    return e.directiveDefs = Ue(i, !1), e.pipeDefs = Ue(i, !0), e.id = function At(t) {
                        let n = 0;
                        const e = [t.selectors, t.ngContentSelectors, t.hostVars, t.hostAttrs, t.consts, t.vars, t.decls, t.encapsulation, t.standalone, t.signals, t.exportAs, JSON.stringify(t.inputs), JSON.stringify(t.outputs), Object.getOwnPropertyNames(t.type.prototype), !!t.contentQueries, !!t.viewQuery].join("|");
                        for (const r of e) n = Math.imul(31, n) + r.charCodeAt(0) << 0;
                        return n += 2147483648, "c" + n
                    }(e), e
                })
            }

            function Fa(t) {
                return Yi(t) || Kr(t)
            }

            function Fh(t) {
                return null !== t
            }

            function _i(t) {
                return zs(() => ({
                    type: t.type,
                    bootstrap: t.bootstrap || Vn,
                    declarations: t.declarations || Vn,
                    imports: t.imports || Vn,
                    exports: t.exports || Vn,
                    transitiveCompileScopes: null,
                    schemas: t.schemas || null,
                    id: t.id || null
                }))
            }

            function Vh(t, n) {
                if (null == t) return xs;
                const e = {};
                for (const i in t)
                    if (t.hasOwnProperty(i)) {
                        let r = t[i],
                            s = r;
                        Array.isArray(r) && (s = r[1], r = r[0]), e[r] = i, n && (n[r] = s)
                    }
                return e
            }

            function Un(t) {
                return zs(() => {
                    const n = X(t);
                    return be(n), n
                })
            }

            function Ps(t) {
                return {
                    type: t.type,
                    name: t.name,
                    factory: null,
                    pure: !1 !== t.pure,
                    standalone: !0 === t.standalone,
                    onDestroy: t.type.prototype.ngOnDestroy || null
                }
            }

            function Yi(t) {
                return t[tl] || null
            }

            function Kr(t) {
                return t[gd] || null
            }

            function js(t) {
                return t[nl] || null
            }

            function lo(t, n) {
                const e = t[Ph] || null;
                if (!e && !0 === n) throw new Error(`Type ${ti(t)} does not have '\u0275mod' property.`);
                return e
            }

            function X(t) {
                const n = {};
                return {
                    type: t.type,
                    providersResolver: null,
                    factory: null,
                    hostBindings: t.hostBindings || null,
                    hostVars: t.hostVars || 0,
                    hostAttrs: t.hostAttrs || null,
                    contentQueries: t.contentQueries || null,
                    declaredInputs: n,
                    inputTransforms: null,
                    inputConfig: t.inputs || xs,
                    exportAs: t.exportAs || null,
                    standalone: !0 === t.standalone,
                    signals: !0 === t.signals,
                    selectors: t.selectors || Vn,
                    viewQuery: t.viewQuery || null,
                    features: t.features || null,
                    setInput: null,
                    findHostDirectiveDefs: null,
                    hostDirectives: null,
                    inputs: Vh(t.inputs, n),
                    outputs: Vh(t.outputs)
                }
            }

            function be(t) {
                t.features ? .forEach(n => n(t))
            }

            function Ue(t, n) {
                if (!t) return null;
                const e = n ? js : Fa;
                return () => ("function" == typeof t ? t() : t).map(i => e(i)).filter(Fh)
            }
            const Wt = 0,
                Ct = 1,
                bn = 2,
                vi = 3,
                ni = 4,
                fr = 5,
                ii = 6,
                no = 7,
                vr = 8,
                Zr = 9,
                rs = 10,
                Hn = 11,
                rl = 12,
                Uh = 13,
                sl = 14,
                Er = 15,
                No = 16,
                Xo = 17,
                ma = 18,
                wd = 19,
                yg = 20,
                Lc = 21,
                Ua = 22,
                xd = 23,
                Bl = 24,
                Ni = 25,
                Cd = 1,
                pp = 2,
                io = 7,
                Or = 9,
                ms = 11;

            function To(t) {
                return Array.isArray(t) && "object" == typeof t[Cd]
            }

            function uo(t) {
                return Array.isArray(t) && !0 === t[Cd]
            }

            function oc(t) {
                return 0 != (4 & t.flags)
            }

            function Rc(t) {
                return t.componentOffset > -1
            }

            function Hh(t) {
                return 1 == (1 & t.flags)
            }

            function ga(t) {
                return !!t.template
            }

            function $h(t) {
                return 0 != (512 & t[bn])
            }

            function ie(t, n) {
                return t.hasOwnProperty(Ba) ? t[Ba] : null
            }
            let ri = null,
                Pi = !1;

            function lr(t) {
                const n = ri;
                return ri = t, n
            }
            const Tu = {
                version: 0,
                dirty: !1,
                producerNode: void 0,
                producerLastReadVersion: void 0,
                producerIndexOfThis: void 0,
                nextProducerIndex: 0,
                liveConsumerNode: void 0,
                liveConsumerIndexOfThis: void 0,
                consumerAllowSignalWrites: !1,
                consumerIsAlwaysLive: !1,
                producerMustRecompute: () => !1,
                producerRecomputeValue: () => {},
                consumerMarkedDirty: () => {}
            };

            function O_(t) {
                if (!Ad(t) || t.dirty) {
                    if (!t.producerMustRecompute(t) && !Oi(t)) return void(t.dirty = !1);
                    t.producerRecomputeValue(t), t.dirty = !1
                }
            }

            function Tg(t) {
                t.dirty = !0,
                    function Cg(t) {
                        if (void 0 === t.liveConsumerNode) return;
                        const n = Pi;
                        Pi = !0;
                        try {
                            for (const e of t.liveConsumerNode) e.dirty || Tg(e)
                        } finally {
                            Pi = n
                        }
                    }(t), t.consumerMarkedDirty ? .(t)
            }

            function zh(t) {
                return t && (t.nextProducerIndex = 0), lr(t)
            }

            function Sg(t, n) {
                if (lr(n), t && void 0 !== t.producerNode && void 0 !== t.producerIndexOfThis && void 0 !== t.producerLastReadVersion) {
                    if (Ad(t))
                        for (let e = t.nextProducerIndex; e < t.producerNode.length; e++) Nl(t.producerNode[e], t.producerIndexOfThis[e]);
                    for (; t.producerNode.length > t.nextProducerIndex;) t.producerNode.pop(), t.producerLastReadVersion.pop(), t.producerIndexOfThis.pop()
                }
            }

            function Oi(t) {
                Su(t);
                for (let n = 0; n < t.producerNode.length; n++) {
                    const e = t.producerNode[n],
                        i = t.producerLastReadVersion[n];
                    if (i !== e.version || (O_(e), i !== e.version)) return !0
                }
                return !1
            }

            function bp(t) {
                if (Su(t), Ad(t))
                    for (let n = 0; n < t.producerNode.length; n++) Nl(t.producerNode[n], t.producerIndexOfThis[n]);
                t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0, t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0)
            }

            function Nl(t, n) {
                if (function ac(t) {
                        t.liveConsumerNode ? ? = [], t.liveConsumerIndexOfThis ? ? = []
                    }(t), Su(t), 1 === t.liveConsumerNode.length)
                    for (let i = 0; i < t.producerNode.length; i++) Nl(t.producerNode[i], t.producerIndexOfThis[i]);
                const e = t.liveConsumerNode.length - 1;
                if (t.liveConsumerNode[n] = t.liveConsumerNode[e], t.liveConsumerIndexOfThis[n] = t.liveConsumerIndexOfThis[e], t.liveConsumerNode.length--, t.liveConsumerIndexOfThis.length--, n < t.liveConsumerNode.length) {
                    const i = t.liveConsumerIndexOfThis[n],
                        r = t.liveConsumerNode[n];
                    Su(r), r.producerIndexOfThis[i] = n
                }
            }

            function Ad(t) {
                return t.consumerIsAlwaysLive || (t ? .liveConsumerNode ? .length ? ? 0) > 0
            }

            function Su(t) {
                t.producerNode ? ? = [], t.producerIndexOfThis ? ? = [], t.producerLastReadVersion ? ? = []
            }
            let jh = null;
            const Fo = () => {},
                _a = (() => ({ ...Tu,
                    consumerIsAlwaysLive: !0,
                    consumerAllowSignalWrites: !1,
                    consumerMarkedDirty: t => {
                        t.schedule(t.ref)
                    },
                    hasRun: !1,
                    cleanupFn: Fo
                }))();
            class xp {
                constructor(n, e, i) {
                    this.previousValue = n, this.currentValue = e, this.firstChange = i
                }
                isFirstChange() {
                    return this.firstChange
                }
            }

            function Xi() {
                return cc
            }

            function cc(t) {
                return t.type.prototype.ngOnChanges && (t.setInput = lc), Jo
            }

            function Jo() {
                const t = Cp(this),
                    n = t ? .current;
                if (n) {
                    const e = t.previous;
                    if (e === xs) t.previous = n;
                    else
                        for (let i in n) e[i] = n[i];
                    t.current = null, this.ngOnChanges(n)
                }
            }

            function lc(t, n, e, i) {
                const r = this.declaredInputs[e],
                    s = Cp(t) || function al(t, n) {
                        return t[Vl] = n
                    }(t, {
                        previous: xs,
                        current: null
                    }),
                    o = s.current || (s.current = {}),
                    a = s.previous,
                    c = a[r];
                o[r] = new xp(c && c.currentValue, n, a === xs), t[i] = n
            }
            Xi.ngInherit = !0;
            const Vl = "__ngSimpleChanges__";

            function Cp(t) {
                return t[Vl] || null
            }
            const Fi = function(t, n, e) {},
                Tp = "svg";

            function Xr(t) {
                for (; Array.isArray(t);) t = t[Wt];
                return t
            }

            function Ag(t, n) {
                return Xr(n[t])
            }

            function Vo(t, n) {
                return Xr(n[t.index])
            }

            function V_(t, n) {
                return t.data[n]
            }

            function kd(t, n) {
                return t[n]
            }

            function So(t, n) {
                const e = n[t];
                return To(e) ? e : e[Wt]
            }

            function Ul(t, n) {
                return null == n ? null : t[n]
            }

            function Kh(t) {
                t[Xo] = 0
            }

            function kg(t) {
                1024 & t[bn] || (t[bn] |= 1024, Hl(t, 1))
            }

            function Ep(t) {
                1024 & t[bn] && (t[bn] &= -1025, Hl(t, -1))
            }

            function Hl(t, n) {
                let e = t[vi];
                if (null === e) return;
                e[fr] += n;
                let i = e;
                for (e = e[vi]; null !== e && (1 === n && 1 === i[fr] || -1 === n && 0 === i[fr]);) e[fr] += n, i = e, e = e[vi]
            }
            const mi = {
                lFrame: Li(null),
                bindingsEnabled: !0,
                skipHydrationRootTNode: null
            };

            function Au() {
                return mi.bindingsEnabled
            }

            function Id() {
                return null !== mi.skipHydrationRootTNode
            }

            function It() {
                return mi.lFrame.lView
            }

            function ur() {
                return mi.lFrame.tView
            }

            function Nt(t) {
                return mi.lFrame.contextLView = t, t[vr]
            }

            function Ft(t) {
                return mi.lFrame.contextLView = null, t
            }

            function Cs() {
                let t = H_();
                for (; null !== t && 64 === t.type;) t = t.parent;
                return t
            }

            function H_() {
                return mi.lFrame.currentTNode
            }

            function ea(t, n) {
                const e = mi.lFrame;
                e.currentTNode = t, e.isParent = n
            }

            function qh() {
                return mi.lFrame.isParent
            }

            function Pg() {
                mi.lFrame.isParent = !1
            }

            function wn() {
                const t = mi.lFrame;
                let n = t.bindingRootIndex;
                return -1 === n && (n = t.bindingRootIndex = t.tView.bindingStartIndex), n
            }

            function cl() {
                return mi.lFrame.bindingIndex
            }

            function Od() {
                return mi.lFrame.bindingIndex++
            }

            function Nc(t) {
                const n = mi.lFrame,
                    e = n.bindingIndex;
                return n.bindingIndex = n.bindingIndex + t, e
            }

            function U1(t, n) {
                const e = mi.lFrame;
                e.bindingIndex = e.bindingRootIndex = t, gs(n)
            }

            function gs(t) {
                mi.lFrame.currentDirectiveIndex = t
            }

            function kp() {
                return mi.lFrame.currentQueryIndex
            }

            function Mp(t) {
                mi.lFrame.currentQueryIndex = t
            }

            function $1(t) {
                const n = t[Ct];
                return 2 === n.type ? n.declTNode : 1 === n.type ? t[ii] : null
            }

            function Qr(t, n, e) {
                if (e & kt.SkipSelf) {
                    let r = n,
                        s = t;
                    for (; !(r = r.parent, null !== r || e & kt.Host || (r = $1(s), null === r || (s = s[sl], 10 & r.type))););
                    if (null === r) return !1;
                    n = r, t = s
                }
                const i = mi.lFrame = K_();
                return i.currentTNode = n, i.lView = t, !0
            }

            function Ip(t) {
                const n = K_(),
                    e = t[Ct];
                mi.lFrame = n, n.currentTNode = e.firstChild, n.lView = t, n.tView = e, n.contextLView = t, n.bindingIndex = e.bindingStartIndex, n.inI18n = !1
            }

            function K_() {
                const t = mi.lFrame,
                    n = null === t ? null : t.child;
                return null === n ? Li(t) : n
            }

            function Li(t) {
                const n = {
                    currentTNode: null,
                    isParent: !0,
                    lView: null,
                    tView: null,
                    selectedIndex: -1,
                    contextLView: null,
                    elementDepthCount: 0,
                    currentNamespace: null,
                    currentDirectiveIndex: -1,
                    bindingRootIndex: -1,
                    bindingIndex: -1,
                    currentQueryIndex: 0,
                    parent: t,
                    child: null,
                    inI18n: !1
                };
                return null !== t && (t.child = n), n
            }

            function us() {
                const t = mi.lFrame;
                return mi.lFrame = t.parent, t.currentTNode = null, t.lView = null, t
            }
            const Zh = us;

            function Yh() {
                const t = us();
                t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0
            }

            function Uo() {
                return mi.lFrame.selectedIndex
            }

            function ku(t) {
                mi.lFrame.selectedIndex = t
            }

            function ds() {
                const t = mi.lFrame;
                return V_(t.tView, t.selectedIndex)
            }

            function Pn() {
                mi.lFrame.currentNamespace = Tp
            }

            function Fc() {
                ! function G1() {
                    mi.lFrame.currentNamespace = null
                }()
            }
            let Z_ = !0;

            function Xh() {
                return Z_
            }

            function $l(t) {
                Z_ = t
            }

            function Pp(t, n) {
                for (let e = n.directiveStart, i = n.directiveEnd; e < i; e++) {
                    const s = t.data[e].type.prototype,
                        {
                            ngAfterContentInit: o,
                            ngAfterContentChecked: a,
                            ngAfterViewInit: c,
                            ngAfterViewChecked: u,
                            ngOnDestroy: h
                        } = s;
                    o && (t.contentHooks ? ? = []).push(-e, o), a && ((t.contentHooks ? ? = []).push(e, a), (t.contentCheckHooks ? ? = []).push(e, a)), c && (t.viewHooks ? ? = []).push(-e, c), u && ((t.viewHooks ? ? = []).push(e, u), (t.viewCheckHooks ? ? = []).push(e, u)), null != h && (t.destroyHooks ? ? = []).push(e, h)
                }
            }

            function Op(t, n, e) {
                Y_(t, n, 3, e)
            }

            function Lp(t, n, e, i) {
                (3 & t[bn]) === e && Y_(t, n, e, i)
            }

            function Lg(t, n) {
                let e = t[bn];
                (3 & e) === n && (e &= 8191, e += 1, t[bn] = e)
            }

            function Y_(t, n, e, i) {
                const s = i ? ? -1,
                    o = n.length - 1;
                let a = 0;
                for (let c = void 0 !== i ? 65535 & t[Xo] : 0; c < o; c++)
                    if ("number" == typeof n[c + 1]) {
                        if (a = n[c], null != i && a >= i) break
                    } else n[c] < 0 && (t[Xo] += 65536), (a < s || -1 == s) && (q1(t, e, n, c), t[Xo] = (4294901760 & t[Xo]) + c + 2), c++
            }

            function X_(t, n) {
                Fi(4, t, n);
                const e = lr(null);
                try {
                    n.call(t)
                } finally {
                    lr(e), Fi(5, t, n)
                }
            }

            function q1(t, n, e, i) {
                const r = e[i] < 0,
                    s = e[i + 1],
                    a = t[r ? -e[i] : e[i]];
                r ? t[bn] >> 13 < t[Xo] >> 16 && (3 & t[bn]) === n && (t[bn] += 8192, X_(a, s)) : X_(a, s)
            }
            const Ld = -1;
            class Qh {
                constructor(n, e, i) {
                    this.factory = n, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i
                }
            }

            function Ng(t) {
                return t !== Ld
            }

            function Jh(t) {
                return 32767 & t
            }

            function ef(t, n) {
                let e = function Fg(t) {
                        return t >> 16
                    }(t),
                    i = n;
                for (; e > 0;) i = i[sl], e--;
                return i
            }
            let Vg = !0;

            function Bp(t) {
                const n = Vg;
                return Vg = t, n
            }
            const J_ = 255,
                ev = 5;
            let X1 = 0;
            const Vc = {};

            function Np(t, n) {
                const e = tv(t, n);
                if (-1 !== e) return e;
                const i = n[Ct];
                i.firstCreatePass && (t.injectorIndex = n.length, Ug(i.data, t), Ug(n, null), Ug(i.blueprint, null));
                const r = Fp(t, n),
                    s = t.injectorIndex;
                if (Ng(r)) {
                    const o = Jh(r),
                        a = ef(r, n),
                        c = a[Ct].data;
                    for (let u = 0; u < 8; u++) n[s + u] = a[o + u] | c[o + u]
                }
                return n[s + 8] = r, s
            }

            function Ug(t, n) {
                t.push(0, 0, 0, 0, 0, 0, 0, 0, n)
            }

            function tv(t, n) {
                return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === n[t.injectorIndex + 8] ? -1 : t.injectorIndex
            }

            function Fp(t, n) {
                if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex;
                let e = 0,
                    i = null,
                    r = n;
                for (; null !== r;) {
                    if (i = nf(r), null === i) return Ld;
                    if (e++, r = r[sl], -1 !== i.injectorIndex) return i.injectorIndex | e << 16
                }
                return Ld
            }

            function Hg(t, n, e) {
                ! function Q1(t, n, e) {
                    let i;
                    "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(Pl) && (i = e[Pl]), null == i && (i = e[Pl] = X1++);
                    const r = i & J_;
                    n.data[t + (r >> ev)] |= 1 << r
                }(t, n, e)
            }

            function iv(t, n, e) {
                if (e & kt.Optional || void 0 !== t) return t;
                Qs()
            }

            function rv(t, n, e, i) {
                if (e & kt.Optional && void 0 === i && (i = null), !(e & (kt.Self | kt.Host))) {
                    const r = t[Zr],
                        s = Ei(void 0);
                    try {
                        return r ? r.get(n, i, e & kt.Optional) : ks(n, i, e & kt.Optional)
                    } finally {
                        Ei(s)
                    }
                }
                return iv(i, 0, e)
            }

            function sv(t, n, e, i = kt.Default, r) {
                if (null !== t) {
                    if (2048 & n[bn] && !(i & kt.Self)) {
                        const o = function lv(t, n, e, i, r) {
                            let s = t,
                                o = n;
                            for (; null !== s && null !== o && 2048 & o[bn] && !(512 & o[bn]);) {
                                const a = ov(s, o, e, i | kt.Self, Vc);
                                if (a !== Vc) return a;
                                let c = s.parent;
                                if (!c) {
                                    const u = o[yg];
                                    if (u) {
                                        const h = u.get(e, Vc, i);
                                        if (h !== Vc) return h
                                    }
                                    c = nf(o), o = o[sl]
                                }
                                s = c
                            }
                            return r
                        }(t, n, e, i, Vc);
                        if (o !== Vc) return o
                    }
                    const s = ov(t, n, e, i, Vc);
                    if (s !== Vc) return s
                }
                return rv(n, e, i, r)
            }

            function ov(t, n, e, i, r) {
                const s = function av(t) {
                    if ("string" == typeof t) return t.charCodeAt(0) || 0;
                    const n = t.hasOwnProperty(Pl) ? t[Pl] : void 0;
                    return "number" == typeof n ? n >= 0 ? n & J_ : cv : n
                }(e);
                if ("function" == typeof s) {
                    if (!Qr(n, t, i)) return i & kt.Host ? iv(r, 0, i) : rv(n, e, i, r);
                    try {
                        let o;
                        if (o = s(i), null != o || i & kt.Optional) return o;
                        Qs()
                    } finally {
                        Zh()
                    }
                } else if ("number" == typeof s) {
                    let o = null,
                        a = tv(t, n),
                        c = Ld,
                        u = i & kt.Host ? n[Er][ii] : null;
                    for ((-1 === a || i & kt.SkipSelf) && (c = -1 === a ? Fp(t, n) : n[a + 8], c !== Ld && zg(i, !1) ? (o = n[Ct], a = Jh(c), n = ef(c, n)) : a = -1); - 1 !== a;) {
                        const h = n[Ct];
                        if ($g(s, a, h.data)) {
                            const m = J1(a, n, e, o, i, u);
                            if (m !== Vc) return m
                        }
                        c = n[a + 8], c !== Ld && zg(i, n[Ct].data[a + 8] === u) && $g(s, a, n) ? (o = h, a = Jh(c), n = ef(c, n)) : a = -1
                    }
                }
                return r
            }

            function J1(t, n, e, i, r, s) {
                const o = n[Ct],
                    a = o.data[t + 8],
                    h = tf(a, o, e, null == i ? Rc(a) && Vg : i != o && 0 != (3 & a.type), r & kt.Host && s === a);
                return null !== h ? ll(n, o, h, a) : Vc
            }

            function tf(t, n, e, i, r) {
                const s = t.providerIndexes,
                    o = n.data,
                    a = 1048575 & s,
                    c = t.directiveStart,
                    h = s >> 20,
                    x = r ? a + h : t.directiveEnd;
                for (let D = i ? a : a + h; D < x; D++) {
                    const V = o[D];
                    if (D < c && e === V || D >= c && V.type === e) return D
                }
                if (r) {
                    const D = o[c];
                    if (D && ga(D) && D.type === e) return c
                }
                return null
            }

            function ll(t, n, e, i) {
                let r = t[e];
                const s = n.data;
                if (function Z1(t) {
                        return t instanceof Qh
                    }(r)) {
                    const o = r;
                    o.resolving && function Nr(t, n) {
                        const e = n ? `. Dependency path: ${n.join(" > ")} > ${t}` : "";
                        throw new mt(-200, `Circular dependency in DI detected for ${t}${e}`)
                    }(function di(t) {
                        return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : Zn(t)
                    }(s[e]));
                    const a = Bp(o.canSeeViewProviders);
                    o.resolving = !0;
                    const u = o.injectImpl ? Ei(o.injectImpl) : null;
                    Qr(t, i, kt.Default);
                    try {
                        r = t[e] = o.factory(void 0, s, t, i), n.firstCreatePass && e >= i.directiveStart && function K1(t, n, e) {
                            const {
                                ngOnChanges: i,
                                ngOnInit: r,
                                ngDoCheck: s
                            } = n.type.prototype;
                            if (i) {
                                const o = cc(n);
                                (e.preOrderHooks ? ? = []).push(t, o), (e.preOrderCheckHooks ? ? = []).push(t, o)
                            }
                            r && (e.preOrderHooks ? ? = []).push(0 - t, r), s && ((e.preOrderHooks ? ? = []).push(t, s), (e.preOrderCheckHooks ? ? = []).push(t, s))
                        }(e, s[e], n)
                    } finally {
                        null !== u && Ei(u), Bp(a), o.resolving = !1, Zh()
                    }
                }
                return r
            }

            function $g(t, n, e) {
                return !!(e[n + (t >> ev)] & 1 << t)
            }

            function zg(t, n) {
                return !(t & kt.Self || t & kt.Host && n)
            }
            class Ho {
                constructor(n, e) {
                    this._tNode = n, this._lView = e
                }
                get(n, e, i) {
                    return sv(this._tNode, this._lView, n, sc(i), e)
                }
            }

            function cv() {
                return new Ho(Cs(), It())
            }

            function ys(t) {
                return zs(() => {
                    const n = t.prototype.constructor,
                        e = n[Ba] || Bd(n),
                        i = Object.prototype;
                    let r = Object.getPrototypeOf(t.prototype).constructor;
                    for (; r && r !== i;) {
                        const s = r[Ba] || Bd(r);
                        if (s && s !== e) return s;
                        r = Object.getPrototypeOf(r)
                    }
                    return s => new s
                })
            }

            function Bd(t) {
                return As(t) ? () => {
                    const n = Bd(an(t));
                    return n && n()
                } : ie(t)
            }

            function nf(t) {
                const n = t[Ct],
                    e = n.type;
                return 2 === e ? n.declTNode : 1 === e ? t[ii] : null
            }
            const Ha = "__parameters__";

            function Vd(t, n, e) {
                return zs(() => {
                    const i = function jg(t) {
                        return function(...e) {
                            if (t) {
                                const i = t(...e);
                                for (const r in i) this[r] = i[r]
                            }
                        }
                    }(n);

                    function r(...s) {
                        if (this instanceof r) return i.apply(this, s), this;
                        const o = new r(...s);
                        return a.annotation = o, a;

                        function a(c, u, h) {
                            const m = c.hasOwnProperty(Ha) ? c[Ha] : Object.defineProperty(c, Ha, {
                                value: []
                            })[Ha];
                            for (; m.length <= h;) m.push(null);
                            return (m[h] = m[h] || []).push(o), c
                        }
                    }
                    return e && (r.prototype = Object.create(e.prototype)), r.prototype.ngMetadataName = t, r.annotationCls = r, r
                })
            }

            function Hd(t, n) {
                t.forEach(e => Array.isArray(e) ? Hd(e, n) : n(e))
            }

            function hv(t, n, e) {
                n >= t.length ? t.push(e) : t.splice(n, 0, e)
            }

            function ul(t, n) {
                return n >= t.length - 1 ? t.pop() : t.splice(n, 1)[0]
            }

            function va(t, n) {
                const e = [];
                for (let i = 0; i < t; i++) e.push(n);
                return e
            }

            function $o(t, n, e) {
                let i = Mu(t, n);
                return i >= 0 ? t[1 | i] = e : (i = ~i, function cC(t, n, e, i) {
                    let r = t.length;
                    if (r == n) t.push(e, i);
                    else if (1 === r) t.push(i, t[0]), t[0] = e;
                    else {
                        for (r--, t.push(t[r - 1], t[r]); r > n;) t[r] = t[r - 2], r--;
                        t[n] = e, t[n + 1] = i
                    }
                }(t, i, n, e)), i
            }

            function Vp(t, n) {
                const e = Mu(t, n);
                if (e >= 0) return t[1 | e]
            }

            function Mu(t, n) {
                return function Gg(t, n, e) {
                    let i = 0,
                        r = t.length >> e;
                    for (; r !== i;) {
                        const s = i + (r - i >> 1),
                            o = t[s << e];
                        if (n === o) return s << e;
                        o > n ? r = s : i = s + 1
                    }
                    return ~(r << e)
                }(t, n, 1)
            }
            const zl = Is(Vd("Optional"), 8),
                jd = Is(Vd("SkipSelf"), 4);

            function pn(t) {
                return 128 == (128 & t.flags)
            }
            var Tn = function(t) {
                return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t
            }(Tn || {});
            const si = /^>|^->|<!--|-->|--!>|<!-$/g,
                Qn = /(<|>)/g,
                Fr = "\u200b$1\u200b";
            const Vi = new Map;
            let Ls = 0;
            const Jn = "__ngContext__";

            function Gn(t, n) {
                To(n) ? (t[Jn] = n[wd], function za(t) {
                    Vi.set(t[wd], t)
                }(n)) : t[Jn] = n
            }
            let dc;

            function hl(t, n) {
                return dc(t, n)
            }

            function Gd(t) {
                const n = t[vi];
                return uo(n) ? n[vi] : n
            }

            function Cv(t) {
                return Xg(t[rl])
            }

            function Tv(t) {
                return Xg(t[ni])
            }

            function Xg(t) {
                for (; null !== t && !uo(t);) t = t[ni];
                return t
            }

            function Iu(t, n, e, i, r) {
                if (null != i) {
                    let s, o = !1;
                    uo(i) ? s = i : To(i) && (o = !0, i = i[Wt]);
                    const a = Xr(i);
                    0 === t && null !== e ? null == r ? zI(n, e, a) : hf(n, e, a, r || null, !0) : 1 === t && null !== e ? hf(n, e, a, r || null, !0) : 2 === t ? function Mv(t, n, e) {
                        const i = Av(t, n);
                        i && function Z7(t, n, e, i) {
                            t.removeChild(n, e, i)
                        }(t, i, n, e)
                    }(n, a, o) : 3 === t && n.destroyNode(a), null != s && function Q7(t, n, e, i, r) {
                        const s = e[io];
                        s !== Xr(e) && Iu(n, t, i, s, r);
                        for (let a = ms; a < e.length; a++) {
                            const c = e[a];
                            ey(c[Ct], c, t, n, i, s)
                        }
                    }(n, t, s, e, r)
                }
            }

            function zp(t, n) {
                return t.createComment(function pr(t) {
                    return t.replace(si, n => n.replace(Qn, Fr))
                }(n))
            }

            function df(t, n, e) {
                return t.createElement(n, e)
            }

            function HI(t, n) {
                const e = t[Or],
                    i = e.indexOf(n);
                Ep(n), e.splice(i, 1)
            }

            function Dv(t, n) {
                if (t.length <= ms) return;
                const e = ms + n,
                    i = t[e];
                if (i) {
                    const r = i[No];
                    null !== r && r !== t && HI(r, i), n > 0 && (t[e - 1][ni] = i[ni]);
                    const s = ul(t, ms + n);
                    ! function Sv(t, n) {
                        ey(t, n, n[Hn], 2, null, null), n[Wt] = null, n[ii] = null
                    }(i[Ct], i);
                    const o = s[ma];
                    null !== o && o.detachView(s[Ct]), i[vi] = null, i[ni] = null, i[bn] &= -129
                }
                return i
            }

            function xC(t, n) {
                if (!(256 & n[bn])) {
                    const e = n[Hn];
                    n[xd] && bp(n[xd]), n[Bl] && bp(n[Bl]), e.destroyNode && ey(t, n, e, 3, null, null),
                        function vC(t) {
                            let n = t[rl];
                            if (!n) return CC(t[Ct], t);
                            for (; n;) {
                                let e = null;
                                if (To(n)) e = n[rl];
                                else {
                                    const i = n[ms];
                                    i && (e = i)
                                }
                                if (!e) {
                                    for (; n && !n[ni] && n !== t;) To(n) && CC(n[Ct], n), n = n[vi];
                                    null === n && (n = t), To(n) && CC(n[Ct], n), e = n && n[ni]
                                }
                                n = e
                            }
                        }(n)
                }
            }

            function CC(t, n) {
                if (!(256 & n[bn])) {
                    n[bn] &= -129, n[bn] |= 256,
                        function q7(t, n) {
                            let e;
                            if (null != t && null != (e = t.destroyHooks))
                                for (let i = 0; i < e.length; i += 2) {
                                    const r = n[e[i]];
                                    if (!(r instanceof Qh)) {
                                        const s = e[i + 1];
                                        if (Array.isArray(s))
                                            for (let o = 0; o < s.length; o += 2) {
                                                const a = r[s[o]],
                                                    c = s[o + 1];
                                                Fi(4, a, c);
                                                try {
                                                    c.call(a)
                                                } finally {
                                                    Fi(5, a, c)
                                                }
                                            } else {
                                                Fi(4, r, s);
                                                try {
                                                    s.call(r)
                                                } finally {
                                                    Fi(5, r, s)
                                                }
                                            }
                                    }
                                }
                        }(t, n),
                        function K7(t, n) {
                            const e = t.cleanup,
                                i = n[no];
                            if (null !== e)
                                for (let s = 0; s < e.length - 1; s += 2)
                                    if ("string" == typeof e[s]) {
                                        const o = e[s + 3];
                                        o >= 0 ? i[o]() : i[-o].unsubscribe(), s += 2
                                    } else e[s].call(i[e[s + 1]]);
                            null !== i && (n[no] = null);
                            const r = n[Lc];
                            if (null !== r) {
                                n[Lc] = null;
                                for (let s = 0; s < r.length; s++)(0, r[s])()
                            }
                        }(t, n), 1 === n[Ct].type && n[Hn].destroy();
                    const e = n[No];
                    if (null !== e && uo(n[vi])) {
                        e !== n[vi] && HI(e, n);
                        const i = n[ma];
                        null !== i && i.detachView(t)
                    }! function zn(t) {
                        Vi.delete(t[wd])
                    }(n)
                }
            }

            function TC(t, n, e) {
                return function $I(t, n, e) {
                    let i = n;
                    for (; null !== i && 40 & i.type;) i = (n = i).parent;
                    if (null === i) return e[Wt]; {
                        const {
                            componentOffset: r
                        } = i;
                        if (r > -1) {
                            const {
                                encapsulation: s
                            } = t.data[i.directiveStart + r];
                            if (s === ls.None || s === ls.Emulated) return null
                        }
                        return Vo(i, e)
                    }
                }(t, n.parent, e)
            }

            function hf(t, n, e, i, r) {
                t.insertBefore(n, e, i, r)
            }

            function zI(t, n, e) {
                t.appendChild(n, e)
            }

            function jI(t, n, e, i, r) {
                null !== i ? hf(t, n, e, i, r) : zI(t, n, e)
            }

            function Av(t, n) {
                return t.parentNode(n)
            }

            function WI(t, n, e) {
                return KI(t, n, e)
            }
            let SC, Iv, kC, Pv, KI = function GI(t, n, e) {
                return 40 & t.type ? Vo(t, e) : null
            };

            function kv(t, n, e, i) {
                const r = TC(t, i, n),
                    s = n[Hn],
                    a = WI(i.parent || n[ii], i, n);
                if (null != r)
                    if (Array.isArray(e))
                        for (let c = 0; c < e.length; c++) jI(s, r, e[c], a, !1);
                    else jI(s, r, e, a, !1);
                void 0 !== SC && SC(s, i, n, e, r)
            }

            function Jg(t, n) {
                if (null !== n) {
                    const e = n.type;
                    if (3 & e) return Vo(n, t);
                    if (4 & e) return EC(-1, t[n.index]);
                    if (8 & e) {
                        const i = n.child;
                        if (null !== i) return Jg(t, i); {
                            const r = t[n.index];
                            return uo(r) ? EC(-1, r) : Xr(r)
                        }
                    }
                    if (32 & e) return hl(n, t)() || Xr(t[n.index]); {
                        const i = ZI(t, n);
                        return null !== i ? Array.isArray(i) ? i[0] : Jg(Gd(t[Er]), i) : Jg(t, n.next)
                    }
                }
                return null
            }

            function ZI(t, n) {
                return null !== n ? t[Er][ii].projection[n.projection] : null
            }

            function EC(t, n) {
                const e = ms + t + 1;
                if (e < n.length) {
                    const i = n[e],
                        r = i[Ct].firstChild;
                    if (null !== r) return Jg(i, r)
                }
                return n[io]
            }

            function DC(t, n, e, i, r, s, o) {
                for (; null != e;) {
                    const a = i[e.index],
                        c = e.type;
                    if (o && 0 === n && (a && Gn(Xr(a), i), e.flags |= 2), 32 != (32 & e.flags))
                        if (8 & c) DC(t, n, e.child, i, r, s, !1), Iu(n, t, r, a, s);
                        else if (32 & c) {
                        const u = hl(e, i);
                        let h;
                        for (; h = u();) Iu(n, t, r, h, s);
                        Iu(n, t, r, a, s)
                    } else 16 & c ? XI(t, n, i, e, r, s) : Iu(n, t, r, a, s);
                    e = o ? e.projectionNext : e.next
                }
            }

            function ey(t, n, e, i, r, s) {
                DC(e, i, t.firstChild, n, r, s, !1)
            }

            function XI(t, n, e, i, r, s) {
                const o = e[Er],
                    c = o[ii].projection[i.projection];
                if (Array.isArray(c))
                    for (let u = 0; u < c.length; u++) Iu(n, t, r, c[u], s);
                else {
                    let u = c;
                    const h = o[vi];
                    pn(i) && (u.flags |= 128), DC(t, n, u, h, r, s, !0)
                }
            }

            function QI(t, n, e) {
                "" === e ? t.removeAttribute(n, "class") : t.setAttribute(n, "class", e)
            }

            function JI(t, n, e) {
                const {
                    mergedAttrs: i,
                    classes: r,
                    styles: s
                } = e;
                null !== i && dn(t, n, i), null !== r && QI(t, n, r), null !== s && function e$(t, n, e) {
                    t.setAttribute(n, "style", e)
                }(t, n, s)
            }

            function jp(t) {
                return function AC() {
                    if (void 0 === Iv && (Iv = null, Di.trustedTypes)) try {
                        Iv = Di.trustedTypes.createPolicy("angular", {
                            createHTML: t => t,
                            createScript: t => t,
                            createScriptURL: t => t
                        })
                    } catch {}
                    return Iv
                }() ? .createHTML(t) || t
            }

            function Wp() {
                if (void 0 !== kC) return kC;
                if (typeof document < "u") return document;
                throw new mt(210, !1)
            }

            function MC() {
                if (void 0 === Pv && (Pv = null, Di.trustedTypes)) try {
                    Pv = Di.trustedTypes.createPolicy("angular#unsafe-bypass", {
                        createHTML: t => t,
                        createScript: t => t,
                        createScriptURL: t => t
                    })
                } catch {}
                return Pv
            }

            function eP(t) {
                return MC() ? .createHTML(t) || t
            }

            function nP(t) {
                return MC() ? .createScriptURL(t) || t
            }
            class iP {
                constructor(n) {
                    this.changingThisBreaksApplicationSecurity = n
                }
                toString() {
                    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Wr})`
                }
            }

            function qd(t) {
                return t instanceof iP ? t.changingThisBreaksApplicationSecurity : t
            }

            function ty(t, n) {
                const e = function u$(t) {
                    return t instanceof iP && t.getTypeName() || null
                }(t);
                if (null != e && e !== n) {
                    if ("ResourceURL" === e && "URL" === n) return !0;
                    throw new Error(`Required a safe ${n}, got a ${e} (see ${Wr})`)
                }
                return e === n
            }
            class d$ {
                constructor(n) {
                    this.inertDocumentHelper = n
                }
                getInertBodyElement(n) {
                    n = "<body><remove></remove>" + n;
                    try {
                        const e = (new window.DOMParser).parseFromString(jp(n), "text/html").body;
                        return null === e ? this.inertDocumentHelper.getInertBodyElement(n) : (e.removeChild(e.firstChild), e)
                    } catch {
                        return null
                    }
                }
            }
            class h$ {
                constructor(n) {
                    this.defaultDoc = n, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")
                }
                getInertBodyElement(n) {
                    const e = this.inertDocument.createElement("template");
                    return e.innerHTML = jp(n), e
                }
            }
            const p$ = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;

            function IC(t) {
                return (t = String(t)).match(p$) ? t : "unsafe:" + t
            }

            function Pu(t) {
                const n = {};
                for (const e of t.split(",")) n[e] = !0;
                return n
            }

            function ny(...t) {
                const n = {};
                for (const e of t)
                    for (const i in e) e.hasOwnProperty(i) && (n[i] = !0);
                return n
            }
            const sP = Pu("area,br,col,hr,img,wbr"),
                oP = Pu("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                aP = Pu("rp,rt"),
                PC = ny(sP, ny(oP, Pu("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), ny(aP, Pu("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), ny(aP, oP)),
                OC = Pu("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
                cP = ny(OC, Pu("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Pu("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),
                m$ = Pu("script,style,template");
            class g$ {
                constructor() {
                    this.sanitizedSomething = !1, this.buf = []
                }
                sanitizeChildren(n) {
                    let e = n.firstChild,
                        i = !0;
                    for (; e;)
                        if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild;
                        else
                            for (; e;) {
                                e.nodeType === Node.ELEMENT_NODE && this.endElement(e);
                                let r = this.checkClobberedElement(e, e.nextSibling);
                                if (r) {
                                    e = r;
                                    break
                                }
                                e = this.checkClobberedElement(e, e.parentNode)
                            }
                    return this.buf.join("")
                }
                startElement(n) {
                    const e = n.nodeName.toLowerCase();
                    if (!PC.hasOwnProperty(e)) return this.sanitizedSomething = !0, !m$.hasOwnProperty(e);
                    this.buf.push("<"), this.buf.push(e);
                    const i = n.attributes;
                    for (let r = 0; r < i.length; r++) {
                        const s = i.item(r),
                            o = s.name,
                            a = o.toLowerCase();
                        if (!cP.hasOwnProperty(a)) {
                            this.sanitizedSomething = !0;
                            continue
                        }
                        let c = s.value;
                        OC[a] && (c = IC(c)), this.buf.push(" ", o, '="', lP(c), '"')
                    }
                    return this.buf.push(">"), !0
                }
                endElement(n) {
                    const e = n.nodeName.toLowerCase();
                    PC.hasOwnProperty(e) && !sP.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">"))
                }
                chars(n) {
                    this.buf.push(lP(n))
                }
                checkClobberedElement(n, e) {
                    if (e && (n.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${n.outerHTML}`);
                    return e
                }
            }
            const y$ = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                _$ = /([^\#-~ |!])/g;

            function lP(t) {
                return t.replace(/&/g, "&amp;").replace(y$, function(n) {
                    return "&#" + (1024 * (n.charCodeAt(0) - 55296) + (n.charCodeAt(1) - 56320) + 65536) + ";"
                }).replace(_$, function(n) {
                    return "&#" + n.charCodeAt(0) + ";"
                }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
            }
            let Ov;

            function LC(t) {
                return "content" in t && function b$(t) {
                    return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName
                }(t) ? t.content : null
            }
            var Gp = function(t) {
                return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t
            }(Gp || {});

            function iy(t) {
                const n = ry();
                return n ? eP(n.sanitize(Gp.HTML, t) || "") : ty(t, "HTML") ? eP(qd(t)) : function v$(t, n) {
                    let e = null;
                    try {
                        Ov = Ov || function rP(t) {
                            const n = new h$(t);
                            return function f$() {
                                try {
                                    return !!(new window.DOMParser).parseFromString(jp(""), "text/html")
                                } catch {
                                    return !1
                                }
                            }() ? new d$(n) : n
                        }(t);
                        let i = n ? String(n) : "";
                        e = Ov.getInertBodyElement(i);
                        let r = 5,
                            s = i;
                        do {
                            if (0 === r) throw new Error("Failed to sanitize html because the input is unstable");
                            r--, i = s, s = e.innerHTML, e = Ov.getInertBodyElement(i)
                        } while (i !== s);
                        return jp((new g$).sanitizeChildren(LC(e) || e))
                    } finally {
                        if (e) {
                            const i = LC(e) || e;
                            for (; i.firstChild;) i.removeChild(i.firstChild)
                        }
                    }
                }(Wp(), Zn(t))
            }

            function fo(t) {
                const n = ry();
                return n ? n.sanitize(Gp.URL, t) || "" : ty(t, "URL") ? qd(t) : IC(Zn(t))
            }

            function uP(t) {
                const n = ry();
                if (n) return nP(n.sanitize(Gp.RESOURCE_URL, t) || "");
                if (ty(t, "ResourceURL")) return nP(qd(t));
                throw new mt(904, !1)
            }

            function ry() {
                const t = It();
                return t && t[rs].sanitizer
            }
            const sy = new nn("ENVIRONMENT_INITIALIZER"),
                hP = new nn("INJECTOR", -1),
                fP = new nn("INJECTOR_DEF_TYPES");
            class RC {
                get(n, e = $s) {
                    if (e === $s) {
                        const i = new Error(`NullInjectorError: No provider for ${ti(n)}!`);
                        throw i.name = "NullInjectorError", i
                    }
                    return e
                }
            }

            function E$(...t) {
                return {\
                    u0275providers: pP(0, t),
                    \u0275fromNgModule: !0
                }
            }

            function pP(t, ...n) {
                const e = [],
                    i = new Set;
                let r;
                const s = o => {
                    e.push(o)
                };
                return Hd(n, o => {
                    const a = o;
                    Lv(a, s, [], i) && (r || = [], r.push(a))
                }), void 0 !== r && mP(r, s), e
            }

            function mP(t, n) {
                for (let e = 0; e < t.length; e++) {
                    const {
                        ngModule: i,
                        providers: r
                    } = t[e];
                    NC(r, s => {
                        n(s, i)
                    })
                }
            }

            function Lv(t, n, e, i) {
                if (!(t = an(t))) return !1;
                let r = null,
                    s = kc(t);
                const o = !s && Yi(t);
                if (s || o) {
                    if (o && !o.standalone) return !1;
                    r = t
                } else {
                    const c = t.ngModule;
                    if (s = kc(c), !s) return !1;
                    r = c
                }
                const a = i.has(r);
                if (o) {
                    if (a) return !1;
                    if (i.add(r), o.dependencies) {
                        const c = "function" == typeof o.dependencies ? o.dependencies() : o.dependencies;
                        for (const u of c) Lv(u, n, e, i)
                    }
                } else {
                    if (!s) return !1; {
                        if (null != s.imports && !a) {
                            let u;
                            i.add(r);
                            try {
                                Hd(s.imports, h => {
                                    Lv(h, n, e, i) && (u || = [], u.push(h))
                                })
                            } finally {}
                            void 0 !== u && mP(u, n)
                        }
                        if (!a) {
                            const u = ie(r) || (() => new r);
                            n({
                                provide: r,
                                useFactory: u,
                                deps: Vn
                            }, r), n({
                                provide: fP,
                                useValue: r,
                                multi: !0
                            }, r), n({
                                provide: sy,
                                useValue: () => _t(r),
                                multi: !0
                            }, r)
                        }
                        const c = s.providers;
                        if (null != c && !a) {
                            const u = t;
                            NC(c, h => {
                                n(h, u)
                            })
                        }
                    }
                }
                return r !== t && void 0 !== t.providers
            }

            function NC(t, n) {
                for (let e of t) wo(e) && (e = e.\u0275providers), Array.isArray(e) ? NC(e, n) : n(e)
            }
            const D$ = Ut({
                provide: String,
                useValue: Ut
            });

            function FC(t) {
                return null !== t && "object" == typeof t && D$ in t
            }

            function ff(t) {
                return "function" == typeof t
            }
            const VC = new nn("Set Injector scope."),
                Rv = {},
                k$ = {};
            let UC;

            function Bv() {
                return void 0 === UC && (UC = new RC), UC
            }
            class hc {}
            class Kp extends hc {
                get destroyed() {
                    return this._destroyed
                }
                constructor(n, e, i, r) {
                    super(), this.parent = e, this.source = i, this.scopes = r, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, $C(n, o => this.processProvider(o)), this.records.set(hP, qp(void 0, this)), r.has("environment") && this.records.set(hc, qp(void 0, this));
                    const s = this.records.get(VC);
                    null != s && "string" == typeof s.value && this.scopes.add(s.value), this.injectorDefTypes = new Set(this.get(fP.multi, Vn, kt.Self))
                }
                destroy() {
                    this.assertNotDestroyed(), this._destroyed = !0;
                    try {
                        for (const e of this._ngOnDestroyHooks) e.ngOnDestroy();
                        const n = this._onDestroyHooks;
                        this._onDestroyHooks = [];
                        for (const e of n) e()
                    } finally {
                        this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear()
                    }
                }
                onDestroy(n) {
                    return this.assertNotDestroyed(), this._onDestroyHooks.push(n), () => this.removeOnDestroy(n)
                }
                runInContext(n) {
                    this.assertNotDestroyed();
                    const e = Ra(this),
                        i = Ei(void 0);
                    try {
                        return n()
                    } finally {
                        Ra(e), Ei(i)
                    }
                }
                get(n, e = $s, i = kt.Default) {
                    if (this.assertNotDestroyed(), n.hasOwnProperty(Oh)) return n[Oh](this);
                    i = sc(i);
                    const s = Ra(this),
                        o = Ei(void 0);
                    try {
                        if (!(i & kt.SkipSelf)) {
                            let c = this.records.get(n);
                            if (void 0 === c) {
                                const u = function L$(t) {
                                    return "function" == typeof t || "object" == typeof t && t instanceof nn
                                }(n) && Ac(n);
                                c = u && this.injectableDefInScope(u) ? qp(HC(n), Rv) : null, this.records.set(n, c)
                            }
                            if (null != c) return this.hydrate(n, c)
                        }
                        return (i & kt.Self ? Bv() : this.parent).get(n, e = i & kt.Optional && e === $s ? null : e)
                    } catch (a) {
                        if ("NullInjectorError" === a.name) {
                            if ((a[Mc] = a[Mc] || []).unshift(ti(n)), s) throw a;
                            return function bu(t, n, e, i) {
                                const r = t[Mc];
                                throw n[He] && r.unshift(n[He]), t.message = function $t(t, n, e, i = null) {
                                    t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.slice(2) : t;
                                    let r = ti(n);
                                    if (Array.isArray(n)) r = n.map(ti).join(" -> ");
                                    else if ("object" == typeof n) {
                                        let s = [];
                                        for (let o in n)
                                            if (n.hasOwnProperty(o)) {
                                                let a = n[o];
                                                s.push(o + ":" + ("string" == typeof a ? JSON.stringify(a) : ti(a)))
                                            }
                                        r = `{${s.join(", ")}}`
                                    }
                                    return `${e}${i?"("+i+")":""}[${r}]: ${t.replace(vu,"\n  ")}`
                                }("\n" + t.message, r, e, i), t.ngTokenPath = r, t[Mc] = null, t
                            }(a, n, "R3InjectorError", this.source)
                        }
                        throw a
                    } finally {
                        Ei(o), Ra(s)
                    }
                }
                resolveInjectorInitializers() {
                    const n = Ra(this),
                        e = Ei(void 0);
                    try {
                        const r = this.get(sy.multi, Vn, kt.Self);
                        for (const s of r) s()
                    } finally {
                        Ra(n), Ei(e)
                    }
                }
                toString() {
                    const n = [],
                        e = this.records;
                    for (const i of e.keys()) n.push(ti(i));
                    return `R3Injector[${n.join(", ")}]`
                }
                assertNotDestroyed() {
                    if (this._destroyed) throw new mt(205, !1)
                }
                processProvider(n) {
                    let e = ff(n = an(n)) ? n : an(n && n.provide);
                    const i = function I$(t) {
                        return FC(t) ? qp(void 0, t.useValue) : qp(_P(t), Rv)
                    }(n);
                    if (ff(n) || !0 !== n.multi) this.records.get(e);
                    else {
                        let r = this.records.get(e);
                        r || (r = qp(void 0, Rv, !0), r.factory = () => Pc(r.multi), this.records.set(e, r)), e = n, r.multi.push(n)
                    }
                    this.records.set(e, i)
                }
                hydrate(n, e) {
                    return e.value === Rv && (e.value = k$, e.value = e.factory()), "object" == typeof e.value && e.value && function O$(t) {
                        return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy
                    }(e.value) && this._ngOnDestroyHooks.add(e.value), e.value
                }
                injectableDefInScope(n) {
                    if (!n.providedIn) return !1;
                    const e = an(n.providedIn);
                    return "string" == typeof e ? "any" === e || this.scopes.has(e) : this.injectorDefTypes.has(e)
                }
                removeOnDestroy(n) {
                    const e = this._onDestroyHooks.indexOf(n); - 1 !== e && this._onDestroyHooks.splice(e, 1)
                }
            }

            function HC(t) {
                const n = Ac(t),
                    e = null !== n ? n.factory : ie(t);
                if (null !== e) return e;
                if (t instanceof nn) throw new mt(204, !1);
                if (t instanceof Function) return function M$(t) {
                    const n = t.length;
                    if (n > 0) throw va(n, "?"), new mt(204, !1);
                    const e = function md(t) {
                        return t && (t[lt] || t[ot]) || null
                    }(t);
                    return null !== e ? () => e.factory(t) : () => new t
                }(t);
                throw new mt(204, !1)
            }

            function _P(t, n, e) {
                let i;
                if (ff(t)) {
                    const r = an(t);
                    return ie(r) || HC(r)
                }
                if (FC(t)) i = () => an(t.useValue);
                else if (function yP(t) {
                        return !(!t || !t.useFactory)
                    }(t)) i = () => t.useFactory(...Pc(t.deps || []));
                else if (function gP(t) {
                        return !(!t || !t.useExisting)
                    }(t)) i = () => _t(an(t.useExisting));
                else {
                    const r = an(t && (t.useClass || t.provide));
                    if (! function P$(t) {
                            return !!t.deps
                        }(t)) return ie(r) || HC(r);
                    i = () => new r(...Pc(t.deps))
                }
                return i
            }

            function qp(t, n, e = !1) {
                return {
                    factory: t,
                    value: n,
                    multi: e ? [] : void 0
                }
            }

            function $C(t, n) {
                for (const e of t) Array.isArray(e) ? $C(e, n) : e && wo(e) ? $C(e.\u0275providers, n) : n(e)
            }
            const Nv = new nn("AppId", {
                    providedIn: "root",
                    factory: () => R$
                }),
                R$ = "ng",
                vP = new nn("Platform Initializer"),
                Bs = new nn("Platform ID", {
                    providedIn: "platform",
                    factory: () => "unknown"
                }),
                bP = new nn("AnimationModuleType"),
                wP = new nn("CSP nonce", {
                    providedIn: "root",
                    factory: () => Wp().body ? .querySelector("[ngCspNonce]") ? .getAttribute("ngCspNonce") || null
                });
            let xP = (t, n, e) => null;

            function YC(t, n, e = !1) {
                return xP(t, n, e)
            }
            class W$ {}
            class SP {}
            class K$ {
                resolveComponentFactory(n) {
                    throw function G$(t) {
                        const n = Error(`No component factory found for ${ti(t)}.`);
                        return n.ngComponent = t, n
                    }(n)
                }
            }
            let Xp = (() => {
                class t {
                    static# e = this.NULL = new K$
                }
                return t
            })();

            function q$() {
                return Qp(Cs(), It())
            }

            function Qp(t, n) {
                return new ir(Vo(t, n))
            }
            let ir = (() => {
                class t {
                    constructor(e) {
                        this.nativeElement = e
                    }
                    static# e = this.__NG_ELEMENT_ID__ = q$
                }
                return t
            })();

            function Z$(t) {
                return t instanceof ir ? t.nativeElement : t
            }
            class pf {}
            let Ks = (() => {
                    class t {
                        constructor() {
                            this.destroyNode = null
                        }
                        static# e = this.__NG_ELEMENT_ID__ = () => function Y$() {
                            const t = It(),
                                e = So(Cs().index, t);
                            return (To(e) ? e : t)[Hn]
                        }()
                    }
                    return t
                })(),
                X$ = (() => {
                    class t {
                        static# e = this.\u0275prov = Dt({
                            token: t,
                            providedIn: "root",
                            factory: () => null
                        })
                    }
                    return t
                })();
            class cy {
                constructor(n) {
                    this.full = n, this.major = n.split(".")[0], this.minor = n.split(".")[1], this.patch = n.split(".").slice(2).join(".")
                }
            }
            const Q$ = new cy("16.2.12"),
                JC = {};

            function MP(t, n = null, e = null, i) {
                const r = IP(t, n, e, i);
                return r.resolveInjectorInitializers(), r
            }

            function IP(t, n = null, e = null, i, r = new Set) {
                const s = [e || Vn, E$(t)];
                return i = i || ("object" == typeof t ? void 0 : ti(t)), new Kp(s, n || Bv(), i || null, r)
            }
            let Do = (() => {
                class t {
                    static# e = this.THROW_IF_NOT_FOUND = $s;
                    static# t = this.NULL = new RC;
                    static create(e, i) {
                        if (Array.isArray(e)) return MP({
                            name: ""
                        }, i, e, ""); {
                            const r = e.name ? ? "";
                            return MP({
                                name: r
                            }, e.parent, e.providers, r)
                        }
                    }
                    static# n = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "any",
                        factory: () => _t(hP)
                    });
                    static# i = this.__NG_ELEMENT_ID__ = -1
                }
                return t
            })();

            function tT(t) {
                return t.ngOriginalError
            }
            class jl {
                constructor() {
                    this._console = console
                }
                handleError(n) {
                    const e = this._findOriginalError(n);
                    this._console.error("ERROR", n), e && this._console.error("ORIGINAL ERROR", e)
                }
                _findOriginalError(n) {
                    let e = n && tT(n);
                    for (; e && tT(e);) e = tT(e);
                    return e || null
                }
            }

            function iT(t) {
                return n => {
                    setTimeout(t, void 0, n)
                }
            }
            const zt = class sz extends A {
                constructor(n = !1) {
                    super(), this.__isAsync = n
                }
                emit(n) {
                    super.next(n)
                }
                subscribe(n, e, i) {
                    let r = n,
                        s = e || (() => null),
                        o = i;
                    if (n && "object" == typeof n) {
                        const c = n;
                        r = c.next ? .bind(c), s = c.error ? .bind(c), o = c.complete ? .bind(c)
                    }
                    this.__isAsync && (s = iT(s), r && (r = iT(r)), o && (o = iT(o)));
                    const a = super.subscribe({
                        next: r,
                        error: s,
                        complete: o
                    });
                    return n instanceof S && n.add(a), a
                }
            };

            function OP(...t) {}
            class cr {
                constructor({
                    enableLongStackTrace: n = !1,
                    shouldCoalesceEventChangeDetection: e = !1,
                    shouldCoalesceRunChangeDetection: i = !1
                }) {
                    if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new zt(!1), this.onMicrotaskEmpty = new zt(!1), this.onStable = new zt(!1), this.onError = new zt(!1), typeof Zone > "u") throw new mt(908, !1);
                    Zone.assertZonePatched();
                    const r = this;
                    r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !i && e, r.shouldCoalesceRunChangeDetection = i, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function oz() {
                            const t = "function" == typeof Di.requestAnimationFrame;
                            let n = Di[t ? "requestAnimationFrame" : "setTimeout"],
                                e = Di[t ? "cancelAnimationFrame" : "clearTimeout"];
                            if (typeof Zone < "u" && n && e) {
                                const i = n[Zone.__symbol__("OriginalDelegate")];
                                i && (n = i);
                                const r = e[Zone.__symbol__("OriginalDelegate")];
                                r && (e = r)
                            }
                            return {
                                nativeRequestAnimationFrame: n,
                                nativeCancelAnimationFrame: e
                            }
                        }().nativeRequestAnimationFrame,
                        function lz(t) {
                            const n = () => {
                                ! function cz(t) {
                                    t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Di, () => {
                                        t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
                                            t.lastRequestAnimationFrameId = -1, sT(t), t.isCheckStableRunning = !0, rT(t), t.isCheckStableRunning = !1
                                        }, void 0, () => {}, () => {})), t.fakeTopEventTask.invoke()
                                    }), sT(t))
                                }(t)
                            };
                            t._inner = t._inner.fork({
                                name: "angular",
                                properties: {
                                    isAngularZone: !0
                                },
                                onInvokeTask: (e, i, r, s, o, a) => {
                                    if (function dz(t) {
                                            return !(!Array.isArray(t) || 1 !== t.length) && !0 === t[0].data ? .__ignore_ng_zone__
                                        }(a)) return e.invokeTask(r, s, o, a);
                                    try {
                                        return LP(t), e.invokeTask(r, s, o, a)
                                    } finally {
                                        (t.shouldCoalesceEventChangeDetection && "eventTask" === s.type || t.shouldCoalesceRunChangeDetection) && n(), RP(t)
                                    }
                                },
                                onInvoke: (e, i, r, s, o, a, c) => {
                                    try {
                                        return LP(t), e.invoke(r, s, o, a, c)
                                    } finally {
                                        t.shouldCoalesceRunChangeDetection && n(), RP(t)
                                    }
                                },
                                onHasTask: (e, i, r, s) => {
                                    e.hasTask(r, s), i === r && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, sT(t), rT(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask))
                                },
                                onHandleError: (e, i, r, s) => (e.handleError(r, s), t.runOutsideAngular(() => t.onError.emit(s)), !1)
                            })
                        }(r)
                }
                static isInAngularZone() {
                    return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone")
                }
                static assertInAngularZone() {
                    if (!cr.isInAngularZone()) throw new mt(909, !1)
                }
                static assertNotInAngularZone() {
                    if (cr.isInAngularZone()) throw new mt(909, !1)
                }
                run(n, e, i) {
                    return this._inner.run(n, e, i)
                }
                runTask(n, e, i, r) {
                    const s = this._inner,
                        o = s.scheduleEventTask("NgZoneEvent: " + r, n, az, OP, OP);
                    try {
                        return s.runTask(o, e, i)
                    } finally {
                        s.cancelTask(o)
                    }
                }
                runGuarded(n, e, i) {
                    return this._inner.runGuarded(n, e, i)
                }
                runOutsideAngular(n) {
                    return this._outer.run(n)
                }
            }
            const az = {};

            function rT(t) {
                if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try {
                    t._nesting++, t.onMicrotaskEmpty.emit(null)
                } finally {
                    if (t._nesting--, !t.hasPendingMicrotasks) try {
                        t.runOutsideAngular(() => t.onStable.emit(null))
                    } finally {
                        t.isStable = !0
                    }
                }
            }

            function sT(t) {
                t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId)
            }

            function LP(t) {
                t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null))
            }

            function RP(t) {
                t._nesting--, rT(t)
            }
            class uz {
                constructor() {
                    this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new zt, this.onMicrotaskEmpty = new zt, this.onStable = new zt, this.onError = new zt
                }
                run(n, e, i) {
                    return n.apply(e, i)
                }
                runGuarded(n, e, i) {
                    return n.apply(e, i)
                }
                runOutsideAngular(n) {
                    return n()
                }
                runTask(n, e, i, r) {
                    return n.apply(e, i)
                }
            }
            const BP = new nn("", {
                providedIn: "root",
                factory: NP
            });

            function NP() {
                const t = vn(cr);
                let n = !0;
                return Si(new M(r => {
                    n = t.isStable && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks, t.runOutsideAngular(() => {
                        r.next(n), r.complete()
                    })
                }), new M(r => {
                    let s;
                    t.runOutsideAngular(() => {
                        s = t.onStable.subscribe(() => {
                            cr.assertNotInAngularZone(), queueMicrotask(() => {
                                !n && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks && (n = !0, r.next(!0))
                            })
                        })
                    });
                    const o = t.onUnstable.subscribe(() => {
                        cr.assertInAngularZone(), n && (n = !1, t.runOutsideAngular(() => {
                            r.next(!1)
                        }))
                    });
                    return () => {
                        s.unsubscribe(), o.unsubscribe()
                    }
                }).pipe(at()))
            }

            function fl(t) {
                return t.ownerDocument.defaultView
            }

            function FP(t) {
                return t.ownerDocument
            }

            function Ou(t) {
                return t instanceof Function ? t() : t
            }
            let oT = (() => {
                class t {
                    constructor() {
                        this.renderDepth = 0, this.handler = null
                    }
                    begin() {
                        this.handler ? .validateBegin(), this.renderDepth++
                    }
                    end() {
                        this.renderDepth--, 0 === this.renderDepth && this.handler ? .execute()
                    }
                    ngOnDestroy() {
                        this.handler ? .destroy(), this.handler = null
                    }
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "root",
                        factory: () => new t
                    })
                }
                return t
            })();

            function ly(t) {
                for (; t;) {
                    t[bn] |= 64;
                    const n = Gd(t);
                    if ($h(t) && !n) return t;
                    t = n
                }
                return null
            }
            const zP = new nn("", {
                providedIn: "root",
                factory: () => !1
            });
            let jv = null;

            function KP(t, n) {
                return t[n] ? ? YP()
            }

            function qP(t, n) {
                const e = YP();
                e.producerNode ? .length && (t[n] = jv, e.lView = t, jv = ZP())
            }
            const vz = { ...Tu,
                consumerIsAlwaysLive: !0,
                consumerMarkedDirty: t => {
                    ly(t.lView)
                },
                lView: null
            };

            function ZP() {
                return Object.create(vz)
            }

            function YP() {
                return jv ? ? = ZP(), jv
            }
            const ki = {};

            function he(t) {
                XP(ur(), It(), Uo() + t, !1)
            }

            function XP(t, n, e, i) {
                if (!i)
                    if (3 == (3 & n[bn])) {
                        const s = t.preOrderCheckHooks;
                        null !== s && Op(n, s, e)
                    } else {
                        const s = t.preOrderHooks;
                        null !== s && Lp(n, s, 0, e)
                    }
                ku(e)
            }

            function We(t, n = kt.Default) {
                const e = It();
                return null === e ? _t(t, n) : sv(Cs(), e, an(t), n)
            }

            function Wv(t, n, e, i, r, s, o, a, c, u, h) {
                const m = n.blueprint.slice();
                return m[Wt] = r, m[bn] = 140 | i, (null !== u || t && 2048 & t[bn]) && (m[bn] |= 2048), Kh(m), m[vi] = m[sl] = t, m[vr] = e, m[rs] = o || t && t[rs], m[Hn] = a || t && t[Hn], m[Zr] = c || t && t[Zr] || null, m[ii] = s, m[wd] = function Ts() {
                    return Ls++
                }(), m[Ua] = h, m[yg] = u, m[Er] = 2 == n.type ? t[Er] : m, m
            }

            function tm(t, n, e, i, r) {
                let s = t.data[n];
                if (null === s) s = function aT(t, n, e, i, r) {
                        const s = H_(),
                            o = qh(),
                            c = t.data[n] = function Dz(t, n, e, i, r, s) {
                                let o = n ? n.injectorIndex : -1,
                                    a = 0;
                                return Id() && (a |= 128), {
                                    type: e,
                                    index: i,
                                    insertBeforeIndex: null,
                                    injectorIndex: o,
                                    directiveStart: -1,
                                    directiveEnd: -1,
                                    directiveStylingLast: -1,
                                    componentOffset: -1,
                                    propertyBindings: null,
                                    flags: a,
                                    providerIndexes: 0,
                                    value: r,
                                    attrs: s,
                                    mergedAttrs: null,
                                    localNames: null,
                                    initialInputs: void 0,
                                    inputs: null,
                                    outputs: null,
                                    tView: null,
                                    next: null,
                                    prev: null,
                                    projectionNext: null,
                                    child: null,
                                    parent: n,
                                    projection: null,
                                    styles: null,
                                    stylesWithoutHost: null,
                                    residualStyles: void 0,
                                    classes: null,
                                    classesWithoutHost: null,
                                    residualClasses: void 0,
                                    classBindings: 0,
                                    styleBindings: 0
                                }
                            }(0, o ? s : s && s.parent, e, n, i, r);
                        return null === t.firstChild && (t.firstChild = c), null !== s && (o ? null == s.child && null !== c.parent && (s.child = c) : null === s.next && (s.next = c, c.prev = s)), c
                    }(t, n, e, i, r),
                    function Og() {
                        return mi.lFrame.inI18n
                    }() && (s.flags |= 32);
                else if (64 & s.type) {
                    s.type = e, s.value = i, s.attrs = r;
                    const o = function Pd() {
                        const t = mi.lFrame,
                            n = t.currentTNode;
                        return t.isParent ? n : n.parent
                    }();
                    s.injectorIndex = null === o ? -1 : o.injectorIndex
                }
                return ea(s, !0), s
            }

            function uy(t, n, e, i) {
                if (0 === e) return -1;
                const r = n.length;
                for (let s = 0; s < e; s++) n.push(i), t.blueprint.push(i), t.data.push(null);
                return r
            }

            function JP(t, n, e, i, r) {
                const s = KP(n, xd),
                    o = Uo(),
                    a = 2 & i;
                try {
                    ku(-1), a && n.length > Ni && XP(t, n, Ni, !1), Fi(a ? 2 : 0, r);
                    const u = a ? s : null,
                        h = zh(u);
                    try {
                        null !== u && (u.dirty = !1), e(i, r)
                    } finally {
                        Sg(u, h)
                    }
                } finally {
                    a && null === n[xd] && qP(n, xd), ku(o), Fi(a ? 3 : 1, r)
                }
            }

            function cT(t, n, e) {
                if (oc(n)) {
                    const i = lr(null);
                    try {
                        const s = n.directiveEnd;
                        for (let o = n.directiveStart; o < s; o++) {
                            const a = t.data[o];
                            a.contentQueries && a.contentQueries(1, e[o], o)
                        }
                    } finally {
                        lr(i)
                    }
                }
            }

            function lT(t, n, e) {
                Au() && (function Lz(t, n, e, i) {
                    const r = e.directiveStart,
                        s = e.directiveEnd;
                    Rc(e) && function Hz(t, n, e) {
                        const i = Vo(n, t),
                            r = eO(e);
                        let o = 16;
                        e.signals ? o = 4096 : e.onPush && (o = 64);
                        const a = Gv(t, Wv(t, r, null, o, i, n, null, t[rs].rendererFactory.createRenderer(i, e), null, null, null));
                        t[n.index] = a
                    }(n, e, t.data[r + e.componentOffset]), t.firstCreatePass || Np(e, n), Gn(i, n);
                    const o = e.initialInputs;
                    for (let a = r; a < s; a++) {
                        const c = t.data[a],
                            u = ll(n, t, a, e);
                        Gn(u, n), null !== o && $z(0, a - r, u, c, 0, o), ga(c) && (So(e.index, n)[vr] = ll(n, t, a, e))
                    }
                }(t, n, e, Vo(e, n)), 64 == (64 & e.flags) && sO(t, n, e))
            }

            function uT(t, n, e = Vo) {
                const i = n.localNames;
                if (null !== i) {
                    let r = n.index + 1;
                    for (let s = 0; s < i.length; s += 2) {
                        const o = i[s + 1],
                            a = -1 === o ? e(n, t) : t[o];
                        t[r++] = a
                    }
                }
            }

            function eO(t) {
                const n = t.tView;
                return null === n || n.incompleteFirstPass ? t.tView = dT(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts, t.id) : n
            }

            function dT(t, n, e, i, r, s, o, a, c, u, h) {
                const m = Ni + i,
                    x = m + r,
                    D = function wz(t, n) {
                        const e = [];
                        for (let i = 0; i < n; i++) e.push(i < t ? null : ki);
                        return e
                    }(m, x),
                    V = "function" == typeof u ? u() : u;
                return D[Ct] = {
                    type: t,
                    blueprint: D,
                    template: e,
                    queries: null,
                    viewQuery: a,
                    declTNode: n,
                    data: D.slice().fill(null, m),
                    bindingStartIndex: m,
                    expandoStartIndex: x,
                    hostBindingOpCodes: null,
                    firstCreatePass: !0,
                    firstUpdatePass: !0,
                    staticViewQueries: !1,
                    staticContentQueries: !1,
                    preOrderHooks: null,
                    preOrderCheckHooks: null,
                    contentHooks: null,
                    contentCheckHooks: null,
                    viewHooks: null,
                    viewCheckHooks: null,
                    destroyHooks: null,
                    cleanup: null,
                    contentQueries: null,
                    components: null,
                    directiveRegistry: "function" == typeof s ? s() : s,
                    pipeRegistry: "function" == typeof o ? o() : o,
                    firstChild: null,
                    schemas: c,
                    consts: V,
                    incompleteFirstPass: !1,
                    ssrId: h
                }
            }
            let tO = t => null;

            function nO(t, n, e, i) {
                for (let r in t)
                    if (t.hasOwnProperty(r)) {
                        e = null === e ? {} : e;
                        const s = t[r];
                        null === i ? iO(e, n, r, s) : i.hasOwnProperty(r) && iO(e, n, i[r], s)
                    }
                return e
            }

            function iO(t, n, e, i) {
                t.hasOwnProperty(e) ? t[e].push(n, i) : t[e] = [n, i]
            }

            function fc(t, n, e, i, r, s, o, a) {
                const c = Vo(n, e);
                let h, u = n.inputs;
                !a && null != u && (h = u[i]) ? (gT(t, e, h, i, r), Rc(n) && function Mz(t, n) {
                    const e = So(n, t);
                    16 & e[bn] || (e[bn] |= 64)
                }(e, n.index)) : 3 & n.type && (i = function kz(t) {
                    return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t
                }(i), r = null != o ? o(r, n.value || "", i) : r, s.setProperty(c, i, r))
            }

            function hT(t, n, e, i) {
                if (Au()) {
                    const r = null === i ? null : {
                            "": -1
                        },
                        s = function Bz(t, n) {
                            const e = t.directiveRegistry;
                            let i = null,
                                r = null;
                            if (e)
                                for (let s = 0; s < e.length; s++) {
                                    const o = e[s];
                                    if (ct(n, o.selectors, !1))
                                        if (i || (i = []), ga(o))
                                            if (null !== o.findHostDirectiveDefs) {
                                                const a = [];
                                                r = r || new Map, o.findHostDirectiveDefs(o, a, r), i.unshift(...a, o), fT(t, n, a.length)
                                            } else i.unshift(o), fT(t, n, 0);
                                    else r = r || new Map, o.findHostDirectiveDefs ? .(o, i, r), i.push(o)
                                }
                            return null === i ? null : [i, r]
                        }(t, e);
                    let o, a;
                    null === s ? o = a = null : [o, a] = s, null !== o && rO(t, n, e, o, r, a), r && function Nz(t, n, e) {
                        if (n) {
                            const i = t.localNames = [];
                            for (let r = 0; r < n.length; r += 2) {
                                const s = e[n[r + 1]];
                                if (null == s) throw new mt(-301, !1);
                                i.push(n[r], s)
                            }
                        }
                    }(e, i, r)
                }
                e.mergedAttrs = il(e.mergedAttrs, e.attrs)
            }

            function rO(t, n, e, i, r, s) {
                for (let u = 0; u < i.length; u++) Hg(Np(e, n), t, i[u].type);
                ! function Vz(t, n, e) {
                    t.flags |= 1, t.directiveStart = n, t.directiveEnd = n + e, t.providerIndexes = n
                }(e, t.data.length, i.length);
                for (let u = 0; u < i.length; u++) {
                    const h = i[u];
                    h.providersResolver && h.providersResolver(h)
                }
                let o = !1,
                    a = !1,
                    c = uy(t, n, i.length, null);
                for (let u = 0; u < i.length; u++) {
                    const h = i[u];
                    e.mergedAttrs = il(e.mergedAttrs, h.hostAttrs), Uz(t, e, n, c, h), Fz(c, h, r), null !== h.contentQueries && (e.flags |= 4), (null !== h.hostBindings || null !== h.hostAttrs || 0 !== h.hostVars) && (e.flags |= 64);
                    const m = h.type.prototype;
                    !o && (m.ngOnChanges || m.ngOnInit || m.ngDoCheck) && ((t.preOrderHooks ? ? = []).push(e.index), o = !0), !a && (m.ngOnChanges || m.ngDoCheck) && ((t.preOrderCheckHooks ? ? = []).push(e.index), a = !0), c++
                }! function Az(t, n, e) {
                    const r = n.directiveEnd,
                        s = t.data,
                        o = n.attrs,
                        a = [];
                    let c = null,
                        u = null;
                    for (let h = n.directiveStart; h < r; h++) {
                        const m = s[h],
                            x = e ? e.get(m) : null,
                            V = x ? x.outputs : null;
                        c = nO(m.inputs, h, c, x ? x.inputs : null), u = nO(m.outputs, h, u, V);
                        const te = null === c || null === o || Rh(n) ? null : zz(c, h, o);
                        a.push(te)
                    }
                    null !== c && (c.hasOwnProperty("class") && (n.flags |= 8), c.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = c, n.outputs = u
                }(t, e, s)
            }

            function sO(t, n, e) {
                const i = e.directiveStart,
                    r = e.directiveEnd,
                    s = e.index,
                    o = function H1() {
                        return mi.lFrame.currentDirectiveIndex
                    }();
                try {
                    ku(s);
                    for (let a = i; a < r; a++) {
                        const c = t.data[a],
                            u = n[a];
                        gs(a), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && Rz(c, u)
                    }
                } finally {
                    ku(-1), gs(o)
                }
            }

            function Rz(t, n) {
                null !== t.hostBindings && t.hostBindings(1, n)
            }

            function fT(t, n, e) {
                n.componentOffset = e, (t.components ? ? = []).push(n.index)
            }

            function Fz(t, n, e) {
                if (e) {
                    if (n.exportAs)
                        for (let i = 0; i < n.exportAs.length; i++) e[n.exportAs[i]] = t;
                    ga(n) && (e[""] = t)
                }
            }

            function Uz(t, n, e, i, r) {
                t.data[i] = r;
                const s = r.factory || (r.factory = ie(r.type)),
                    o = new Qh(s, ga(r), We);
                t.blueprint[i] = o, e[i] = o,
                    function Pz(t, n, e, i, r) {
                        const s = r.hostBindings;
                        if (s) {
                            let o = t.hostBindingOpCodes;
                            null === o && (o = t.hostBindingOpCodes = []);
                            const a = ~n.index;
                            (function Oz(t) {
                                let n = t.length;
                                for (; n > 0;) {
                                    const e = t[--n];
                                    if ("number" == typeof e && e < 0) return e
                                }
                                return 0
                            })(o) != a && o.push(a), o.push(e, i, s)
                        }
                    }(t, n, i, uy(t, e, r.hostVars, ki), r)
            }

            function Wl(t, n, e, i, r, s) {
                const o = Vo(t, n);
                ! function pT(t, n, e, i, r, s, o) {
                    if (null == s) t.removeAttribute(n, r, e);
                    else {
                        const a = null == o ? Zn(s) : o(s, i || "", r);
                        t.setAttribute(n, r, a, e)
                    }
                }(n[Hn], o, s, t.value, e, i, r)
            }

            function $z(t, n, e, i, r, s) {
                const o = s[n];
                if (null !== o)
                    for (let a = 0; a < o.length;) oO(i, e, o[a++], o[a++], o[a++])
            }

            function oO(t, n, e, i, r) {
                const s = lr(null);
                try {
                    const o = t.inputTransforms;
                    null !== o && o.hasOwnProperty(i) && (r = o[i].call(n, r)), null !== t.setInput ? t.setInput(n, r, e, i) : n[i] = r
                } finally {
                    lr(s)
                }
            }

            function zz(t, n, e) {
                let i = null,
                    r = 0;
                for (; r < e.length;) {
                    const s = e[r];
                    if (0 !== s)
                        if (5 !== s) {
                            if ("number" == typeof s) break;
                            if (t.hasOwnProperty(s)) {
                                null === i && (i = []);
                                const o = t[s];
                                for (let a = 0; a < o.length; a += 2)
                                    if (o[a] === n) {
                                        i.push(s, o[a + 1], e[r + 1]);
                                        break
                                    }
                            }
                            r += 2
                        } else r += 2;
                    else r += 4
                }
                return i
            }

            function aO(t, n, e, i) {
                return [t, !0, !1, n, null, 0, i, e, null, null, null]
            }

            function cO(t, n) {
                const e = t.contentQueries;
                if (null !== e)
                    for (let i = 0; i < e.length; i += 2) {
                        const s = e[i + 1];
                        if (-1 !== s) {
                            const o = t.data[s];
                            Mp(e[i]), o.contentQueries(2, n[s], s)
                        }
                    }
            }

            function Gv(t, n) {
                return t[rl] ? t[Uh][ni] = n : t[rl] = n, t[Uh] = n, n
            }

            function mT(t, n, e) {
                Mp(0);
                const i = lr(null);
                try {
                    n(t, e)
                } finally {
                    lr(i)
                }
            }

            function lO(t) {
                return t[no] || (t[no] = [])
            }

            function uO(t) {
                return t.cleanup || (t.cleanup = [])
            }

            function hO(t, n) {
                const e = t[Zr],
                    i = e ? e.get(jl, null) : null;
                i && i.handleError(n)
            }

            function gT(t, n, e, i, r) {
                for (let s = 0; s < e.length;) {
                    const o = e[s++],
                        a = e[s++];
                    oO(t.data[o], n[o], i, a, r)
                }
            }

            function Lu(t, n, e) {
                const i = Ag(n, t);
                ! function Qg(t, n, e) {
                    t.setValue(n, e)
                }(t[Hn], i, e)
            }

            function jz(t, n) {
                const e = So(n, t),
                    i = e[Ct];
                ! function Wz(t, n) {
                    for (let e = n.length; e < t.blueprint.length; e++) n.push(t.blueprint[e])
                }(i, e);
                const r = e[Wt];
                null !== r && null === e[Ua] && (e[Ua] = YC(r, e[Zr])), yT(i, e, e[vr])
            }

            function yT(t, n, e) {
                Ip(n);
                try {
                    const i = t.viewQuery;
                    null !== i && mT(1, i, e);
                    const r = t.template;
                    null !== r && JP(t, n, r, 1, e), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && cO(t, n), t.staticViewQueries && mT(2, t.viewQuery, e);
                    const s = t.components;
                    null !== s && function Gz(t, n) {
                        for (let e = 0; e < n.length; e++) jz(t, n[e])
                    }(n, s)
                } catch (i) {
                    throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), i
                } finally {
                    n[bn] &= -5, Yh()
                }
            }
            let fO = (() => {
                class t {
                    constructor() {
                        this.all = new Set, this.queue = new Map
                    }
                    create(e, i, r) {
                        const s = typeof Zone > "u" ? null : Zone.current,
                            o = function N_(t, n, e) {
                                const i = Object.create(_a);
                                e && (i.consumerAllowSignalWrites = !0), i.fn = t, i.schedule = n;
                                const r = o => {
                                    i.cleanupFn = o
                                };
                                return i.ref = {
                                    notify: () => Tg(i),
                                    run: () => {
                                        if (i.dirty = !1, i.hasRun && !Oi(i)) return;
                                        i.hasRun = !0;
                                        const o = zh(i);
                                        try {
                                            i.cleanupFn(), i.cleanupFn = Fo, i.fn(r)
                                        } finally {
                                            Sg(i, o)
                                        }
                                    },
                                    cleanup: () => i.cleanupFn()
                                }, i.ref
                            }(e, u => {
                                this.all.has(u) && this.queue.set(u, s)
                            }, r);
                        let a;
                        this.all.add(o), o.notify();
                        const c = () => {
                            o.cleanup(), a ? .(), this.all.delete(o), this.queue.delete(o)
                        };
                        return a = i ? .onDestroy(c), {
                            destroy: c
                        }
                    }
                    flush() {
                        if (0 !== this.queue.size)
                            for (const [e, i] of this.queue) this.queue.delete(e), i ? i.run(() => e.run()) : e.run()
                    }
                    get isQueueEmpty() {
                        return 0 === this.queue.size
                    }
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "root",
                        factory: () => new t
                    })
                }
                return t
            })();

            function Kv(t, n, e) {
                let i = e ? t.styles : null,
                    r = e ? t.classes : null,
                    s = 0;
                if (null !== n)
                    for (let o = 0; o < n.length; o++) {
                        const a = n[o];
                        "number" == typeof a ? s = a : 1 == s ? r = qi(r, a) : 2 == s && (i = qi(i, a + ": " + n[++o] + ";"))
                    }
                e ? t.styles = i : t.stylesWithoutHost = i, e ? t.classes = r : t.classesWithoutHost = r
            }

            function dy(t, n, e, i, r = !1) {
                for (; null !== e;) {
                    const s = n[e.index];
                    null !== s && i.push(Xr(s)), uo(s) && pO(s, i);
                    const o = e.type;
                    if (8 & o) dy(t, n, e.child, i);
                    else if (32 & o) {
                        const a = hl(e, n);
                        let c;
                        for (; c = a();) i.push(c)
                    } else if (16 & o) {
                        const a = ZI(n, e);
                        if (Array.isArray(a)) i.push(...a);
                        else {
                            const c = Gd(n[Er]);
                            dy(c[Ct], c, a, i, !0)
                        }
                    }
                    e = r ? e.projectionNext : e.next
                }
                return i
            }

            function pO(t, n) {
                for (let e = ms; e < t.length; e++) {
                    const i = t[e],
                        r = i[Ct].firstChild;
                    null !== r && dy(i[Ct], i, r, n)
                }
                t[io] !== t[Wt] && n.push(t[io])
            }

            function qv(t, n, e, i = !0) {
                const r = n[rs],
                    s = r.rendererFactory,
                    o = r.afterRenderEventManager;
                s.begin ? .(), o ? .begin();
                try {
                    mO(t, n, t.template, e)
                } catch (c) {
                    throw i && hO(n, c), c
                } finally {
                    s.end ? .(), r.effectManager ? .flush(), o ? .end()
                }
            }

            function mO(t, n, e, i) {
                const r = n[bn];
                if (256 != (256 & r)) {
                    n[rs].effectManager ? .flush(), Ip(n);
                    try {
                        Kh(n),
                            function W_(t) {
                                return mi.lFrame.bindingIndex = t
                            }(t.bindingStartIndex), null !== e && JP(t, n, e, 2, i);
                        const o = 3 == (3 & r);
                        if (o) {
                            const u = t.preOrderCheckHooks;
                            null !== u && Op(n, u, null)
                        } else {
                            const u = t.preOrderHooks;
                            null !== u && Lp(n, u, 0, null), Lg(n, 0)
                        }
                        if (function Zz(t) {
                                for (let n = Cv(t); null !== n; n = Tv(n)) {
                                    if (!n[pp]) continue;
                                    const e = n[Or];
                                    for (let i = 0; i < e.length; i++) {
                                        kg(e[i])
                                    }
                                }
                            }(n), gO(n, 2), null !== t.contentQueries && cO(t, n), o) {
                            const u = t.contentCheckHooks;
                            null !== u && Op(n, u)
                        } else {
                            const u = t.contentHooks;
                            null !== u && Lp(n, u, 1), Lg(n, 1)
                        }! function bz(t, n) {
                            const e = t.hostBindingOpCodes;
                            if (null === e) return;
                            const i = KP(n, Bl);
                            try {
                                for (let r = 0; r < e.length; r++) {
                                    const s = e[r];
                                    if (s < 0) ku(~s);
                                    else {
                                        const o = s,
                                            a = e[++r],
                                            c = e[++r];
                                        U1(a, o), i.dirty = !1;
                                        const u = zh(i);
                                        try {
                                            c(2, n[o])
                                        } finally {
                                            Sg(i, u)
                                        }
                                    }
                                }
                            } finally {
                                null === n[Bl] && qP(n, Bl), ku(-1)
                            }
                        }(t, n);
                        const a = t.components;
                        null !== a && _O(n, a, 0);
                        const c = t.viewQuery;
                        if (null !== c && mT(2, c, i), o) {
                            const u = t.viewCheckHooks;
                            null !== u && Op(n, u)
                        } else {
                            const u = t.viewHooks;
                            null !== u && Lp(n, u, 2), Lg(n, 2)
                        }!0 === t.firstUpdatePass && (t.firstUpdatePass = !1), n[bn] &= -73, Ep(n)
                    } finally {
                        Yh()
                    }
                }
            }

            function gO(t, n) {
                for (let e = Cv(t); null !== e; e = Tv(e))
                    for (let i = ms; i < e.length; i++) yO(e[i], n)
            }

            function Yz(t, n, e) {
                yO(So(n, t), e)
            }

            function yO(t, n) {
                if (! function R1(t) {
                        return 128 == (128 & t[bn])
                    }(t)) return;
                const e = t[Ct],
                    i = t[bn];
                if (80 & i && 0 === n || 1024 & i || 2 === n) mO(e, t, e.template, t[vr]);
                else if (t[fr] > 0) {
                    gO(t, 1);
                    const r = e.components;
                    null !== r && _O(t, r, 1)
                }
            }

            function _O(t, n, e) {
                for (let i = 0; i < n.length; i++) Yz(t, n[i], e)
            }
            class hy {
                get rootNodes() {
                    const n = this._lView,
                        e = n[Ct];
                    return dy(e, n, e.firstChild, [])
                }
                constructor(n, e) {
                    this._lView = n, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1
                }
                get context() {
                    return this._lView[vr]
                }
                set context(n) {
                    this._lView[vr] = n
                }
                get destroyed() {
                    return 256 == (256 & this._lView[bn])
                }
                destroy() {
                    if (this._appRef) this._appRef.detachView(this);
                    else if (this._attachedToViewContainer) {
                        const n = this._lView[vi];
                        if (uo(n)) {
                            const e = n[8],
                                i = e ? e.indexOf(this) : -1;
                            i > -1 && (Dv(n, i), ul(e, i))
                        }
                        this._attachedToViewContainer = !1
                    }
                    xC(this._lView[Ct], this._lView)
                }
                onDestroy(n) {
                    ! function ar(t, n) {
                        if (256 == (256 & t[bn])) throw new mt(911, !1);
                        null === t[Lc] && (t[Lc] = []), t[Lc].push(n)
                    }(this._lView, n)
                }
                markForCheck() {
                    ly(this._cdRefInjectingView || this._lView)
                }
                detach() {
                    this._lView[bn] &= -129
                }
                reattach() {
                    this._lView[bn] |= 128
                }
                detectChanges() {
                    qv(this._lView[Ct], this._lView, this.context)
                }
                checkNoChanges() {}
                attachToViewContainerRef() {
                    if (this._appRef) throw new mt(902, !1);
                    this._attachedToViewContainer = !0
                }
                detachFromAppRef() {
                    this._appRef = null,
                        function _C(t, n) {
                            ey(t, n, n[Hn], 2, null, null)
                        }(this._lView[Ct], this._lView)
                }
                attachToAppRef(n) {
                    if (this._attachedToViewContainer) throw new mt(902, !1);
                    this._appRef = n
                }
            }
            class Xz extends hy {
                constructor(n) {
                    super(n), this._view = n
                }
                detectChanges() {
                    const n = this._view;
                    qv(n[Ct], n, n[vr], !1)
                }
                checkNoChanges() {}
                get context() {
                    return null
                }
            }
            class vO extends Xp {
                constructor(n) {
                    super(), this.ngModule = n
                }
                resolveComponentFactory(n) {
                    const e = Yi(n);
                    return new fy(e, this.ngModule)
                }
            }

            function bO(t) {
                const n = [];
                for (let e in t) t.hasOwnProperty(e) && n.push({
                    propName: t[e],
                    templateName: e
                });
                return n
            }
            class Jz {
                constructor(n, e) {
                    this.injector = n, this.parentInjector = e
                }
                get(n, e, i) {
                    i = sc(i);
                    const r = this.injector.get(n, JC, i);
                    return r !== JC || e === JC ? r : this.parentInjector.get(n, e, i)
                }
            }
            class fy extends SP {
                get inputs() {
                    const n = this.componentDef,
                        e = n.inputTransforms,
                        i = bO(n.inputs);
                    if (null !== e)
                        for (const r of i) e.hasOwnProperty(r.propName) && (r.transform = e[r.propName]);
                    return i
                }
                get outputs() {
                    return bO(this.componentDef.outputs)
                }
                constructor(n, e) {
                    super(), this.componentDef = n, this.ngModule = e, this.componentType = n.type, this.selector = function Rl(t) {
                        return t.map(Jt).join(",")
                    }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!e
                }
                create(n, e, i, r) {
                    let s = (r = r || this.ngModule) instanceof hc ? r : r ? .injector;
                    s && null !== this.componentDef.getStandaloneInjector && (s = this.componentDef.getStandaloneInjector(s) || s);
                    const o = s ? new Jz(n, s) : n,
                        a = o.get(pf, null);
                    if (null === a) throw new mt(407, !1);
                    const m = {
                            rendererFactory: a,
                            sanitizer: o.get(X$, null),
                            effectManager: o.get(fO, null),
                            afterRenderEventManager: o.get(oT, null)
                        },
                        x = a.createRenderer(null, this.componentDef),
                        D = this.componentDef.selectors[0][0] || "div",
                        V = i ? function xz(t, n, e, i) {
                            const s = i.get(zP, !1) || e === ls.ShadowDom,
                                o = t.selectRootElement(n, s);
                            return function Cz(t) {
                                tO(t)
                            }(o), o
                        }(x, i, this.componentDef.encapsulation, o) : df(x, D, function Qz(t) {
                            const n = t.toLowerCase();
                            return "svg" === n ? Tp : "math" === n ? "math" : null
                        }(D)),
                        _e = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528;
                    let ye = null;
                    null !== V && (ye = YC(V, o, !0));
                    const Be = dT(0, null, null, 1, 0, null, null, null, null, null, null),
                        ze = Wv(null, Be, null, _e, null, null, m, x, o, null, ye);
                    let Xe, ht;
                    Ip(ze);
                    try {
                        const vt = this.componentDef;
                        let jt, Cn = null;
                        vt.findHostDirectiveDefs ? (jt = [], Cn = new Map, vt.findHostDirectiveDefs(vt, jt, Cn), jt.push(vt)) : jt = [vt];
                        const Xt = function tj(t, n) {
                                const e = t[Ct],
                                    i = Ni;
                                return t[i] = n, tm(e, i, 2, "#host", null)
                            }(ze, V),
                            Rt = function nj(t, n, e, i, r, s, o) {
                                const a = r[Ct];
                                ! function ij(t, n, e, i) {
                                    for (const r of t) n.mergedAttrs = il(n.mergedAttrs, r.hostAttrs);
                                    null !== n.mergedAttrs && (Kv(n, n.mergedAttrs, !0), null !== e && JI(i, e, n))
                                }(i, t, n, o);
                                let c = null;
                                null !== n && (c = YC(n, r[Zr]));
                                const u = s.rendererFactory.createRenderer(n, e);
                                let h = 16;
                                e.signals ? h = 4096 : e.onPush && (h = 64);
                                const m = Wv(r, eO(e), null, h, r[t.index], t, s, u, null, null, c);
                                return a.firstCreatePass && fT(a, t, i.length - 1), Gv(r, m), r[t.index] = m
                            }(Xt, V, vt, jt, ze, m, x);
                        ht = V_(Be, Ni), V && function sj(t, n, e, i) {
                            if (i) dn(t, e, ["ng-version", Q$.full]);
                            else {
                                const {
                                    attrs: r,
                                    classes: s
                                } = function Ot(t) {
                                    const n = [],
                                        e = [];
                                    let i = 1,
                                        r = 2;
                                    for (; i < t.length;) {
                                        let s = t[i];
                                        if ("string" == typeof s) 2 === r ? "" !== s && n.push(s, t[++i]) : 8 === r && e.push(s);
                                        else {
                                            if (!to(r)) break;
                                            r = s
                                        }
                                        i++
                                    }
                                    return {
                                        attrs: n,
                                        classes: e
                                    }
                                }(n.selectors[0]);
                                r && dn(t, e, r), s && s.length > 0 && QI(t, e, s.join(" "))
                            }
                        }(x, vt, V, i), void 0 !== e && function oj(t, n, e) {
                            const i = t.projection = [];
                            for (let r = 0; r < n.length; r++) {
                                const s = e[r];
                                i.push(null != s ? Array.from(s) : null)
                            }
                        }(ht, this.ngContentSelectors, e), Xe = function rj(t, n, e, i, r, s) {
                            const o = Cs(),
                                a = r[Ct],
                                c = Vo(o, r);
                            rO(a, r, o, e, null, i);
                            for (let h = 0; h < e.length; h++) Gn(ll(r, a, o.directiveStart + h, o), r);
                            sO(a, r, o), c && Gn(c, r);
                            const u = ll(r, a, o.directiveStart + o.componentOffset, o);
                            if (t[vr] = r[vr] = u, null !== s)
                                for (const h of s) h(u, n);
                            return cT(a, o, t), u
                        }(Rt, vt, jt, Cn, ze, [aj]), yT(Be, ze, null)
                    } finally {
                        Yh()
                    }
                    return new ej(this.componentType, Xe, Qp(ht, ze), ze, ht)
                }
            }
            class ej extends W$ {
                constructor(n, e, i, r, s) {
                    super(), this.location = i, this._rootLView = r, this._tNode = s, this.previousInputValues = null, this.instance = e, this.hostView = this.changeDetectorRef = new Xz(r), this.componentType = n
                }
                setInput(n, e) {
                    const i = this._tNode.inputs;
                    let r;
                    if (null !== i && (r = i[n])) {
                        if (this.previousInputValues ? ? = new Map, this.previousInputValues.has(n) && Object.is(this.previousInputValues.get(n), e)) return;
                        const s = this._rootLView;
                        gT(s[Ct], s, r, n, e), this.previousInputValues.set(n, e), ly(So(this._tNode.index, s))
                    }
                }
                get injector() {
                    return new Ho(this._tNode, this._rootLView)
                }
                destroy() {
                    this.hostView.destroy()
                }
                onDestroy(n) {
                    this.hostView.onDestroy(n)
                }
            }

            function aj() {
                const t = Cs();
                Pp(It()[Ct], t)
            }

            function Vr(t) {
                let n = function wO(t) {
                        return Object.getPrototypeOf(t.prototype).constructor
                    }(t.type),
                    e = !0;
                const i = [t];
                for (; n;) {
                    let r;
                    if (ga(t)) r = n.\u0275cmp || n.\u0275dir;
                    else {
                        if (n.\u0275cmp) throw new mt(903, !1);
                        r = n.\u0275dir
                    }
                    if (r) {
                        if (e) {
                            i.push(r);
                            const o = t;
                            o.inputs = Zv(t.inputs), o.inputTransforms = Zv(t.inputTransforms), o.declaredInputs = Zv(t.declaredInputs), o.outputs = Zv(t.outputs);
                            const a = r.hostBindings;
                            a && dj(t, a);
                            const c = r.viewQuery,
                                u = r.contentQueries;
                            if (c && lj(t, c), u && uj(t, u), or(t.inputs, r.inputs), or(t.declaredInputs, r.declaredInputs), or(t.outputs, r.outputs), null !== r.inputTransforms && (null === o.inputTransforms && (o.inputTransforms = {}), or(o.inputTransforms, r.inputTransforms)), ga(r) && r.data.animation) {
                                const h = t.data;
                                h.animation = (h.animation || []).concat(r.data.animation)
                            }
                        }
                        const s = r.features;
                        if (s)
                            for (let o = 0; o < s.length; o++) {
                                const a = s[o];
                                a && a.ngInherit && a(t), a === Vr && (e = !1)
                            }
                    }
                    n = Object.getPrototypeOf(n)
                }! function cj(t) {
                    let n = 0,
                        e = null;
                    for (let i = t.length - 1; i >= 0; i--) {
                        const r = t[i];
                        r.hostVars = n += r.hostVars, r.hostAttrs = il(r.hostAttrs, e = il(e, r.hostAttrs))
                    }
                }(i)
            }

            function Zv(t) {
                return t === xs ? {} : t === Vn ? [] : t
            }

            function lj(t, n) {
                const e = t.viewQuery;
                t.viewQuery = e ? (i, r) => {
                    n(i, r), e(i, r)
                } : n
            }

            function uj(t, n) {
                const e = t.contentQueries;
                t.contentQueries = e ? (i, r, s) => {
                    n(i, r, s), e(i, r, s)
                } : n
            }

            function dj(t, n) {
                const e = t.hostBindings;
                t.hostBindings = e ? (i, r) => {
                    n(i, r), e(i, r)
                } : n
            }

            function SO(t) {
                const n = t.inputConfig,
                    e = {};
                for (const i in n)
                    if (n.hasOwnProperty(i)) {
                        const r = n[i];
                        Array.isArray(r) && r[2] && (e[i] = r[2])
                    }
                t.inputTransforms = e
            }

            function Yv(t) {
                return !!_T(t) && (Array.isArray(t) || !(t instanceof Map) && Symbol.iterator in t)
            }

            function _T(t) {
                return null !== t && ("function" == typeof t || "object" == typeof t)
            }

            function Gl(t, n, e) {
                return t[n] = e
            }

            function py(t, n) {
                return t[n]
            }

            function ta(t, n, e) {
                return !Object.is(t[n], e) && (t[n] = e, !0)
            }

            function mf(t, n, e, i) {
                const r = ta(t, n, e);
                return ta(t, n + 1, i) || r
            }

            function Xv(t, n, e, i, r) {
                const s = mf(t, n, e, i);
                return ta(t, n + 2, r) || s
            }

            function Uc(t, n, e, i, r, s) {
                const o = mf(t, n, e, i);
                return mf(t, n + 2, r, s) || o
            }

            function hi(t, n, e, i) {
                const r = It();
                return ta(r, Od(), n) && (ur(), Wl(ds(), r, t, n, e, i)), hi
            }

            function im(t, n, e, i) {
                return ta(t, Od(), e) ? n + Zn(e) + i : ki
            }

            function tt(t, n, e, i, r, s, o, a) {
                const c = It(),
                    u = ur(),
                    h = t + Ni,
                    m = u.firstCreatePass ? function Bj(t, n, e, i, r, s, o, a, c) {
                        const u = n.consts,
                            h = tm(n, t, 4, o || null, Ul(u, a));
                        hT(n, e, h, Ul(u, c)), Pp(n, h);
                        const m = h.tView = dT(2, h, i, r, s, n.directiveRegistry, n.pipeRegistry, null, n.schemas, u, null);
                        return null !== n.queries && (n.queries.template(n, h), m.queries = n.queries.embeddedTView(h)), h
                    }(h, u, c, n, e, i, r, s, o) : u.data[h];
                ea(m, !1);
                const x = FO(u, c, m, t);
                Xh() && kv(u, c, x, m), Gn(x, c), Gv(c, c[h] = aO(x, c, x, m)), Hh(m) && lT(u, c, m), null != o && uT(c, m, a)
            }
            let FO = function VO(t, n, e, i) {
                return $l(!0), n[Hn].createComment("")
            };

            function pl(t) {
                return kd(function $_() {
                    return mi.lFrame.contextLView
                }(), Ni + t)
            }

            function Re(t, n, e) {
                const i = It();
                return ta(i, Od(), n) && fc(ur(), ds(), i, t, n, i[Hn], e, !1), Re
            }

            function TT(t, n, e, i, r) {
                const o = r ? "class" : "style";
                gT(t, e, n.inputs[o], o, i)
            }

            function J(t, n, e, i) {
                const r = It(),
                    s = ur(),
                    o = Ni + t,
                    a = r[Hn],
                    c = s.firstCreatePass ? function Uj(t, n, e, i, r, s) {
                        const o = n.consts,
                            c = tm(n, t, 2, i, Ul(o, r));
                        return hT(n, e, c, Ul(o, s)), null !== c.attrs && Kv(c, c.attrs, !1), null !== c.mergedAttrs && Kv(c, c.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, c), c
                    }(o, s, r, n, e, i) : s.data[o],
                    u = UO(s, r, c, a, n, t);
                r[o] = u;
                const h = Hh(c);
                return ea(c, !0), JI(a, u, c), 32 != (32 & c.flags) && Xh() && kv(s, r, u, c), 0 === function Dp() {
                        return mi.lFrame.elementDepthCount
                    }() && Gn(u, r),
                    function N1() {
                        mi.lFrame.elementDepthCount++
                    }(), h && (lT(s, r, c), cT(s, c, r)), null !== i && uT(r, c), J
            }

            function ce() {
                let t = Cs();
                qh() ? Pg() : (t = t.parent, ea(t, !1));
                const n = t;
                (function qr(t) {
                    return mi.skipHydrationRootTNode === t
                })(n) && function V1() {
                    mi.skipHydrationRootTNode = null
                }(),
                function MI() {
                    mi.lFrame.elementDepthCount--
                }();
                const e = ur();
                return e.firstCreatePass && (Pp(e, t), oc(t) && e.queries.elementEnd(t)), null != n.classesWithoutHost && function Bg(t) {
                    return 0 != (8 & t.flags)
                }(n) && TT(e, n, It(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function Y1(t) {
                    return 0 != (16 & t.flags)
                }(n) && TT(e, n, It(), n.stylesWithoutHost, !1), ce
            }

            function gt(t, n, e, i) {
                return J(t, n, e, i), ce(), gt
            }
            let UO = (t, n, e, i, r, s) => ($l(!0), df(i, r, function q_() {
                return mi.lFrame.currentNamespace
            }()));

            function Kl(t, n, e) {
                const i = It(),
                    r = ur(),
                    s = t + Ni,
                    o = r.firstCreatePass ? function zj(t, n, e, i, r) {
                        const s = n.consts,
                            o = Ul(s, i),
                            a = tm(n, t, 8, "ng-container", o);
                        return null !== o && Kv(a, o, !0), hT(n, e, a, Ul(s, r)), null !== n.queries && n.queries.elementStart(n, a), a
                    }(s, r, i, n, e) : r.data[s];
                ea(o, !0);
                const a = HO(r, i, o, t);
                return i[s] = a, Xh() && kv(r, i, a, o), Gn(a, i), Hh(o) && (lT(r, i, o), cT(r, o, i)), null != e && uT(i, o), Kl
            }

            function ql() {
                let t = Cs();
                const n = ur();
                return qh() ? Pg() : (t = t.parent, ea(t, !1)), n.firstCreatePass && (Pp(n, t), oc(t) && n.queries.elementEnd(t)), ql
            }

            function tb(t, n, e) {
                return Kl(t, n, e), ql(), tb
            }
            let HO = (t, n, e, i) => ($l(!0), zp(n[Hn], ""));

            function On() {
                return It()
            }

            function _y(t) {
                return !!t && "function" == typeof t.then
            }

            function $O(t) {
                return !!t && "function" == typeof t.subscribe
            }

            function xt(t, n, e, i) {
                const r = It(),
                    s = ur(),
                    o = Cs();
                return function jO(t, n, e, i, r, s, o) {
                    const a = Hh(i),
                        u = t.firstCreatePass && uO(t),
                        h = n[vr],
                        m = lO(n);
                    let x = !0;
                    if (3 & i.type || o) {
                        const te = Vo(i, n),
                            ee = o ? o(te) : te,
                            _e = m.length,
                            ye = o ? ze => o(Xr(ze[i.index])) : i.index;
                        let Be = null;
                        if (!o && a && (Be = function Gj(t, n, e, i) {
                                const r = t.cleanup;
                                if (null != r)
                                    for (let s = 0; s < r.length - 1; s += 2) {
                                        const o = r[s];
                                        if (o === e && r[s + 1] === i) {
                                            const a = n[no],
                                                c = r[s + 2];
                                            return a.length > c ? a[c] : null
                                        }
                                        "string" == typeof o && (s += 2)
                                    }
                                return null
                            }(t, n, r, i.index)), null !== Be)(Be.__ngLastListenerFn__ || Be).__ngNextListenerFn__ = s, Be.__ngLastListenerFn__ = s, x = !1;
                        else {
                            s = GO(i, n, h, s, !1);
                            const ze = e.listen(ee, r, s);
                            m.push(s, ze), u && u.push(r, ye, _e, _e + 1)
                        }
                    } else s = GO(i, n, h, s, !1);
                    const D = i.outputs;
                    let V;
                    if (x && null !== D && (V = D[r])) {
                        const te = V.length;
                        if (te)
                            for (let ee = 0; ee < te; ee += 2) {
                                const Xe = n[V[ee]][V[ee + 1]].subscribe(s),
                                    ht = m.length;
                                m.push(s, Xe), u && u.push(r, i.index, ht, -(ht + 1))
                            }
                    }
                }(s, r, r[Hn], o, t, n, i), xt
            }

            function WO(t, n, e, i) {
                try {
                    return Fi(6, n, e), !1 !== e(i)
                } catch (r) {
                    return hO(t, r), !1
                } finally {
                    Fi(7, n, e)
                }
            }

            function GO(t, n, e, i, r) {
                return function s(o) {
                    if (o === Function) return i;
                    ly(t.componentOffset > -1 ? So(t.index, n) : n);
                    let c = WO(n, e, i, o),
                        u = s.__ngNextListenerFn__;
                    for (; u;) c = WO(n, e, u, o) && c, u = u.__ngNextListenerFn__;
                    return r && !1 === c && o.preventDefault(), c
                }
            }

            function Ke(t = 1) {
                return function z1(t) {
                    return (mi.lFrame.contextLView = function j1(t, n) {
                        for (; t > 0;) n = n[sl], t--;
                        return n
                    }(t, mi.lFrame.contextLView))[vr]
                }(t)
            }

            function Kj(t, n) {
                let e = null;
                const i = function Oc(t) {
                    const n = t.attrs;
                    if (null != n) {
                        const e = n.indexOf(5);
                        if (!(1 & e)) return n[e + 1]
                    }
                    return null
                }(t);
                for (let r = 0; r < n.length; r++) {
                    const s = n[r];
                    if ("*" !== s) {
                        if (null === i ? ct(t, s, !0) : Nh(i, s)) return r
                    } else e = r
                }
                return e
            }

            function Zd(t) {
                const n = It()[Er][ii];
                if (!n.projection) {
                    const i = n.projection = va(t ? t.length : 1, null),
                        r = i.slice();
                    let s = n.child;
                    for (; null !== s;) {
                        const o = t ? Kj(s, t) : 0;
                        null !== o && (r[o] ? r[o].projectionNext = s : i[o] = s, r[o] = s), s = s.next
                    }
                }
            }

            function Ru(t, n = 0, e) {
                const i = It(),
                    r = ur(),
                    s = tm(r, Ni + t, 16, null, e || null);
                null === s.projection && (s.projection = n), Pg(), (!i[Ua] || Id()) && 32 != (32 & s.flags) && function X7(t, n, e) {
                    XI(n[Hn], 0, n, e, TC(t, e, n), WI(e.parent || n[ii], e, n))
                }(r, i, s)
            }

            function Yd(t, n, e) {
                return qs(t, "", n, "", e), Yd
            }

            function qs(t, n, e, i, r) {
                const s = It(),
                    o = im(s, n, e, i);
                return o !== ki && fc(ur(), ds(), s, t, o, s[Hn], r, !1), qs
            }

            function nb(t, n) {
                return t << 17 | n << 2
            }

            function Xd(t) {
                return t >> 17 & 32767
            }

            function ST(t) {
                return 2 | t
            }

            function gf(t) {
                return (131068 & t) >> 2
            }

            function ET(t, n) {
                return -131069 & t | n << 2
            }

            function DT(t) {
                return 1 | t
            }

            function tL(t, n, e, i, r) {
                const s = t[e + 1],
                    o = null === n;
                let a = i ? Xd(s) : gf(s),
                    c = !1;
                for (; 0 !== a && (!1 === c || o);) {
                    const h = t[a + 1];
                    Jj(t[a], n) && (c = !0, t[a + 1] = i ? DT(h) : ST(h)), a = i ? Xd(h) : gf(h)
                }
                c && (t[e + 1] = i ? ST(s) : DT(s))
            }

            function Jj(t, n) {
                return null === t || null == n || (Array.isArray(t) ? t[1] : t) === n || !(!Array.isArray(t) || "string" != typeof n) && Mu(t, n) >= 0
            }
            const po = {
                textEnd: 0,
                key: 0,
                keyEnd: 0,
                value: 0,
                valueEnd: 0
            };

            function nL(t) {
                return t.substring(po.key, po.keyEnd)
            }

            function iL(t, n) {
                const e = po.textEnd;
                return e === n ? -1 : (n = po.keyEnd = function i9(t, n, e) {
                    for (; n < e && t.charCodeAt(n) > 32;) n++;
                    return n
                }(t, po.key = n, e), dm(t, n, e))
            }

            function dm(t, n, e) {
                for (; n < e && t.charCodeAt(n) <= 32;) n++;
                return n
            }

            function jo(t, n, e) {
                return ml(t, n, e, !1), jo
            }

            function ja(t, n) {
                return ml(t, n, null, !0), ja
            }

            function AT(t) {
                gl(h9, Yl, t, !0)
            }

            function Yl(t, n) {
                for (let e = function t9(t) {
                        return function sL(t) {
                            po.key = 0, po.keyEnd = 0, po.value = 0, po.valueEnd = 0, po.textEnd = t.length
                        }(t), iL(t, dm(t, 0, po.textEnd))
                    }(n); e >= 0; e = iL(n, e)) $o(t, nL(n), !0)
            }

            function ml(t, n, e, i) {
                const r = It(),
                    s = ur(),
                    o = Nc(2);
                s.firstUpdatePass && lL(s, t, o, i), n !== ki && ta(r, o, n) && dL(s, s.data[Uo()], r, r[Hn], t, r[o + 1] = function p9(t, n) {
                    return null == t || "" === t || ("string" == typeof n ? t += n : "object" == typeof t && (t = ti(qd(t)))), t
                }(n, e), i, o)
            }

            function gl(t, n, e, i) {
                const r = ur(),
                    s = Nc(2);
                r.firstUpdatePass && lL(r, null, s, i);
                const o = It();
                if (e !== ki && ta(o, s, e)) {
                    const a = r.data[Uo()];
                    if (fL(a, i) && !cL(r, s)) {
                        let c = i ? a.classesWithoutHost : a.stylesWithoutHost;
                        null !== c && (e = qi(c, e || "")), TT(r, a, o, e, i)
                    } else ! function f9(t, n, e, i, r, s, o, a) {
                        r === ki && (r = Vn);
                        let c = 0,
                            u = 0,
                            h = 0 < r.length ? r[0] : null,
                            m = 0 < s.length ? s[0] : null;
                        for (; null !== h || null !== m;) {
                            const x = c < r.length ? r[c + 1] : void 0,
                                D = u < s.length ? s[u + 1] : void 0;
                            let te, V = null;
                            h === m ? (c += 2, u += 2, x !== D && (V = m, te = D)) : null === m || null !== h && h < m ? (c += 2, V = h) : (u += 2, V = m, te = D), null !== V && dL(t, n, e, i, V, te, o, a), h = c < r.length ? r[c] : null, m = u < s.length ? s[u] : null
                        }
                    }(r, a, o, o[Hn], o[s + 1], o[s + 1] = function d9(t, n, e) {
                        if (null == e || "" === e) return Vn;
                        const i = [],
                            r = qd(e);
                        if (Array.isArray(r))
                            for (let s = 0; s < r.length; s++) t(i, r[s], !0);
                        else if ("object" == typeof r)
                            for (const s in r) r.hasOwnProperty(s) && t(i, s, r[s]);
                        else "string" == typeof r && n(i, r);
                        return i
                    }(t, n, e), i, s)
                }
            }

            function cL(t, n) {
                return n >= t.expandoStartIndex
            }

            function lL(t, n, e, i) {
                const r = t.data;
                if (null === r[e + 1]) {
                    const s = r[Uo()],
                        o = cL(t, e);
                    fL(s, i) && null === n && !o && (n = !1), n = function a9(t, n, e, i) {
                            const r = function Ap(t) {
                                const n = mi.lFrame.currentDirectiveIndex;
                                return -1 === n ? null : t[n]
                            }(t);
                            let s = i ? n.residualClasses : n.residualStyles;
                            if (null === r) 0 === (i ? n.classBindings : n.styleBindings) && (e = vy(e = kT(null, t, n, e, i), n.attrs, i), s = null);
                            else {
                                const o = n.directiveStylingLast;
                                if (-1 === o || t[o] !== r)
                                    if (e = kT(r, t, n, e, i), null === s) {
                                        let c = function c9(t, n, e) {
                                            const i = e ? n.classBindings : n.styleBindings;
                                            if (0 !== gf(i)) return t[Xd(i)]
                                        }(t, n, i);
                                        void 0 !== c && Array.isArray(c) && (c = kT(null, t, n, c[1], i), c = vy(c, n.attrs, i), function l9(t, n, e, i) {
                                            t[Xd(e ? n.classBindings : n.styleBindings)] = i
                                        }(t, n, i, c))
                                    } else s = function u9(t, n, e) {
                                        let i;
                                        const r = n.directiveEnd;
                                        for (let s = 1 + n.directiveStylingLast; s < r; s++) i = vy(i, t[s].hostAttrs, e);
                                        return vy(i, n.attrs, e)
                                    }(t, n, i)
                            }
                            return void 0 !== s && (i ? n.residualClasses = s : n.residualStyles = s), e
                        }(r, s, n, i),
                        function Xj(t, n, e, i, r, s) {
                            let o = s ? n.classBindings : n.styleBindings,
                                a = Xd(o),
                                c = gf(o);
                            t[i] = e;
                            let h, u = !1;
                            if (Array.isArray(e) ? (h = e[1], (null === h || Mu(e, h) > 0) && (u = !0)) : h = e, r)
                                if (0 !== c) {
                                    const x = Xd(t[a + 1]);
                                    t[i + 1] = nb(x, a), 0 !== x && (t[x + 1] = ET(t[x + 1], i)), t[a + 1] = function Zj(t, n) {
                                        return 131071 & t | n << 17
                                    }(t[a + 1], i)
                                } else t[i + 1] = nb(a, 0), 0 !== a && (t[a + 1] = ET(t[a + 1], i)), a = i;
                            else t[i + 1] = nb(c, 0), 0 === a ? a = i : t[c + 1] = ET(t[c + 1], i), c = i;
                            u && (t[i + 1] = ST(t[i + 1])), tL(t, h, i, !0), tL(t, h, i, !1),
                                function Qj(t, n, e, i, r) {
                                    const s = r ? t.residualClasses : t.residualStyles;
                                    null != s && "string" == typeof n && Mu(s, n) >= 0 && (e[i + 1] = DT(e[i + 1]))
                                }(n, h, t, i, s), o = nb(a, c), s ? n.classBindings = o : n.styleBindings = o
                        }(r, s, n, e, o, i)
                }
            }

            function kT(t, n, e, i, r) {
                let s = null;
                const o = e.directiveEnd;
                let a = e.directiveStylingLast;
                for (-1 === a ? a = e.directiveStart : a++; a < o && (s = n[a], i = vy(i, s.hostAttrs, r), s !== t);) a++;
                return null !== t && (e.directiveStylingLast = a), i
            }

            function vy(t, n, e) {
                const i = e ? 1 : 2;
                let r = -1;
                if (null !== n)
                    for (let s = 0; s < n.length; s++) {
                        const o = n[s];
                        "number" == typeof o ? r = o : r === i && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), $o(t, o, !!e || n[++s]))
                    }
                return void 0 === t ? null : t
            }

            function h9(t, n, e) {
                const i = String(n);
                "" !== i && !i.includes(" ") && $o(t, i, e)
            }

            function dL(t, n, e, i, r, s, o, a) {
                if (!(3 & n.type)) return;
                const c = t.data,
                    u = c[a + 1],
                    h = function Yj(t) {
                        return 1 == (1 & t)
                    }(u) ? hL(c, n, e, r, gf(u), o) : void 0;
                ib(h) || (ib(s) || function qj(t) {
                    return 2 == (2 & t)
                }(u) && (s = hL(c, null, e, r, a, o)), function J7(t, n, e, i, r) {
                    if (n) r ? t.addClass(e, i) : t.removeClass(e, i);
                    else {
                        let s = -1 === i.indexOf("-") ? void 0 : Tn.DashCase;
                        null == r ? t.removeStyle(e, i, s) : ("string" == typeof r && r.endsWith("!important") && (r = r.slice(0, -10), s |= Tn.Important), t.setStyle(e, i, r, s))
                    }
                }(i, o, Ag(Uo(), e), r, s))
            }

            function hL(t, n, e, i, r, s) {
                const o = null === n;
                let a;
                for (; r > 0;) {
                    const c = t[r],
                        u = Array.isArray(c),
                        h = u ? c[1] : c,
                        m = null === h;
                    let x = e[r + 1];
                    x === ki && (x = m ? Vn : void 0);
                    let D = m ? Vp(x, i) : h === i ? x : void 0;
                    if (u && !ib(D) && (D = Vp(c, i)), ib(D) && (a = D, o)) return a;
                    const V = t[r + 1];
                    r = o ? Xd(V) : gf(V)
                }
                if (null !== n) {
                    let c = s ? n.residualClasses : n.residualStyles;
                    null != c && (a = Vp(c, i))
                }
                return a
            }

            function ib(t) {
                return void 0 !== t
            }

            function fL(t, n) {
                return 0 != (t.flags & (n ? 8 : 16))
            }

            function Oe(t, n = "") {
                const e = It(),
                    i = ur(),
                    r = t + Ni,
                    s = i.firstCreatePass ? tm(i, r, 1, n, null) : i.data[r],
                    o = pL(i, e, s, n, t);
                e[r] = o, Xh() && kv(i, e, o, s), ea(s, !1)
            }
            let pL = (t, n, e, i, r) => ($l(!0), function Kd(t, n) {
                return t.createText(n)
            }(n[Hn], i));

            function on(t) {
                return Ln("", t, ""), on
            }

            function Ln(t, n, e) {
                const i = It(),
                    r = im(i, t, n, e);
                return r !== ki && Lu(i, Uo(), r), Ln
            }

            function by(t, n, e, i, r) {
                const s = It(),
                    o = function rm(t, n, e, i, r, s) {
                        const a = mf(t, cl(), e, r);
                        return Nc(2), a ? n + Zn(e) + i + Zn(r) + s : ki
                    }(s, t, n, e, i, r);
                return o !== ki && Lu(s, Uo(), o), by
            }

            function wy(t, n, e, i, r, s, o) {
                const a = It(),
                    c = function sm(t, n, e, i, r, s, o, a) {
                        const u = Xv(t, cl(), e, r, o);
                        return Nc(3), u ? n + Zn(e) + i + Zn(r) + s + Zn(o) + a : ki
                    }(a, t, n, e, i, r, s, o);
                return c !== ki && Lu(a, Uo(), c), wy
            }

            function MT(t, n, e) {
                gl($o, Yl, im(It(), t, n, e), !0)
            }
            const yf = void 0;
            var R9 = ["en", [
                    ["a", "p"],
                    ["AM", "PM"], yf
                ],
                [
                    ["AM", "PM"], yf, yf
                ],
                [
                    ["S", "M", "T", "W", "T", "F", "S"],
                    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                ], yf, [
                    ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                    ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                ], yf, [
                    ["B", "A"],
                    ["BC", "AD"],
                    ["Before Christ", "Anno Domini"]
                ], 0, [6, 0],
                ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
                ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
                ["{1}, {0}", yf, "{1} 'at' {0}", yf],
                [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
                ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
                function L9(t) {
                    const e = Math.floor(Math.abs(t)),
                        i = t.toString().replace(/^[^.]*\.?/, "").length;
                    return 1 === e && 0 === i ? 1 : 5
                }
            ];
            let hm = {};

            function ba(t) {
                const n = function B9(t) {
                    return t.toLowerCase().replace(/_/g, "-")
                }(t);
                let e = OL(n);
                if (e) return e;
                const i = n.split("-")[0];
                if (e = OL(i), e) return e;
                if ("en" === i) return R9;
                throw new mt(701, !1)
            }

            function OL(t) {
                return t in hm || (hm[t] = Di.ng && Di.ng.common && Di.ng.common.locales && Di.ng.common.locales[t]), hm[t]
            }
            var ss = function(t) {
                return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t
            }(ss || {});
            const fm = "en-US";
            let LL = fm;

            function OT(t, n, e, i, r) {
                if (t = an(t), Array.isArray(t))
                    for (let s = 0; s < t.length; s++) OT(t[s], n, e, i, r);
                else {
                    const s = ur(),
                        o = It(),
                        a = Cs();
                    let c = ff(t) ? t : an(t.provide);
                    const u = _P(t),
                        h = 1048575 & a.providerIndexes,
                        m = a.directiveStart,
                        x = a.providerIndexes >> 20;
                    if (ff(t) || !t.multi) {
                        const D = new Qh(u, r, We),
                            V = RT(c, n, r ? h : h + x, m); - 1 === V ? (Hg(Np(a, o), s, c), LT(s, t, n.length), n.push(c), a.directiveStart++, a.directiveEnd++, r && (a.providerIndexes += 1048576), e.push(D), o.push(D)) : (e[V] = D, o[V] = D)
                    } else {
                        const D = RT(c, n, h + x, m),
                            V = RT(c, n, h, h + x),
                            ee = V >= 0 && e[V];
                        if (r && !ee || !r && !(D >= 0 && e[D])) {
                            Hg(Np(a, o), s, c);
                            const _e = function LW(t, n, e, i, r) {
                                const s = new Qh(t, e, We);
                                return s.multi = [], s.index = n, s.componentProviders = 0, o3(s, r, i && !e), s
                            }(r ? OW : PW, e.length, r, i, u);
                            !r && ee && (e[V].providerFactory = _e), LT(s, t, n.length, 0), n.push(c), a.directiveStart++, a.directiveEnd++, r && (a.providerIndexes += 1048576), e.push(_e), o.push(_e)
                        } else LT(s, t, D > -1 ? D : V, o3(e[r ? V : D], u, !r && i));
                        !r && i && ee && e[V].componentProviders++
                    }
                }
            }

            function LT(t, n, e, i) {
                const r = ff(n),
                    s = function A$(t) {
                        return !!t.useClass
                    }(n);
                if (r || s) {
                    const c = (s ? an(n.useClass) : n).prototype.ngOnDestroy;
                    if (c) {
                        const u = t.destroyHooks || (t.destroyHooks = []);
                        if (!r && n.multi) {
                            const h = u.indexOf(e); - 1 === h ? u.push(e, [i, c]) : u[h + 1].push(i, c)
                        } else u.push(e, c)
                    }
                }
            }

            function o3(t, n, e) {
                return e && t.componentProviders++, t.multi.push(n) - 1
            }

            function RT(t, n, e, i) {
                for (let r = e; r < i; r++)
                    if (n[r] === t) return r;
                return -1
            }

            function PW(t, n, e, i) {
                return BT(this.multi, [])
            }

            function OW(t, n, e, i) {
                const r = this.multi;
                let s;
                if (this.providerFactory) {
                    const o = this.providerFactory.componentProviders,
                        a = ll(e, e[Ct], this.providerFactory.index, i);
                    s = a.slice(0, o), BT(r, s);
                    for (let c = o; c < a.length; c++) s.push(a[c])
                } else s = [], BT(r, s);
                return s
            }

            function BT(t, n) {
                for (let e = 0; e < t.length; e++) n.push((0, t[e])());
                return n
            }

            function Jr(t, n = []) {
                return e => {
                    e.providersResolver = (i, r) => function IW(t, n, e) {
                        const i = ur();
                        if (i.firstCreatePass) {
                            const r = ga(t);
                            OT(e, i.data, i.blueprint, r, !0), OT(n, i.data, i.blueprint, r, !1)
                        }
                    }(i, r ? r(t) : t, n)
                }
            }
            class _f {}
            class a3 {}
            class NT extends _f {
                constructor(n, e, i) {
                    super(), this._parent = e, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new vO(this);
                    const r = lo(n);
                    this._bootstrapComponents = Ou(r.bootstrap), this._r3Injector = IP(n, e, [{
                        provide: _f,
                        useValue: this
                    }, {
                        provide: Xp,
                        useValue: this.componentFactoryResolver
                    }, ...i], ti(n), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(n)
                }
                get injector() {
                    return this._r3Injector
                }
                destroy() {
                    const n = this._r3Injector;
                    !n.destroyed && n.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null
                }
                onDestroy(n) {
                    this.destroyCbs.push(n)
                }
            }
            class FT extends a3 {
                constructor(n) {
                    super(), this.moduleType = n
                }
                create(n) {
                    return new NT(this.moduleType, n, [])
                }
            }
            class c3 extends _f {
                constructor(n) {
                    super(), this.componentFactoryResolver = new vO(this), this.instance = null;
                    const e = new Kp([...n.providers, {
                        provide: _f,
                        useValue: this
                    }, {
                        provide: Xp,
                        useValue: this.componentFactoryResolver
                    }], n.parent || Bv(), n.debugName, new Set(["environment"]));
                    this.injector = e, n.runEnvironmentInitializers && e.resolveInjectorInitializers()
                }
                destroy() {
                    this.injector.destroy()
                }
                onDestroy(n) {
                    this.injector.onDestroy(n)
                }
            }

            function VT(t, n, e = null) {
                return new c3({
                    providers: t,
                    parent: n,
                    debugName: e,
                    runEnvironmentInitializers: !0
                }).injector
            }
            let NW = (() => {
                class t {
                    constructor(e) {
                        this._injector = e, this.cachedInjectors = new Map
                    }
                    getOrCreateStandaloneInjector(e) {
                        if (!e.standalone) return null;
                        if (!this.cachedInjectors.has(e)) {
                            const i = pP(0, e.type),
                                r = i.length > 0 ? VT([i], this._injector, `Standalone[${e.type.name}]`) : null;
                            this.cachedInjectors.set(e, r)
                        }
                        return this.cachedInjectors.get(e)
                    }
                    ngOnDestroy() {
                        try {
                            for (const e of this.cachedInjectors.values()) null !== e && e.destroy()
                        } finally {
                            this.cachedInjectors.clear()
                        }
                    }
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "environment",
                        factory: () => new t(_t(hc))
                    })
                }
                return t
            })();

            function l3(t) {
                t.getStandaloneInjector = n => n.get(NW).getOrCreateStandaloneInjector(t)
            }

            function Ns(t, n, e) {
                const i = wn() + t,
                    r = It();
                return r[i] === ki ? Gl(r, i, e ? n.call(e) : n()) : py(r, i)
            }

            function fi(t, n, e, i) {
                return _3(It(), wn(), t, n, e, i)
            }

            function yl(t, n, e, i, r) {
                return v3(It(), wn(), t, n, e, i, r)
            }

            function g3(t, n, e, i, r, s) {
                return function b3(t, n, e, i, r, s, o, a) {
                    const c = n + e;
                    return Xv(t, c, r, s, o) ? Gl(t, c + 3, a ? i.call(a, r, s, o) : i(r, s, o)) : Dy(t, c + 3)
                }(It(), wn(), t, n, e, i, r, s)
            }

            function y3(t, n, e, i, r, s, o) {
                return function w3(t, n, e, i, r, s, o, a, c) {
                    const u = n + e;
                    return Uc(t, u, r, s, o, a) ? Gl(t, u + 4, c ? i.call(c, r, s, o, a) : i(r, s, o, a)) : Dy(t, u + 4)
                }(It(), wn(), t, n, e, i, r, s, o)
            }

            function HT(t, n, e, i, r, s, o, a) {
                const c = wn() + t,
                    u = It(),
                    h = Uc(u, c, e, i, r, s);
                return ta(u, c + 4, o) || h ? Gl(u, c + 5, a ? n.call(a, e, i, r, s, o) : n(e, i, r, s, o)) : py(u, c + 5)
            }

            function Dy(t, n) {
                const e = t[n];
                return e === ki ? void 0 : e
            }

            function _3(t, n, e, i, r, s) {
                const o = n + e;
                return ta(t, o, r) ? Gl(t, o + 1, s ? i.call(s, r) : i(r)) : Dy(t, o + 1)
            }

            function v3(t, n, e, i, r, s, o) {
                const a = n + e;
                return mf(t, a, r, s) ? Gl(t, a + 2, o ? i.call(o, r, s) : i(r, s)) : Dy(t, a + 2)
            }

            function qt(t, n) {
                const e = ur();
                let i;
                const r = t + Ni;
                e.firstCreatePass ? (i = function YW(t, n) {
                    if (n)
                        for (let e = n.length - 1; e >= 0; e--) {
                            const i = n[e];
                            if (t === i.name) return i
                        }
                }(n, e.pipeRegistry), e.data[r] = i, i.onDestroy && (e.destroyHooks ? ? = []).push(r, i.onDestroy)) : i = e.data[r];
                const s = i.factory || (i.factory = ie(i.type)),
                    a = Ei(We);
                try {
                    const c = Bp(!1),
                        u = s();
                    return Bp(c),
                        function Vj(t, n, e, i) {
                            e >= t.data.length && (t.data[e] = null, t.blueprint[e] = null), n[e] = i
                        }(e, It(), r, u), u
                } finally {
                    Ei(a)
                }
            }

            function Dn(t, n, e) {
                const i = t + Ni,
                    r = It(),
                    s = kd(r, i);
                return Ay(r, i) ? _3(r, wn(), n, s.transform, e, s) : s.transform(e)
            }

            function _s(t, n, e, i) {
                const r = t + Ni,
                    s = It(),
                    o = kd(s, r);
                return Ay(s, r) ? v3(s, wn(), n, o.transform, e, i, o) : o.transform(e, i)
            }

            function Ay(t, n) {
                return t[Ct].data[n].pure
            }

            function eG() {
                return this._results[Symbol.iterator]()
            }
            class $T {
                static# e = Symbol.iterator;
                get changes() {
                    return this._changes || (this._changes = new zt)
                }
                constructor(n = !1) {
                    this._emitDistinctChangesOnly = n, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0;
                    const e = $T.prototype;
                    e[Symbol.iterator] || (e[Symbol.iterator] = eG)
                }
                get(n) {
                    return this._results[n]
                }
                map(n) {
                    return this._results.map(n)
                }
                filter(n) {
                    return this._results.filter(n)
                }
                find(n) {
                    return this._results.find(n)
                }
                reduce(n, e) {
                    return this._results.reduce(n, e)
                }
                forEach(n) {
                    this._results.forEach(n)
                }
                some(n) {
                    return this._results.some(n)
                }
                toArray() {
                    return this._results.slice()
                }
                toString() {
                    return this._results.toString()
                }
                reset(n, e) {
                    const i = this;
                    i.dirty = !1;
                    const r = function $a(t) {
                        return t.flat(Number.POSITIVE_INFINITY)
                    }(n);
                    (this._changesDetected = ! function oC(t, n, e) {
                        if (t.length !== n.length) return !1;
                        for (let i = 0; i < t.length; i++) {
                            let r = t[i],
                                s = n[i];
                            if (e && (r = e(r), s = e(s)), s !== r) return !1
                        }
                        return !0
                    }(i._results, r, e)) && (i._results = r, i.length = r.length, i.last = r[this.length - 1], i.first = r[0])
                }
                notifyOnChanges() {
                    this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this)
                }
                setDirty() {
                    this.dirty = !0
                }
                destroy() {
                    this.changes.complete(), this.changes.unsubscribe()
                }
            }

            function nG(t, n, e, i = !0) {
                const r = n[Ct];
                if (function bC(t, n, e, i) {
                        const r = ms + i,
                            s = e.length;
                        i > 0 && (e[r - 1][ni] = n), i < s - ms ? (n[ni] = e[r], hv(e, ms + i, n)) : (e.push(n), n[ni] = null), n[vi] = e;
                        const o = n[No];
                        null !== o && e !== o && function wC(t, n) {
                            const e = t[Or];
                            n[Er] !== n[vi][vi][Er] && (t[pp] = !0), null === e ? t[Or] = [n] : e.push(n)
                        }(o, n);
                        const a = n[ma];
                        null !== a && a.insertView(t), n[bn] |= 128
                    }(r, n, t, e), i) {
                    const s = EC(e, t),
                        o = n[Hn],
                        a = Av(o, t[io]);
                    null !== a && function Ev(t, n, e, i, r, s) {
                        i[Wt] = r, i[ii] = n, ey(t, i, e, 1, r, s)
                    }(r, t[ii], o, n, a, s)
                }
            }
            let Hc = (() => {
                class t {
                    static# e = this.__NG_ELEMENT_ID__ = sG
                }
                return t
            })();
            const iG = Hc,
                rG = class extends iG {
                    constructor(n, e, i) {
                        super(), this._declarationLView = n, this._declarationTContainer = e, this.elementRef = i
                    }
                    get ssrId() {
                        return this._declarationTContainer.tView ? .ssrId || null
                    }
                    createEmbeddedView(n, e) {
                        return this.createEmbeddedViewImpl(n, e)
                    }
                    createEmbeddedViewImpl(n, e, i) {
                        const r = function tG(t, n, e, i) {
                            const r = n.tView,
                                a = Wv(t, r, e, 4096 & t[bn] ? 4096 : 16, null, n, null, null, null, i ? .injector ? ? null, i ? .hydrationInfo ? ? null);
                            a[No] = t[n.index];
                            const u = t[ma];
                            return null !== u && (a[ma] = u.createEmbeddedView(r)), yT(r, a, e), a
                        }(this._declarationLView, this._declarationTContainer, n, {
                            injector: e,
                            hydrationInfo: i
                        });
                        return new hy(r)
                    }
                };

            function sG() {
                return cb(Cs(), It())
            }

            function cb(t, n) {
                return 4 & t.type ? new rG(n, t, Qp(t, n)) : null
            }
            let Ga = (() => {
                class t {
                    static# e = this.__NG_ELEMENT_ID__ = dG
                }
                return t
            })();

            function dG() {
                return k3(Cs(), It())
            }
            const hG = Ga,
                D3 = class extends hG {
                    constructor(n, e, i) {
                        super(), this._lContainer = n, this._hostTNode = e, this._hostLView = i
                    }
                    get element() {
                        return Qp(this._hostTNode, this._hostLView)
                    }
                    get injector() {
                        return new Ho(this._hostTNode, this._hostLView)
                    }
                    get parentInjector() {
                        const n = Fp(this._hostTNode, this._hostLView);
                        if (Ng(n)) {
                            const e = ef(n, this._hostLView),
                                i = Jh(n);
                            return new Ho(e[Ct].data[i + 8], e)
                        }
                        return new Ho(null, this._hostLView)
                    }
                    clear() {
                        for (; this.length > 0;) this.remove(this.length - 1)
                    }
                    get(n) {
                        const e = A3(this._lContainer);
                        return null !== e && e[n] || null
                    }
                    get length() {
                        return this._lContainer.length - ms
                    }
                    createEmbeddedView(n, e, i) {
                        let r, s;
                        "number" == typeof i ? r = i : null != i && (r = i.index, s = i.injector);
                        const a = n.createEmbeddedViewImpl(e || {}, s, null);
                        return this.insertImpl(a, r, false), a
                    }
                    createComponent(n, e, i, r, s) {
                        const o = n && ! function rf(t) {
                            return "function" == typeof t
                        }(n);
                        let a;
                        if (o) a = e;
                        else {
                            const te = e || {};
                            a = te.index, i = te.injector, r = te.projectableNodes, s = te.environmentInjector || te.ngModuleRef
                        }
                        const c = o ? n : new fy(Yi(n)),
                            u = i || this.parentInjector;
                        if (!s && null == c.ngModule) {
                            const ee = (o ? u : this.parentInjector).get(hc, null);
                            ee && (s = ee)
                        }
                        Yi(c.componentType ? ? {});
                        const D = c.create(u, r, null, s);
                        return this.insertImpl(D.hostView, a, false), D
                    }
                    insert(n, e) {
                        return this.insertImpl(n, e, !1)
                    }
                    insertImpl(n, e, i) {
                        const r = n._lView;
                        if (function B1(t) {
                                return uo(t[vi])
                            }(r)) {
                            const c = this.indexOf(n);
                            if (-1 !== c) this.detach(c);
                            else {
                                const u = r[vi],
                                    h = new D3(u, u[ii], u[vi]);
                                h.detach(h.indexOf(n))
                            }
                        }
                        const o = this._adjustIndex(e),
                            a = this._lContainer;
                        return nG(a, r, o, !i), n.attachToViewContainerRef(), hv(zT(a), o, n), n
                    }
                    move(n, e) {
                        return this.insert(n, e)
                    }
                    indexOf(n) {
                        const e = A3(this._lContainer);
                        return null !== e ? e.indexOf(n) : -1
                    }
                    remove(n) {
                        const e = this._adjustIndex(n, -1),
                            i = Dv(this._lContainer, e);
                        i && (ul(zT(this._lContainer), e), xC(i[Ct], i))
                    }
                    detach(n) {
                        const e = this._adjustIndex(n, -1),
                            i = Dv(this._lContainer, e);
                        return i && null != ul(zT(this._lContainer), e) ? new hy(i) : null
                    }
                    _adjustIndex(n, e = 0) {
                        return n ? ? this.length + e
                    }
                };

            function A3(t) {
                return t[8]
            }

            function zT(t) {
                return t[8] || (t[8] = [])
            }

            function k3(t, n) {
                let e;
                const i = n[t.index];
                return uo(i) ? e = i : (e = aO(i, n, null, t), n[t.index] = e, Gv(n, e)), M3(e, n, t, i), new D3(e, t, n)
            }
            let M3 = function I3(t, n, e, i) {
                if (t[io]) return;
                let r;
                r = 8 & e.type ? Xr(i) : function fG(t, n) {
                    const e = t[Hn],
                        i = e.createComment(""),
                        r = Vo(n, t);
                    return hf(e, Av(e, r), i, function Y7(t, n) {
                        return t.nextSibling(n)
                    }(e, r), !1), i
                }(n, e), t[io] = r
            };
            class jT {
                constructor(n) {
                    this.queryList = n, this.matches = null
                }
                clone() {
                    return new jT(this.queryList)
                }
                setDirty() {
                    this.queryList.setDirty()
                }
            }
            class WT {
                constructor(n = []) {
                    this.queries = n
                }
                createEmbeddedView(n) {
                    const e = n.queries;
                    if (null !== e) {
                        const i = null !== n.contentQueries ? n.contentQueries[0] : e.length,
                            r = [];
                        for (let s = 0; s < i; s++) {
                            const o = e.getByIndex(s);
                            r.push(this.queries[o.indexInDeclarationView].clone())
                        }
                        return new WT(r)
                    }
                    return null
                }
                insertView(n) {
                    this.dirtyQueriesWithMatches(n)
                }
                detachView(n) {
                    this.dirtyQueriesWithMatches(n)
                }
                dirtyQueriesWithMatches(n) {
                    for (let e = 0; e < this.queries.length; e++) null !== B3(n, e).matches && this.queries[e].setDirty()
                }
            }
            class P3 {
                constructor(n, e, i = null) {
                    this.predicate = n, this.flags = e, this.read = i
                }
            }
            class GT {
                constructor(n = []) {
                    this.queries = n
                }
                elementStart(n, e) {
                    for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(n, e)
                }
                elementEnd(n) {
                    for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(n)
                }
                embeddedTView(n) {
                    let e = null;
                    for (let i = 0; i < this.length; i++) {
                        const r = null !== e ? e.length : 0,
                            s = this.getByIndex(i).embeddedTView(n, r);
                        s && (s.indexInDeclarationView = i, null !== e ? e.push(s) : e = [s])
                    }
                    return null !== e ? new GT(e) : null
                }
                template(n, e) {
                    for (let i = 0; i < this.queries.length; i++) this.queries[i].template(n, e)
                }
                getByIndex(n) {
                    return this.queries[n]
                }
                get length() {
                    return this.queries.length
                }
                track(n) {
                    this.queries.push(n)
                }
            }
            class KT {
                constructor(n, e = -1) {
                    this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e
                }
                elementStart(n, e) {
                    this.isApplyingToNode(e) && this.matchTNode(n, e)
                }
                elementEnd(n) {
                    this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1)
                }
                template(n, e) {
                    this.elementStart(n, e)
                }
                embeddedTView(n, e) {
                    return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, e), new KT(this.metadata)) : null
                }
                isApplyingToNode(n) {
                    if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
                        const e = this._declarationNodeIndex;
                        let i = n.parent;
                        for (; null !== i && 8 & i.type && i.index !== e;) i = i.parent;
                        return e === (null !== i ? i.index : -1)
                    }
                    return this._appliesToNextNode
                }
                matchTNode(n, e) {
                    const i = this.metadata.predicate;
                    if (Array.isArray(i))
                        for (let r = 0; r < i.length; r++) {
                            const s = i[r];
                            this.matchTNodeWithReadOption(n, e, gG(e, s)), this.matchTNodeWithReadOption(n, e, tf(e, n, s, !1, !1))
                        } else i === Hc ? 4 & e.type && this.matchTNodeWithReadOption(n, e, -1) : this.matchTNodeWithReadOption(n, e, tf(e, n, i, !1, !1))
                }
                matchTNodeWithReadOption(n, e, i) {
                    if (null !== i) {
                        const r = this.metadata.read;
                        if (null !== r)
                            if (r === ir || r === Ga || r === Hc && 4 & e.type) this.addMatch(e.index, -2);
                            else {
                                const s = tf(e, n, r, !1, !1);
                                null !== s && this.addMatch(e.index, s)
                            }
                        else this.addMatch(e.index, i)
                    }
                }
                addMatch(n, e) {
                    null === this.matches ? this.matches = [n, e] : this.matches.push(n, e)
                }
            }

            function gG(t, n) {
                const e = t.localNames;
                if (null !== e)
                    for (let i = 0; i < e.length; i += 2)
                        if (e[i] === n) return e[i + 1];
                return null
            }

            function _G(t, n, e, i) {
                return -1 === e ? function yG(t, n) {
                    return 11 & t.type ? Qp(t, n) : 4 & t.type ? cb(t, n) : null
                }(n, t) : -2 === e ? function vG(t, n, e) {
                    return e === ir ? Qp(n, t) : e === Hc ? cb(n, t) : e === Ga ? k3(n, t) : void 0
                }(t, n, i) : ll(t, t[Ct], e, n)
            }

            function O3(t, n, e, i) {
                const r = n[ma].queries[i];
                if (null === r.matches) {
                    const s = t.data,
                        o = e.matches,
                        a = [];
                    for (let c = 0; c < o.length; c += 2) {
                        const u = o[c];
                        a.push(u < 0 ? null : _G(n, s[u], o[c + 1], e.metadata.read))
                    }
                    r.matches = a
                }
                return r.matches
            }

            function qT(t, n, e, i) {
                const r = t.queries.getByIndex(e),
                    s = r.matches;
                if (null !== s) {
                    const o = O3(t, n, r, e);
                    for (let a = 0; a < s.length; a += 2) {
                        const c = s[a];
                        if (c > 0) i.push(o[a / 2]);
                        else {
                            const u = s[a + 1],
                                h = n[-c];
                            for (let m = ms; m < h.length; m++) {
                                const x = h[m];
                                x[No] === x[vi] && qT(x[Ct], x, u, i)
                            }
                            if (null !== h[Or]) {
                                const m = h[Or];
                                for (let x = 0; x < m.length; x++) {
                                    const D = m[x];
                                    qT(D[Ct], D, u, i)
                                }
                            }
                        }
                    }
                }
                return i
            }

            function wa(t) {
                const n = It(),
                    e = ur(),
                    i = kp();
                Mp(i + 1);
                const r = B3(e, i);
                if (t.dirty && function Md(t) {
                        return 4 == (4 & t[bn])
                    }(n) === (2 == (2 & r.metadata.flags))) {
                    if (null === r.matches) t.reset([]);
                    else {
                        const s = r.crossesNgTemplate ? qT(e, n, i, []) : O3(e, n, r, i);
                        t.reset(s, Z$), t.notifyOnChanges()
                    }
                    return !0
                }
                return !1
            }

            function $c(t, n, e) {
                const i = ur();
                i.firstCreatePass && (R3(i, new P3(t, n, e), -1), 2 == (2 & n) && (i.staticViewQueries = !0)), L3(i, It(), n)
            }

            function ub(t, n, e, i) {
                const r = ur();
                if (r.firstCreatePass) {
                    const s = Cs();
                    R3(r, new P3(n, e, i), s.index),
                        function wG(t, n) {
                            const e = t.contentQueries || (t.contentQueries = []);
                            n !== (e.length ? e[e.length - 1] : -1) && e.push(t.queries.length - 1, n)
                        }(r, t), 2 == (2 & e) && (r.staticContentQueries = !0)
                }
                L3(r, It(), e)
            }

            function xa() {
                return function bG(t, n) {
                    return t[ma].queries[n].queryList
                }(It(), kp())
            }

            function L3(t, n, e) {
                const i = new $T(4 == (4 & e));
                (function Ez(t, n, e, i) {
                    const r = lO(n);
                    r.push(e), t.firstCreatePass && uO(t).push(i, r.length - 1)
                })(t, n, i, i.destroy), null === n[ma] && (n[ma] = new WT), n[ma].queries.push(new jT(i))
            }

            function R3(t, n, e) {
                null === t.queries && (t.queries = new GT), t.queries.track(new KT(n, e))
            }

            function B3(t, n) {
                return t.queries.getByIndex(n)
            }

            function _l(t, n) {
                return cb(t, n)
            }
            const eS = new nn("Application Initializer");
            let tS = (() => {
                    class t {
                        constructor() {
                            this.initialized = !1, this.done = !1, this.donePromise = new Promise((e, i) => {
                                this.resolve = e, this.reject = i
                            }), this.appInits = vn(eS, {
                                optional: !0
                            }) ? ? []
                        }
                        runInitializers() {
                            if (this.initialized) return;
                            const e = [];
                            for (const r of this.appInits) {
                                const s = r();
                                if (_y(s)) e.push(s);
                                else if ($O(s)) {
                                    const o = new Promise((a, c) => {
                                        s.subscribe({
                                            complete: a,
                                            error: c
                                        })
                                    });
                                    e.push(o)
                                }
                            }
                            const i = () => {
                                this.done = !0, this.resolve()
                            };
                            Promise.all(e).then(() => {
                                i()
                            }).catch(r => {
                                this.reject(r)
                            }), 0 === e.length && i(), this.initialized = !0
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "root"
                        })
                    }
                    return t
                })(),
                J3 = (() => {
                    class t {
                        log(e) {
                            console.log(e)
                        }
                        warn(e) {
                            console.warn(e)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "platform"
                        })
                    }
                    return t
                })();
            const Bu = new nn("LocaleId", {
                providedIn: "root",
                factory: () => vn(Bu, kt.Optional | kt.SkipSelf) || function $G() {
                    return typeof $localize < "u" && $localize.locale || fm
                }()
            });
            let hb = (() => {
                class t {
                    constructor() {
                        this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new qn(!1)
                    }
                    add() {
                        this.hasPendingTasks.next(!0);
                        const e = this.taskId++;
                        return this.pendingTasks.add(e), e
                    }
                    remove(e) {
                        this.pendingTasks.delete(e), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1)
                    }
                    ngOnDestroy() {
                        this.pendingTasks.clear(), this.hasPendingTasks.next(!1)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            class WG {
                constructor(n, e) {
                    this.ngModuleFactory = n, this.componentFactories = e
                }
            }
            let e5 = (() => {
                class t {
                    compileModuleSync(e) {
                        return new FT(e)
                    }
                    compileModuleAsync(e) {
                        return Promise.resolve(this.compileModuleSync(e))
                    }
                    compileModuleAndAllComponentsSync(e) {
                        const i = this.compileModuleSync(e),
                            s = Ou(lo(e).declarations).reduce((o, a) => {
                                const c = Yi(a);
                                return c && o.push(new fy(c)), o
                            }, []);
                        return new WG(i, s)
                    }
                    compileModuleAndAllComponentsAsync(e) {
                        return Promise.resolve(this.compileModuleAndAllComponentsSync(e))
                    }
                    clearCache() {}
                    clearCacheFor(e) {}
                    getModuleId(e) {}
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            const r5 = new nn(""),
                pb = new nn("");
            let oS, rS = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._ngZone = e, this.registry = i, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, oS || (function fK(t) {
                                oS = t
                            }(r), r.addToWindow(i)), this._watchAngularEvents(), e.run(() => {
                                this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone")
                            })
                        }
                        _watchAngularEvents() {
                            this._ngZone.onUnstable.subscribe({
                                next: () => {
                                    this._didWork = !0, this._isZoneStable = !1
                                }
                            }), this._ngZone.runOutsideAngular(() => {
                                this._ngZone.onStable.subscribe({
                                    next: () => {
                                        cr.assertNotInAngularZone(), queueMicrotask(() => {
                                            this._isZoneStable = !0, this._runCallbacksIfReady()
                                        })
                                    }
                                })
                            })
                        }
                        increasePendingRequestCount() {
                            return this._pendingCount += 1, this._didWork = !0, this._pendingCount
                        }
                        decreasePendingRequestCount() {
                            if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                            return this._runCallbacksIfReady(), this._pendingCount
                        }
                        isStable() {
                            return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
                        }
                        _runCallbacksIfReady() {
                            if (this.isStable()) queueMicrotask(() => {
                                for (; 0 !== this._callbacks.length;) {
                                    let e = this._callbacks.pop();
                                    clearTimeout(e.timeoutId), e.doneCb(this._didWork)
                                }
                                this._didWork = !1
                            });
                            else {
                                let e = this.getPendingTasks();
                                this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0
                            }
                        }
                        getPendingTasks() {
                            return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({
                                source: e.source,
                                creationLocation: e.creationLocation,
                                data: e.data
                            })) : []
                        }
                        addCallback(e, i, r) {
                            let s = -1;
                            i && i > 0 && (s = setTimeout(() => {
                                this._callbacks = this._callbacks.filter(o => o.timeoutId !== s), e(this._didWork, this.getPendingTasks())
                            }, i)), this._callbacks.push({
                                doneCb: e,
                                timeoutId: s,
                                updateCb: r
                            })
                        }
                        whenStable(e, i, r) {
                            if (r && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
                            this.addCallback(e, i, r), this._runCallbacksIfReady()
                        }
                        getPendingRequestCount() {
                            return this._pendingCount
                        }
                        registerApplication(e) {
                            this.registry.registerApplication(e, this)
                        }
                        unregisterApplication(e) {
                            this.registry.unregisterApplication(e)
                        }
                        findProviders(e, i, r) {
                            return []
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(cr), _t(sS), _t(pb))
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                sS = (() => {
                    class t {
                        constructor() {
                            this._applications = new Map
                        }
                        registerApplication(e, i) {
                            this._applications.set(e, i)
                        }
                        unregisterApplication(e) {
                            this._applications.delete(e)
                        }
                        unregisterAllApplications() {
                            this._applications.clear()
                        }
                        getTestability(e) {
                            return this._applications.get(e) || null
                        }
                        getAllTestabilities() {
                            return Array.from(this._applications.values())
                        }
                        getAllRootElements() {
                            return Array.from(this._applications.keys())
                        }
                        findTestabilityInTree(e, i = !0) {
                            return oS ? .findTestabilityInTree(this, e, i) ? ? null
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "platform"
                        })
                    }
                    return t
                })(),
                Qd = null;
            const s5 = new nn("AllowMultipleToken"),
                aS = new nn("PlatformDestroyListeners"),
                cS = new nn("appBootstrapListener");
            class a5 {
                constructor(n, e) {
                    this.name = n, this.token = e
                }
            }

            function l5(t, n, e = []) {
                const i = `Platform: ${n}`,
                    r = new nn(i);
                return (s = []) => {
                    let o = lS();
                    if (!o || o.injector.get(s5, !1)) {
                        const a = [...e, ...s, {
                            provide: r,
                            useValue: !0
                        }];
                        t ? t(a) : function gK(t) {
                            if (Qd && !Qd.get(s5, !1)) throw new mt(400, !1);
                            (function o5() {
                                ! function Eg(t) {
                                    jh = t
                                }(() => {
                                    throw new mt(600, !1)
                                })
                            })(), Qd = t;
                            const n = t.get(d5);
                            (function c5(t) {
                                t.get(vP, null) ? .forEach(e => e())
                            })(t)
                        }(function u5(t = [], n) {
                            return Do.create({
                                name: n,
                                providers: [{
                                    provide: VC,
                                    useValue: "platform"
                                }, {
                                    provide: aS,
                                    useValue: new Set([() => Qd = null])
                                }, ...t]
                            })
                        }(a, i))
                    }
                    return function _K(t) {
                        const n = lS();
                        if (!n) throw new mt(401, !1);
                        return n
                    }()
                }
            }

            function lS() {
                return Qd ? .get(d5) ? ? null
            }
            let d5 = (() => {
                class t {
                    constructor(e) {
                        this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1
                    }
                    bootstrapModuleFactory(e, i) {
                        const r = function vK(t = "zone.js", n) {
                            return "noop" === t ? new uz : "zone.js" === t ? new cr(n) : t
                        }(i ? .ngZone, function h5(t) {
                            return {
                                enableLongStackTrace: !1,
                                shouldCoalesceEventChangeDetection: t ? .eventCoalescing ? ? !1,
                                shouldCoalesceRunChangeDetection: t ? .runCoalescing ? ? !1
                            }
                        }({
                            eventCoalescing: i ? .ngZoneEventCoalescing,
                            runCoalescing: i ? .ngZoneRunCoalescing
                        }));
                        return r.run(() => {
                            const s = function BW(t, n, e) {
                                    return new NT(t, n, e)
                                }(e.moduleType, this.injector, function y5(t) {
                                    return [{
                                        provide: cr,
                                        useFactory: t
                                    }, {
                                        provide: sy,
                                        multi: !0,
                                        useFactory: () => {
                                            const n = vn(wK, {
                                                optional: !0
                                            });
                                            return () => n.initialize()
                                        }
                                    }, {
                                        provide: g5,
                                        useFactory: bK
                                    }, {
                                        provide: BP,
                                        useFactory: NP
                                    }]
                                }(() => r)),
                                o = s.injector.get(jl, null);
                            return r.runOutsideAngular(() => {
                                    const a = r.onError.subscribe({
                                        next: c => {
                                            o.handleError(c)
                                        }
                                    });
                                    s.onDestroy(() => {
                                        mb(this._modules, s), a.unsubscribe()
                                    })
                                }),
                                function f5(t, n, e) {
                                    try {
                                        const i = e();
                                        return _y(i) ? i.catch(r => {
                                            throw n.runOutsideAngular(() => t.handleError(r)), r
                                        }) : i
                                    } catch (i) {
                                        throw n.runOutsideAngular(() => t.handleError(i)), i
                                    }
                                }(o, r, () => {
                                    const a = s.injector.get(tS);
                                    return a.runInitializers(), a.donePromise.then(() => (function RL(t) {
                                        fs(t, "Expected localeId to be defined"), "string" == typeof t && (LL = t.toLowerCase().replace(/_/g, "-"))
                                    }(s.injector.get(Bu, fm) || fm), this._moduleDoBootstrap(s), s))
                                })
                        })
                    }
                    bootstrapModule(e, i = []) {
                        const r = p5({}, i);
                        return function pK(t, n, e) {
                            const i = new FT(e);
                            return Promise.resolve(i)
                        }(0, 0, e).then(s => this.bootstrapModuleFactory(s, r))
                    }
                    _moduleDoBootstrap(e) {
                        const i = e.injector.get(Xl);
                        if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => i.bootstrap(r));
                        else {
                            if (!e.instance.ngDoBootstrap) throw new mt(-403, !1);
                            e.instance.ngDoBootstrap(i)
                        }
                        this._modules.push(e)
                    }
                    onDestroy(e) {
                        this._destroyListeners.push(e)
                    }
                    get injector() {
                        return this._injector
                    }
                    destroy() {
                        if (this._destroyed) throw new mt(404, !1);
                        this._modules.slice().forEach(i => i.destroy()), this._destroyListeners.forEach(i => i());
                        const e = this._injector.get(aS, null);
                        e && (e.forEach(i => i()), e.clear()), this._destroyed = !0
                    }
                    get destroyed() {
                        return this._destroyed
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Do))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "platform"
                    })
                }
                return t
            })();

            function p5(t, n) {
                return Array.isArray(n) ? n.reduce(p5, t) : { ...t,
                    ...n
                }
            }
            let Xl = (() => {
                class t {
                    constructor() {
                        this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = vn(g5), this.zoneIsStable = vn(BP), this.componentTypes = [], this.components = [], this.isStable = vn(hb).hasPendingTasks.pipe(St(e => e ? Ve(!1) : this.zoneIsStable), function Bn(t, n = $) {
                            return t = t ? ? Nn, R((e, i) => {
                                let r, s = !0;
                                e.subscribe(Q(i, o => {
                                    const a = n(o);
                                    (s || !t(r, a)) && (s = !1, r = a, i.next(o))
                                }))
                            })
                        }(), at()), this._injector = vn(hc)
                    }
                    get destroyed() {
                        return this._destroyed
                    }
                    get injector() {
                        return this._injector
                    }
                    bootstrap(e, i) {
                        const r = e instanceof SP;
                        if (!this._injector.get(tS).done) throw !r && function Va(t) {
                            const n = Yi(t) || Kr(t) || js(t);
                            return null !== n && n.standalone
                        }(e), new mt(405, !1);
                        let o;
                        o = r ? e : this._injector.get(Xp).resolveComponentFactory(e), this.componentTypes.push(o.componentType);
                        const a = function mK(t) {
                                return t.isBoundToModule
                            }(o) ? void 0 : this._injector.get(_f),
                            u = o.create(Do.NULL, [], i || o.selector, a),
                            h = u.location.nativeElement,
                            m = u.injector.get(r5, null);
                        return m ? .registerApplication(h), u.onDestroy(() => {
                            this.detachView(u.hostView), mb(this.components, u), m ? .unregisterApplication(h)
                        }), this._loadComponent(u), u
                    }
                    tick() {
                        if (this._runningTick) throw new mt(101, !1);
                        try {
                            this._runningTick = !0;
                            for (let e of this._views) e.detectChanges()
                        } catch (e) {
                            this.internalErrorHandler(e)
                        } finally {
                            this._runningTick = !1
                        }
                    }
                    attachView(e) {
                        const i = e;
                        this._views.push(i), i.attachToAppRef(this)
                    }
                    detachView(e) {
                        const i = e;
                        mb(this._views, i), i.detachFromAppRef()
                    }
                    _loadComponent(e) {
                        this.attachView(e.hostView), this.tick(), this.components.push(e);
                        const i = this._injector.get(cS, []);
                        i.push(...this._bootstrapListeners), i.forEach(r => r(e))
                    }
                    ngOnDestroy() {
                        if (!this._destroyed) try {
                            this._destroyListeners.forEach(e => e()), this._views.slice().forEach(e => e.destroy())
                        } finally {
                            this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = []
                        }
                    }
                    onDestroy(e) {
                        return this._destroyListeners.push(e), () => mb(this._destroyListeners, e)
                    }
                    destroy() {
                        if (this._destroyed) throw new mt(406, !1);
                        const e = this._injector;
                        e.destroy && !e.destroyed && e.destroy()
                    }
                    get viewCount() {
                        return this._views.length
                    }
                    warnIfDestroyed() {}
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();

            function mb(t, n) {
                const e = t.indexOf(n);
                e > -1 && t.splice(e, 1)
            }
            const g5 = new nn("", {
                providedIn: "root",
                factory: () => vn(jl).handleError.bind(void 0)
            });

            function bK() {
                const t = vn(cr),
                    n = vn(jl);
                return e => t.runOutsideAngular(() => n.handleError(e))
            }
            let wK = (() => {
                class t {
                    constructor() {
                        this.zone = vn(cr), this.applicationRef = vn(Xl)
                    }
                    initialize() {
                        this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
                            next: () => {
                                this.zone.run(() => {
                                    this.applicationRef.tick()
                                })
                            }
                        }))
                    }
                    ngOnDestroy() {
                        this._onMicrotaskEmptySubscription ? .unsubscribe()
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            let qa = (() => {
                class t {
                    static# e = this.__NG_ELEMENT_ID__ = TK
                }
                return t
            })();

            function TK(t) {
                return function SK(t, n, e) {
                    if (Rc(t) && !e) {
                        const i = So(t.index, n);
                        return new hy(i, i)
                    }
                    return 47 & t.type ? new hy(n[Er], n) : null
                }(Cs(), It(), 16 == (16 & t))
            }
            class w5 {
                constructor() {}
                supports(n) {
                    return Yv(n)
                }
                create(n) {
                    return new IK(n)
                }
            }
            const MK = (t, n) => n;
            class IK {
                constructor(n) {
                    this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || MK
                }
                forEachItem(n) {
                    let e;
                    for (e = this._itHead; null !== e; e = e._next) n(e)
                }
                forEachOperation(n) {
                    let e = this._itHead,
                        i = this._removalsHead,
                        r = 0,
                        s = null;
                    for (; e || i;) {
                        const o = !i || e && e.currentIndex < C5(i, r, s) ? e : i,
                            a = C5(o, r, s),
                            c = o.currentIndex;
                        if (o === i) r--, i = i._nextRemoved;
                        else if (e = e._next, null == o.previousIndex) r++;
                        else {
                            s || (s = []);
                            const u = a - r,
                                h = c - r;
                            if (u != h) {
                                for (let x = 0; x < u; x++) {
                                    const D = x < s.length ? s[x] : s[x] = 0,
                                        V = D + x;
                                    h <= V && V < u && (s[x] = D + 1)
                                }
                                s[o.previousIndex] = h - u
                            }
                        }
                        a !== c && n(o, a, c)
                    }
                }
                forEachPreviousItem(n) {
                    let e;
                    for (e = this._previousItHead; null !== e; e = e._nextPrevious) n(e)
                }
                forEachAddedItem(n) {
                    let e;
                    for (e = this._additionsHead; null !== e; e = e._nextAdded) n(e)
                }
                forEachMovedItem(n) {
                    let e;
                    for (e = this._movesHead; null !== e; e = e._nextMoved) n(e)
                }
                forEachRemovedItem(n) {
                    let e;
                    for (e = this._removalsHead; null !== e; e = e._nextRemoved) n(e)
                }
                forEachIdentityChange(n) {
                    let e;
                    for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange) n(e)
                }
                diff(n) {
                    if (null == n && (n = []), !Yv(n)) throw new mt(900, !1);
                    return this.check(n) ? this : null
                }
                onDestroy() {}
                check(n) {
                    this._reset();
                    let r, s, o, e = this._itHead,
                        i = !1;
                    if (Array.isArray(n)) {
                        this.length = n.length;
                        for (let a = 0; a < this.length; a++) s = n[a], o = this._trackByFn(a, s), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, s, o, a)), Object.is(e.item, s) || this._addIdentityChange(e, s)) : (e = this._mismatch(e, s, o, a), i = !0), e = e._next
                    } else r = 0,
                        function _j(t, n) {
                            if (Array.isArray(t))
                                for (let e = 0; e < t.length; e++) n(t[e]);
                            else {
                                const e = t[Symbol.iterator]();
                                let i;
                                for (; !(i = e.next()).done;) n(i.value)
                            }
                        }(n, a => {
                            o = this._trackByFn(r, a), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, a, o, r)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, o, r), i = !0), e = e._next, r++
                        }), this.length = r;
                    return this._truncate(e), this.collection = n, this.isDirty
                }
                get isDirty() {
                    return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
                }
                _reset() {
                    if (this.isDirty) {
                        let n;
                        for (n = this._previousItHead = this._itHead; null !== n; n = n._next) n._nextPrevious = n._next;
                        for (n = this._additionsHead; null !== n; n = n._nextAdded) n.previousIndex = n.currentIndex;
                        for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved) n.previousIndex = n.currentIndex;
                        this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
                    }
                }
                _mismatch(n, e, i, r) {
                    let s;
                    return null === n ? s = this._itTail : (s = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._reinsertAfter(n, s, r)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(i, r)) ? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._moveAfter(n, s, r)) : n = this._addAfter(new PK(e, i), s, r), n
                }
                _verifyReinsertion(n, e, i, r) {
                    let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null);
                    return null !== s ? n = this._reinsertAfter(s, n._prev, r) : n.currentIndex != r && (n.currentIndex = r, this._addToMoves(n, r)), n
                }
                _truncate(n) {
                    for (; null !== n;) {
                        const e = n._next;
                        this._addToRemovals(this._unlink(n)), n = e
                    }
                    null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
                }
                _reinsertAfter(n, e, i) {
                    null !== this._unlinkedRecords && this._unlinkedRecords.remove(n);
                    const r = n._prevRemoved,
                        s = n._nextRemoved;
                    return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(n, e, i), this._addToMoves(n, i), n
                }
                _moveAfter(n, e, i) {
                    return this._unlink(n), this._insertAfter(n, e, i), this._addToMoves(n, i), n
                }
                _addAfter(n, e, i) {
                    return this._insertAfter(n, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n
                }
                _insertAfter(n, e, i) {
                    const r = null === e ? this._itHead : e._next;
                    return n._next = r, n._prev = e, null === r ? this._itTail = n : r._prev = n, null === e ? this._itHead = n : e._next = n, null === this._linkedRecords && (this._linkedRecords = new x5), this._linkedRecords.put(n), n.currentIndex = i, n
                }
                _remove(n) {
                    return this._addToRemovals(this._unlink(n))
                }
                _unlink(n) {
                    null !== this._linkedRecords && this._linkedRecords.remove(n);
                    const e = n._prev,
                        i = n._next;
                    return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, n
                }
                _addToMoves(n, e) {
                    return n.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n
                }
                _addToRemovals(n) {
                    return null === this._unlinkedRecords && (this._unlinkedRecords = new x5), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n
                }
                _addIdentityChange(n, e) {
                    return n.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n
                }
            }
            class PK {
                constructor(n, e) {
                    this.item = n, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
                }
            }
            class OK {
                constructor() {
                    this._head = null, this._tail = null
                }
                add(n) {
                    null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n)
                }
                get(n, e) {
                    let i;
                    for (i = this._head; null !== i; i = i._nextDup)
                        if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, n)) return i;
                    return null
                }
                remove(n) {
                    const e = n._prevDup,
                        i = n._nextDup;
                    return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head
                }
            }
            class x5 {
                constructor() {
                    this.map = new Map
                }
                put(n) {
                    const e = n.trackById;
                    let i = this.map.get(e);
                    i || (i = new OK, this.map.set(e, i)), i.add(n)
                }
                get(n, e) {
                    const r = this.map.get(n);
                    return r ? r.get(n, e) : null
                }
                remove(n) {
                    const e = n.trackById;
                    return this.map.get(e).remove(n) && this.map.delete(e), n
                }
                get isEmpty() {
                    return 0 === this.map.size
                }
                clear() {
                    this.map.clear()
                }
            }

            function C5(t, n, e) {
                const i = t.previousIndex;
                if (null === i) return i;
                let r = 0;
                return e && i < e.length && (r = e[i]), i + n + r
            }
            class T5 {
                constructor() {}
                supports(n) {
                    return n instanceof Map || _T(n)
                }
                create() {
                    return new LK
                }
            }
            class LK {
                constructor() {
                    this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
                }
                get isDirty() {
                    return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
                }
                forEachItem(n) {
                    let e;
                    for (e = this._mapHead; null !== e; e = e._next) n(e)
                }
                forEachPreviousItem(n) {
                    let e;
                    for (e = this._previousMapHead; null !== e; e = e._nextPrevious) n(e)
                }
                forEachChangedItem(n) {
                    let e;
                    for (e = this._changesHead; null !== e; e = e._nextChanged) n(e)
                }
                forEachAddedItem(n) {
                    let e;
                    for (e = this._additionsHead; null !== e; e = e._nextAdded) n(e)
                }
                forEachRemovedItem(n) {
                    let e;
                    for (e = this._removalsHead; null !== e; e = e._nextRemoved) n(e)
                }
                diff(n) {
                    if (n) {
                        if (!(n instanceof Map || _T(n))) throw new mt(900, !1)
                    } else n = new Map;
                    return this.check(n) ? this : null
                }
                onDestroy() {}
                check(n) {
                    this._reset();
                    let e = this._mapHead;
                    if (this._appendAfter = null, this._forEach(n, (i, r) => {
                            if (e && e.key === r) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next;
                            else {
                                const s = this._getOrCreateRecordForKey(r, i);
                                e = this._insertBeforeOrAppend(e, s)
                            }
                        }), e) {
                        e._prev && (e._prev._next = null), this._removalsHead = e;
                        for (let i = e; null !== i; i = i._nextRemoved) i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null
                    }
                    return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
                }
                _insertBeforeOrAppend(n, e) {
                    if (n) {
                        const i = n._prev;
                        return e._next = n, e._prev = i, n._prev = e, i && (i._next = e), n === this._mapHead && (this._mapHead = e), this._appendAfter = n, n
                    }
                    return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null
                }
                _getOrCreateRecordForKey(n, e) {
                    if (this._records.has(n)) {
                        const r = this._records.get(n);
                        this._maybeAddToChanges(r, e);
                        const s = r._prev,
                            o = r._next;
                        return s && (s._next = o), o && (o._prev = s), r._next = null, r._prev = null, r
                    }
                    const i = new RK(n);
                    return this._records.set(n, i), i.currentValue = e, this._addToAdditions(i), i
                }
                _reset() {
                    if (this.isDirty) {
                        let n;
                        for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next) n._nextPrevious = n._next;
                        for (n = this._changesHead; null !== n; n = n._nextChanged) n.previousValue = n.currentValue;
                        for (n = this._additionsHead; null != n; n = n._nextAdded) n.previousValue = n.currentValue;
                        this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
                    }
                }
                _maybeAddToChanges(n, e) {
                    Object.is(e, n.currentValue) || (n.previousValue = n.currentValue, n.currentValue = e, this._addToChanges(n))
                }
                _addToAdditions(n) {
                    null === this._additionsHead ? this._additionsHead = this._additionsTail = n : (this._additionsTail._nextAdded = n, this._additionsTail = n)
                }
                _addToChanges(n) {
                    null === this._changesHead ? this._changesHead = this._changesTail = n : (this._changesTail._nextChanged = n, this._changesTail = n)
                }
                _forEach(n, e) {
                    n instanceof Map ? n.forEach(e) : Object.keys(n).forEach(i => e(n[i], i))
                }
            }
            class RK {
                constructor(n) {
                    this.key = n, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
                }
            }

            function S5() {
                return new _b([new w5])
            }
            let _b = (() => {
                class t {
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "root",
                        factory: S5
                    });
                    constructor(e) {
                        this.factories = e
                    }
                    static create(e, i) {
                        if (null != i) {
                            const r = i.factories.slice();
                            e = e.concat(r)
                        }
                        return new t(e)
                    }
                    static extend(e) {
                        return {
                            provide: t,
                            useFactory: i => t.create(e, i || S5()),
                            deps: [
                                [t, new jd, new zl]
                            ]
                        }
                    }
                    find(e) {
                        const i = this.factories.find(r => r.supports(e));
                        if (null != i) return i;
                        throw new mt(901, !1)
                    }
                }
                return t
            })();

            function E5() {
                return new gm([new T5])
            }
            let gm = (() => {
                class t {
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "root",
                        factory: E5
                    });
                    constructor(e) {
                        this.factories = e
                    }
                    static create(e, i) {
                        if (i) {
                            const r = i.factories.slice();
                            e = e.concat(r)
                        }
                        return new t(e)
                    }
                    static extend(e) {
                        return {
                            provide: t,
                            useFactory: i => t.create(e, i || E5()),
                            deps: [
                                [t, new jd, new zl]
                            ]
                        }
                    }
                    find(e) {
                        const i = this.factories.find(r => r.supports(e));
                        if (i) return i;
                        throw new mt(901, !1)
                    }
                }
                return t
            })();
            const FK = l5(null, "core", []);
            let VK = (() => {
                class t {
                    constructor(e) {}
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Xl))
                    };
                    static# t = this.\u0275mod = _i({
                        type: t
                    });
                    static# n = this.\u0275inj = wi({})
                }
                return t
            })();

            function ym(t) {
                return "boolean" == typeof t ? t : null != t && "false" !== t
            }
            let mS = null;

            function Nu() {
                return mS
            }
            class JK {}
            const Ss = new nn("DocumentToken");
            let gS = (() => {
                class t {
                    historyGo(e) {
                        throw new Error("Not implemented")
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: function() {
                            return vn(tq)
                        },
                        providedIn: "platform"
                    })
                }
                return t
            })();
            const eq = new nn("Location Initialized");
            let tq = (() => {
                class t extends gS {
                    constructor() {
                        super(), this._doc = vn(Ss), this._location = window.location, this._history = window.history
                    }
                    getBaseHrefFromDOM() {
                        return Nu().getBaseHref(this._doc)
                    }
                    onPopState(e) {
                        const i = Nu().getGlobalEventTarget(this._doc, "window");
                        return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e)
                    }
                    onHashChange(e) {
                        const i = Nu().getGlobalEventTarget(this._doc, "window");
                        return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e)
                    }
                    get href() {
                        return this._location.href
                    }
                    get protocol() {
                        return this._location.protocol
                    }
                    get hostname() {
                        return this._location.hostname
                    }
                    get port() {
                        return this._location.port
                    }
                    get pathname() {
                        return this._location.pathname
                    }
                    get search() {
                        return this._location.search
                    }
                    get hash() {
                        return this._location.hash
                    }
                    set pathname(e) {
                        this._location.pathname = e
                    }
                    pushState(e, i, r) {
                        this._history.pushState(e, i, r)
                    }
                    replaceState(e, i, r) {
                        this._history.replaceState(e, i, r)
                    }
                    forward() {
                        this._history.forward()
                    }
                    back() {
                        this._history.back()
                    }
                    historyGo(e = 0) {
                        this._history.go(e)
                    }
                    getState() {
                        return this._history.state
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: function() {
                            return new t
                        },
                        providedIn: "platform"
                    })
                }
                return t
            })();

            function yS(t, n) {
                if (0 == t.length) return n;
                if (0 == n.length) return t;
                let e = 0;
                return t.endsWith("/") && e++, n.startsWith("/") && e++, 2 == e ? t + n.substring(1) : 1 == e ? t + n : t + "/" + n
            }

            function R5(t) {
                const n = t.match(/#|\?|$/),
                    e = n && n.index || t.length;
                return t.slice(0, e - ("/" === t[e - 1] ? 1 : 0)) + t.slice(e)
            }

            function Fu(t) {
                return t && "?" !== t[0] ? "?" + t : t
            }
            let bf = (() => {
                class t {
                    historyGo(e) {
                        throw new Error("Not implemented")
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: function() {
                            return vn(N5)
                        },
                        providedIn: "root"
                    })
                }
                return t
            })();
            const B5 = new nn("appBaseHref");
            let N5 = (() => {
                    class t extends bf {
                        constructor(e, i) {
                            super(), this._platformLocation = e, this._removeListenerFns = [], this._baseHref = i ? ? this._platformLocation.getBaseHrefFromDOM() ? ? vn(Ss).location ? .origin ? ? ""
                        }
                        ngOnDestroy() {
                            for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
                        }
                        onPopState(e) {
                            this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e))
                        }
                        getBaseHref() {
                            return this._baseHref
                        }
                        prepareExternalUrl(e) {
                            return yS(this._baseHref, e)
                        }
                        path(e = !1) {
                            const i = this._platformLocation.pathname + Fu(this._platformLocation.search),
                                r = this._platformLocation.hash;
                            return r && e ? `${i}${r}` : i
                        }
                        pushState(e, i, r, s) {
                            const o = this.prepareExternalUrl(r + Fu(s));
                            this._platformLocation.pushState(e, i, o)
                        }
                        replaceState(e, i, r, s) {
                            const o = this.prepareExternalUrl(r + Fu(s));
                            this._platformLocation.replaceState(e, i, o)
                        }
                        forward() {
                            this._platformLocation.forward()
                        }
                        back() {
                            this._platformLocation.back()
                        }
                        getState() {
                            return this._platformLocation.getState()
                        }
                        historyGo(e = 0) {
                            this._platformLocation.historyGo ? .(e)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(gS), _t(B5, 8))
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "root"
                        })
                    }
                    return t
                })(),
                nq = (() => {
                    class t extends bf {
                        constructor(e, i) {
                            super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != i && (this._baseHref = i)
                        }
                        ngOnDestroy() {
                            for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
                        }
                        onPopState(e) {
                            this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e))
                        }
                        getBaseHref() {
                            return this._baseHref
                        }
                        path(e = !1) {
                            let i = this._platformLocation.hash;
                            return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i
                        }
                        prepareExternalUrl(e) {
                            const i = yS(this._baseHref, e);
                            return i.length > 0 ? "#" + i : i
                        }
                        pushState(e, i, r, s) {
                            let o = this.prepareExternalUrl(r + Fu(s));
                            0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.pushState(e, i, o)
                        }
                        replaceState(e, i, r, s) {
                            let o = this.prepareExternalUrl(r + Fu(s));
                            0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.replaceState(e, i, o)
                        }
                        forward() {
                            this._platformLocation.forward()
                        }
                        back() {
                            this._platformLocation.back()
                        }
                        getState() {
                            return this._platformLocation.getState()
                        }
                        historyGo(e = 0) {
                            this._platformLocation.historyGo ? .(e)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(gS), _t(B5, 8))
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                bb = (() => {
                    class t {
                        constructor(e) {
                            this._subject = new zt, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = e;
                            const i = this._locationStrategy.getBaseHref();
                            this._basePath = function sq(t) {
                                if (new RegExp("^(https?:)?//").test(t)) {
                                    const [, e] = t.split(/\/\/[^\/]+/);
                                    return e
                                }
                                return t
                            }(R5(F5(i))), this._locationStrategy.onPopState(r => {
                                this._subject.emit({
                                    url: this.path(!0),
                                    pop: !0,
                                    state: r.state,
                                    type: r.type
                                })
                            })
                        }
                        ngOnDestroy() {
                            this._urlChangeSubscription ? .unsubscribe(), this._urlChangeListeners = []
                        }
                        path(e = !1) {
                            return this.normalize(this._locationStrategy.path(e))
                        }
                        getState() {
                            return this._locationStrategy.getState()
                        }
                        isCurrentPathEqualTo(e, i = "") {
                            return this.path() == this.normalize(e + Fu(i))
                        }
                        normalize(e) {
                            return t.stripTrailingSlash(function rq(t, n) {
                                if (!t || !n.startsWith(t)) return n;
                                const e = n.substring(t.length);
                                return "" === e || ["/", ";", "?", "#"].includes(e[0]) ? e : n
                            }(this._basePath, F5(e)))
                        }
                        prepareExternalUrl(e) {
                            return e && "/" !== e[0] && (e = "/" + e), this._locationStrategy.prepareExternalUrl(e)
                        }
                        go(e, i = "", r = null) {
                            this._locationStrategy.pushState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Fu(i)), r)
                        }
                        replaceState(e, i = "", r = null) {
                            this._locationStrategy.replaceState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Fu(i)), r)
                        }
                        forward() {
                            this._locationStrategy.forward()
                        }
                        back() {
                            this._locationStrategy.back()
                        }
                        historyGo(e = 0) {
                            this._locationStrategy.historyGo ? .(e)
                        }
                        onUrlChange(e) {
                            return this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => {
                                this._notifyUrlChangeListeners(i.url, i.state)
                            })), () => {
                                const i = this._urlChangeListeners.indexOf(e);
                                this._urlChangeListeners.splice(i, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription ? .unsubscribe(), this._urlChangeSubscription = null)
                            }
                        }
                        _notifyUrlChangeListeners(e = "", i) {
                            this._urlChangeListeners.forEach(r => r(e, i))
                        }
                        subscribe(e, i, r) {
                            return this._subject.subscribe({
                                next: e,
                                error: i,
                                complete: r
                            })
                        }
                        static# e = this.normalizeQueryParams = Fu;
                        static# t = this.joinWithSlash = yS;
                        static# n = this.stripTrailingSlash = R5;
                        static# i = this.\u0275fac = function(i) {
                            return new(i || t)(_t(bf))
                        };
                        static# r = this.\u0275prov = Dt({
                            token: t,
                            factory: function() {
                                return function iq() {
                                    return new bb(_t(bf))
                                }()
                            },
                            providedIn: "root"
                        })
                    }
                    return t
                })();

            function F5(t) {
                return t.replace(/\/index.html$/, "")
            }
            var Ta = function(t) {
                    return t[t.Format = 0] = "Format", t[t.Standalone = 1] = "Standalone", t
                }(Ta || {}),
                es = function(t) {
                    return t[t.Narrow = 0] = "Narrow", t[t.Abbreviated = 1] = "Abbreviated", t[t.Wide = 2] = "Wide", t[t.Short = 3] = "Short", t
                }(es || {}),
                pc = function(t) {
                    return t[t.Short = 0] = "Short", t[t.Medium = 1] = "Medium", t[t.Long = 2] = "Long", t[t.Full = 3] = "Full", t
                }(pc || {}),
                Zs = function(t) {
                    return t[t.Decimal = 0] = "Decimal", t[t.Group = 1] = "Group", t[t.List = 2] = "List", t[t.PercentSign = 3] = "PercentSign", t[t.PlusSign = 4] = "PlusSign", t[t.MinusSign = 5] = "MinusSign", t[t.Exponential = 6] = "Exponential", t[t.SuperscriptingExponent = 7] = "SuperscriptingExponent", t[t.PerMille = 8] = "PerMille", t[t.Infinity = 9] = "Infinity", t[t.NaN = 10] = "NaN", t[t.TimeSeparator = 11] = "TimeSeparator", t[t.CurrencyDecimal = 12] = "CurrencyDecimal", t[t.CurrencyGroup = 13] = "CurrencyGroup", t
                }(Zs || {});

            function xb(t, n) {
                return jc(ba(t)[ss.DateFormat], n)
            }

            function Cb(t, n) {
                return jc(ba(t)[ss.TimeFormat], n)
            }

            function Tb(t, n) {
                return jc(ba(t)[ss.DateTimeFormat], n)
            }

            function zc(t, n) {
                const e = ba(t),
                    i = e[ss.NumberSymbols][n];
                if (typeof i > "u") {
                    if (n === Zs.CurrencyDecimal) return e[ss.NumberSymbols][Zs.Decimal];
                    if (n === Zs.CurrencyGroup) return e[ss.NumberSymbols][Zs.Group]
                }
                return i
            }

            function U5(t) {
                if (!t[ss.ExtraData]) throw new Error(`Missing extra locale data for the locale "${t[ss.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`)
            }

            function jc(t, n) {
                for (let e = n; e > -1; e--)
                    if (typeof t[e] < "u") return t[e];
                throw new Error("Locale data API: locale data undefined")
            }

            function vS(t) {
                const [n, e] = t.split(":");
                return {
                    hours: +n,
                    minutes: +e
                }
            }
            const vq = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
                Iy = {},
                bq = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
            var Vu = function(t) {
                    return t[t.Short = 0] = "Short", t[t.ShortGMT = 1] = "ShortGMT", t[t.Long = 2] = "Long", t[t.Extended = 3] = "Extended", t
                }(Vu || {}),
                Lr = function(t) {
                    return t[t.FullYear = 0] = "FullYear", t[t.Month = 1] = "Month", t[t.Date = 2] = "Date", t[t.Hours = 3] = "Hours", t[t.Minutes = 4] = "Minutes", t[t.Seconds = 5] = "Seconds", t[t.FractionalSeconds = 6] = "FractionalSeconds", t[t.Day = 7] = "Day", t
                }(Lr || {}),
                Rr = function(t) {
                    return t[t.DayPeriods = 0] = "DayPeriods", t[t.Days = 1] = "Days", t[t.Months = 2] = "Months", t[t.Eras = 3] = "Eras", t
                }(Rr || {});

            function wq(t, n, e, i) {
                let r = function Mq(t) {
                    if (z5(t)) return t;
                    if ("number" == typeof t && !isNaN(t)) return new Date(t);
                    if ("string" == typeof t) {
                        if (t = t.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(t)) {
                            const [r, s = 1, o = 1] = t.split("-").map(a => +a);
                            return Sb(r, s - 1, o)
                        }
                        const e = parseFloat(t);
                        if (!isNaN(t - e)) return new Date(e);
                        let i;
                        if (i = t.match(vq)) return function Iq(t) {
                            const n = new Date(0);
                            let e = 0,
                                i = 0;
                            const r = t[8] ? n.setUTCFullYear : n.setFullYear,
                                s = t[8] ? n.setUTCHours : n.setHours;
                            t[9] && (e = Number(t[9] + t[10]), i = Number(t[9] + t[11])), r.call(n, Number(t[1]), Number(t[2]) - 1, Number(t[3]));
                            const o = Number(t[4] || 0) - e,
                                a = Number(t[5] || 0) - i,
                                c = Number(t[6] || 0),
                                u = Math.floor(1e3 * parseFloat("0." + (t[7] || 0)));
                            return s.call(n, o, a, c, u), n
                        }(i)
                    }
                    const n = new Date(t);
                    if (!z5(n)) throw new Error(`Unable to convert "${t}" into a date`);
                    return n
                }(t);
                n = Uu(e, n) || n;
                let a, o = [];
                for (; n;) {
                    if (a = bq.exec(n), !a) {
                        o.push(n);
                        break
                    } {
                        o = o.concat(a.slice(1));
                        const h = o.pop();
                        if (!h) break;
                        n = h
                    }
                }
                let c = r.getTimezoneOffset();
                i && (c = $5(i, c), r = function kq(t, n, e) {
                    const i = e ? -1 : 1,
                        r = t.getTimezoneOffset();
                    return function Aq(t, n) {
                        return (t = new Date(t.getTime())).setMinutes(t.getMinutes() + n), t
                    }(t, i * ($5(n, r) - r))
                }(r, i, !0));
                let u = "";
                return o.forEach(h => {
                    const m = function Dq(t) {
                        if (wS[t]) return wS[t];
                        let n;
                        switch (t) {
                            case "G":
                            case "GG":
                            case "GGG":
                                n = os(Rr.Eras, es.Abbreviated);
                                break;
                            case "GGGG":
                                n = os(Rr.Eras, es.Wide);
                                break;
                            case "GGGGG":
                                n = os(Rr.Eras, es.Narrow);
                                break;
                            case "y":
                                n = oo(Lr.FullYear, 1, 0, !1, !0);
                                break;
                            case "yy":
                                n = oo(Lr.FullYear, 2, 0, !0, !0);
                                break;
                            case "yyy":
                                n = oo(Lr.FullYear, 3, 0, !1, !0);
                                break;
                            case "yyyy":
                                n = oo(Lr.FullYear, 4, 0, !1, !0);
                                break;
                            case "Y":
                                n = kb(1);
                                break;
                            case "YY":
                                n = kb(2, !0);
                                break;
                            case "YYY":
                                n = kb(3);
                                break;
                            case "YYYY":
                                n = kb(4);
                                break;
                            case "M":
                            case "L":
                                n = oo(Lr.Month, 1, 1);
                                break;
                            case "MM":
                            case "LL":
                                n = oo(Lr.Month, 2, 1);
                                break;
                            case "MMM":
                                n = os(Rr.Months, es.Abbreviated);
                                break;
                            case "MMMM":
                                n = os(Rr.Months, es.Wide);
                                break;
                            case "MMMMM":
                                n = os(Rr.Months, es.Narrow);
                                break;
                            case "LLL":
                                n = os(Rr.Months, es.Abbreviated, Ta.Standalone);
                                break;
                            case "LLLL":
                                n = os(Rr.Months, es.Wide, Ta.Standalone);
                                break;
                            case "LLLLL":
                                n = os(Rr.Months, es.Narrow, Ta.Standalone);
                                break;
                            case "w":
                                n = bS(1);
                                break;
                            case "ww":
                                n = bS(2);
                                break;
                            case "W":
                                n = bS(1, !0);
                                break;
                            case "d":
                                n = oo(Lr.Date, 1);
                                break;
                            case "dd":
                                n = oo(Lr.Date, 2);
                                break;
                            case "c":
                            case "cc":
                                n = oo(Lr.Day, 1);
                                break;
                            case "ccc":
                                n = os(Rr.Days, es.Abbreviated, Ta.Standalone);
                                break;
                            case "cccc":
                                n = os(Rr.Days, es.Wide, Ta.Standalone);
                                break;
                            case "ccccc":
                                n = os(Rr.Days, es.Narrow, Ta.Standalone);
                                break;
                            case "cccccc":
                                n = os(Rr.Days, es.Short, Ta.Standalone);
                                break;
                            case "E":
                            case "EE":
                            case "EEE":
                                n = os(Rr.Days, es.Abbreviated);
                                break;
                            case "EEEE":
                                n = os(Rr.Days, es.Wide);
                                break;
                            case "EEEEE":
                                n = os(Rr.Days, es.Narrow);
                                break;
                            case "EEEEEE":
                                n = os(Rr.Days, es.Short);
                                break;
                            case "a":
                            case "aa":
                            case "aaa":
                                n = os(Rr.DayPeriods, es.Abbreviated);
                                break;
                            case "aaaa":
                                n = os(Rr.DayPeriods, es.Wide);
                                break;
                            case "aaaaa":
                                n = os(Rr.DayPeriods, es.Narrow);
                                break;
                            case "b":
                            case "bb":
                            case "bbb":
                                n = os(Rr.DayPeriods, es.Abbreviated, Ta.Standalone, !0);
                                break;
                            case "bbbb":
                                n = os(Rr.DayPeriods, es.Wide, Ta.Standalone, !0);
                                break;
                            case "bbbbb":
                                n = os(Rr.DayPeriods, es.Narrow, Ta.Standalone, !0);
                                break;
                            case "B":
                            case "BB":
                            case "BBB":
                                n = os(Rr.DayPeriods, es.Abbreviated, Ta.Format, !0);
                                break;
                            case "BBBB":
                                n = os(Rr.DayPeriods, es.Wide, Ta.Format, !0);
                                break;
                            case "BBBBB":
                                n = os(Rr.DayPeriods, es.Narrow, Ta.Format, !0);
                                break;
                            case "h":
                                n = oo(Lr.Hours, 1, -12);
                                break;
                            case "hh":
                                n = oo(Lr.Hours, 2, -12);
                                break;
                            case "H":
                                n = oo(Lr.Hours, 1);
                                break;
                            case "HH":
                                n = oo(Lr.Hours, 2);
                                break;
                            case "m":
                                n = oo(Lr.Minutes, 1);
                                break;
                            case "mm":
                                n = oo(Lr.Minutes, 2);
                                break;
                            case "s":
                                n = oo(Lr.Seconds, 1);
                                break;
                            case "ss":
                                n = oo(Lr.Seconds, 2);
                                break;
                            case "S":
                                n = oo(Lr.FractionalSeconds, 1);
                                break;
                            case "SS":
                                n = oo(Lr.FractionalSeconds, 2);
                                break;
                            case "SSS":
                                n = oo(Lr.FractionalSeconds, 3);
                                break;
                            case "Z":
                            case "ZZ":
                            case "ZZZ":
                                n = Db(Vu.Short);
                                break;
                            case "ZZZZZ":
                                n = Db(Vu.Extended);
                                break;
                            case "O":
                            case "OO":
                            case "OOO":
                            case "z":
                            case "zz":
                            case "zzz":
                                n = Db(Vu.ShortGMT);
                                break;
                            case "OOOO":
                            case "ZZZZ":
                            case "zzzz":
                                n = Db(Vu.Long);
                                break;
                            default:
                                return null
                        }
                        return wS[t] = n, n
                    }(h);
                    u += m ? m(r, e, c) : "''" === h ? "'" : h.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), u
            }

            function Sb(t, n, e) {
                const i = new Date(0);
                return i.setFullYear(t, n, e), i.setHours(0, 0, 0), i
            }

            function Uu(t, n) {
                const e = function aq(t) {
                    return ba(t)[ss.LocaleId]
                }(t);
                if (Iy[e] = Iy[e] || {}, Iy[e][n]) return Iy[e][n];
                let i = "";
                switch (n) {
                    case "shortDate":
                        i = xb(t, pc.Short);
                        break;
                    case "mediumDate":
                        i = xb(t, pc.Medium);
                        break;
                    case "longDate":
                        i = xb(t, pc.Long);
                        break;
                    case "fullDate":
                        i = xb(t, pc.Full);
                        break;
                    case "shortTime":
                        i = Cb(t, pc.Short);
                        break;
                    case "mediumTime":
                        i = Cb(t, pc.Medium);
                        break;
                    case "longTime":
                        i = Cb(t, pc.Long);
                        break;
                    case "fullTime":
                        i = Cb(t, pc.Full);
                        break;
                    case "short":
                        const r = Uu(t, "shortTime"),
                            s = Uu(t, "shortDate");
                        i = Eb(Tb(t, pc.Short), [r, s]);
                        break;
                    case "medium":
                        const o = Uu(t, "mediumTime"),
                            a = Uu(t, "mediumDate");
                        i = Eb(Tb(t, pc.Medium), [o, a]);
                        break;
                    case "long":
                        const c = Uu(t, "longTime"),
                            u = Uu(t, "longDate");
                        i = Eb(Tb(t, pc.Long), [c, u]);
                        break;
                    case "full":
                        const h = Uu(t, "fullTime"),
                            m = Uu(t, "fullDate");
                        i = Eb(Tb(t, pc.Full), [h, m])
                }
                return i && (Iy[e][n] = i), i
            }

            function Eb(t, n) {
                return n && (t = t.replace(/\{([^}]+)}/g, function(e, i) {
                    return null != n && i in n ? n[i] : e
                })), t
            }

            function vl(t, n, e = "-", i, r) {
                let s = "";
                (t < 0 || r && t <= 0) && (r ? t = 1 - t : (t = -t, s = e));
                let o = String(t);
                for (; o.length < n;) o = "0" + o;
                return i && (o = o.slice(o.length - n)), s + o
            }

            function oo(t, n, e = 0, i = !1, r = !1) {
                return function(s, o) {
                    let a = function Cq(t, n) {
                        switch (t) {
                            case Lr.FullYear:
                                return n.getFullYear();
                            case Lr.Month:
                                return n.getMonth();
                            case Lr.Date:
                                return n.getDate();
                            case Lr.Hours:
                                return n.getHours();
                            case Lr.Minutes:
                                return n.getMinutes();
                            case Lr.Seconds:
                                return n.getSeconds();
                            case Lr.FractionalSeconds:
                                return n.getMilliseconds();
                            case Lr.Day:
                                return n.getDay();
                            default:
                                throw new Error(`Unknown DateType value "${t}".`)
                        }
                    }(t, s);
                    if ((e > 0 || a > -e) && (a += e), t === Lr.Hours) 0 === a && -12 === e && (a = 12);
                    else if (t === Lr.FractionalSeconds) return function xq(t, n) {
                        return vl(t, 3).substring(0, n)
                    }(a, n);
                    const c = zc(o, Zs.MinusSign);
                    return vl(a, n, c, i, r)
                }
            }

            function os(t, n, e = Ta.Format, i = !1) {
                return function(r, s) {
                    return function Tq(t, n, e, i, r, s) {
                        switch (e) {
                            case Rr.Months:
                                return function uq(t, n, e) {
                                    const i = ba(t),
                                        s = jc([i[ss.MonthsFormat], i[ss.MonthsStandalone]], n);
                                    return jc(s, e)
                                }(n, r, i)[t.getMonth()];
                            case Rr.Days:
                                return function lq(t, n, e) {
                                    const i = ba(t),
                                        s = jc([i[ss.DaysFormat], i[ss.DaysStandalone]], n);
                                    return jc(s, e)
                                }(n, r, i)[t.getDay()];
                            case Rr.DayPeriods:
                                const o = t.getHours(),
                                    a = t.getMinutes();
                                if (s) {
                                    const u = function pq(t) {
                                            const n = ba(t);
                                            return U5(n), (n[ss.ExtraData][2] || []).map(i => "string" == typeof i ? vS(i) : [vS(i[0]), vS(i[1])])
                                        }(n),
                                        h = function mq(t, n, e) {
                                            const i = ba(t);
                                            U5(i);
                                            const s = jc([i[ss.ExtraData][0], i[ss.ExtraData][1]], n) || [];
                                            return jc(s, e) || []
                                        }(n, r, i),
                                        m = u.findIndex(x => {
                                            if (Array.isArray(x)) {
                                                const [D, V] = x, te = o >= D.hours && a >= D.minutes, ee = o < V.hours || o === V.hours && a < V.minutes;
                                                if (D.hours < V.hours) {
                                                    if (te && ee) return !0
                                                } else if (te || ee) return !0
                                            } else if (x.hours === o && x.minutes === a) return !0;
                                            return !1
                                        });
                                    if (-1 !== m) return h[m]
                                }
                                return function cq(t, n, e) {
                                    const i = ba(t),
                                        s = jc([i[ss.DayPeriodsFormat], i[ss.DayPeriodsStandalone]], n);
                                    return jc(s, e)
                                }(n, r, i)[o < 12 ? 0 : 1];
                            case Rr.Eras:
                                return function dq(t, n) {
                                    return jc(ba(t)[ss.Eras], n)
                                }(n, i)[t.getFullYear() <= 0 ? 0 : 1];
                            default:
                                throw new Error(`unexpected translation type ${e}`)
                        }
                    }(r, s, t, n, e, i)
                }
            }

            function Db(t) {
                return function(n, e, i) {
                    const r = -1 * i,
                        s = zc(e, Zs.MinusSign),
                        o = r > 0 ? Math.floor(r / 60) : Math.ceil(r / 60);
                    switch (t) {
                        case Vu.Short:
                            return (r >= 0 ? "+" : "") + vl(o, 2, s) + vl(Math.abs(r % 60), 2, s);
                        case Vu.ShortGMT:
                            return "GMT" + (r >= 0 ? "+" : "") + vl(o, 1, s);
                        case Vu.Long:
                            return "GMT" + (r >= 0 ? "+" : "") + vl(o, 2, s) + ":" + vl(Math.abs(r % 60), 2, s);
                        case Vu.Extended:
                            return 0 === i ? "Z" : (r >= 0 ? "+" : "") + vl(o, 2, s) + ":" + vl(Math.abs(r % 60), 2, s);
                        default:
                            throw new Error(`Unknown zone width "${t}"`)
                    }
                }
            }
            const Sq = 0,
                Ab = 4;

            function H5(t) {
                return Sb(t.getFullYear(), t.getMonth(), t.getDate() + (Ab - t.getDay()))
            }

            function bS(t, n = !1) {
                return function(e, i) {
                    let r;
                    if (n) {
                        const s = new Date(e.getFullYear(), e.getMonth(), 1).getDay() - 1,
                            o = e.getDate();
                        r = 1 + Math.floor((o + s) / 7)
                    } else {
                        const s = H5(e),
                            o = function Eq(t) {
                                const n = Sb(t, Sq, 1).getDay();
                                return Sb(t, 0, 1 + (n <= Ab ? Ab : Ab + 7) - n)
                            }(s.getFullYear()),
                            a = s.getTime() - o.getTime();
                        r = 1 + Math.round(a / 6048e5)
                    }
                    return vl(r, t, zc(i, Zs.MinusSign))
                }
            }

            function kb(t, n = !1) {
                return function(e, i) {
                    return vl(H5(e).getFullYear(), t, zc(i, Zs.MinusSign), n)
                }
            }
            const wS = {};

            function $5(t, n) {
                t = t.replace(/:/g, "");
                const e = Date.parse("Jan 01, 1970 00:00:00 " + t) / 6e4;
                return isNaN(e) ? n : e
            }

            function z5(t) {
                return t instanceof Date && !isNaN(t.valueOf())
            }

            function K5(t, n) {
                n = encodeURIComponent(n);
                for (const e of t.split(";")) {
                    const i = e.indexOf("="),
                        [r, s] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)];
                    if (r.trim() === n) return decodeURIComponent(s)
                }
                return null
            }
            const DS = /\s+/,
                q5 = [];
            let Jd = (() => {
                class t {
                    constructor(e, i, r, s) {
                        this._iterableDiffers = e, this._keyValueDiffers = i, this._ngEl = r, this._renderer = s, this.initialClasses = q5, this.stateMap = new Map
                    }
                    set klass(e) {
                        this.initialClasses = null != e ? e.trim().split(DS) : q5
                    }
                    set ngClass(e) {
                        this.rawClass = "string" == typeof e ? e.trim().split(DS) : e
                    }
                    ngDoCheck() {
                        for (const i of this.initialClasses) this._updateState(i, !0);
                        const e = this.rawClass;
                        if (Array.isArray(e) || e instanceof Set)
                            for (const i of e) this._updateState(i, !0);
                        else if (null != e)
                            for (const i of Object.keys(e)) this._updateState(i, !!e[i]);
                        this._applyStateDiff()
                    }
                    _updateState(e, i) {
                        const r = this.stateMap.get(e);
                        void 0 !== r ? (r.enabled !== i && (r.changed = !0, r.enabled = i), r.touched = !0) : this.stateMap.set(e, {
                            enabled: i,
                            changed: !0,
                            touched: !0
                        })
                    }
                    _applyStateDiff() {
                        for (const e of this.stateMap) {
                            const i = e[0],
                                r = e[1];
                            r.changed ? (this._toggleClass(i, r.enabled), r.changed = !1) : r.touched || (r.enabled && this._toggleClass(i, !1), this.stateMap.delete(i)), r.touched = !1
                        }
                    }
                    _toggleClass(e, i) {
                        (e = e.trim()).length > 0 && e.split(DS).forEach(r => {
                            i ? this._renderer.addClass(this._ngEl.nativeElement, r) : this._renderer.removeClass(this._ngEl.nativeElement, r)
                        })
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(We(_b), We(gm), We(ir), We(Ks))
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "ngClass", ""]
                        ],
                        inputs: {
                            klass: ["class", "klass"],
                            ngClass: "ngClass"
                        },
                        standalone: !0
                    })
                }
                return t
            })();
            class jq {
                constructor(n, e, i, r) {
                    this.$implicit = n, this.ngForOf = e, this.index = i, this.count = r
                }
                get first() {
                    return 0 === this.index
                }
                get last() {
                    return this.index === this.count - 1
                }
                get even() {
                    return this.index % 2 == 0
                }
                get odd() {
                    return !this.even
                }
            }
            let Ao = (() => {
                class t {
                    set ngForOf(e) {
                        this._ngForOf = e, this._ngForOfDirty = !0
                    }
                    set ngForTrackBy(e) {
                        this._trackByFn = e
                    }
                    get ngForTrackBy() {
                        return this._trackByFn
                    }
                    constructor(e, i, r) {
                        this._viewContainer = e, this._template = i, this._differs = r, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
                    }
                    set ngForTemplate(e) {
                        e && (this._template = e)
                    }
                    ngDoCheck() {
                        if (this._ngForOfDirty) {
                            this._ngForOfDirty = !1;
                            const e = this._ngForOf;
                            !this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy))
                        }
                        if (this._differ) {
                            const e = this._differ.diff(this._ngForOf);
                            e && this._applyChanges(e)
                        }
                    }
                    _applyChanges(e) {
                        const i = this._viewContainer;
                        e.forEachOperation((r, s, o) => {
                            if (null == r.previousIndex) i.createEmbeddedView(this._template, new jq(r.item, this._ngForOf, -1, -1), null === o ? void 0 : o);
                            else if (null == o) i.remove(null === s ? void 0 : s);
                            else if (null !== s) {
                                const a = i.get(s);
                                i.move(a, o), Y5(a, r)
                            }
                        });
                        for (let r = 0, s = i.length; r < s; r++) {
                            const a = i.get(r).context;
                            a.index = r, a.count = s, a.ngForOf = this._ngForOf
                        }
                        e.forEachIdentityChange(r => {
                            Y5(i.get(r.currentIndex), r)
                        })
                    }
                    static ngTemplateContextGuard(e, i) {
                        return !0
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(We(Ga), We(Hc), We(_b))
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "ngFor", "", "ngForOf", ""]
                        ],
                        inputs: {
                            ngForOf: "ngForOf",
                            ngForTrackBy: "ngForTrackBy",
                            ngForTemplate: "ngForTemplate"
                        },
                        standalone: !0
                    })
                }
                return t
            })();

            function Y5(t, n) {
                t.context.$implicit = n.item
            }
            let ts = (() => {
                class t {
                    constructor(e, i) {
                        this._viewContainer = e, this._context = new Wq, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i
                    }
                    set ngIf(e) {
                        this._context.$implicit = this._context.ngIf = e, this._updateView()
                    }
                    set ngIfThen(e) {
                        X5("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView()
                    }
                    set ngIfElse(e) {
                        X5("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView()
                    }
                    _updateView() {
                        this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
                    }
                    static ngTemplateContextGuard(e, i) {
                        return !0
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(We(Ga), We(Hc))
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "ngIf", ""]
                        ],
                        inputs: {
                            ngIf: "ngIf",
                            ngIfThen: "ngIfThen",
                            ngIfElse: "ngIfElse"
                        },
                        standalone: !0
                    })
                }
                return t
            })();
            class Wq {
                constructor() {
                    this.$implicit = null, this.ngIf = null
                }
            }

            function X5(t, n) {
                if (n && !n.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${ti(n)}'.`)
            }
            let J5 = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._ngEl = e, this._differs = i, this._renderer = r, this._ngStyle = null, this._differ = null
                        }
                        set ngStyle(e) {
                            this._ngStyle = e, !this._differ && e && (this._differ = this._differs.find(e).create())
                        }
                        ngDoCheck() {
                            if (this._differ) {
                                const e = this._differ.diff(this._ngStyle);
                                e && this._applyChanges(e)
                            }
                        }
                        _setStyle(e, i) {
                            const [r, s] = e.split("."), o = -1 === r.indexOf("-") ? void 0 : Tn.DashCase;
                            null != i ? this._renderer.setStyle(this._ngEl.nativeElement, r, s ? `${i}${s}` : i, o) : this._renderer.removeStyle(this._ngEl.nativeElement, r, o)
                        }
                        _applyChanges(e) {
                            e.forEachRemovedItem(i => this._setStyle(i.key, null)), e.forEachAddedItem(i => this._setStyle(i.key, i.currentValue)), e.forEachChangedItem(i => this._setStyle(i.key, i.currentValue))
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(ir), We(gm), We(Ks))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "ngStyle", ""]
                            ],
                            inputs: {
                                ngStyle: "ngStyle"
                            },
                            standalone: !0
                        })
                    }
                    return t
                })(),
                MS = (() => {
                    class t {
                        constructor(e) {
                            this._viewContainerRef = e, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null
                        }
                        ngOnChanges(e) {
                            if (e.ngTemplateOutlet || e.ngTemplateOutletInjector) {
                                const i = this._viewContainerRef;
                                if (this._viewRef && i.remove(i.indexOf(this._viewRef)), this.ngTemplateOutlet) {
                                    const {
                                        ngTemplateOutlet: r,
                                        ngTemplateOutletContext: s,
                                        ngTemplateOutletInjector: o
                                    } = this;
                                    this._viewRef = i.createEmbeddedView(r, s, o ? {
                                        injector: o
                                    } : void 0)
                                } else this._viewRef = null
                            } else this._viewRef && e.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Ga))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "ngTemplateOutlet", ""]
                            ],
                            inputs: {
                                ngTemplateOutletContext: "ngTemplateOutletContext",
                                ngTemplateOutlet: "ngTemplateOutlet",
                                ngTemplateOutletInjector: "ngTemplateOutletInjector"
                            },
                            standalone: !0,
                            features: [Xi]
                        })
                    }
                    return t
                })();
            const sZ = new nn("DATE_PIPE_DEFAULT_TIMEZONE"),
                oZ = new nn("DATE_PIPE_DEFAULT_OPTIONS");
            let eR = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.locale = e, this.defaultTimezone = i, this.defaultOptions = r
                        }
                        transform(e, i, r, s) {
                            if (null == e || "" === e || e != e) return null;
                            try {
                                return wq(e, i ? ? this.defaultOptions ? .dateFormat ? ? "mediumDate", s || this.locale, r ? ? this.defaultOptions ? .timezone ? ? this.defaultTimezone ? ? void 0)
                            } catch (o) {
                                throw function bl(t, n) {
                                    return new mt(2100, !1)
                                }()
                            }
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Bu, 16), We(sZ, 24), We(oZ, 24))
                        };
                        static# t = this.\u0275pipe = Ps({
                            name: "date",
                            type: t,
                            pure: !0,
                            standalone: !0
                        })
                    }
                    return t
                })(),
                mc = (() => {
                    class t {
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({})
                    }
                    return t
                })();
            const nR = "browser";

            function gc(t) {
                return t === nR
            }

            function Oy(t) {
                return "server" === t
            }
            let vZ = (() => {
                class t {
                    static# e = this.\u0275prov = Dt({
                        token: t,
                        providedIn: "root",
                        factory: () => new bZ(_t(Ss), window)
                    })
                }
                return t
            })();
            class bZ {
                constructor(n, e) {
                    this.document = n, this.window = e, this.offset = () => [0, 0]
                }
                setOffset(n) {
                    this.offset = Array.isArray(n) ? () => n : n
                }
                getScrollPosition() {
                    return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
                }
                scrollToPosition(n) {
                    this.supportsScrolling() && this.window.scrollTo(n[0], n[1])
                }
                scrollToAnchor(n) {
                    if (!this.supportsScrolling()) return;
                    const e = function wZ(t, n) {
                        const e = t.getElementById(n) || t.getElementsByName(n)[0];
                        if (e) return e;
                        if ("function" == typeof t.createTreeWalker && t.body && "function" == typeof t.body.attachShadow) {
                            const i = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT);
                            let r = i.currentNode;
                            for (; r;) {
                                const s = r.shadowRoot;
                                if (s) {
                                    const o = s.getElementById(n) || s.querySelector(`[name="${n}"]`);
                                    if (o) return o
                                }
                                r = i.nextNode()
                            }
                        }
                        return null
                    }(this.document, n);
                    e && (this.scrollToElement(e), e.focus())
                }
                setHistoryScrollRestoration(n) {
                    this.supportsScrolling() && (this.window.history.scrollRestoration = n)
                }
                scrollToElement(n) {
                    const e = n.getBoundingClientRect(),
                        i = e.left + this.window.pageXOffset,
                        r = e.top + this.window.pageYOffset,
                        s = this.offset();
                    this.window.scrollTo(i - s[0], r - s[1])
                }
                supportsScrolling() {
                    try {
                        return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
                    } catch {
                        return !1
                    }
                }
            }
            class iR {}
            class jZ extends JK {
                constructor() {
                    super(...arguments), this.supportsDOMEvents = !0
                }
            }
            class RS extends jZ {
                static makeCurrent() {
                    ! function QK(t) {
                        mS || (mS = t)
                    }(new RS)
                }
                onAndCancel(n, e, i) {
                    return n.addEventListener(e, i), () => {
                        n.removeEventListener(e, i)
                    }
                }
                dispatchEvent(n, e) {
                    n.dispatchEvent(e)
                }
                remove(n) {
                    n.parentNode && n.parentNode.removeChild(n)
                }
                createElement(n, e) {
                    return (e = e || this.getDefaultDocument()).createElement(n)
                }
                createHtmlDocument() {
                    return document.implementation.createHTMLDocument("fakeTitle")
                }
                getDefaultDocument() {
                    return document
                }
                isElementNode(n) {
                    return n.nodeType === Node.ELEMENT_NODE
                }
                isShadowRoot(n) {
                    return n instanceof DocumentFragment
                }
                getGlobalEventTarget(n, e) {
                    return "window" === e ? window : "document" === e ? n : "body" === e ? n.body : null
                }
                getBaseHref(n) {
                    const e = function WZ() {
                        return Ry = Ry || document.querySelector("base"), Ry ? Ry.getAttribute("href") : null
                    }();
                    return null == e ? null : function GZ(t) {
                        Ob = Ob || document.createElement("a"), Ob.setAttribute("href", t);
                        const n = Ob.pathname;
                        return "/" === n.charAt(0) ? n : `/${n}`
                    }(e)
                }
                resetBaseElement() {
                    Ry = null
                }
                getUserAgent() {
                    return window.navigator.userAgent
                }
                getCookie(n) {
                    return K5(document.cookie, n)
                }
            }
            let Ob, Ry = null,
                qZ = (() => {
                    class t {
                        build() {
                            return new XMLHttpRequest
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })();
            const BS = new nn("EventManagerPlugins");
            let cR = (() => {
                class t {
                    constructor(e, i) {
                        this._zone = i, this._eventNameToPlugin = new Map, e.forEach(r => {
                            r.manager = this
                        }), this._plugins = e.slice().reverse()
                    }
                    addEventListener(e, i, r) {
                        return this._findPluginFor(i).addEventListener(e, i, r)
                    }
                    getZone() {
                        return this._zone
                    }
                    _findPluginFor(e) {
                        let i = this._eventNameToPlugin.get(e);
                        if (i) return i;
                        if (i = this._plugins.find(s => s.supports(e)), !i) throw new mt(5101, !1);
                        return this._eventNameToPlugin.set(e, i), i
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(BS), _t(cr))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            class lR {
                constructor(n) {
                    this._doc = n
                }
            }
            const NS = "ng-app-id";
            let uR = (() => {
                class t {
                    constructor(e, i, r, s = {}) {
                        this.doc = e, this.appId = i, this.nonce = r, this.platformId = s, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = Oy(s), this.resetHostNodes()
                    }
                    addStyles(e) {
                        for (const i of e) 1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i)
                    }
                    removeStyles(e) {
                        for (const i of e) this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i)
                    }
                    ngOnDestroy() {
                        const e = this.styleNodesInDOM;
                        e && (e.forEach(i => i.remove()), e.clear());
                        for (const i of this.getAllStyles()) this.onStyleRemoved(i);
                        this.resetHostNodes()
                    }
                    addHost(e) {
                        this.hostNodes.add(e);
                        for (const i of this.getAllStyles()) this.addStyleToHost(e, i)
                    }
                    removeHost(e) {
                        this.hostNodes.delete(e)
                    }
                    getAllStyles() {
                        return this.styleRef.keys()
                    }
                    onStyleAdded(e) {
                        for (const i of this.hostNodes) this.addStyleToHost(i, e)
                    }
                    onStyleRemoved(e) {
                        const i = this.styleRef;
                        i.get(e) ? .elements ? .forEach(r => r.remove()), i.delete(e)
                    }
                    collectServerRenderedStyles() {
                        const e = this.doc.head ? .querySelectorAll(`style[${NS}="${this.appId}"]`);
                        if (e ? .length) {
                            const i = new Map;
                            return e.forEach(r => {
                                null != r.textContent && i.set(r.textContent, r)
                            }), i
                        }
                        return null
                    }
                    changeUsageCount(e, i) {
                        const r = this.styleRef;
                        if (r.has(e)) {
                            const s = r.get(e);
                            return s.usage += i, s.usage
                        }
                        return r.set(e, {
                            usage: i,
                            elements: []
                        }), i
                    }
                    getStyleElement(e, i) {
                        const r = this.styleNodesInDOM,
                            s = r ? .get(i);
                        if (s ? .parentNode === e) return r.delete(i), s.removeAttribute(NS), s; {
                            const o = this.doc.createElement("style");
                            return this.nonce && o.setAttribute("nonce", this.nonce), o.textContent = i, this.platformIsServer && o.setAttribute(NS, this.appId), o
                        }
                    }
                    addStyleToHost(e, i) {
                        const r = this.getStyleElement(e, i);
                        e.appendChild(r);
                        const s = this.styleRef,
                            o = s.get(i) ? .elements;
                        o ? o.push(r) : s.set(i, {
                            elements: [r],
                            usage: 1
                        })
                    }
                    resetHostNodes() {
                        const e = this.hostNodes;
                        e.clear(), e.add(this.doc.head)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss), _t(Nv), _t(wP, 8), _t(Bs))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const FS = {
                    svg: "http://www.w3.org/2000/svg",
                    xhtml: "http://www.w3.org/1999/xhtml",
                    xlink: "http://www.w3.org/1999/xlink",
                    xml: "http://www.w3.org/XML/1998/namespace",
                    xmlns: "http://www.w3.org/2000/xmlns/",
                    math: "http://www.w3.org/1998/MathML/"
                },
                VS = /%COMP%/g,
                QZ = new nn("RemoveStylesOnCompDestroy", {
                    providedIn: "root",
                    factory: () => !1
                });

            function hR(t, n) {
                return n.map(e => e.replace(VS, t))
            }
            let US = (() => {
                class t {
                    constructor(e, i, r, s, o, a, c, u = null) {
                        this.eventManager = e, this.sharedStylesHost = i, this.appId = r, this.removeStylesOnCompDestroy = s, this.doc = o, this.platformId = a, this.ngZone = c, this.nonce = u, this.rendererByCompId = new Map, this.platformIsServer = Oy(a), this.defaultRenderer = new HS(e, o, c, this.platformIsServer)
                    }
                    createRenderer(e, i) {
                        if (!e || !i) return this.defaultRenderer;
                        this.platformIsServer && i.encapsulation === ls.ShadowDom && (i = { ...i,
                            encapsulation: ls.Emulated
                        });
                        const r = this.getOrCreateRenderer(e, i);
                        return r instanceof pR ? r.applyToHost(e) : r instanceof $S && r.applyStyles(), r
                    }
                    getOrCreateRenderer(e, i) {
                        const r = this.rendererByCompId;
                        let s = r.get(i.id);
                        if (!s) {
                            const o = this.doc,
                                a = this.ngZone,
                                c = this.eventManager,
                                u = this.sharedStylesHost,
                                h = this.removeStylesOnCompDestroy,
                                m = this.platformIsServer;
                            switch (i.encapsulation) {
                                case ls.Emulated:
                                    s = new pR(c, u, i, this.appId, h, o, a, m);
                                    break;
                                case ls.ShadowDom:
                                    return new nY(c, u, e, i, o, a, this.nonce, m);
                                default:
                                    s = new $S(c, u, i, h, o, a, m)
                            }
                            r.set(i.id, s)
                        }
                        return s
                    }
                    ngOnDestroy() {
                        this.rendererByCompId.clear()
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(cR), _t(uR), _t(Nv), _t(QZ), _t(Ss), _t(Bs), _t(cr), _t(wP))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            class HS {
                constructor(n, e, i, r) {
                    this.eventManager = n, this.doc = e, this.ngZone = i, this.platformIsServer = r, this.data = Object.create(null), this.destroyNode = null
                }
                destroy() {}
                createElement(n, e) {
                    return e ? this.doc.createElementNS(FS[e] || e, n) : this.doc.createElement(n)
                }
                createComment(n) {
                    return this.doc.createComment(n)
                }
                createText(n) {
                    return this.doc.createTextNode(n)
                }
                appendChild(n, e) {
                    (fR(n) ? n.content : n).appendChild(e)
                }
                insertBefore(n, e, i) {
                    n && (fR(n) ? n.content : n).insertBefore(e, i)
                }
                removeChild(n, e) {
                    n && n.removeChild(e)
                }
                selectRootElement(n, e) {
                    let i = "string" == typeof n ? this.doc.querySelector(n) : n;
                    if (!i) throw new mt(-5104, !1);
                    return e || (i.textContent = ""), i
                }
                parentNode(n) {
                    return n.parentNode
                }
                nextSibling(n) {
                    return n.nextSibling
                }
                setAttribute(n, e, i, r) {
                    if (r) {
                        e = r + ":" + e;
                        const s = FS[r];
                        s ? n.setAttributeNS(s, e, i) : n.setAttribute(e, i)
                    } else n.setAttribute(e, i)
                }
                removeAttribute(n, e, i) {
                    if (i) {
                        const r = FS[i];
                        r ? n.removeAttributeNS(r, e) : n.removeAttribute(`${i}:${e}`)
                    } else n.removeAttribute(e)
                }
                addClass(n, e) {
                    n.classList.add(e)
                }
                removeClass(n, e) {
                    n.classList.remove(e)
                }
                setStyle(n, e, i, r) {
                    r & (Tn.DashCase | Tn.Important) ? n.style.setProperty(e, i, r & Tn.Important ? "important" : "") : n.style[e] = i
                }
                removeStyle(n, e, i) {
                    i & Tn.DashCase ? n.style.removeProperty(e) : n.style[e] = ""
                }
                setProperty(n, e, i) {
                    n[e] = i
                }
                setValue(n, e) {
                    n.nodeValue = e
                }
                listen(n, e, i) {
                    if ("string" == typeof n && !(n = Nu().getGlobalEventTarget(this.doc, n))) throw new Error(`Unsupported event target ${n} for event ${e}`);
                    return this.eventManager.addEventListener(n, e, this.decoratePreventDefault(i))
                }
                decoratePreventDefault(n) {
                    return e => {
                        if ("__ngUnwrap__" === e) return n;
                        !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => n(e)) : n(e)) && e.preventDefault()
                    }
                }
            }

            function fR(t) {
                return "TEMPLATE" === t.tagName && void 0 !== t.content
            }
            class nY extends HS {
                constructor(n, e, i, r, s, o, a, c) {
                    super(n, s, o, c), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({
                        mode: "open"
                    }), this.sharedStylesHost.addHost(this.shadowRoot);
                    const u = hR(r.id, r.styles);
                    for (const h of u) {
                        const m = document.createElement("style");
                        a && m.setAttribute("nonce", a), m.textContent = h, this.shadowRoot.appendChild(m)
                    }
                }
                nodeOrShadowRoot(n) {
                    return n === this.hostEl ? this.shadowRoot : n
                }
                appendChild(n, e) {
                    return super.appendChild(this.nodeOrShadowRoot(n), e)
                }
                insertBefore(n, e, i) {
                    return super.insertBefore(this.nodeOrShadowRoot(n), e, i)
                }
                removeChild(n, e) {
                    return super.removeChild(this.nodeOrShadowRoot(n), e)
                }
                parentNode(n) {
                    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))
                }
                destroy() {
                    this.sharedStylesHost.removeHost(this.shadowRoot)
                }
            }
            class $S extends HS {
                constructor(n, e, i, r, s, o, a, c) {
                    super(n, s, o, a), this.sharedStylesHost = e, this.removeStylesOnCompDestroy = r, this.styles = c ? hR(c, i.styles) : i.styles
                }
                applyStyles() {
                    this.sharedStylesHost.addStyles(this.styles)
                }
                destroy() {
                    this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles)
                }
            }
            class pR extends $S {
                constructor(n, e, i, r, s, o, a, c) {
                    const u = r + "-" + i.id;
                    super(n, e, i, s, o, a, c, u), this.contentAttr = function JZ(t) {
                        return "_ngcontent-%COMP%".replace(VS, t)
                    }(u), this.hostAttr = function eY(t) {
                        return "_nghost-%COMP%".replace(VS, t)
                    }(u)
                }
                applyToHost(n) {
                    this.applyStyles(), this.setAttribute(n, this.hostAttr, "")
                }
                createElement(n, e) {
                    const i = super.createElement(n, e);
                    return super.setAttribute(i, this.contentAttr, ""), i
                }
            }
            let iY = (() => {
                class t extends lR {
                    constructor(e) {
                        super(e)
                    }
                    supports(e) {
                        return !0
                    }
                    addEventListener(e, i, r) {
                        return e.addEventListener(i, r, !1), () => this.removeEventListener(e, i, r)
                    }
                    removeEventListener(e, i, r) {
                        return e.removeEventListener(i, r)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const mR = ["alt", "control", "meta", "shift"],
                rY = {
                    "\b": "Backspace",
                    "\t": "Tab",
                    "\x7f": "Delete",
                    "\x1b": "Escape",
                    Del: "Delete",
                    Esc: "Escape",
                    Left: "ArrowLeft",
                    Right: "ArrowRight",
                    Up: "ArrowUp",
                    Down: "ArrowDown",
                    Menu: "ContextMenu",
                    Scroll: "ScrollLock",
                    Win: "OS"
                },
                sY = {
                    alt: t => t.altKey,
                    control: t => t.ctrlKey,
                    meta: t => t.metaKey,
                    shift: t => t.shiftKey
                };
            let oY = (() => {
                class t extends lR {
                    constructor(e) {
                        super(e)
                    }
                    supports(e) {
                        return null != t.parseEventName(e)
                    }
                    addEventListener(e, i, r) {
                        const s = t.parseEventName(i),
                            o = t.eventCallback(s.fullKey, r, this.manager.getZone());
                        return this.manager.getZone().runOutsideAngular(() => Nu().onAndCancel(e, s.domEventName, o))
                    }
                    static parseEventName(e) {
                        const i = e.toLowerCase().split("."),
                            r = i.shift();
                        if (0 === i.length || "keydown" !== r && "keyup" !== r) return null;
                        const s = t._normalizeKey(i.pop());
                        let o = "",
                            a = i.indexOf("code");
                        if (a > -1 && (i.splice(a, 1), o = "code."), mR.forEach(u => {
                                const h = i.indexOf(u);
                                h > -1 && (i.splice(h, 1), o += u + ".")
                            }), o += s, 0 != i.length || 0 === s.length) return null;
                        const c = {};
                        return c.domEventName = r, c.fullKey = o, c
                    }
                    static matchEventFullKeyCode(e, i) {
                        let r = rY[e.key] || e.key,
                            s = "";
                        return i.indexOf("code.") > -1 && (r = e.code, s = "code."), !(null == r || !r) && (r = r.toLowerCase(), " " === r ? r = "space" : "." === r && (r = "dot"), mR.forEach(o => {
                            o !== r && (0, sY[o])(e) && (s += o + ".")
                        }), s += r, s === i)
                    }
                    static eventCallback(e, i, r) {
                        return s => {
                            t.matchEventFullKeyCode(s, e) && r.runGuarded(() => i(s))
                        }
                    }
                    static _normalizeKey(e) {
                        return "esc" === e ? "escape" : e
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const yR = [{
                    provide: Bs,
                    useValue: nR
                }, {
                    provide: vP,
                    useValue: function aY() {
                        RS.makeCurrent()
                    },
                    multi: !0
                }, {
                    provide: Ss,
                    useFactory: function lY() {
                        return function r$(t) {
                            kC = t
                        }(document), document
                    },
                    deps: []
                }],
                uY = l5(FK, "browser", yR),
                dY = new nn(""),
                _R = [{
                    provide: pb,
                    useClass: class KZ {
                        addToWindow(n) {
                            Di.getAngularTestability = (i, r = !0) => {
                                const s = n.findTestabilityInTree(i, r);
                                if (null == s) throw new mt(5103, !1);
                                return s
                            }, Di.getAllAngularTestabilities = () => n.getAllTestabilities(), Di.getAllAngularRootElements = () => n.getAllRootElements(), Di.frameworkStabilizers || (Di.frameworkStabilizers = []), Di.frameworkStabilizers.push(i => {
                                const r = Di.getAllAngularTestabilities();
                                let s = r.length,
                                    o = !1;
                                const a = function(c) {
                                    o = o || c, s--, 0 == s && i(o)
                                };
                                r.forEach(c => {
                                    c.whenStable(a)
                                })
                            })
                        }
                        findTestabilityInTree(n, e, i) {
                            return null == e ? null : n.getTestability(e) ? ? (i ? Nu().isShadowRoot(e) ? this.findTestabilityInTree(n, e.host, !0) : this.findTestabilityInTree(n, e.parentElement, !0) : null)
                        }
                    },
                    deps: []
                }, {
                    provide: r5,
                    useClass: rS,
                    deps: [cr, sS, pb]
                }, {
                    provide: rS,
                    useClass: rS,
                    deps: [cr, sS, pb]
                }],
                vR = [{
                        provide: VC,
                        useValue: "root"
                    }, {
                        provide: jl,
                        useFactory: function cY() {
                            return new jl
                        },
                        deps: []
                    }, {
                        provide: BS,
                        useClass: iY,
                        multi: !0,
                        deps: [Ss, cr, Bs]
                    }, {
                        provide: BS,
                        useClass: oY,
                        multi: !0,
                        deps: [Ss]
                    }, US, uR, cR, {
                        provide: pf,
                        useExisting: US
                    }, {
                        provide: iR,
                        useClass: qZ,
                        deps: []
                    },
                    []
                ];
            let hY = (() => {
                    class t {
                        constructor(e) {}
                        static withServerTransition(e) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: Nv,
                                    useValue: e.appId
                                }]
                            }
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(dY, 12))
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({
                            providers: [...vR, ..._R],
                            imports: [mc, VK]
                        })
                    }
                    return t
                })(),
                bR = (() => {
                    class t {
                        constructor(e) {
                            this._doc = e, this._dom = Nu()
                        }
                        addTag(e, i = !1) {
                            return e ? this._getOrCreateElement(e, i) : null
                        }
                        addTags(e, i = !1) {
                            return e ? e.reduce((r, s) => (s && r.push(this._getOrCreateElement(s, i)), r), []) : []
                        }
                        getTag(e) {
                            return e && this._doc.querySelector(`meta[${e}]`) || null
                        }
                        getTags(e) {
                            if (!e) return [];
                            const i = this._doc.querySelectorAll(`meta[${e}]`);
                            return i ? [].slice.call(i) : []
                        }
                        updateTag(e, i) {
                            if (!e) return null;
                            i = i || this._parseSelector(e);
                            const r = this.getTag(i);
                            return r ? this._setMetaElementAttributes(e, r) : this._getOrCreateElement(e, !0)
                        }
                        removeTag(e) {
                            this.removeTagElement(this.getTag(e))
                        }
                        removeTagElement(e) {
                            e && this._dom.remove(e)
                        }
                        _getOrCreateElement(e, i = !1) {
                            if (!i) {
                                const o = this._parseSelector(e),
                                    a = this.getTags(o).filter(c => this._containsAttributes(e, c))[0];
                                if (void 0 !== a) return a
                            }
                            const r = this._dom.createElement("meta");
                            return this._setMetaElementAttributes(e, r), this._doc.getElementsByTagName("head")[0].appendChild(r), r
                        }
                        _setMetaElementAttributes(e, i) {
                            return Object.keys(e).forEach(r => i.setAttribute(this._getMetaKeyMap(r), e[r])), i
                        }
                        _parseSelector(e) {
                            const i = e.name ? "name" : "property";
                            return `${i}="${e[i]}"`
                        }
                        _containsAttributes(e, i) {
                            return Object.keys(e).every(r => i.getAttribute(this._getMetaKeyMap(r)) === e[r])
                        }
                        _getMetaKeyMap(e) {
                            return pY[e] || e
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(Ss))
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: function(i) {
                                let r = null;
                                return r = i ? new i : function fY() {
                                    return new bR(_t(Ss))
                                }(), r
                            },
                            providedIn: "root"
                        })
                    }
                    return t
                })();
            const pY = {
                httpEquiv: "http-equiv"
            };
            let zS = (() => {
                class t {
                    constructor(e) {
                        this._doc = e
                    }
                    getTitle() {
                        return this._doc.title
                    }
                    setTitle(e) {
                        this._doc.title = e || ""
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: function(i) {
                            let r = null;
                            return r = i ? new i : function mY() {
                                return new zS(_t(Ss))
                            }(), r
                        },
                        providedIn: "root"
                    })
                }
                return t
            })();
            typeof window < "u" && window;
            class By {}
            class bY {}
            const Hu = "*";

            function Lb(t, n) {
                return {
                    type: 7,
                    name: t,
                    definitions: n,
                    options: {}
                }
            }

            function $u(t, n = null) {
                return {
                    type: 4,
                    styles: n,
                    timings: t
                }
            }

            function TR(t, n = null) {
                return {
                    type: 2,
                    steps: t,
                    options: n
                }
            }

            function ko(t) {
                return {
                    type: 6,
                    styles: t,
                    offset: null
                }
            }

            function SR(t, n, e) {
                return {
                    type: 0,
                    name: t,
                    styles: n,
                    options: e
                }
            }

            function vm(t, n, e = null) {
                return {
                    type: 1,
                    expr: t,
                    animation: n,
                    options: e
                }
            }
            class Ny {
                constructor(n = 0, e = 0) {
                    this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = n + e
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = [])
                }
                onStart(n) {
                    this._originalOnStartFns.push(n), this._onStartFns.push(n)
                }
                onDone(n) {
                    this._originalOnDoneFns.push(n), this._onDoneFns.push(n)
                }
                onDestroy(n) {
                    this._onDestroyFns.push(n)
                }
                hasStarted() {
                    return this._started
                }
                init() {}
                play() {
                    this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0
                }
                triggerMicrotask() {
                    queueMicrotask(() => this._onFinish())
                }
                _onStart() {
                    this._onStartFns.forEach(n => n()), this._onStartFns = []
                }
                pause() {}
                restart() {}
                finish() {
                    this._onFinish()
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = [])
                }
                reset() {
                    this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
                }
                setPosition(n) {
                    this._position = this.totalTime ? n * this.totalTime : 1
                }
                getPosition() {
                    return this.totalTime ? this._position / this.totalTime : 1
                }
                triggerCallback(n) {
                    const e = "start" == n ? this._onStartFns : this._onDoneFns;
                    e.forEach(i => i()), e.length = 0
                }
            }
            class ER {
                constructor(n) {
                    this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = n;
                    let e = 0,
                        i = 0,
                        r = 0;
                    const s = this.players.length;
                    0 == s ? queueMicrotask(() => this._onFinish()) : this.players.forEach(o => {
                        o.onDone(() => {
                            ++e == s && this._onFinish()
                        }), o.onDestroy(() => {
                            ++i == s && this._onDestroy()
                        }), o.onStart(() => {
                            ++r == s && this._onStart()
                        })
                    }), this.totalTime = this.players.reduce((o, a) => Math.max(o, a.totalTime), 0)
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = [])
                }
                init() {
                    this.players.forEach(n => n.init())
                }
                onStart(n) {
                    this._onStartFns.push(n)
                }
                _onStart() {
                    this.hasStarted() || (this._started = !0, this._onStartFns.forEach(n => n()), this._onStartFns = [])
                }
                onDone(n) {
                    this._onDoneFns.push(n)
                }
                onDestroy(n) {
                    this._onDestroyFns.push(n)
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this.parentPlayer || this.init(), this._onStart(), this.players.forEach(n => n.play())
                }
                pause() {
                    this.players.forEach(n => n.pause())
                }
                restart() {
                    this.players.forEach(n => n.restart())
                }
                finish() {
                    this._onFinish(), this.players.forEach(n => n.finish())
                }
                destroy() {
                    this._onDestroy()
                }
                _onDestroy() {
                    this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(n => n.destroy()), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = [])
                }
                reset() {
                    this.players.forEach(n => n.reset()), this._destroyed = !1, this._finished = !1, this._started = !1
                }
                setPosition(n) {
                    const e = n * this.totalTime;
                    this.players.forEach(i => {
                        const r = i.totalTime ? Math.min(1, e / i.totalTime) : 1;
                        i.setPosition(r)
                    })
                }
                getPosition() {
                    const n = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null);
                    return null != n ? n.getPosition() : 0
                }
                beforeDestroy() {
                    this.players.forEach(n => {
                        n.beforeDestroy && n.beforeDestroy()
                    })
                }
                triggerCallback(n) {
                    const e = "start" == n ? this._onStartFns : this._onDoneFns;
                    e.forEach(i => i()), e.length = 0
                }
            }

            function DR(t) {
                return new mt(3e3, !1)
            }

            function th(t) {
                switch (t.length) {
                    case 0:
                        return new Ny;
                    case 1:
                        return t[0];
                    default:
                        return new ER(t)
                }
            }

            function AR(t, n, e = new Map, i = new Map) {
                const r = [],
                    s = [];
                let o = -1,
                    a = null;
                if (n.forEach(c => {
                        const u = c.get("offset"),
                            h = u == o,
                            m = h && a || new Map;
                        c.forEach((x, D) => {
                            let V = D,
                                te = x;
                            if ("offset" !== D) switch (V = t.normalizePropertyName(V, r), te) {
                                case "!":
                                    te = e.get(D);
                                    break;
                                case Hu:
                                    te = i.get(D);
                                    break;
                                default:
                                    te = t.normalizeStyleValue(D, V, te, r)
                            }
                            m.set(V, te)
                        }), h || s.push(m), a = m, o = u
                    }), r.length) throw function zY(t) {
                    return new mt(3502, !1)
                }();
                return s
            }

            function GS(t, n, e, i) {
                switch (n) {
                    case "start":
                        t.onStart(() => i(e && KS(e, "start", t)));
                        break;
                    case "done":
                        t.onDone(() => i(e && KS(e, "done", t)));
                        break;
                    case "destroy":
                        t.onDestroy(() => i(e && KS(e, "destroy", t)))
                }
            }

            function KS(t, n, e) {
                const s = qS(t.element, t.triggerName, t.fromState, t.toState, n || t.phaseName, e.totalTime ? ? t.totalTime, !!e.disabled),
                    o = t._data;
                return null != o && (s._data = o), s
            }

            function qS(t, n, e, i, r = "", s = 0, o) {
                return {
                    element: t,
                    triggerName: n,
                    fromState: e,
                    toState: i,
                    phaseName: r,
                    totalTime: s,
                    disabled: !!o
                }
            }

            function yc(t, n, e) {
                let i = t.get(n);
                return i || t.set(n, i = e), i
            }

            function kR(t) {
                const n = t.indexOf(":");
                return [t.substring(1, n), t.slice(n + 1)]
            }
            const tX = (() => typeof document > "u" ? null : document.documentElement)();

            function ZS(t) {
                const n = t.parentNode || t.host || null;
                return n === tX ? null : n
            }
            let wf = null,
                MR = !1;

            function IR(t, n) {
                for (; n;) {
                    if (n === t) return !0;
                    n = ZS(n)
                }
                return !1
            }

            function PR(t, n, e) {
                if (e) return Array.from(t.querySelectorAll(n));
                const i = t.querySelector(n);
                return i ? [i] : []
            }
            let OR = (() => {
                    class t {
                        validateStyleProperty(e) {
                            return function iX(t) {
                                wf || (wf = function rX() {
                                    return typeof document < "u" ? document.body : null
                                }() || {}, MR = !!wf.style && "WebkitAppearance" in wf.style);
                                let n = !0;
                                return wf.style && ! function nX(t) {
                                    return "ebkit" == t.substring(1, 6)
                                }(t) && (n = t in wf.style, !n && MR && (n = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in wf.style)), n
                            }(e)
                        }
                        matchesElement(e, i) {
                            return !1
                        }
                        containsElement(e, i) {
                            return IR(e, i)
                        }
                        getParentElement(e) {
                            return ZS(e)
                        }
                        query(e, i, r) {
                            return PR(e, i, r)
                        }
                        computeStyle(e, i, r) {
                            return r || ""
                        }
                        animate(e, i, r, s, o, a = [], c) {
                            return new Ny(r, s)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                YS = (() => {
                    class t {
                        static# e = this.NOOP = new OR
                    }
                    return t
                })();
            const sX = 1e3,
                XS = "ng-enter",
                Rb = "ng-leave",
                Bb = "ng-trigger",
                Nb = ".ng-trigger",
                RR = "ng-animating",
                QS = ".ng-animating";

            function zu(t) {
                if ("number" == typeof t) return t;
                const n = t.match(/^(-?[\.\d]+)(m?s)/);
                return !n || n.length < 2 ? 0 : JS(parseFloat(n[1]), n[2])
            }

            function JS(t, n) {
                return "s" === n ? t * sX : t
            }

            function Fb(t, n, e) {
                return t.hasOwnProperty("duration") ? t : function aX(t, n, e) {
                    let r, s = 0,
                        o = "";
                    if ("string" == typeof t) {
                        const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);
                        if (null === a) return n.push(DR()), {
                            duration: 0,
                            delay: 0,
                            easing: ""
                        };
                        r = JS(parseFloat(a[1]), a[2]);
                        const c = a[3];
                        null != c && (s = JS(parseFloat(c), a[4]));
                        const u = a[5];
                        u && (o = u)
                    } else r = t;
                    if (!e) {
                        let a = !1,
                            c = n.length;
                        r < 0 && (n.push(function wY() {
                            return new mt(3100, !1)
                        }()), a = !0), s < 0 && (n.push(function xY() {
                            return new mt(3101, !1)
                        }()), a = !0), a && n.splice(c, 0, DR())
                    }
                    return {
                        duration: r,
                        delay: s,
                        easing: o
                    }
                }(t, n, e)
            }

            function Fy(t, n = {}) {
                return Object.keys(t).forEach(e => {
                    n[e] = t[e]
                }), n
            }

            function BR(t) {
                const n = new Map;
                return Object.keys(t).forEach(e => {
                    n.set(e, t[e])
                }), n
            }

            function nh(t, n = new Map, e) {
                if (e)
                    for (let [i, r] of e) n.set(i, r);
                for (let [i, r] of t) n.set(i, r);
                return n
            }

            function Ql(t, n, e) {
                n.forEach((i, r) => {
                    const s = t2(r);
                    e && !e.has(r) && e.set(r, t.style[s]), t.style[s] = i
                })
            }

            function xf(t, n) {
                n.forEach((e, i) => {
                    const r = t2(i);
                    t.style[r] = ""
                })
            }

            function Vy(t) {
                return Array.isArray(t) ? 1 == t.length ? t[0] : TR(t) : t
            }
            const e2 = new RegExp("{{\\s*(.+?)\\s*}}", "g");

            function FR(t) {
                let n = [];
                if ("string" == typeof t) {
                    let e;
                    for (; e = e2.exec(t);) n.push(e[1]);
                    e2.lastIndex = 0
                }
                return n
            }

            function Uy(t, n, e) {
                const i = t.toString(),
                    r = i.replace(e2, (s, o) => {
                        let a = n[o];
                        return null == a && (e.push(function TY(t) {
                            return new mt(3003, !1)
                        }()), a = ""), a.toString()
                    });
                return r == i ? t : r
            }

            function Vb(t) {
                const n = [];
                let e = t.next();
                for (; !e.done;) n.push(e.value), e = t.next();
                return n
            }
            const uX = /-+([a-z0-9])/g;

            function t2(t) {
                return t.replace(uX, (...n) => n[1].toUpperCase())
            }

            function _c(t, n, e) {
                switch (n.type) {
                    case 7:
                        return t.visitTrigger(n, e);
                    case 0:
                        return t.visitState(n, e);
                    case 1:
                        return t.visitTransition(n, e);
                    case 2:
                        return t.visitSequence(n, e);
                    case 3:
                        return t.visitGroup(n, e);
                    case 4:
                        return t.visitAnimate(n, e);
                    case 5:
                        return t.visitKeyframes(n, e);
                    case 6:
                        return t.visitStyle(n, e);
                    case 8:
                        return t.visitReference(n, e);
                    case 9:
                        return t.visitAnimateChild(n, e);
                    case 10:
                        return t.visitAnimateRef(n, e);
                    case 11:
                        return t.visitQuery(n, e);
                    case 12:
                        return t.visitStagger(n, e);
                    default:
                        throw function SY(t) {
                            return new mt(3004, !1)
                        }()
                }
            }

            function VR(t, n) {
                return window.getComputedStyle(t)[n]
            }
            const Ub = "*";

            function fX(t, n) {
                const e = [];
                return "string" == typeof t ? t.split(/\s*,\s*/).forEach(i => function pX(t, n, e) {
                    if (":" == t[0]) {
                        const c = function mX(t, n) {
                            switch (t) {
                                case ":enter":
                                    return "void => *";
                                case ":leave":
                                    return "* => void";
                                case ":increment":
                                    return (e, i) => parseFloat(i) > parseFloat(e);
                                case ":decrement":
                                    return (e, i) => parseFloat(i) < parseFloat(e);
                                default:
                                    return n.push(function VY(t) {
                                        return new mt(3016, !1)
                                    }()), "* => *"
                            }
                        }(t, e);
                        if ("function" == typeof c) return void n.push(c);
                        t = c
                    }
                    const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                    if (null == i || i.length < 4) return e.push(function FY(t) {
                        return new mt(3015, !1)
                    }()), n;
                    const r = i[1],
                        s = i[2],
                        o = i[3];
                    n.push(UR(r, o));
                    "<" == s[0] && !(r == Ub && o == Ub) && n.push(UR(o, r))
                }(i, e, n)) : e.push(t), e
            }
            const Hb = new Set(["true", "1"]),
                $b = new Set(["false", "0"]);

            function UR(t, n) {
                const e = Hb.has(t) || $b.has(t),
                    i = Hb.has(n) || $b.has(n);
                return (r, s) => {
                    let o = t == Ub || t == r,
                        a = n == Ub || n == s;
                    return !o && e && "boolean" == typeof r && (o = r ? Hb.has(t) : $b.has(t)), !a && i && "boolean" == typeof s && (a = s ? Hb.has(n) : $b.has(n)), o && a
                }
            }
            const gX = new RegExp("s*:selfs*,?", "g");

            function n2(t, n, e, i) {
                return new yX(t).build(n, e, i)
            }
            class yX {
                constructor(n) {
                    this._driver = n
                }
                build(n, e, i) {
                    const r = new bX(e);
                    return this._resetContextStyleTimingState(r), _c(this, Vy(n), r)
                }
                _resetContextStyleTimingState(n) {
                    n.currentQuerySelector = "", n.collectedStyles = new Map, n.collectedStyles.set("", new Map), n.currentTime = 0
                }
                visitTrigger(n, e) {
                    let i = e.queryCount = 0,
                        r = e.depCount = 0;
                    const s = [],
                        o = [];
                    return "@" == n.name.charAt(0) && e.errors.push(function DY() {
                        return new mt(3006, !1)
                    }()), n.definitions.forEach(a => {
                        if (this._resetContextStyleTimingState(e), 0 == a.type) {
                            const c = a,
                                u = c.name;
                            u.toString().split(/\s*,\s*/).forEach(h => {
                                c.name = h, s.push(this.visitState(c, e))
                            }), c.name = u
                        } else if (1 == a.type) {
                            const c = this.visitTransition(a, e);
                            i += c.queryCount, r += c.depCount, o.push(c)
                        } else e.errors.push(function AY() {
                            return new mt(3007, !1)
                        }())
                    }), {
                        type: 7,
                        name: n.name,
                        states: s,
                        transitions: o,
                        queryCount: i,
                        depCount: r,
                        options: null
                    }
                }
                visitState(n, e) {
                    const i = this.visitStyle(n.styles, e),
                        r = n.options && n.options.params || null;
                    if (i.containsDynamicStyles) {
                        const s = new Set,
                            o = r || {};
                        i.styles.forEach(a => {
                            a instanceof Map && a.forEach(c => {
                                FR(c).forEach(u => {
                                    o.hasOwnProperty(u) || s.add(u)
                                })
                            })
                        }), s.size && (Vb(s.values()), e.errors.push(function kY(t, n) {
                            return new mt(3008, !1)
                        }()))
                    }
                    return {
                        type: 0,
                        name: n.name,
                        style: i,
                        options: r ? {
                            params: r
                        } : null
                    }
                }
                visitTransition(n, e) {
                    e.queryCount = 0, e.depCount = 0;
                    const i = _c(this, Vy(n.animation), e);
                    return {
                        type: 1,
                        matchers: fX(n.expr, e.errors),
                        animation: i,
                        queryCount: e.queryCount,
                        depCount: e.depCount,
                        options: Cf(n.options)
                    }
                }
                visitSequence(n, e) {
                    return {
                        type: 2,
                        steps: n.steps.map(i => _c(this, i, e)),
                        options: Cf(n.options)
                    }
                }
                visitGroup(n, e) {
                    const i = e.currentTime;
                    let r = 0;
                    const s = n.steps.map(o => {
                        e.currentTime = i;
                        const a = _c(this, o, e);
                        return r = Math.max(r, e.currentTime), a
                    });
                    return e.currentTime = r, {
                        type: 3,
                        steps: s,
                        options: Cf(n.options)
                    }
                }
                visitAnimate(n, e) {
                    const i = function xX(t, n) {
                        if (t.hasOwnProperty("duration")) return t;
                        if ("number" == typeof t) return r2(Fb(t, n).duration, 0, "");
                        const e = t;
                        if (e.split(/\s+/).some(s => "{" == s.charAt(0) && "{" == s.charAt(1))) {
                            const s = r2(0, 0, "");
                            return s.dynamic = !0, s.strValue = e, s
                        }
                        const r = Fb(e, n);
                        return r2(r.duration, r.delay, r.easing)
                    }(n.timings, e.errors);
                    e.currentAnimateTimings = i;
                    let r, s = n.styles ? n.styles : ko({});
                    if (5 == s.type) r = this.visitKeyframes(s, e);
                    else {
                        let o = n.styles,
                            a = !1;
                        if (!o) {
                            a = !0;
                            const u = {};
                            i.easing && (u.easing = i.easing), o = ko(u)
                        }
                        e.currentTime += i.duration + i.delay;
                        const c = this.visitStyle(o, e);
                        c.isEmptyStep = a, r = c
                    }
                    return e.currentAnimateTimings = null, {
                        type: 4,
                        timings: i,
                        style: r,
                        options: null
                    }
                }
                visitStyle(n, e) {
                    const i = this._makeStyleAst(n, e);
                    return this._validateStyleAst(i, e), i
                }
                _makeStyleAst(n, e) {
                    const i = [],
                        r = Array.isArray(n.styles) ? n.styles : [n.styles];
                    for (let a of r) "string" == typeof a ? a === Hu ? i.push(a) : e.errors.push(new mt(3002, !1)) : i.push(BR(a));
                    let s = !1,
                        o = null;
                    return i.forEach(a => {
                        if (a instanceof Map && (a.has("easing") && (o = a.get("easing"), a.delete("easing")), !s))
                            for (let c of a.values())
                                if (c.toString().indexOf("{{") >= 0) {
                                    s = !0;
                                    break
                                }
                    }), {
                        type: 6,
                        styles: i,
                        easing: o,
                        offset: n.offset,
                        containsDynamicStyles: s,
                        options: null
                    }
                }
                _validateStyleAst(n, e) {
                    const i = e.currentAnimateTimings;
                    let r = e.currentTime,
                        s = e.currentTime;
                    i && s > 0 && (s -= i.duration + i.delay), n.styles.forEach(o => {
                        "string" != typeof o && o.forEach((a, c) => {
                            const u = e.collectedStyles.get(e.currentQuerySelector),
                                h = u.get(c);
                            let m = !0;
                            h && (s != r && s >= h.startTime && r <= h.endTime && (e.errors.push(function IY(t, n, e, i, r) {
                                return new mt(3010, !1)
                            }()), m = !1), s = h.startTime), m && u.set(c, {
                                startTime: s,
                                endTime: r
                            }), e.options && function lX(t, n, e) {
                                const i = n.params || {},
                                    r = FR(t);
                                r.length && r.forEach(s => {
                                    i.hasOwnProperty(s) || e.push(function CY(t) {
                                        return new mt(3001, !1)
                                    }())
                                })
                            }(a, e.options, e.errors)
                        })
                    })
                }
                visitKeyframes(n, e) {
                    const i = {
                        type: 5,
                        styles: [],
                        options: null
                    };
                    if (!e.currentAnimateTimings) return e.errors.push(function PY() {
                        return new mt(3011, !1)
                    }()), i;
                    let s = 0;
                    const o = [];
                    let a = !1,
                        c = !1,
                        u = 0;
                    const h = n.steps.map(_e => {
                        const ye = this._makeStyleAst(_e, e);
                        let Be = null != ye.offset ? ye.offset : function wX(t) {
                                if ("string" == typeof t) return null;
                                let n = null;
                                if (Array.isArray(t)) t.forEach(e => {
                                    if (e instanceof Map && e.has("offset")) {
                                        const i = e;
                                        n = parseFloat(i.get("offset")), i.delete("offset")
                                    }
                                });
                                else if (t instanceof Map && t.has("offset")) {
                                    const e = t;
                                    n = parseFloat(e.get("offset")), e.delete("offset")
                                }
                                return n
                            }(ye.styles),
                            ze = 0;
                        return null != Be && (s++, ze = ye.offset = Be), c = c || ze < 0 || ze > 1, a = a || ze < u, u = ze, o.push(ze), ye
                    });
                    c && e.errors.push(function OY() {
                        return new mt(3012, !1)
                    }()), a && e.errors.push(function LY() {
                        return new mt(3200, !1)
                    }());
                    const m = n.steps.length;
                    let x = 0;
                    s > 0 && s < m ? e.errors.push(function RY() {
                        return new mt(3202, !1)
                    }()) : 0 == s && (x = 1 / (m - 1));
                    const D = m - 1,
                        V = e.currentTime,
                        te = e.currentAnimateTimings,
                        ee = te.duration;
                    return h.forEach((_e, ye) => {
                        const Be = x > 0 ? ye == D ? 1 : x * ye : o[ye],
                            ze = Be * ee;
                        e.currentTime = V + te.delay + ze, te.duration = ze, this._validateStyleAst(_e, e), _e.offset = Be, i.styles.push(_e)
                    }), i
                }
                visitReference(n, e) {
                    return {
                        type: 8,
                        animation: _c(this, Vy(n.animation), e),
                        options: Cf(n.options)
                    }
                }
                visitAnimateChild(n, e) {
                    return e.depCount++, {
                        type: 9,
                        options: Cf(n.options)
                    }
                }
                visitAnimateRef(n, e) {
                    return {
                        type: 10,
                        animation: this.visitReference(n.animation, e),
                        options: Cf(n.options)
                    }
                }
                visitQuery(n, e) {
                    const i = e.currentQuerySelector,
                        r = n.options || {};
                    e.queryCount++, e.currentQuery = n;
                    const [s, o] = function _X(t) {
                        const n = !!t.split(/\s*,\s*/).find(e => ":self" == e);
                        return n && (t = t.replace(gX, "")), t = t.replace(/@\*/g, Nb).replace(/@\w+/g, e => Nb + "-" + e.slice(1)).replace(/:animating/g, QS), [t, n]
                    }(n.selector);
                    e.currentQuerySelector = i.length ? i + " " + s : s, yc(e.collectedStyles, e.currentQuerySelector, new Map);
                    const a = _c(this, Vy(n.animation), e);
                    return e.currentQuery = null, e.currentQuerySelector = i, {
                        type: 11,
                        selector: s,
                        limit: r.limit || 0,
                        optional: !!r.optional,
                        includeSelf: o,
                        animation: a,
                        originalSelector: n.selector,
                        options: Cf(n.options)
                    }
                }
                visitStagger(n, e) {
                    e.currentQuery || e.errors.push(function BY() {
                        return new mt(3013, !1)
                    }());
                    const i = "full" === n.timings ? {
                        duration: 0,
                        delay: 0,
                        easing: "full"
                    } : Fb(n.timings, e.errors, !0);
                    return {
                        type: 12,
                        animation: _c(this, Vy(n.animation), e),
                        timings: i,
                        options: null
                    }
                }
            }
            class bX {
                constructor(n) {
                    this.errors = n, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set
                }
            }

            function Cf(t) {
                return t ? (t = Fy(t)).params && (t.params = function vX(t) {
                    return t ? Fy(t) : null
                }(t.params)) : t = {}, t
            }

            function r2(t, n, e) {
                return {
                    duration: t,
                    delay: n,
                    easing: e
                }
            }

            function s2(t, n, e, i, r, s, o = null, a = !1) {
                return {
                    type: 1,
                    element: t,
                    keyframes: n,
                    preStyleProps: e,
                    postStyleProps: i,
                    duration: r,
                    delay: s,
                    totalTime: r + s,
                    easing: o,
                    subTimeline: a
                }
            }
            class zb {
                constructor() {
                    this._map = new Map
                }
                get(n) {
                    return this._map.get(n) || []
                }
                append(n, e) {
                    let i = this._map.get(n);
                    i || this._map.set(n, i = []), i.push(...e)
                }
                has(n) {
                    return this._map.has(n)
                }
                clear() {
                    this._map.clear()
                }
            }
            const SX = new RegExp(":enter", "g"),
                DX = new RegExp(":leave", "g");

            function o2(t, n, e, i, r, s = new Map, o = new Map, a, c, u = []) {
                return (new AX).buildKeyframes(t, n, e, i, r, s, o, a, c, u)
            }
            class AX {
                buildKeyframes(n, e, i, r, s, o, a, c, u, h = []) {
                    u = u || new zb;
                    const m = new a2(n, e, u, r, s, h, []);
                    m.options = c;
                    const x = c.delay ? zu(c.delay) : 0;
                    m.currentTimeline.delayNextStep(x), m.currentTimeline.setStyles([o], null, m.errors, c), _c(this, i, m);
                    const D = m.timelines.filter(V => V.containsAnimation());
                    if (D.length && a.size) {
                        let V;
                        for (let te = D.length - 1; te >= 0; te--) {
                            const ee = D[te];
                            if (ee.element === e) {
                                V = ee;
                                break
                            }
                        }
                        V && !V.allowOnlyTimelineStyles() && V.setStyles([a], null, m.errors, c)
                    }
                    return D.length ? D.map(V => V.buildKeyframes()) : [s2(e, [], [], [], 0, x, "", !1)]
                }
                visitTrigger(n, e) {}
                visitState(n, e) {}
                visitTransition(n, e) {}
                visitAnimateChild(n, e) {
                    const i = e.subInstructions.get(e.element);
                    if (i) {
                        const r = e.createSubContext(n.options),
                            s = e.currentTimeline.currentTime,
                            o = this._visitSubInstructions(i, r, r.options);
                        s != o && e.transformIntoNewTimeline(o)
                    }
                    e.previousNode = n
                }
                visitAnimateRef(n, e) {
                    const i = e.createSubContext(n.options);
                    i.transformIntoNewTimeline(), this._applyAnimationRefDelays([n.options, n.animation.options], e, i), this.visitReference(n.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = n
                }
                _applyAnimationRefDelays(n, e, i) {
                    for (const r of n) {
                        const s = r ? .delay;
                        if (s) {
                            const o = "number" == typeof s ? s : zu(Uy(s, r ? .params ? ? {}, e.errors));
                            i.delayNextStep(o)
                        }
                    }
                }
                _visitSubInstructions(n, e, i) {
                    let s = e.currentTimeline.currentTime;
                    const o = null != i.duration ? zu(i.duration) : null,
                        a = null != i.delay ? zu(i.delay) : null;
                    return 0 !== o && n.forEach(c => {
                        const u = e.appendInstructionToTimeline(c, o, a);
                        s = Math.max(s, u.duration + u.delay)
                    }), s
                }
                visitReference(n, e) {
                    e.updateOptions(n.options, !0), _c(this, n.animation, e), e.previousNode = n
                }
                visitSequence(n, e) {
                    const i = e.subContextCount;
                    let r = e;
                    const s = n.options;
                    if (s && (s.params || s.delay) && (r = e.createSubContext(s), r.transformIntoNewTimeline(), null != s.delay)) {
                        6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = jb);
                        const o = zu(s.delay);
                        r.delayNextStep(o)
                    }
                    n.steps.length && (n.steps.forEach(o => _c(this, o, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > i && r.transformIntoNewTimeline()), e.previousNode = n
                }
                visitGroup(n, e) {
                    const i = [];
                    let r = e.currentTimeline.currentTime;
                    const s = n.options && n.options.delay ? zu(n.options.delay) : 0;
                    n.steps.forEach(o => {
                        const a = e.createSubContext(n.options);
                        s && a.delayNextStep(s), _c(this, o, a), r = Math.max(r, a.currentTimeline.currentTime), i.push(a.currentTimeline)
                    }), i.forEach(o => e.currentTimeline.mergeTimelineCollectedStyles(o)), e.transformIntoNewTimeline(r), e.previousNode = n
                }
                _visitTiming(n, e) {
                    if (n.dynamic) {
                        const i = n.strValue;
                        return Fb(e.params ? Uy(i, e.params, e.errors) : i, e.errors)
                    }
                    return {
                        duration: n.duration,
                        delay: n.delay,
                        easing: n.easing
                    }
                }
                visitAnimate(n, e) {
                    const i = e.currentAnimateTimings = this._visitTiming(n.timings, e),
                        r = e.currentTimeline;
                    i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles());
                    const s = n.style;
                    5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(i.duration), this.visitStyle(s, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = n
                }
                visitStyle(n, e) {
                    const i = e.currentTimeline,
                        r = e.currentAnimateTimings;
                    !r && i.hasCurrentStyleProperties() && i.forwardFrame();
                    const s = r && r.easing || n.easing;
                    n.isEmptyStep ? i.applyEmptyStep(s) : i.setStyles(n.styles, s, e.errors, e.options), e.previousNode = n
                }
                visitKeyframes(n, e) {
                    const i = e.currentAnimateTimings,
                        r = e.currentTimeline.duration,
                        s = i.duration,
                        a = e.createSubContext().currentTimeline;
                    a.easing = i.easing, n.styles.forEach(c => {
                        a.forwardTime((c.offset || 0) * s), a.setStyles(c.styles, c.easing, e.errors, e.options), a.applyStylesToKeyframe()
                    }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(r + s), e.previousNode = n
                }
                visitQuery(n, e) {
                    const i = e.currentTimeline.currentTime,
                        r = n.options || {},
                        s = r.delay ? zu(r.delay) : 0;
                    s && (6 === e.previousNode.type || 0 == i && e.currentTimeline.hasCurrentStyleProperties()) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = jb);
                    let o = i;
                    const a = e.invokeQuery(n.selector, n.originalSelector, n.limit, n.includeSelf, !!r.optional, e.errors);
                    e.currentQueryTotal = a.length;
                    let c = null;
                    a.forEach((u, h) => {
                        e.currentQueryIndex = h;
                        const m = e.createSubContext(n.options, u);
                        s && m.delayNextStep(s), u === e.element && (c = m.currentTimeline), _c(this, n.animation, m), m.currentTimeline.applyStylesToKeyframe(), o = Math.max(o, m.currentTimeline.currentTime)
                    }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(o), c && (e.currentTimeline.mergeTimelineCollectedStyles(c), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = n
                }
                visitStagger(n, e) {
                    const i = e.parentContext,
                        r = e.currentTimeline,
                        s = n.timings,
                        o = Math.abs(s.duration),
                        a = o * (e.currentQueryTotal - 1);
                    let c = o * e.currentQueryIndex;
                    switch (s.duration < 0 ? "reverse" : s.easing) {
                        case "reverse":
                            c = a - c;
                            break;
                        case "full":
                            c = i.currentStaggerTime
                    }
                    const h = e.currentTimeline;
                    c && h.delayNextStep(c);
                    const m = h.currentTime;
                    _c(this, n.animation, e), e.previousNode = n, i.currentStaggerTime = r.currentTime - m + (r.startTime - i.currentTimeline.startTime)
                }
            }
            const jb = {};
            class a2 {
                constructor(n, e, i, r, s, o, a, c) {
                    this._driver = n, this.element = e, this.subInstructions = i, this._enterClassName = r, this._leaveClassName = s, this.errors = o, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = jb, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = c || new Wb(this._driver, e, 0), a.push(this.currentTimeline)
                }
                get params() {
                    return this.options.params
                }
                updateOptions(n, e) {
                    if (!n) return;
                    const i = n;
                    let r = this.options;
                    null != i.duration && (r.duration = zu(i.duration)), null != i.delay && (r.delay = zu(i.delay));
                    const s = i.params;
                    if (s) {
                        let o = r.params;
                        o || (o = this.options.params = {}), Object.keys(s).forEach(a => {
                            (!e || !o.hasOwnProperty(a)) && (o[a] = Uy(s[a], o, this.errors))
                        })
                    }
                }
                _copyOptions() {
                    const n = {};
                    if (this.options) {
                        const e = this.options.params;
                        if (e) {
                            const i = n.params = {};
                            Object.keys(e).forEach(r => {
                                i[r] = e[r]
                            })
                        }
                    }
                    return n
                }
                createSubContext(n = null, e, i) {
                    const r = e || this.element,
                        s = new a2(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, i || 0));
                    return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(n), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s
                }
                transformIntoNewTimeline(n) {
                    return this.previousNode = jb, this.currentTimeline = this.currentTimeline.fork(this.element, n), this.timelines.push(this.currentTimeline), this.currentTimeline
                }
                appendInstructionToTimeline(n, e, i) {
                    const r = {
                            duration: e ? ? n.duration,
                            delay: this.currentTimeline.currentTime + (i ? ? 0) + n.delay,
                            easing: ""
                        },
                        s = new kX(this._driver, n.element, n.keyframes, n.preStyleProps, n.postStyleProps, r, n.stretchStartingKeyframe);
                    return this.timelines.push(s), r
                }
                incrementTime(n) {
                    this.currentTimeline.forwardTime(this.currentTimeline.duration + n)
                }
                delayNextStep(n) {
                    n > 0 && this.currentTimeline.delayNextStep(n)
                }
                invokeQuery(n, e, i, r, s, o) {
                    let a = [];
                    if (r && a.push(this.element), n.length > 0) {
                        n = (n = n.replace(SX, "." + this._enterClassName)).replace(DX, "." + this._leaveClassName);
                        let u = this._driver.query(this.element, n, 1 != i);
                        0 !== i && (u = i < 0 ? u.slice(u.length + i, u.length) : u.slice(0, i)), a.push(...u)
                    }
                    return !s && 0 == a.length && o.push(function NY(t) {
                        return new mt(3014, !1)
                    }()), a
                }
            }
            class Wb {
                constructor(n, e, i, r) {
                    this._driver = n, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = r, this.duration = 0, this.easing = null, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe()
                }
                containsAnimation() {
                    switch (this._keyframes.size) {
                        case 0:
                            return !1;
                        case 1:
                            return this.hasCurrentStyleProperties();
                        default:
                            return !0
                    }
                }
                hasCurrentStyleProperties() {
                    return this._currentKeyframe.size > 0
                }
                get currentTime() {
                    return this.startTime + this.duration
                }
                delayNextStep(n) {
                    const e = 1 === this._keyframes.size && this._pendingStyles.size;
                    this.duration || e ? (this.forwardTime(this.currentTime + n), e && this.snapshotCurrentStyles()) : this.startTime += n
                }
                fork(n, e) {
                    return this.applyStylesToKeyframe(), new Wb(this._driver, n, e || this.currentTime, this._elementTimelineStylesLookup)
                }
                _loadKeyframe() {
                    this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe))
                }
                forwardFrame() {
                    this.duration += 1, this._loadKeyframe()
                }
                forwardTime(n) {
                    this.applyStylesToKeyframe(), this.duration = n, this._loadKeyframe()
                }
                _updateStyle(n, e) {
                    this._localTimelineStyles.set(n, e), this._globalTimelineStyles.set(n, e), this._styleSummary.set(n, {
                        time: this.currentTime,
                        value: e
                    })
                }
                allowOnlyTimelineStyles() {
                    return this._currentEmptyStepKeyframe !== this._currentKeyframe
                }
                applyEmptyStep(n) {
                    n && this._previousKeyframe.set("easing", n);
                    for (let [e, i] of this._globalTimelineStyles) this._backFill.set(e, i || Hu), this._currentKeyframe.set(e, Hu);
                    this._currentEmptyStepKeyframe = this._currentKeyframe
                }
                setStyles(n, e, i, r) {
                    e && this._previousKeyframe.set("easing", e);
                    const s = r && r.params || {},
                        o = function MX(t, n) {
                            const e = new Map;
                            let i;
                            return t.forEach(r => {
                                if ("*" === r) {
                                    i = i || n.keys();
                                    for (let s of i) e.set(s, Hu)
                                } else nh(r, e)
                            }), e
                        }(n, this._globalTimelineStyles);
                    for (let [a, c] of o) {
                        const u = Uy(c, s, i);
                        this._pendingStyles.set(a, u), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ? ? Hu), this._updateStyle(a, u)
                    }
                }
                applyStylesToKeyframe() {
                    0 != this._pendingStyles.size && (this._pendingStyles.forEach((n, e) => {
                        this._currentKeyframe.set(e, n)
                    }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((n, e) => {
                        this._currentKeyframe.has(e) || this._currentKeyframe.set(e, n)
                    }))
                }
                snapshotCurrentStyles() {
                    for (let [n, e] of this._localTimelineStyles) this._pendingStyles.set(n, e), this._updateStyle(n, e)
                }
                getFinalKeyframe() {
                    return this._keyframes.get(this.duration)
                }
                get properties() {
                    const n = [];
                    for (let e in this._currentKeyframe) n.push(e);
                    return n
                }
                mergeTimelineCollectedStyles(n) {
                    n._styleSummary.forEach((e, i) => {
                        const r = this._styleSummary.get(i);
                        (!r || e.time > r.time) && this._updateStyle(i, e.value)
                    })
                }
                buildKeyframes() {
                    this.applyStylesToKeyframe();
                    const n = new Set,
                        e = new Set,
                        i = 1 === this._keyframes.size && 0 === this.duration;
                    let r = [];
                    this._keyframes.forEach((a, c) => {
                        const u = nh(a, new Map, this._backFill);
                        u.forEach((h, m) => {
                            "!" === h ? n.add(m) : h === Hu && e.add(m)
                        }), i || u.set("offset", c / this.duration), r.push(u)
                    });
                    const s = n.size ? Vb(n.values()) : [],
                        o = e.size ? Vb(e.values()) : [];
                    if (i) {
                        const a = r[0],
                            c = new Map(a);
                        a.set("offset", 0), c.set("offset", 1), r = [a, c]
                    }
                    return s2(this.element, r, s, o, this.duration, this.startTime, this.easing, !1)
                }
            }
            class kX extends Wb {
                constructor(n, e, i, r, s, o, a = !1) {
                    super(n, e, o.delay), this.keyframes = i, this.preStyleProps = r, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = {
                        duration: o.duration,
                        delay: o.delay,
                        easing: o.easing
                    }
                }
                containsAnimation() {
                    return this.keyframes.length > 1
                }
                buildKeyframes() {
                    let n = this.keyframes,
                        {
                            delay: e,
                            duration: i,
                            easing: r
                        } = this.timings;
                    if (this._stretchStartingKeyframe && e) {
                        const s = [],
                            o = i + e,
                            a = e / o,
                            c = nh(n[0]);
                        c.set("offset", 0), s.push(c);
                        const u = nh(n[0]);
                        u.set("offset", zR(a)), s.push(u);
                        const h = n.length - 1;
                        for (let m = 1; m <= h; m++) {
                            let x = nh(n[m]);
                            const D = x.get("offset");
                            x.set("offset", zR((e + D * i) / o)), s.push(x)
                        }
                        i = o, e = 0, r = "", n = s
                    }
                    return s2(this.element, n, this.preStyleProps, this.postStyleProps, i, e, r, !0)
                }
            }

            function zR(t, n = 3) {
                const e = Math.pow(10, n - 1);
                return Math.round(t * e) / e
            }
            class c2 {}
            const IX = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
            class PX extends c2 {
                normalizePropertyName(n, e) {
                    return t2(n)
                }
                normalizeStyleValue(n, e, i, r) {
                    let s = "";
                    const o = i.toString().trim();
                    if (IX.has(e) && 0 !== i && "0" !== i)
                        if ("number" == typeof i) s = "px";
                        else {
                            const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
                            a && 0 == a[1].length && r.push(function EY(t, n) {
                                return new mt(3005, !1)
                            }())
                        }
                    return o + s
                }
            }

            function jR(t, n, e, i, r, s, o, a, c, u, h, m, x) {
                return {
                    type: 0,
                    element: t,
                    triggerName: n,
                    isRemovalTransition: r,
                    fromState: e,
                    fromStyles: s,
                    toState: i,
                    toStyles: o,
                    timelines: a,
                    queriedElements: c,
                    preStyleProps: u,
                    postStyleProps: h,
                    totalTime: m,
                    errors: x
                }
            }
            const l2 = {};
            class WR {
                constructor(n, e, i) {
                    this._triggerName = n, this.ast = e, this._stateStyles = i
                }
                match(n, e, i, r) {
                    return function OX(t, n, e, i, r) {
                        return t.some(s => s(n, e, i, r))
                    }(this.ast.matchers, n, e, i, r)
                }
                buildStyles(n, e, i) {
                    let r = this._stateStyles.get("*");
                    return void 0 !== n && (r = this._stateStyles.get(n ? .toString()) || r), r ? r.buildStyles(e, i) : new Map
                }
                build(n, e, i, r, s, o, a, c, u, h) {
                    const m = [],
                        x = this.ast.options && this.ast.options.params || l2,
                        V = this.buildStyles(i, a && a.params || l2, m),
                        te = c && c.params || l2,
                        ee = this.buildStyles(r, te, m),
                        _e = new Set,
                        ye = new Map,
                        Be = new Map,
                        ze = "void" === r,
                        Xe = {
                            params: LX(te, x),
                            delay: this.ast.options ? .delay
                        },
                        ht = h ? [] : o2(n, e, this.ast.animation, s, o, V, ee, Xe, u, m);
                    let vt = 0;
                    if (ht.forEach(Cn => {
                            vt = Math.max(Cn.duration + Cn.delay, vt)
                        }), m.length) return jR(e, this._triggerName, i, r, ze, V, ee, [], [], ye, Be, vt, m);
                    ht.forEach(Cn => {
                        const Xt = Cn.element,
                            Rt = yc(ye, Xt, new Set);
                        Cn.preStyleProps.forEach(xi => Rt.add(xi));
                        const wr = yc(Be, Xt, new Set);
                        Cn.postStyleProps.forEach(xi => wr.add(xi)), Xt !== e && _e.add(Xt)
                    });
                    const jt = Vb(_e.values());
                    return jR(e, this._triggerName, i, r, ze, V, ee, ht, jt, ye, Be, vt)
                }
            }

            function LX(t, n) {
                const e = Fy(n);
                for (const i in t) t.hasOwnProperty(i) && null != t[i] && (e[i] = t[i]);
                return e
            }
            class RX {
                constructor(n, e, i) {
                    this.styles = n, this.defaultParams = e, this.normalizer = i
                }
                buildStyles(n, e) {
                    const i = new Map,
                        r = Fy(this.defaultParams);
                    return Object.keys(n).forEach(s => {
                        const o = n[s];
                        null !== o && (r[s] = o)
                    }), this.styles.styles.forEach(s => {
                        "string" != typeof s && s.forEach((o, a) => {
                            o && (o = Uy(o, r, e));
                            const c = this.normalizer.normalizePropertyName(a, e);
                            o = this.normalizer.normalizeStyleValue(a, c, o, e), i.set(a, o)
                        })
                    }), i
                }
            }
            class NX {
                constructor(n, e, i) {
                    this.name = n, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = new Map, e.states.forEach(r => {
                        this.states.set(r.name, new RX(r.style, r.options && r.options.params || {}, i))
                    }), GR(this.states, "true", "1"), GR(this.states, "false", "0"), e.transitions.forEach(r => {
                        this.transitionFactories.push(new WR(n, r, this.states))
                    }), this.fallbackTransition = function FX(t, n, e) {
                        return new WR(t, {
                            type: 1,
                            animation: {
                                type: 2,
                                steps: [],
                                options: null
                            },
                            matchers: [(o, a) => !0],
                            options: null,
                            queryCount: 0,
                            depCount: 0
                        }, n)
                    }(n, this.states)
                }
                get containsQueries() {
                    return this.ast.queryCount > 0
                }
                matchTransition(n, e, i, r) {
                    return this.transitionFactories.find(o => o.match(n, e, i, r)) || null
                }
                matchStyles(n, e, i) {
                    return this.fallbackTransition.buildStyles(n, e, i)
                }
            }

            function GR(t, n, e) {
                t.has(n) ? t.has(e) || t.set(e, t.get(n)) : t.has(e) && t.set(n, t.get(e))
            }
            const VX = new zb;
            class UX {
                constructor(n, e, i) {
                    this.bodyNode = n, this._driver = e, this._normalizer = i, this._animations = new Map, this._playersById = new Map, this.players = []
                }
                register(n, e) {
                    const i = [],
                        s = n2(this._driver, e, i, []);
                    if (i.length) throw function jY(t) {
                        return new mt(3503, !1)
                    }();
                    this._animations.set(n, s)
                }
                _buildPlayer(n, e, i) {
                    const r = n.element,
                        s = AR(this._normalizer, n.keyframes, e, i);
                    return this._driver.animate(r, s, n.duration, n.delay, n.easing, [], !0)
                }
                create(n, e, i = {}) {
                    const r = [],
                        s = this._animations.get(n);
                    let o;
                    const a = new Map;
                    if (s ? (o = o2(this._driver, e, s, XS, Rb, new Map, new Map, i, VX, r), o.forEach(h => {
                            const m = yc(a, h.element, new Map);
                            h.postStyleProps.forEach(x => m.set(x, null))
                        })) : (r.push(function WY() {
                            return new mt(3300, !1)
                        }()), o = []), r.length) throw function GY(t) {
                        return new mt(3504, !1)
                    }();
                    a.forEach((h, m) => {
                        h.forEach((x, D) => {
                            h.set(D, this._driver.computeStyle(m, D, Hu))
                        })
                    });
                    const u = th(o.map(h => {
                        const m = a.get(h.element);
                        return this._buildPlayer(h, new Map, m)
                    }));
                    return this._playersById.set(n, u), u.onDestroy(() => this.destroy(n)), this.players.push(u), u
                }
                destroy(n) {
                    const e = this._getPlayer(n);
                    e.destroy(), this._playersById.delete(n);
                    const i = this.players.indexOf(e);
                    i >= 0 && this.players.splice(i, 1)
                }
                _getPlayer(n) {
                    const e = this._playersById.get(n);
                    if (!e) throw function KY(t) {
                        return new mt(3301, !1)
                    }();
                    return e
                }
                listen(n, e, i, r) {
                    const s = qS(e, "", "", "");
                    return GS(this._getPlayer(n), i, s, r), () => {}
                }
                command(n, e, i, r) {
                    if ("register" == i) return void this.register(n, r[0]);
                    if ("create" == i) return void this.create(n, e, r[0] || {});
                    const s = this._getPlayer(n);
                    switch (i) {
                        case "play":
                            s.play();
                            break;
                        case "pause":
                            s.pause();
                            break;
                        case "reset":
                            s.reset();
                            break;
                        case "restart":
                            s.restart();
                            break;
                        case "finish":
                            s.finish();
                            break;
                        case "init":
                            s.init();
                            break;
                        case "setPosition":
                            s.setPosition(parseFloat(r[0]));
                            break;
                        case "destroy":
                            this.destroy(n)
                    }
                }
            }
            const KR = "ng-animate-queued",
                u2 = "ng-animate-disabled",
                WX = [],
                qR = {
                    namespaceId: "",
                    setForRemoval: !1,
                    setForMove: !1,
                    hasAnimation: !1,
                    removedBeforeQueried: !1
                },
                GX = {
                    namespaceId: "",
                    setForMove: !1,
                    setForRemoval: !1,
                    hasAnimation: !1,
                    removedBeforeQueried: !0
                },
                wl = "__ng_removed";
            class d2 {
                get params() {
                    return this.options.params
                }
                constructor(n, e = "") {
                    this.namespaceId = e;
                    const i = n && n.hasOwnProperty("value");
                    if (this.value = function YX(t) {
                            return t ? ? null
                        }(i ? n.value : n), i) {
                        const s = Fy(n);
                        delete s.value, this.options = s
                    } else this.options = {};
                    this.options.params || (this.options.params = {})
                }
                absorbOptions(n) {
                    const e = n.params;
                    if (e) {
                        const i = this.options.params;
                        Object.keys(e).forEach(r => {
                            null == i[r] && (i[r] = e[r])
                        })
                    }
                }
            }
            const Hy = "void",
                h2 = new d2(Hy);
            class KX {
                constructor(n, e, i) {
                    this.id = n, this.hostElement = e, this._engine = i, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + n, Wc(e, this._hostClassName)
                }
                listen(n, e, i, r) {
                    if (!this._triggers.has(e)) throw function qY(t, n) {
                        return new mt(3302, !1)
                    }();
                    if (null == i || 0 == i.length) throw function ZY(t) {
                        return new mt(3303, !1)
                    }();
                    if (! function XX(t) {
                            return "start" == t || "done" == t
                        }(i)) throw function YY(t, n) {
                        return new mt(3400, !1)
                    }();
                    const s = yc(this._elementListeners, n, []),
                        o = {
                            name: e,
                            phase: i,
                            callback: r
                        };
                    s.push(o);
                    const a = yc(this._engine.statesByElement, n, new Map);
                    return a.has(e) || (Wc(n, Bb), Wc(n, Bb + "-" + e), a.set(e, h2)), () => {
                        this._engine.afterFlush(() => {
                            const c = s.indexOf(o);
                            c >= 0 && s.splice(c, 1), this._triggers.has(e) || a.delete(e)
                        })
                    }
                }
                register(n, e) {
                    return !this._triggers.has(n) && (this._triggers.set(n, e), !0)
                }
                _getTrigger(n) {
                    const e = this._triggers.get(n);
                    if (!e) throw function XY(t) {
                        return new mt(3401, !1)
                    }();
                    return e
                }
                trigger(n, e, i, r = !0) {
                    const s = this._getTrigger(e),
                        o = new f2(this.id, e, n);
                    let a = this._engine.statesByElement.get(n);
                    a || (Wc(n, Bb), Wc(n, Bb + "-" + e), this._engine.statesByElement.set(n, a = new Map));
                    let c = a.get(e);
                    const u = new d2(i, this.id);
                    if (!(i && i.hasOwnProperty("value")) && c && u.absorbOptions(c.options), a.set(e, u), c || (c = h2), u.value !== Hy && c.value === u.value) {
                        if (! function eQ(t, n) {
                                const e = Object.keys(t),
                                    i = Object.keys(n);
                                if (e.length != i.length) return !1;
                                for (let r = 0; r < e.length; r++) {
                                    const s = e[r];
                                    if (!n.hasOwnProperty(s) || t[s] !== n[s]) return !1
                                }
                                return !0
                            }(c.params, u.params)) {
                            const te = [],
                                ee = s.matchStyles(c.value, c.params, te),
                                _e = s.matchStyles(u.value, u.params, te);
                            te.length ? this._engine.reportError(te) : this._engine.afterFlush(() => {
                                xf(n, ee), Ql(n, _e)
                            })
                        }
                        return
                    }
                    const x = yc(this._engine.playersByElement, n, []);
                    x.forEach(te => {
                        te.namespaceId == this.id && te.triggerName == e && te.queued && te.destroy()
                    });
                    let D = s.matchTransition(c.value, u.value, n, u.params),
                        V = !1;
                    if (!D) {
                        if (!r) return;
                        D = s.fallbackTransition, V = !0
                    }
                    return this._engine.totalQueuedPlayers++, this._queue.push({
                        element: n,
                        triggerName: e,
                        transition: D,
                        fromState: c,
                        toState: u,
                        player: o,
                        isFallbackTransition: V
                    }), V || (Wc(n, KR), o.onStart(() => {
                        bm(n, KR)
                    })), o.onDone(() => {
                        let te = this.players.indexOf(o);
                        te >= 0 && this.players.splice(te, 1);
                        const ee = this._engine.playersByElement.get(n);
                        if (ee) {
                            let _e = ee.indexOf(o);
                            _e >= 0 && ee.splice(_e, 1)
                        }
                    }), this.players.push(o), x.push(o), o
                }
                deregister(n) {
                    this._triggers.delete(n), this._engine.statesByElement.forEach(e => e.delete(n)), this._elementListeners.forEach((e, i) => {
                        this._elementListeners.set(i, e.filter(r => r.name != n))
                    })
                }
                clearElementCache(n) {
                    this._engine.statesByElement.delete(n), this._elementListeners.delete(n);
                    const e = this._engine.playersByElement.get(n);
                    e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(n))
                }
                _signalRemovalForInnerTriggers(n, e) {
                    const i = this._engine.driver.query(n, Nb, !0);
                    i.forEach(r => {
                        if (r[wl]) return;
                        const s = this._engine.fetchNamespacesByElement(r);
                        s.size ? s.forEach(o => o.triggerLeaveAnimation(r, e, !1, !0)) : this.clearElementCache(r)
                    }), this._engine.afterFlushAnimationsDone(() => i.forEach(r => this.clearElementCache(r)))
                }
                triggerLeaveAnimation(n, e, i, r) {
                    const s = this._engine.statesByElement.get(n),
                        o = new Map;
                    if (s) {
                        const a = [];
                        if (s.forEach((c, u) => {
                                if (o.set(u, c.value), this._triggers.has(u)) {
                                    const h = this.trigger(n, u, Hy, r);
                                    h && a.push(h)
                                }
                            }), a.length) return this._engine.markElementAsRemoved(this.id, n, !0, e, o), i && th(a).onDone(() => this._engine.processLeaveNode(n)), !0
                    }
                    return !1
                }
                prepareLeaveAnimationListeners(n) {
                    const e = this._elementListeners.get(n),
                        i = this._engine.statesByElement.get(n);
                    if (e && i) {
                        const r = new Set;
                        e.forEach(s => {
                            const o = s.name;
                            if (r.has(o)) return;
                            r.add(o);
                            const c = this._triggers.get(o).fallbackTransition,
                                u = i.get(o) || h2,
                                h = new d2(Hy),
                                m = new f2(this.id, o, n);
                            this._engine.totalQueuedPlayers++, this._queue.push({
                                element: n,
                                triggerName: o,
                                transition: c,
                                fromState: u,
                                toState: h,
                                player: m,
                                isFallbackTransition: !0
                            })
                        })
                    }
                }
                removeNode(n, e) {
                    const i = this._engine;
                    if (n.childElementCount && this._signalRemovalForInnerTriggers(n, e), this.triggerLeaveAnimation(n, e, !0)) return;
                    let r = !1;
                    if (i.totalAnimations) {
                        const s = i.players.length ? i.playersByQueriedElement.get(n) : [];
                        if (s && s.length) r = !0;
                        else {
                            let o = n;
                            for (; o = o.parentNode;)
                                if (i.statesByElement.get(o)) {
                                    r = !0;
                                    break
                                }
                        }
                    }
                    if (this.prepareLeaveAnimationListeners(n), r) i.markElementAsRemoved(this.id, n, !1, e);
                    else {
                        const s = n[wl];
                        (!s || s === qR) && (i.afterFlush(() => this.clearElementCache(n)), i.destroyInnerAnimations(n), i._onRemovalComplete(n, e))
                    }
                }
                insertNode(n, e) {
                    Wc(n, this._hostClassName)
                }
                drainQueuedTransitions(n) {
                    const e = [];
                    return this._queue.forEach(i => {
                        const r = i.player;
                        if (r.destroyed) return;
                        const s = i.element,
                            o = this._elementListeners.get(s);
                        o && o.forEach(a => {
                            if (a.name == i.triggerName) {
                                const c = qS(s, i.triggerName, i.fromState.value, i.toState.value);
                                c._data = n, GS(i.player, a.phase, c, a.callback)
                            }
                        }), r.markedForDestroy ? this._engine.afterFlush(() => {
                            r.destroy()
                        }) : e.push(i)
                    }), this._queue = [], e.sort((i, r) => {
                        const s = i.transition.ast.depCount,
                            o = r.transition.ast.depCount;
                        return 0 == s || 0 == o ? s - o : this._engine.driver.containsElement(i.element, r.element) ? 1 : -1
                    })
                }
                destroy(n) {
                    this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, n)
                }
            }
            class qX {
                _onRemovalComplete(n, e) {
                    this.onRemovalComplete(n, e)
                }
                constructor(n, e, i) {
                    this.bodyNode = n, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (r, s) => {}
                }
                get queuedPlayers() {
                    const n = [];
                    return this._namespaceList.forEach(e => {
                        e.players.forEach(i => {
                            i.queued && n.push(i)
                        })
                    }), n
                }
                createNamespace(n, e) {
                    const i = new KX(n, e, this);
                    return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[n] = i
                }
                _balanceNamespaceList(n, e) {
                    const i = this._namespaceList,
                        r = this.namespacesByHostElement;
                    if (i.length - 1 >= 0) {
                        let o = !1,
                            a = this.driver.getParentElement(e);
                        for (; a;) {
                            const c = r.get(a);
                            if (c) {
                                const u = i.indexOf(c);
                                i.splice(u + 1, 0, n), o = !0;
                                break
                            }
                            a = this.driver.getParentElement(a)
                        }
                        o || i.unshift(n)
                    } else i.push(n);
                    return r.set(e, n), n
                }
                register(n, e) {
                    let i = this._namespaceLookup[n];
                    return i || (i = this.createNamespace(n, e)), i
                }
                registerTrigger(n, e, i) {
                    let r = this._namespaceLookup[n];
                    r && r.register(e, i) && this.totalAnimations++
                }
                destroy(n, e) {
                    n && (this.afterFlush(() => {}), this.afterFlushAnimationsDone(() => {
                        const i = this._fetchNamespace(n);
                        this.namespacesByHostElement.delete(i.hostElement);
                        const r = this._namespaceList.indexOf(i);
                        r >= 0 && this._namespaceList.splice(r, 1), i.destroy(e), delete this._namespaceLookup[n]
                    }))
                }
                _fetchNamespace(n) {
                    return this._namespaceLookup[n]
                }
                fetchNamespacesByElement(n) {
                    const e = new Set,
                        i = this.statesByElement.get(n);
                    if (i)
                        for (let r of i.values())
                            if (r.namespaceId) {
                                const s = this._fetchNamespace(r.namespaceId);
                                s && e.add(s)
                            }
                    return e
                }
                trigger(n, e, i, r) {
                    if (Gb(e)) {
                        const s = this._fetchNamespace(n);
                        if (s) return s.trigger(e, i, r), !0
                    }
                    return !1
                }
                insertNode(n, e, i, r) {
                    if (!Gb(e)) return;
                    const s = e[wl];
                    if (s && s.setForRemoval) {
                        s.setForRemoval = !1, s.setForMove = !0;
                        const o = this.collectedLeaveElements.indexOf(e);
                        o >= 0 && this.collectedLeaveElements.splice(o, 1)
                    }
                    if (n) {
                        const o = this._fetchNamespace(n);
                        o && o.insertNode(e, i)
                    }
                    r && this.collectEnterElement(e)
                }
                collectEnterElement(n) {
                    this.collectedEnterElements.push(n)
                }
                markElementAsDisabled(n, e) {
                    e ? this.disabledNodes.has(n) || (this.disabledNodes.add(n), Wc(n, u2)) : this.disabledNodes.has(n) && (this.disabledNodes.delete(n), bm(n, u2))
                }
                removeNode(n, e, i) {
                    if (Gb(e)) {
                        const r = n ? this._fetchNamespace(n) : null;
                        r ? r.removeNode(e, i) : this.markElementAsRemoved(n, e, !1, i);
                        const s = this.namespacesByHostElement.get(e);
                        s && s.id !== n && s.removeNode(e, i)
                    } else this._onRemovalComplete(e, i)
                }
                markElementAsRemoved(n, e, i, r, s) {
                    this.collectedLeaveElements.push(e), e[wl] = {
                        namespaceId: n,
                        setForRemoval: r,
                        hasAnimation: i,
                        removedBeforeQueried: !1,
                        previousTriggersValues: s
                    }
                }
                listen(n, e, i, r, s) {
                    return Gb(e) ? this._fetchNamespace(n).listen(e, i, r, s) : () => {}
                }
                _buildInstruction(n, e, i, r, s) {
                    return n.transition.build(this.driver, n.element, n.fromState.value, n.toState.value, i, r, n.fromState.options, n.toState.options, e, s)
                }
                destroyInnerAnimations(n) {
                    let e = this.driver.query(n, Nb, !0);
                    e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(n, QS, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i)))
                }
                destroyActiveAnimationsForElement(n) {
                    const e = this.playersByElement.get(n);
                    e && e.forEach(i => {
                        i.queued ? i.markedForDestroy = !0 : i.destroy()
                    })
                }
                finishActiveQueriedAnimationOnElement(n) {
                    const e = this.playersByQueriedElement.get(n);
                    e && e.forEach(i => i.finish())
                }
                whenRenderingDone() {
                    return new Promise(n => {
                        if (this.players.length) return th(this.players).onDone(() => n());
                        n()
                    })
                }
                processLeaveNode(n) {
                    const e = n[wl];
                    if (e && e.setForRemoval) {
                        if (n[wl] = qR, e.namespaceId) {
                            this.destroyInnerAnimations(n);
                            const i = this._fetchNamespace(e.namespaceId);
                            i && i.clearElementCache(n)
                        }
                        this._onRemovalComplete(n, e.setForRemoval)
                    }
                    n.classList ? .contains(u2) && this.markElementAsDisabled(n, !1), this.driver.query(n, ".ng-animate-disabled", !0).forEach(i => {
                        this.markElementAsDisabled(i, !1)
                    })
                }
                flush(n = -1) {
                    let e = [];
                    if (this.newHostElements.size && (this.newHostElements.forEach((i, r) => this._balanceNamespaceList(i, r)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
                        for (let i = 0; i < this.collectedEnterElements.length; i++) Wc(this.collectedEnterElements[i], "ng-star-inserted");
                    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                        const i = [];
                        try {
                            e = this._flushAnimations(i, n)
                        } finally {
                            for (let r = 0; r < i.length; r++) i[r]()
                        }
                    } else
                        for (let i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i]);
                    if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) {
                        const i = this._whenQuietFns;
                        this._whenQuietFns = [], e.length ? th(e).onDone(() => {
                            i.forEach(r => r())
                        }) : i.forEach(r => r())
                    }
                }
                reportError(n) {
                    throw function QY(t) {
                        return new mt(3402, !1)
                    }()
                }
                _flushAnimations(n, e) {
                    const i = new zb,
                        r = [],
                        s = new Map,
                        o = [],
                        a = new Map,
                        c = new Map,
                        u = new Map,
                        h = new Set;
                    this.disabledNodes.forEach(Et => {
                        h.add(Et);
                        const Gt = this.driver.query(Et, ".ng-animate-queued", !0);
                        for (let cn = 0; cn < Gt.length; cn++) h.add(Gt[cn])
                    });
                    const m = this.bodyNode,
                        x = Array.from(this.statesByElement.keys()),
                        D = XR(x, this.collectedEnterElements),
                        V = new Map;
                    let te = 0;
                    D.forEach((Et, Gt) => {
                        const cn = XS + te++;
                        V.set(Gt, cn), Et.forEach(Qt => Wc(Qt, cn))
                    });
                    const ee = [],
                        _e = new Set,
                        ye = new Set;
                    for (let Et = 0; Et < this.collectedLeaveElements.length; Et++) {
                        const Gt = this.collectedLeaveElements[Et],
                            cn = Gt[wl];
                        cn && cn.setForRemoval && (ee.push(Gt), _e.add(Gt), cn.hasAnimation ? this.driver.query(Gt, ".ng-star-inserted", !0).forEach(Qt => _e.add(Qt)) : ye.add(Gt))
                    }
                    const Be = new Map,
                        ze = XR(x, Array.from(_e));
                    ze.forEach((Et, Gt) => {
                        const cn = Rb + te++;
                        Be.set(Gt, cn), Et.forEach(Qt => Wc(Qt, cn))
                    }), n.push(() => {
                        D.forEach((Et, Gt) => {
                            const cn = V.get(Gt);
                            Et.forEach(Qt => bm(Qt, cn))
                        }), ze.forEach((Et, Gt) => {
                            const cn = Be.get(Gt);
                            Et.forEach(Qt => bm(Qt, cn))
                        }), ee.forEach(Et => {
                            this.processLeaveNode(Et)
                        })
                    });
                    const Xe = [],
                        ht = [];
                    for (let Et = this._namespaceList.length - 1; Et >= 0; Et--) this._namespaceList[Et].drainQueuedTransitions(e).forEach(cn => {
                        const Qt = cn.player,
                            Ri = cn.element;
                        if (Xe.push(Qt), this.collectedEnterElements.length) {
                            const Sr = Ri[wl];
                            if (Sr && Sr.setForMove) {
                                if (Sr.previousTriggersValues && Sr.previousTriggersValues.has(cn.triggerName)) {
                                    const Ma = Sr.previousTriggersValues.get(cn.triggerName),
                                        yn = this.statesByElement.get(cn.element);
                                    if (yn && yn.has(cn.triggerName)) {
                                        const Ci = yn.get(cn.triggerName);
                                        Ci.value = Ma, yn.set(cn.triggerName, Ci)
                                    }
                                }
                                return void Qt.destroy()
                            }
                        }
                        const sr = !m || !this.driver.containsElement(m, Ri),
                            tr = Be.get(Ri),
                            tc = V.get(Ri),
                            Ur = this._buildInstruction(cn, i, tc, tr, sr);
                        if (Ur.errors && Ur.errors.length) return void ht.push(Ur);
                        if (sr) return Qt.onStart(() => xf(Ri, Ur.fromStyles)), Qt.onDestroy(() => Ql(Ri, Ur.toStyles)), void r.push(Qt);
                        if (cn.isFallbackTransition) return Qt.onStart(() => xf(Ri, Ur.fromStyles)), Qt.onDestroy(() => Ql(Ri, Ur.toStyles)), void r.push(Qt);
                        const dd = [];
                        Ur.timelines.forEach(Sr => {
                            Sr.stretchStartingKeyframe = !0, this.disabledNodes.has(Sr.element) || dd.push(Sr)
                        }), Ur.timelines = dd, i.append(Ri, Ur.timelines), o.push({
                            instruction: Ur,
                            player: Qt,
                            element: Ri
                        }), Ur.queriedElements.forEach(Sr => yc(a, Sr, []).push(Qt)), Ur.preStyleProps.forEach((Sr, Ma) => {
                            if (Sr.size) {
                                let yn = c.get(Ma);
                                yn || c.set(Ma, yn = new Set), Sr.forEach((Ci, nr) => yn.add(nr))
                            }
                        }), Ur.postStyleProps.forEach((Sr, Ma) => {
                            let yn = u.get(Ma);
                            yn || u.set(Ma, yn = new Set), Sr.forEach((Ci, nr) => yn.add(nr))
                        })
                    });
                    if (ht.length) {
                        const Et = [];
                        ht.forEach(Gt => {
                            Et.push(function JY(t, n) {
                                return new mt(3505, !1)
                            }())
                        }), Xe.forEach(Gt => Gt.destroy()), this.reportError(Et)
                    }
                    const vt = new Map,
                        jt = new Map;
                    o.forEach(Et => {
                        const Gt = Et.element;
                        i.has(Gt) && (jt.set(Gt, Gt), this._beforeAnimationBuild(Et.player.namespaceId, Et.instruction, vt))
                    }), r.forEach(Et => {
                        const Gt = Et.element;
                        this._getPreviousPlayers(Gt, !1, Et.namespaceId, Et.triggerName, null).forEach(Qt => {
                            yc(vt, Gt, []).push(Qt), Qt.destroy()
                        })
                    });
                    const Cn = ee.filter(Et => JR(Et, c, u)),
                        Xt = new Map;
                    YR(Xt, this.driver, ye, u, Hu).forEach(Et => {
                        JR(Et, c, u) && Cn.push(Et)
                    });
                    const wr = new Map;
                    D.forEach((Et, Gt) => {
                        YR(wr, this.driver, new Set(Et), c, "!")
                    }), Cn.forEach(Et => {
                        const Gt = Xt.get(Et),
                            cn = wr.get(Et);
                        Xt.set(Et, new Map([...Gt ? .entries() ? ? [], ...cn ? .entries() ? ? []]))
                    });
                    const xi = [],
                        ut = [],
                        Ht = {};
                    o.forEach(Et => {
                        const {
                            element: Gt,
                            player: cn,
                            instruction: Qt
                        } = Et;
                        if (i.has(Gt)) {
                            if (h.has(Gt)) return cn.onDestroy(() => Ql(Gt, Qt.toStyles)), cn.disabled = !0, cn.overrideTotalTime(Qt.totalTime), void r.push(cn);
                            let Ri = Ht;
                            if (jt.size > 1) {
                                let tr = Gt;
                                const tc = [];
                                for (; tr = tr.parentNode;) {
                                    const Ur = jt.get(tr);
                                    if (Ur) {
                                        Ri = Ur;
                                        break
                                    }
                                    tc.push(tr)
                                }
                                tc.forEach(Ur => jt.set(Ur, Ri))
                            }
                            const sr = this._buildAnimation(cn.namespaceId, Qt, vt, s, wr, Xt);
                            if (cn.setRealPlayer(sr), Ri === Ht) xi.push(cn);
                            else {
                                const tr = this.playersByElement.get(Ri);
                                tr && tr.length && (cn.parentPlayer = th(tr)), r.push(cn)
                            }
                        } else xf(Gt, Qt.fromStyles), cn.onDestroy(() => Ql(Gt, Qt.toStyles)), ut.push(cn), h.has(Gt) && r.push(cn)
                    }), ut.forEach(Et => {
                        const Gt = s.get(Et.element);
                        if (Gt && Gt.length) {
                            const cn = th(Gt);
                            Et.setRealPlayer(cn)
                        }
                    }), r.forEach(Et => {
                        Et.parentPlayer ? Et.syncPlayerEvents(Et.parentPlayer) : Et.destroy()
                    });
                    for (let Et = 0; Et < ee.length; Et++) {
                        const Gt = ee[Et],
                            cn = Gt[wl];
                        if (bm(Gt, Rb), cn && cn.hasAnimation) continue;
                        let Qt = [];
                        if (a.size) {
                            let sr = a.get(Gt);
                            sr && sr.length && Qt.push(...sr);
                            let tr = this.driver.query(Gt, QS, !0);
                            for (let tc = 0; tc < tr.length; tc++) {
                                let Ur = a.get(tr[tc]);
                                Ur && Ur.length && Qt.push(...Ur)
                            }
                        }
                        const Ri = Qt.filter(sr => !sr.destroyed);
                        Ri.length ? QX(this, Gt, Ri) : this.processLeaveNode(Gt)
                    }
                    return ee.length = 0, xi.forEach(Et => {
                        this.players.push(Et), Et.onDone(() => {
                            Et.destroy();
                            const Gt = this.players.indexOf(Et);
                            this.players.splice(Gt, 1)
                        }), Et.play()
                    }), xi
                }
                afterFlush(n) {
                    this._flushFns.push(n)
                }
                afterFlushAnimationsDone(n) {
                    this._whenQuietFns.push(n)
                }
                _getPreviousPlayers(n, e, i, r, s) {
                    let o = [];
                    if (e) {
                        const a = this.playersByQueriedElement.get(n);
                        a && (o = a)
                    } else {
                        const a = this.playersByElement.get(n);
                        if (a) {
                            const c = !s || s == Hy;
                            a.forEach(u => {
                                u.queued || !c && u.triggerName != r || o.push(u)
                            })
                        }
                    }
                    return (i || r) && (o = o.filter(a => !(i && i != a.namespaceId || r && r != a.triggerName))), o
                }
                _beforeAnimationBuild(n, e, i) {
                    const s = e.element,
                        o = e.isRemovalTransition ? void 0 : n,
                        a = e.isRemovalTransition ? void 0 : e.triggerName;
                    for (const c of e.timelines) {
                        const u = c.element,
                            h = u !== s,
                            m = yc(i, u, []);
                        this._getPreviousPlayers(u, h, o, a, e.toState).forEach(D => {
                            const V = D.getRealPlayer();
                            V.beforeDestroy && V.beforeDestroy(), D.destroy(), m.push(D)
                        })
                    }
                    xf(s, e.fromStyles)
                }
                _buildAnimation(n, e, i, r, s, o) {
                    const a = e.triggerName,
                        c = e.element,
                        u = [],
                        h = new Set,
                        m = new Set,
                        x = e.timelines.map(V => {
                            const te = V.element;
                            h.add(te);
                            const ee = te[wl];
                            if (ee && ee.removedBeforeQueried) return new Ny(V.duration, V.delay);
                            const _e = te !== c,
                                ye = function JX(t) {
                                    const n = [];
                                    return QR(t, n), n
                                }((i.get(te) || WX).map(vt => vt.getRealPlayer())).filter(vt => !!vt.element && vt.element === te),
                                Be = s.get(te),
                                ze = o.get(te),
                                Xe = AR(this._normalizer, V.keyframes, Be, ze),
                                ht = this._buildPlayer(V, Xe, ye);
                            if (V.subTimeline && r && m.add(te), _e) {
                                const vt = new f2(n, a, te);
                                vt.setRealPlayer(ht), u.push(vt)
                            }
                            return ht
                        });
                    u.forEach(V => {
                        yc(this.playersByQueriedElement, V.element, []).push(V), V.onDone(() => function ZX(t, n, e) {
                            let i = t.get(n);
                            if (i) {
                                if (i.length) {
                                    const r = i.indexOf(e);
                                    i.splice(r, 1)
                                }
                                0 == i.length && t.delete(n)
                            }
                            return i
                        }(this.playersByQueriedElement, V.element, V))
                    }), h.forEach(V => Wc(V, RR));
                    const D = th(x);
                    return D.onDestroy(() => {
                        h.forEach(V => bm(V, RR)), Ql(c, e.toStyles)
                    }), m.forEach(V => {
                        yc(r, V, []).push(D)
                    }), D
                }
                _buildPlayer(n, e, i) {
                    return e.length > 0 ? this.driver.animate(n.element, e, n.duration, n.delay, n.easing, i) : new Ny(n.duration, n.delay)
                }
            }
            class f2 {
                constructor(n, e, i) {
                    this.namespaceId = n, this.triggerName = e, this.element = i, this._player = new Ny, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.parentPlayer = null, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0
                }
                setRealPlayer(n) {
                    this._containsRealPlayer || (this._player = n, this._queuedCallbacks.forEach((e, i) => {
                        e.forEach(r => GS(n, i, void 0, r))
                    }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(n.totalTime), this.queued = !1)
                }
                getRealPlayer() {
                    return this._player
                }
                overrideTotalTime(n) {
                    this.totalTime = n
                }
                syncPlayerEvents(n) {
                    const e = this._player;
                    e.triggerCallback && n.onStart(() => e.triggerCallback("start")), n.onDone(() => this.finish()), n.onDestroy(() => this.destroy())
                }
                _queueEvent(n, e) {
                    yc(this._queuedCallbacks, n, []).push(e)
                }
                onDone(n) {
                    this.queued && this._queueEvent("done", n), this._player.onDone(n)
                }
                onStart(n) {
                    this.queued && this._queueEvent("start", n), this._player.onStart(n)
                }
                onDestroy(n) {
                    this.queued && this._queueEvent("destroy", n), this._player.onDestroy(n)
                }
                init() {
                    this._player.init()
                }
                hasStarted() {
                    return !this.queued && this._player.hasStarted()
                }
                play() {
                    !this.queued && this._player.play()
                }
                pause() {
                    !this.queued && this._player.pause()
                }
                restart() {
                    !this.queued && this._player.restart()
                }
                finish() {
                    this._player.finish()
                }
                destroy() {
                    this.destroyed = !0, this._player.destroy()
                }
                reset() {
                    !this.queued && this._player.reset()
                }
                setPosition(n) {
                    this.queued || this._player.setPosition(n)
                }
                getPosition() {
                    return this.queued ? 0 : this._player.getPosition()
                }
                triggerCallback(n) {
                    const e = this._player;
                    e.triggerCallback && e.triggerCallback(n)
                }
            }

            function Gb(t) {
                return t && 1 === t.nodeType
            }

            function ZR(t, n) {
                const e = t.style.display;
                return t.style.display = n ? ? "none", e
            }

            function YR(t, n, e, i, r) {
                const s = [];
                e.forEach(c => s.push(ZR(c)));
                const o = [];
                i.forEach((c, u) => {
                    const h = new Map;
                    c.forEach(m => {
                        const x = n.computeStyle(u, m, r);
                        h.set(m, x), (!x || 0 == x.length) && (u[wl] = GX, o.push(u))
                    }), t.set(u, h)
                });
                let a = 0;
                return e.forEach(c => ZR(c, s[a++])), o
            }

            function XR(t, n) {
                const e = new Map;
                if (t.forEach(a => e.set(a, [])), 0 == n.length) return e;
                const r = new Set(n),
                    s = new Map;

                function o(a) {
                    if (!a) return 1;
                    let c = s.get(a);
                    if (c) return c;
                    const u = a.parentNode;
                    return c = e.has(u) ? u : r.has(u) ? 1 : o(u), s.set(a, c), c
                }
                return n.forEach(a => {
                    const c = o(a);
                    1 !== c && e.get(c).push(a)
                }), e
            }

            function Wc(t, n) {
                t.classList ? .add(n)
            }

            function bm(t, n) {
                t.classList ? .remove(n)
            }

            function QX(t, n, e) {
                th(e).onDone(() => t.processLeaveNode(n))
            }

            function QR(t, n) {
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    i instanceof ER ? QR(i.players, n) : n.push(i)
                }
            }

            function JR(t, n, e) {
                const i = e.get(t);
                if (!i) return !1;
                let r = n.get(t);
                return r ? i.forEach(s => r.add(s)) : n.set(t, i), e.delete(t), !0
            }
            class Kb {
                constructor(n, e, i) {
                    this.bodyNode = n, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (r, s) => {}, this._transitionEngine = new qX(n, e, i), this._timelineEngine = new UX(n, e, i), this._transitionEngine.onRemovalComplete = (r, s) => this.onRemovalComplete(r, s)
                }
                registerTrigger(n, e, i, r, s) {
                    const o = n + "-" + r;
                    let a = this._triggerCache[o];
                    if (!a) {
                        const c = [],
                            h = n2(this._driver, s, c, []);
                        if (c.length) throw function $Y(t, n) {
                            return new mt(3404, !1)
                        }();
                        a = function BX(t, n, e) {
                            return new NX(t, n, e)
                        }(r, h, this._normalizer), this._triggerCache[o] = a
                    }
                    this._transitionEngine.registerTrigger(e, r, a)
                }
                register(n, e) {
                    this._transitionEngine.register(n, e)
                }
                destroy(n, e) {
                    this._transitionEngine.destroy(n, e)
                }
                onInsert(n, e, i, r) {
                    this._transitionEngine.insertNode(n, e, i, r)
                }
                onRemove(n, e, i) {
                    this._transitionEngine.removeNode(n, e, i)
                }
                disableAnimations(n, e) {
                    this._transitionEngine.markElementAsDisabled(n, e)
                }
                process(n, e, i, r) {
                    if ("@" == i.charAt(0)) {
                        const [s, o] = kR(i);
                        this._timelineEngine.command(s, e, o, r)
                    } else this._transitionEngine.trigger(n, e, i, r)
                }
                listen(n, e, i, r, s) {
                    if ("@" == i.charAt(0)) {
                        const [o, a] = kR(i);
                        return this._timelineEngine.listen(o, e, a, s)
                    }
                    return this._transitionEngine.listen(n, e, i, r, s)
                }
                flush(n = -1) {
                    this._transitionEngine.flush(n)
                }
                get players() {
                    return [...this._transitionEngine.players, ...this._timelineEngine.players]
                }
                whenRenderingDone() {
                    return this._transitionEngine.whenRenderingDone()
                }
                afterFlushAnimationsDone(n) {
                    this._transitionEngine.afterFlushAnimationsDone(n)
                }
            }
            let nQ = (() => {
                class t {
                    static# e = this.initialStylesByElement = new WeakMap;
                    constructor(e, i, r) {
                        this._element = e, this._startStyles = i, this._endStyles = r, this._state = 0;
                        let s = t.initialStylesByElement.get(e);
                        s || t.initialStylesByElement.set(e, s = new Map), this._initialStyles = s
                    }
                    start() {
                        this._state < 1 && (this._startStyles && Ql(this._element, this._startStyles, this._initialStyles), this._state = 1)
                    }
                    finish() {
                        this.start(), this._state < 2 && (Ql(this._element, this._initialStyles), this._endStyles && (Ql(this._element, this._endStyles), this._endStyles = null), this._state = 1)
                    }
                    destroy() {
                        this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (xf(this._element, this._startStyles), this._endStyles = null), this._endStyles && (xf(this._element, this._endStyles), this._endStyles = null), Ql(this._element, this._initialStyles), this._state = 3)
                    }
                }
                return t
            })();

            function p2(t) {
                let n = null;
                return t.forEach((e, i) => {
                    (function iQ(t) {
                        return "display" === t || "position" === t
                    })(i) && (n = n || new Map, n.set(i, e))
                }), n
            }
            class e6 {
                constructor(n, e, i, r) {
                    this.element = n, this.keyframes = e, this.options = i, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = [])
                }
                init() {
                    this._buildPlayer(), this._preparePlayerBeforeStart()
                }
                _buildPlayer() {
                    if (this._initialized) return;
                    this._initialized = !0;
                    const n = this.keyframes;
                    this.domPlayer = this._triggerWebAnimation(this.element, n, this.options), this._finalKeyframe = n.length ? n[n.length - 1] : new Map;
                    const e = () => this._onFinish();
                    this.domPlayer.addEventListener("finish", e), this.onDestroy(() => {
                        this.domPlayer.removeEventListener("finish", e)
                    })
                }
                _preparePlayerBeforeStart() {
                    this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
                }
                _convertKeyframesToObject(n) {
                    const e = [];
                    return n.forEach(i => {
                        e.push(Object.fromEntries(i))
                    }), e
                }
                _triggerWebAnimation(n, e, i) {
                    return n.animate(this._convertKeyframesToObject(e), i)
                }
                onStart(n) {
                    this._originalOnStartFns.push(n), this._onStartFns.push(n)
                }
                onDone(n) {
                    this._originalOnDoneFns.push(n), this._onDoneFns.push(n)
                }
                onDestroy(n) {
                    this._onDestroyFns.push(n)
                }
                play() {
                    this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(n => n()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play()
                }
                pause() {
                    this.init(), this.domPlayer.pause()
                }
                finish() {
                    this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish()
                }
                reset() {
                    this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
                }
                _resetDomPlayerState() {
                    this.domPlayer && this.domPlayer.cancel()
                }
                restart() {
                    this.reset(), this.play()
                }
                hasStarted() {
                    return this._started
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = [])
                }
                setPosition(n) {
                    void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = n * this.time
                }
                getPosition() {
                    return +(this.domPlayer.currentTime ? ? 0) / this.time
                }
                get totalTime() {
                    return this._delay + this._duration
                }
                beforeDestroy() {
                    const n = new Map;
                    this.hasStarted() && this._finalKeyframe.forEach((i, r) => {
                        "offset" !== r && n.set(r, this._finished ? i : VR(this.element, r))
                    }), this.currentSnapshot = n
                }
                triggerCallback(n) {
                    const e = "start" === n ? this._onStartFns : this._onDoneFns;
                    e.forEach(i => i()), e.length = 0
                }
            }
            class rQ {
                validateStyleProperty(n) {
                    return !0
                }
                validateAnimatableStyleProperty(n) {
                    return !0
                }
                matchesElement(n, e) {
                    return !1
                }
                containsElement(n, e) {
                    return IR(n, e)
                }
                getParentElement(n) {
                    return ZS(n)
                }
                query(n, e, i) {
                    return PR(n, e, i)
                }
                computeStyle(n, e, i) {
                    return window.getComputedStyle(n)[e]
                }
                animate(n, e, i, r, s, o = []) {
                    const c = {
                        duration: i,
                        delay: r,
                        fill: 0 == r ? "both" : "forwards"
                    };
                    s && (c.easing = s);
                    const u = new Map,
                        h = o.filter(D => D instanceof e6);
                    (function dX(t, n) {
                        return 0 === t || 0 === n
                    })(i, r) && h.forEach(D => {
                        D.currentSnapshot.forEach((V, te) => u.set(te, V))
                    });
                    let m = function cX(t) {
                        return t.length ? t[0] instanceof Map ? t : t.map(n => BR(n)) : []
                    }(e).map(D => nh(D));
                    m = function hX(t, n, e) {
                        if (e.size && n.length) {
                            let i = n[0],
                                r = [];
                            if (e.forEach((s, o) => {
                                    i.has(o) || r.push(o), i.set(o, s)
                                }), r.length)
                                for (let s = 1; s < n.length; s++) {
                                    let o = n[s];
                                    r.forEach(a => o.set(a, VR(t, a)))
                                }
                        }
                        return n
                    }(n, m, u);
                    const x = function tQ(t, n) {
                        let e = null,
                            i = null;
                        return Array.isArray(n) && n.length ? (e = p2(n[0]), n.length > 1 && (i = p2(n[n.length - 1]))) : n instanceof Map && (e = p2(n)), e || i ? new nQ(t, e, i) : null
                    }(n, m);
                    return new e6(n, m, c, x)
                }
            }
            let sQ = (() => {
                class t extends By {
                    constructor(e, i) {
                        super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, {
                            id: "0",
                            encapsulation: ls.None,
                            styles: [],
                            data: {
                                animation: []
                            }
                        })
                    }
                    build(e) {
                        const i = this._nextAnimationId.toString();
                        this._nextAnimationId++;
                        const r = Array.isArray(e) ? TR(e) : e;
                        return t6(this._renderer, null, i, "register", [r]), new oQ(i, this._renderer)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(pf), _t(Ss))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            class oQ extends bY {
                constructor(n, e) {
                    super(), this._id = n, this._renderer = e
                }
                create(n, e) {
                    return new aQ(this._id, n, e || {}, this._renderer)
                }
            }
            class aQ {
                constructor(n, e, i, r) {
                    this.id = n, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i)
                }
                _listen(n, e) {
                    return this._renderer.listen(this.element, `@@${this.id}:${n}`, e)
                }
                _command(n, ...e) {
                    return t6(this._renderer, this.element, this.id, n, e)
                }
                onDone(n) {
                    this._listen("done", n)
                }
                onStart(n) {
                    this._listen("start", n)
                }
                onDestroy(n) {
                    this._listen("destroy", n)
                }
                init() {
                    this._command("init")
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this._command("play"), this._started = !0
                }
                pause() {
                    this._command("pause")
                }
                restart() {
                    this._command("restart")
                }
                finish() {
                    this._command("finish")
                }
                destroy() {
                    this._command("destroy")
                }
                reset() {
                    this._command("reset"), this._started = !1
                }
                setPosition(n) {
                    this._command("setPosition", n)
                }
                getPosition() {
                    return this._renderer.engine.players[+this.id] ? .getPosition() ? ? 0
                }
            }

            function t6(t, n, e, i, r) {
                return t.setProperty(n, `@@${e}:${i}`, r)
            }
            const n6 = "@.disabled";
            let cQ = (() => {
                class t {
                    constructor(e, i, r) {
                        this.delegate = e, this.engine = i, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, i.onRemovalComplete = (s, o) => {
                            const a = o ? .parentNode(s);
                            a && o.removeChild(a, s)
                        }
                    }
                    createRenderer(e, i) {
                        const s = this.delegate.createRenderer(e, i);
                        if (!(e && i && i.data && i.data.animation)) {
                            let h = this._rendererCache.get(s);
                            return h || (h = new i6("", s, this.engine, () => this._rendererCache.delete(s)), this._rendererCache.set(s, h)), h
                        }
                        const o = i.id,
                            a = i.id + "-" + this._currentId;
                        this._currentId++, this.engine.register(a, e);
                        const c = h => {
                            Array.isArray(h) ? h.forEach(c) : this.engine.registerTrigger(o, a, e, h.name, h)
                        };
                        return i.data.animation.forEach(c), new lQ(this, a, s, this.engine)
                    }
                    begin() {
                        this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
                    }
                    _scheduleCountTask() {
                        queueMicrotask(() => {
                            this._microtaskId++
                        })
                    }
                    scheduleListenerCallback(e, i, r) {
                        e >= 0 && e < this._microtaskId ? this._zone.run(() => i(r)) : (0 == this._animationCallbacksBuffer.length && queueMicrotask(() => {
                            this._zone.run(() => {
                                this._animationCallbacksBuffer.forEach(s => {
                                    const [o, a] = s;
                                    o(a)
                                }), this._animationCallbacksBuffer = []
                            })
                        }), this._animationCallbacksBuffer.push([i, r]))
                    }
                    end() {
                        this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => {
                            this._scheduleCountTask(), this.engine.flush(this._microtaskId)
                        }), this.delegate.end && this.delegate.end()
                    }
                    whenRenderingDone() {
                        return this.engine.whenRenderingDone()
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(pf), _t(Kb), _t(cr))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            class i6 {
                constructor(n, e, i, r) {
                    this.namespaceId = n, this.delegate = e, this.engine = i, this._onDestroy = r
                }
                get data() {
                    return this.delegate.data
                }
                destroyNode(n) {
                    this.delegate.destroyNode ? .(n)
                }
                destroy() {
                    this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => {
                        queueMicrotask(() => {
                            this.delegate.destroy()
                        })
                    }), this._onDestroy ? .()
                }
                createElement(n, e) {
                    return this.delegate.createElement(n, e)
                }
                createComment(n) {
                    return this.delegate.createComment(n)
                }
                createText(n) {
                    return this.delegate.createText(n)
                }
                appendChild(n, e) {
                    this.delegate.appendChild(n, e), this.engine.onInsert(this.namespaceId, e, n, !1)
                }
                insertBefore(n, e, i, r = !0) {
                    this.delegate.insertBefore(n, e, i), this.engine.onInsert(this.namespaceId, e, n, r)
                }
                removeChild(n, e, i) {
                    this.engine.onRemove(this.namespaceId, e, this.delegate)
                }
                selectRootElement(n, e) {
                    return this.delegate.selectRootElement(n, e)
                }
                parentNode(n) {
                    return this.delegate.parentNode(n)
                }
                nextSibling(n) {
                    return this.delegate.nextSibling(n)
                }
                setAttribute(n, e, i, r) {
                    this.delegate.setAttribute(n, e, i, r)
                }
                removeAttribute(n, e, i) {
                    this.delegate.removeAttribute(n, e, i)
                }
                addClass(n, e) {
                    this.delegate.addClass(n, e)
                }
                removeClass(n, e) {
                    this.delegate.removeClass(n, e)
                }
                setStyle(n, e, i, r) {
                    this.delegate.setStyle(n, e, i, r)
                }
                removeStyle(n, e, i) {
                    this.delegate.removeStyle(n, e, i)
                }
                setProperty(n, e, i) {
                    "@" == e.charAt(0) && e == n6 ? this.disableAnimations(n, !!i) : this.delegate.setProperty(n, e, i)
                }
                setValue(n, e) {
                    this.delegate.setValue(n, e)
                }
                listen(n, e, i) {
                    return this.delegate.listen(n, e, i)
                }
                disableAnimations(n, e) {
                    this.engine.disableAnimations(n, e)
                }
            }
            class lQ extends i6 {
                constructor(n, e, i, r, s) {
                    super(e, i, r, s), this.factory = n, this.namespaceId = e
                }
                setProperty(n, e, i) {
                    "@" == e.charAt(0) ? "." == e.charAt(1) && e == n6 ? this.disableAnimations(n, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, n, e.slice(1), i) : this.delegate.setProperty(n, e, i)
                }
                listen(n, e, i) {
                    if ("@" == e.charAt(0)) {
                        const r = function uQ(t) {
                            switch (t) {
                                case "body":
                                    return document.body;
                                case "document":
                                    return document;
                                case "window":
                                    return window;
                                default:
                                    return t
                            }
                        }(n);
                        let s = e.slice(1),
                            o = "";
                        return "@" != s.charAt(0) && ([s, o] = function dQ(t) {
                            const n = t.indexOf(".");
                            return [t.substring(0, n), t.slice(n + 1)]
                        }(s)), this.engine.listen(this.namespaceId, r, s, o, a => {
                            this.factory.scheduleListenerCallback(a._data || -1, i, a)
                        })
                    }
                    return this.delegate.listen(n, e, i)
                }
            }
            let hQ = (() => {
                class t extends Kb {
                    constructor(e, i, r, s) {
                        super(e.body, i, r)
                    }
                    ngOnDestroy() {
                        this.flush()
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss), _t(YS), _t(c2), _t(Xl))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const r6 = [{
                    provide: By,
                    useClass: sQ
                }, {
                    provide: c2,
                    useFactory: function fQ() {
                        return new PX
                    }
                }, {
                    provide: Kb,
                    useClass: hQ
                }, {
                    provide: pf,
                    useFactory: function pQ(t, n, e) {
                        return new cQ(t, n, e)
                    },
                    deps: [US, Kb, cr]
                }],
                m2 = [{
                    provide: YS,
                    useFactory: () => new rQ
                }, {
                    provide: bP,
                    useValue: "BrowserAnimations"
                }, ...r6],
                s6 = [{
                    provide: YS,
                    useClass: OR
                }, {
                    provide: bP,
                    useValue: "NoopAnimations"
                }, ...r6];
            let mQ = (() => {
                class t {
                    static withConfig(e) {
                        return {
                            ngModule: t,
                            providers: e.disableAnimations ? s6 : m2
                        }
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275mod = _i({
                        type: t
                    });
                    static# n = this.\u0275inj = wi({
                        providers: m2,
                        imports: [hY]
                    })
                }
                return t
            })();

            function ju(t) {
                return !!t && (t instanceof M || F(t.lift) && F(t.subscribe))
            }
            const {
                isArray: gQ
            } = Array, {
                getPrototypeOf: yQ,
                prototype: _Q,
                keys: vQ
            } = Object;

            function o6(t) {
                if (1 === t.length) {
                    const n = t[0];
                    if (gQ(n)) return {
                        args: n,
                        keys: null
                    };
                    if (function bQ(t) {
                            return t && "object" == typeof t && yQ(t) === _Q
                        }(n)) {
                        const e = vQ(n);
                        return {
                            args: e.map(i => n[i]),
                            keys: e
                        }
                    }
                }
                return {
                    args: t,
                    keys: null
                }
            }
            const {
                isArray: wQ
            } = Array;

            function g2(t) {
                return Fe(n => function xQ(t, n) {
                    return wQ(n) ? t(...n) : t(n)
                }(t, n))
            }

            function a6(t, n) {
                return t.reduce((e, i, r) => (e[i] = n[r], e), {})
            }

            function c6(...t) {
                const n = $n(t),
                    {
                        args: e,
                        keys: i
                    } = o6(t),
                    r = new M(s => {
                        const {
                            length: o
                        } = e;
                        if (!o) return void s.complete();
                        const a = new Array(o);
                        let c = o,
                            u = o;
                        for (let h = 0; h < o; h++) {
                            let m = !1;
                            ji(e[h]).subscribe(Q(s, x => {
                                m || (m = !0, u--), a[h] = x
                            }, () => c--, void 0, () => {
                                (!c || !m) && (u || s.next(i ? a6(i, a) : a), s.complete())
                            }))
                        }
                    });
                return n ? r.pipe(g2(n)) : r
            }

            function wm(...t) {
                return function CQ() {
                    return je(1)
                }()(gn(t, _n(t)))
            }

            function Zb(t) {
                return new M(n => {
                    ji(t()).subscribe(n)
                })
            }

            function Sa(t) {
                return t <= 0 ? () => Qe : R((n, e) => {
                    let i = 0;
                    n.subscribe(Q(e, r => {
                        ++i <= t && (e.next(r), t <= i && e.complete())
                    }))
                })
            }
            const y2 = {
                now: () => (y2.delegate || Date).now(),
                delegate: void 0
            };
            class TQ extends A {
                constructor(n = 1 / 0, e = 1 / 0, i = y2) {
                    super(), this._bufferSize = n, this._windowTime = e, this._timestampProvider = i, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = e === 1 / 0, this._bufferSize = Math.max(1, n), this._windowTime = Math.max(1, e)
                }
                next(n) {
                    const {
                        isStopped: e,
                        _buffer: i,
                        _infiniteTimeWindow: r,
                        _timestampProvider: s,
                        _windowTime: o
                    } = this;
                    e || (i.push(n), !r && i.push(s.now() + o)), this._trimBuffer(), super.next(n)
                }
                _subscribe(n) {
                    this._throwIfClosed(), this._trimBuffer();
                    const e = this._innerSubscribe(n),
                        {
                            _infiniteTimeWindow: i,
                            _buffer: r
                        } = this,
                        s = r.slice();
                    for (let o = 0; o < s.length && !n.closed; o += i ? 1 : 2) n.next(s[o]);
                    return this._checkFinalizedStatuses(n), e
                }
                _trimBuffer() {
                    const {
                        _bufferSize: n,
                        _timestampProvider: e,
                        _buffer: i,
                        _infiniteTimeWindow: r
                    } = this, s = (r ? 1 : 2) * n;
                    if (n < 1 / 0 && s < i.length && i.splice(0, i.length - s), !r) {
                        const o = e.now();
                        let a = 0;
                        for (let c = 1; c < i.length && i[c] <= o; c += 2) a = c;
                        a && i.splice(0, a + 1)
                    }
                }
            }

            function l6(t, n, e) {
                let i, r = !1;
                return t && "object" == typeof t ? ({
                    bufferSize: i = 1 / 0,
                    windowTime: n = 1 / 0,
                    refCount: r = !1,
                    scheduler: e
                } = t) : i = t ? ? 1 / 0, at({
                    connector: () => new TQ(i, n, e),
                    resetOnError: !0,
                    resetOnComplete: !1,
                    resetOnRefCountZero: r
                })
            }

            function Tf(t, n) {
                return F(n) ? ke(t, n, 1) : ke(t, 1)
            }
            class $y {}
            let u6 = (() => {
                class t extends $y {
                    getTranslation(e) {
                        return Ve({})
                    }
                }
                return t.\u0275fac = function() {
                    let n;
                    return function(i) {
                        return (n || (n = ys(t)))(i || t)
                    }
                }(), t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class _2 {}
            let d6 = (() => {
                class t {
                    handle(e) {
                        return e.key
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function zy(t, n) {
                if (t === n) return !0;
                if (null === t || null === n) return !1;
                if (t != t && n != n) return !0;
                let r, s, o, e = typeof t;
                if (e == typeof n && "object" == e) {
                    if (!Array.isArray(t)) {
                        if (Array.isArray(n)) return !1;
                        for (s in o = Object.create(null), t) {
                            if (!zy(t[s], n[s])) return !1;
                            o[s] = !0
                        }
                        for (s in n)
                            if (!(s in o) && typeof n[s] < "u") return !1;
                        return !0
                    }
                    if (!Array.isArray(n)) return !1;
                    if ((r = t.length) == n.length) {
                        for (s = 0; s < r; s++)
                            if (!zy(t[s], n[s])) return !1;
                        return !0
                    }
                }
                return !1
            }

            function vc(t) {
                return typeof t < "u" && null !== t
            }

            function v2(t) {
                return t && "object" == typeof t && !Array.isArray(t)
            }

            function h6(t, n) {
                let e = Object.assign({}, t);
                return v2(t) && v2(n) && Object.keys(n).forEach(i => {
                    v2(n[i]) ? i in t ? e[i] = h6(t[i], n[i]) : Object.assign(e, {
                        [i]: n[i]
                    }) : Object.assign(e, {
                        [i]: n[i]
                    })
                }), e
            }
            class Yb {}
            let f6 = (() => {
                class t extends Yb {
                    constructor() {
                        super(...arguments), this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g
                    }
                    interpolate(e, i) {
                        let r;
                        return r = "string" == typeof e ? this.interpolateString(e, i) : "function" == typeof e ? this.interpolateFunction(e, i) : e, r
                    }
                    getValue(e, i) {
                        let r = "string" == typeof i ? i.split(".") : [i];
                        i = "";
                        do {
                            i += r.shift(), !vc(e) || !vc(e[i]) || "object" != typeof e[i] && r.length ? r.length ? i += "." : e = void 0 : (e = e[i], i = "")
                        } while (r.length);
                        return e
                    }
                    interpolateFunction(e, i) {
                        return e(i)
                    }
                    interpolateString(e, i) {
                        return i ? e.replace(this.templateMatcher, (r, s) => {
                            let o = this.getValue(i, s);
                            return vc(o) ? o : r
                        }) : e
                    }
                }
                return t.\u0275fac = function() {
                    let n;
                    return function(i) {
                        return (n || (n = ys(t)))(i || t)
                    }
                }(), t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class Xb {}
            let p6 = (() => {
                class t extends Xb {
                    compile(e, i) {
                        return e
                    }
                    compileTranslations(e, i) {
                        return e
                    }
                }
                return t.\u0275fac = function() {
                    let n;
                    return function(i) {
                        return (n || (n = ys(t)))(i || t)
                    }
                }(), t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class m6 {
                constructor() {
                    this.currentLang = this.defaultLang, this.translations = {}, this.langs = [], this.onTranslationChange = new zt, this.onLangChange = new zt, this.onDefaultLangChange = new zt
                }
            }
            const b2 = new nn("USE_STORE"),
                w2 = new nn("USE_DEFAULT_LANG"),
                x2 = new nn("DEFAULT_LANGUAGE"),
                C2 = new nn("USE_EXTEND");
            let bc = (() => {
                    class t {
                        constructor(e, i, r, s, o, a = !0, c = !1, u = !1, h) {
                            this.store = e, this.currentLoader = i, this.compiler = r, this.parser = s, this.missingTranslationHandler = o, this.useDefaultLang = a, this.isolate = c, this.extend = u, this.pending = !1, this._onTranslationChange = new zt, this._onLangChange = new zt, this._onDefaultLangChange = new zt, this._langs = [], this._translations = {}, this._translationRequests = {}, h && this.setDefaultLang(h)
                        }
                        get onTranslationChange() {
                            return this.isolate ? this._onTranslationChange : this.store.onTranslationChange
                        }
                        get onLangChange() {
                            return this.isolate ? this._onLangChange : this.store.onLangChange
                        }
                        get onDefaultLangChange() {
                            return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange
                        }
                        get defaultLang() {
                            return this.isolate ? this._defaultLang : this.store.defaultLang
                        }
                        set defaultLang(e) {
                            this.isolate ? this._defaultLang = e : this.store.defaultLang = e
                        }
                        get currentLang() {
                            return this.isolate ? this._currentLang : this.store.currentLang
                        }
                        set currentLang(e) {
                            this.isolate ? this._currentLang = e : this.store.currentLang = e
                        }
                        get langs() {
                            return this.isolate ? this._langs : this.store.langs
                        }
                        set langs(e) {
                            this.isolate ? this._langs = e : this.store.langs = e
                        }
                        get translations() {
                            return this.isolate ? this._translations : this.store.translations
                        }
                        set translations(e) {
                            this.isolate ? this._translations = e : this.store.translations = e
                        }
                        setDefaultLang(e) {
                            if (e === this.defaultLang) return;
                            let i = this.retrieveTranslations(e);
                            typeof i < "u" ? (null == this.defaultLang && (this.defaultLang = e), i.pipe(Sa(1)).subscribe(r => {
                                this.changeDefaultLang(e)
                            })) : this.changeDefaultLang(e)
                        }
                        getDefaultLang() {
                            return this.defaultLang
                        }
                        use(e) {
                            if (e === this.currentLang) return Ve(this.translations[e]);
                            let i = this.retrieveTranslations(e);
                            return typeof i < "u" ? (this.currentLang || (this.currentLang = e), i.pipe(Sa(1)).subscribe(r => {
                                this.changeLang(e)
                            }), i) : (this.changeLang(e), Ve(this.translations[e]))
                        }
                        retrieveTranslations(e) {
                            let i;
                            return (typeof this.translations[e] > "u" || this.extend) && (this._translationRequests[e] = this._translationRequests[e] || this.getTranslation(e), i = this._translationRequests[e]), i
                        }
                        getTranslation(e) {
                            this.pending = !0;
                            const i = this.currentLoader.getTranslation(e).pipe(l6(1), Sa(1));
                            return this.loadingTranslations = i.pipe(Fe(r => this.compiler.compileTranslations(r, e)), l6(1), Sa(1)), this.loadingTranslations.subscribe({
                                next: r => {
                                    this.translations[e] = this.extend && this.translations[e] ? { ...r,
                                        ...this.translations[e]
                                    } : r, this.updateLangs(), this.pending = !1
                                },
                                error: r => {
                                    this.pending = !1
                                }
                            }), i
                        }
                        setTranslation(e, i, r = !1) {
                            i = this.compiler.compileTranslations(i, e), this.translations[e] = (r || this.extend) && this.translations[e] ? h6(this.translations[e], i) : i, this.updateLangs(), this.onTranslationChange.emit({
                                lang: e,
                                translations: this.translations[e]
                            })
                        }
                        getLangs() {
                            return this.langs
                        }
                        addLangs(e) {
                            e.forEach(i => {
                                -1 === this.langs.indexOf(i) && this.langs.push(i)
                            })
                        }
                        updateLangs() {
                            this.addLangs(Object.keys(this.translations))
                        }
                        getParsedResult(e, i, r) {
                            let s;
                            if (i instanceof Array) {
                                let o = {},
                                    a = !1;
                                for (let c of i) o[c] = this.getParsedResult(e, c, r), ju(o[c]) && (a = !0);
                                return a ? c6(i.map(u => ju(o[u]) ? o[u] : Ve(o[u]))).pipe(Fe(u => {
                                    let h = {};
                                    return u.forEach((m, x) => {
                                        h[i[x]] = m
                                    }), h
                                })) : o
                            }
                            if (e && (s = this.parser.interpolate(this.parser.getValue(e, i), r)), typeof s > "u" && null != this.defaultLang && this.defaultLang !== this.currentLang && this.useDefaultLang && (s = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], i), r)), typeof s > "u") {
                                let o = {
                                    key: i,
                                    translateService: this
                                };
                                typeof r < "u" && (o.interpolateParams = r), s = this.missingTranslationHandler.handle(o)
                            }
                            return typeof s < "u" ? s : i
                        }
                        get(e, i) {
                            if (!vc(e) || !e.length) throw new Error('Parameter "key" required');
                            if (this.pending) return this.loadingTranslations.pipe(Tf(r => ju(r = this.getParsedResult(r, e, i)) ? r : Ve(r))); {
                                let r = this.getParsedResult(this.translations[this.currentLang], e, i);
                                return ju(r) ? r : Ve(r)
                            }
                        }
                        getStreamOnTranslationChange(e, i) {
                            if (!vc(e) || !e.length) throw new Error('Parameter "key" required');
                            return wm(Zb(() => this.get(e, i)), this.onTranslationChange.pipe(St(r => {
                                const s = this.getParsedResult(r.translations, e, i);
                                return "function" == typeof s.subscribe ? s : Ve(s)
                            })))
                        }
                        stream(e, i) {
                            if (!vc(e) || !e.length) throw new Error('Parameter "key" required');
                            return wm(Zb(() => this.get(e, i)), this.onLangChange.pipe(St(r => {
                                const s = this.getParsedResult(r.translations, e, i);
                                return ju(s) ? s : Ve(s)
                            })))
                        }
                        instant(e, i) {
                            if (!vc(e) || !e.length) throw new Error('Parameter "key" required');
                            let r = this.getParsedResult(this.translations[this.currentLang], e, i);
                            if (ju(r)) {
                                if (e instanceof Array) {
                                    let s = {};
                                    return e.forEach((o, a) => {
                                        s[e[a]] = e[a]
                                    }), s
                                }
                                return e
                            }
                            return r
                        }
                        set(e, i, r = this.currentLang) {
                            this.translations[r][e] = this.compiler.compile(i, r), this.updateLangs(), this.onTranslationChange.emit({
                                lang: r,
                                translations: this.translations[r]
                            })
                        }
                        changeLang(e) {
                            this.currentLang = e, this.onLangChange.emit({
                                lang: e,
                                translations: this.translations[e]
                            }), null == this.defaultLang && this.changeDefaultLang(e)
                        }
                        changeDefaultLang(e) {
                            this.defaultLang = e, this.onDefaultLangChange.emit({
                                lang: e,
                                translations: this.translations[e]
                            })
                        }
                        reloadLang(e) {
                            return this.resetLang(e), this.getTranslation(e)
                        }
                        resetLang(e) {
                            this._translationRequests[e] = void 0, this.translations[e] = void 0
                        }
                        getBrowserLang() {
                            if (typeof window > "u" || typeof window.navigator > "u") return;
                            let e = window.navigator.languages ? window.navigator.languages[0] : null;
                            return e = e || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, typeof e > "u" ? void 0 : (-1 !== e.indexOf("-") && (e = e.split("-")[0]), -1 !== e.indexOf("_") && (e = e.split("_")[0]), e)
                        }
                        getBrowserCultureLang() {
                            if (typeof window > "u" || typeof window.navigator > "u") return;
                            let e = window.navigator.languages ? window.navigator.languages[0] : null;
                            return e = e || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(m6), _t($y), _t(Xb), _t(Yb), _t(_2), _t(w2), _t(b2), _t(C2), _t(x2))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                na = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.translateService = e, this.element = i, this._ref = r, this.onTranslationChangeSub || (this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(s => {
                                s.lang === this.translateService.currentLang && this.checkNodes(!0, s.translations)
                            })), this.onLangChangeSub || (this.onLangChangeSub = this.translateService.onLangChange.subscribe(s => {
                                this.checkNodes(!0, s.translations)
                            })), this.onDefaultLangChangeSub || (this.onDefaultLangChangeSub = this.translateService.onDefaultLangChange.subscribe(s => {
                                this.checkNodes(!0)
                            }))
                        }
                        set translate(e) {
                            e && (this.key = e, this.checkNodes())
                        }
                        set translateParams(e) {
                            zy(this.currentParams, e) || (this.currentParams = e, this.checkNodes(!0))
                        }
                        ngAfterViewChecked() {
                            this.checkNodes()
                        }
                        checkNodes(e = !1, i) {
                            let r = this.element.nativeElement.childNodes;
                            r.length || (this.setContent(this.element.nativeElement, this.key), r = this.element.nativeElement.childNodes);
                            for (let s = 0; s < r.length; ++s) {
                                let o = r[s];
                                if (3 === o.nodeType) {
                                    let a;
                                    if (e && (o.lastKey = null), vc(o.lookupKey)) a = o.lookupKey;
                                    else if (this.key) a = this.key;
                                    else {
                                        let c = this.getContent(o),
                                            u = c.trim();
                                        u.length && (o.lookupKey = u, c !== o.currentValue ? (a = u, o.originalContent = c || o.originalContent) : o.originalContent ? a = o.originalContent.trim() : c !== o.currentValue && (a = u, o.originalContent = c || o.originalContent))
                                    }
                                    this.updateValue(a, o, i)
                                }
                            }
                        }
                        updateValue(e, i, r) {
                            if (e) {
                                if (i.lastKey === e && this.lastParams === this.currentParams) return;
                                this.lastParams = this.currentParams;
                                let s = o => {
                                    o !== e && (i.lastKey = e), i.originalContent || (i.originalContent = this.getContent(i)), i.currentValue = vc(o) ? o : i.originalContent || e, this.setContent(i, this.key ? i.currentValue : i.originalContent.replace(e, i.currentValue)), this._ref.markForCheck()
                                };
                                if (vc(r)) {
                                    let o = this.translateService.getParsedResult(r, e, this.currentParams);
                                    ju(o) ? o.subscribe({
                                        next: s
                                    }) : s(o)
                                } else this.translateService.get(e, this.currentParams).subscribe(s)
                            }
                        }
                        getContent(e) {
                            return vc(e.textContent) ? e.textContent : e.data
                        }
                        setContent(e, i) {
                            vc(e.textContent) ? e.textContent = i : e.data = i
                        }
                        ngOnDestroy() {
                            this.onLangChangeSub && this.onLangChangeSub.unsubscribe(), this.onDefaultLangChangeSub && this.onDefaultLangChangeSub.unsubscribe(), this.onTranslationChangeSub && this.onTranslationChangeSub.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(bc), We(ir), We(qa))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "translate", ""],
                            ["", "ngx-translate", ""]
                        ],
                        inputs: {
                            translate: "translate",
                            translateParams: "translateParams"
                        }
                    }), t
                })(),
                Sf = (() => {
                    class t {
                        constructor(e, i) {
                            this.translate = e, this._ref = i, this.value = "", this.lastKey = null, this.lastParams = []
                        }
                        updateValue(e, i, r) {
                            let s = o => {
                                this.value = void 0 !== o ? o : e, this.lastKey = e, this._ref.markForCheck()
                            };
                            if (r) {
                                let o = this.translate.getParsedResult(r, e, i);
                                ju(o.subscribe) ? o.subscribe(s) : s(o)
                            }
                            this.translate.get(e, i).subscribe(s)
                        }
                        transform(e, ...i) {
                            if (!e || !e.length) return e;
                            if (zy(e, this.lastKey) && zy(i, this.lastParams)) return this.value;
                            let r;
                            if (vc(i[0]) && i.length)
                                if ("string" == typeof i[0] && i[0].length) {
                                    let s = i[0].replace(/(\')?([a-zA-Z0-9_]+)(\')?(\s)?:/g, '"$2":').replace(/:(\s)?(\')(.*?)(\')/g, ':"$3"');
                                    try {
                                        r = JSON.parse(s)
                                    } catch {
                                        throw new SyntaxError(`Wrong parameter in TranslatePipe. Expected a valid Object, received: ${i[0]}`)
                                    }
                                } else "object" == typeof i[0] && !Array.isArray(i[0]) && (r = i[0]);
                            return this.lastKey = e, this.lastParams = i, this.updateValue(e, r), this._dispose(), this.onTranslationChange || (this.onTranslationChange = this.translate.onTranslationChange.subscribe(s => {
                                this.lastKey && s.lang === this.translate.currentLang && (this.lastKey = null, this.updateValue(e, r, s.translations))
                            })), this.onLangChange || (this.onLangChange = this.translate.onLangChange.subscribe(s => {
                                this.lastKey && (this.lastKey = null, this.updateValue(e, r, s.translations))
                            })), this.onDefaultLangChange || (this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(() => {
                                this.lastKey && (this.lastKey = null, this.updateValue(e, r))
                            })), this.value
                        }
                        _dispose() {
                            typeof this.onTranslationChange < "u" && (this.onTranslationChange.unsubscribe(), this.onTranslationChange = void 0), typeof this.onLangChange < "u" && (this.onLangChange.unsubscribe(), this.onLangChange = void 0), typeof this.onDefaultLangChange < "u" && (this.onDefaultLangChange.unsubscribe(), this.onDefaultLangChange = void 0)
                        }
                        ngOnDestroy() {
                            this._dispose()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(bc, 16), We(qa, 16))
                    }, t.\u0275pipe = Ps({
                        name: "translate",
                        type: t,
                        pure: !1
                    }), t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                SQ = (() => {
                    class t {
                        static forRoot(e = {}) {
                            return {
                                ngModule: t,
                                providers: [e.loader || {
                                    provide: $y,
                                    useClass: u6
                                }, e.compiler || {
                                    provide: Xb,
                                    useClass: p6
                                }, e.parser || {
                                    provide: Yb,
                                    useClass: f6
                                }, e.missingTranslationHandler || {
                                    provide: _2,
                                    useClass: d6
                                }, m6, {
                                    provide: b2,
                                    useValue: e.isolate
                                }, {
                                    provide: w2,
                                    useValue: e.useDefaultLang
                                }, {
                                    provide: C2,
                                    useValue: e.extend
                                }, {
                                    provide: x2,
                                    useValue: e.defaultLanguage
                                }, bc]
                            }
                        }
                        static forChild(e = {}) {
                            return {
                                ngModule: t,
                                providers: [e.loader || {
                                    provide: $y,
                                    useClass: u6
                                }, e.compiler || {
                                    provide: Xb,
                                    useClass: p6
                                }, e.parser || {
                                    provide: Yb,
                                    useClass: f6
                                }, e.missingTranslationHandler || {
                                    provide: _2,
                                    useClass: d6
                                }, {
                                    provide: b2,
                                    useValue: e.isolate
                                }, {
                                    provide: w2,
                                    useValue: e.useDefaultLang
                                }, {
                                    provide: C2,
                                    useValue: e.extend
                                }, {
                                    provide: x2,
                                    useValue: e.defaultLanguage
                                }, bc]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({}), t
                })();

            function ia(t, n) {
                return R((e, i) => {
                    let r = 0;
                    e.subscribe(Q(i, s => t.call(n, s, r++) && i.next(s)))
                })
            }

            function xm(t) {
                return R((n, e) => {
                    try {
                        n.subscribe(e)
                    } finally {
                        e.add(t)
                    }
                })
            }
            class Qb {}
            class Jb {}
            class Jl {
                constructor(n) {
                    this.normalizedNames = new Map, this.lazyUpdate = null, n ? "string" == typeof n ? this.lazyInit = () => {
                        this.headers = new Map, n.split("\n").forEach(e => {
                            const i = e.indexOf(":");
                            if (i > 0) {
                                const r = e.slice(0, i),
                                    s = r.toLowerCase(),
                                    o = e.slice(i + 1).trim();
                                this.maybeSetNormalizedName(r, s), this.headers.has(s) ? this.headers.get(s).push(o) : this.headers.set(s, [o])
                            }
                        })
                    } : typeof Headers < "u" && n instanceof Headers ? (this.headers = new Map, n.forEach((e, i) => {
                        this.setHeaderEntries(i, e)
                    })) : this.lazyInit = () => {
                        this.headers = new Map, Object.entries(n).forEach(([e, i]) => {
                            this.setHeaderEntries(e, i)
                        })
                    } : this.headers = new Map
                }
                has(n) {
                    return this.init(), this.headers.has(n.toLowerCase())
                }
                get(n) {
                    this.init();
                    const e = this.headers.get(n.toLowerCase());
                    return e && e.length > 0 ? e[0] : null
                }
                keys() {
                    return this.init(), Array.from(this.normalizedNames.values())
                }
                getAll(n) {
                    return this.init(), this.headers.get(n.toLowerCase()) || null
                }
                append(n, e) {
                    return this.clone({
                        name: n,
                        value: e,
                        op: "a"
                    })
                }
                set(n, e) {
                    return this.clone({
                        name: n,
                        value: e,
                        op: "s"
                    })
                }
                delete(n, e) {
                    return this.clone({
                        name: n,
                        value: e,
                        op: "d"
                    })
                }
                maybeSetNormalizedName(n, e) {
                    this.normalizedNames.has(e) || this.normalizedNames.set(e, n)
                }
                init() {
                    this.lazyInit && (this.lazyInit instanceof Jl ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null))
                }
                copyFrom(n) {
                    n.init(), Array.from(n.headers.keys()).forEach(e => {
                        this.headers.set(e, n.headers.get(e)), this.normalizedNames.set(e, n.normalizedNames.get(e))
                    })
                }
                clone(n) {
                    const e = new Jl;
                    return e.lazyInit = this.lazyInit && this.lazyInit instanceof Jl ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([n]), e
                }
                applyUpdate(n) {
                    const e = n.name.toLowerCase();
                    switch (n.op) {
                        case "a":
                        case "s":
                            let i = n.value;
                            if ("string" == typeof i && (i = [i]), 0 === i.length) return;
                            this.maybeSetNormalizedName(n.name, e);
                            const r = ("a" === n.op ? this.headers.get(e) : void 0) || [];
                            r.push(...i), this.headers.set(e, r);
                            break;
                        case "d":
                            const s = n.value;
                            if (s) {
                                let o = this.headers.get(e);
                                if (!o) return;
                                o = o.filter(a => -1 === s.indexOf(a)), 0 === o.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, o)
                            } else this.headers.delete(e), this.normalizedNames.delete(e)
                    }
                }
                setHeaderEntries(n, e) {
                    const i = (Array.isArray(e) ? e : [e]).map(s => s.toString()),
                        r = n.toLowerCase();
                    this.headers.set(r, i), this.maybeSetNormalizedName(n, r)
                }
                forEach(n) {
                    this.init(), Array.from(this.normalizedNames.keys()).forEach(e => n(this.normalizedNames.get(e), this.headers.get(e)))
                }
            }
            class EQ {
                encodeKey(n) {
                    return g6(n)
                }
                encodeValue(n) {
                    return g6(n)
                }
                decodeKey(n) {
                    return decodeURIComponent(n)
                }
                decodeValue(n) {
                    return decodeURIComponent(n)
                }
            }
            const AQ = /%(\d[a-f0-9])/gi,
                kQ = {
                    40: "@",
                    "3A": ":",
                    24: "$",
                    "2C": ",",
                    "3B": ";",
                    "3D": "=",
                    "3F": "?",
                    "2F": "/"
                };

            function g6(t) {
                return encodeURIComponent(t).replace(AQ, (n, e) => kQ[e] ? ? n)
            }

            function ew(t) {
                return `${t}`
            }
            class ih {
                constructor(n = {}) {
                    if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new EQ, n.fromString) {
                        if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                        this.map = function DQ(t, n) {
                            const e = new Map;
                            return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(r => {
                                const s = r.indexOf("="),
                                    [o, a] = -1 == s ? [n.decodeKey(r), ""] : [n.decodeKey(r.slice(0, s)), n.decodeValue(r.slice(s + 1))],
                                    c = e.get(o) || [];
                                c.push(a), e.set(o, c)
                            }), e
                        }(n.fromString, this.encoder)
                    } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(e => {
                        const i = n.fromObject[e],
                            r = Array.isArray(i) ? i.map(ew) : [ew(i)];
                        this.map.set(e, r)
                    })) : this.map = null
                }
                has(n) {
                    return this.init(), this.map.has(n)
                }
                get(n) {
                    this.init();
                    const e = this.map.get(n);
                    return e ? e[0] : null
                }
                getAll(n) {
                    return this.init(), this.map.get(n) || null
                }
                keys() {
                    return this.init(), Array.from(this.map.keys())
                }
                append(n, e) {
                    return this.clone({
                        param: n,
                        value: e,
                        op: "a"
                    })
                }
                appendAll(n) {
                    const e = [];
                    return Object.keys(n).forEach(i => {
                        const r = n[i];
                        Array.isArray(r) ? r.forEach(s => {
                            e.push({
                                param: i,
                                value: s,
                                op: "a"
                            })
                        }) : e.push({
                            param: i,
                            value: r,
                            op: "a"
                        })
                    }), this.clone(e)
                }
                set(n, e) {
                    return this.clone({
                        param: n,
                        value: e,
                        op: "s"
                    })
                }
                delete(n, e) {
                    return this.clone({
                        param: n,
                        value: e,
                        op: "d"
                    })
                }
                toString() {
                    return this.init(), this.keys().map(n => {
                        const e = this.encoder.encodeKey(n);
                        return this.map.get(n).map(i => e + "=" + this.encoder.encodeValue(i)).join("&")
                    }).filter(n => "" !== n).join("&")
                }
                clone(n) {
                    const e = new ih({
                        encoder: this.encoder
                    });
                    return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(n), e
                }
                init() {
                    null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => {
                        switch (n.op) {
                            case "a":
                            case "s":
                                const e = ("a" === n.op ? this.map.get(n.param) : void 0) || [];
                                e.push(ew(n.value)), this.map.set(n.param, e);
                                break;
                            case "d":
                                if (void 0 === n.value) {
                                    this.map.delete(n.param);
                                    break
                                } {
                                    let i = this.map.get(n.param) || [];
                                    const r = i.indexOf(ew(n.value)); - 1 !== r && i.splice(r, 1), i.length > 0 ? this.map.set(n.param, i) : this.map.delete(n.param)
                                }
                        }
                    }), this.cloneFrom = this.updates = null)
                }
            }
            class MQ {
                constructor() {
                    this.map = new Map
                }
                set(n, e) {
                    return this.map.set(n, e), this
                }
                get(n) {
                    return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n)
                }
                delete(n) {
                    return this.map.delete(n), this
                }
                has(n) {
                    return this.map.has(n)
                }
                keys() {
                    return this.map.keys()
                }
            }

            function y6(t) {
                return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer
            }

            function _6(t) {
                return typeof Blob < "u" && t instanceof Blob
            }

            function v6(t) {
                return typeof FormData < "u" && t instanceof FormData
            }
            class jy {
                constructor(n, e, i, r) {
                    let s;
                    if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function IQ(t) {
                            switch (t) {
                                case "DELETE":
                                case "GET":
                                case "HEAD":
                                case "OPTIONS":
                                case "JSONP":
                                    return !1;
                                default:
                                    return !0
                            }
                        }(this.method) || r ? (this.body = void 0 !== i ? i : null, s = r) : s = i, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new Jl), this.context || (this.context = new MQ), this.params) {
                        const o = this.params.toString();
                        if (0 === o.length) this.urlWithParams = e;
                        else {
                            const a = e.indexOf("?");
                            this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + o
                        }
                    } else this.params = new ih, this.urlWithParams = e
                }
                serializeBody() {
                    return null === this.body ? null : y6(this.body) || _6(this.body) || v6(this.body) || function PQ(t) {
                        return typeof URLSearchParams < "u" && t instanceof URLSearchParams
                    }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof ih ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
                }
                detectContentTypeHeader() {
                    return null === this.body || v6(this.body) ? null : _6(this.body) ? this.body.type || null : y6(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof ih ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null
                }
                clone(n = {}) {
                    const e = n.method || this.method,
                        i = n.url || this.url,
                        r = n.responseType || this.responseType,
                        s = void 0 !== n.body ? n.body : this.body,
                        o = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials,
                        a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress;
                    let c = n.headers || this.headers,
                        u = n.params || this.params;
                    const h = n.context ? ? this.context;
                    return void 0 !== n.setHeaders && (c = Object.keys(n.setHeaders).reduce((m, x) => m.set(x, n.setHeaders[x]), c)), n.setParams && (u = Object.keys(n.setParams).reduce((m, x) => m.set(x, n.setParams[x]), u)), new jy(e, i, s, {
                        params: u,
                        headers: c,
                        context: h,
                        reportProgress: a,
                        responseType: r,
                        withCredentials: o
                    })
                }
            }
            var Cm = function(t) {
                return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t
            }(Cm || {});
            class T2 {
                constructor(n, e = 200, i = "OK") {
                    this.headers = n.headers || new Jl, this.status = void 0 !== n.status ? n.status : e, this.statusText = n.statusText || i, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300
                }
            }
            class S2 extends T2 {
                constructor(n = {}) {
                    super(n), this.type = Cm.ResponseHeader
                }
                clone(n = {}) {
                    return new S2({
                        headers: n.headers || this.headers,
                        status: void 0 !== n.status ? n.status : this.status,
                        statusText: n.statusText || this.statusText,
                        url: n.url || this.url || void 0
                    })
                }
            }
            class Tm extends T2 {
                constructor(n = {}) {
                    super(n), this.type = Cm.Response, this.body = void 0 !== n.body ? n.body : null
                }
                clone(n = {}) {
                    return new Tm({
                        body: void 0 !== n.body ? n.body : this.body,
                        headers: n.headers || this.headers,
                        status: void 0 !== n.status ? n.status : this.status,
                        statusText: n.statusText || this.statusText,
                        url: n.url || this.url || void 0
                    })
                }
            }
            class b6 extends T2 {
                constructor(n) {
                    super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url||"(unknown url)"}` : `Http failure response for ${n.url||"(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null
                }
            }

            function E2(t, n) {
                return {
                    body: n,
                    headers: t.headers,
                    context: t.context,
                    observe: t.observe,
                    params: t.params,
                    reportProgress: t.reportProgress,
                    responseType: t.responseType,
                    withCredentials: t.withCredentials
                }
            }
            let Ef = (() => {
                class t {
                    constructor(e) {
                        this.handler = e
                    }
                    request(e, i, r = {}) {
                        let s;
                        if (e instanceof jy) s = e;
                        else {
                            let c, u;
                            c = r.headers instanceof Jl ? r.headers : new Jl(r.headers), r.params && (u = r.params instanceof ih ? r.params : new ih({
                                fromObject: r.params
                            })), s = new jy(e, i, void 0 !== r.body ? r.body : null, {
                                headers: c,
                                context: r.context,
                                params: u,
                                reportProgress: r.reportProgress,
                                responseType: r.responseType || "json",
                                withCredentials: r.withCredentials
                            })
                        }
                        const o = Ve(s).pipe(Tf(c => this.handler.handle(c)));
                        if (e instanceof jy || "events" === r.observe) return o;
                        const a = o.pipe(ia(c => c instanceof Tm));
                        switch (r.observe || "body") {
                            case "body":
                                switch (s.responseType) {
                                    case "arraybuffer":
                                        return a.pipe(Fe(c => {
                                            if (null !== c.body && !(c.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                            return c.body
                                        }));
                                    case "blob":
                                        return a.pipe(Fe(c => {
                                            if (null !== c.body && !(c.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                            return c.body
                                        }));
                                    case "text":
                                        return a.pipe(Fe(c => {
                                            if (null !== c.body && "string" != typeof c.body) throw new Error("Response is not a string.");
                                            return c.body
                                        }));
                                    default:
                                        return a.pipe(Fe(c => c.body))
                                }
                            case "response":
                                return a;
                            default:
                                throw new Error(`Unreachable: unhandled observe type ${r.observe}}`)
                        }
                    }
                    delete(e, i = {}) {
                        return this.request("DELETE", e, i)
                    }
                    get(e, i = {}) {
                        return this.request("GET", e, i)
                    }
                    head(e, i = {}) {
                        return this.request("HEAD", e, i)
                    }
                    jsonp(e, i) {
                        return this.request("JSONP", e, {
                            params: (new ih).append(i, "JSONP_CALLBACK"),
                            observe: "body",
                            responseType: "json"
                        })
                    }
                    options(e, i = {}) {
                        return this.request("OPTIONS", e, i)
                    }
                    patch(e, i, r = {}) {
                        return this.request("PATCH", e, E2(r, i))
                    }
                    post(e, i, r = {}) {
                        return this.request("POST", e, E2(r, i))
                    }
                    put(e, i, r = {}) {
                        return this.request("PUT", e, E2(r, i))
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Qb))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();

            function C6(t, n) {
                return n(t)
            }

            function LQ(t, n) {
                return (e, i) => n.intercept(e, {
                    handle: r => t(r, i)
                })
            }
            const BQ = new nn(""),
                Wy = new nn(""),
                T6 = new nn("");

            function NQ() {
                let t = null;
                return (n, e) => {
                    null === t && (t = (vn(BQ, {
                        optional: !0
                    }) ? ? []).reduceRight(LQ, C6));
                    const i = vn(hb),
                        r = i.add();
                    return t(n, e).pipe(xm(() => i.remove(r)))
                }
            }
            let S6 = (() => {
                class t extends Qb {
                    constructor(e, i) {
                        super(), this.backend = e, this.injector = i, this.chain = null, this.pendingTasks = vn(hb)
                    }
                    handle(e) {
                        if (null === this.chain) {
                            const r = Array.from(new Set([...this.injector.get(Wy), ...this.injector.get(T6, [])]));
                            this.chain = r.reduceRight((s, o) => function RQ(t, n, e) {
                                return (i, r) => e.runInContext(() => n(i, s => t(s, r)))
                            }(s, o, this.injector), C6)
                        }
                        const i = this.pendingTasks.add();
                        return this.chain(e, r => this.backend.handle(r)).pipe(xm(() => this.pendingTasks.remove(i)))
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Jb), _t(hc))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const HQ = /^\)\]\}',?\n/;
            let D6 = (() => {
                class t {
                    constructor(e) {
                        this.xhrFactory = e
                    }
                    handle(e) {
                        if ("JSONP" === e.method) throw new mt(-2800, !1);
                        const i = this.xhrFactory;
                        return (i.\u0275loadImpl ? gn(i.\u0275loadImpl()) : Ve(null)).pipe(St(() => new M(s => {
                            const o = i.build();
                            if (o.open(e.method, e.urlWithParams), e.withCredentials && (o.withCredentials = !0), e.headers.forEach((te, ee) => o.setRequestHeader(te, ee.join(","))), e.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) {
                                const te = e.detectContentTypeHeader();
                                null !== te && o.setRequestHeader("Content-Type", te)
                            }
                            if (e.responseType) {
                                const te = e.responseType.toLowerCase();
                                o.responseType = "json" !== te ? te : "text"
                            }
                            const a = e.serializeBody();
                            let c = null;
                            const u = () => {
                                    if (null !== c) return c;
                                    const te = o.statusText || "OK",
                                        ee = new Jl(o.getAllResponseHeaders()),
                                        _e = function $Q(t) {
                                            return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null
                                        }(o) || e.url;
                                    return c = new S2({
                                        headers: ee,
                                        status: o.status,
                                        statusText: te,
                                        url: _e
                                    }), c
                                },
                                h = () => {
                                    let {
                                        headers: te,
                                        status: ee,
                                        statusText: _e,
                                        url: ye
                                    } = u(), Be = null;
                                    204 !== ee && (Be = typeof o.response > "u" ? o.responseText : o.response), 0 === ee && (ee = Be ? 200 : 0);
                                    let ze = ee >= 200 && ee < 300;
                                    if ("json" === e.responseType && "string" == typeof Be) {
                                        const Xe = Be;
                                        Be = Be.replace(HQ, "");
                                        try {
                                            Be = "" !== Be ? JSON.parse(Be) : null
                                        } catch (ht) {
                                            Be = Xe, ze && (ze = !1, Be = {
                                                error: ht,
                                                text: Be
                                            })
                                        }
                                    }
                                    ze ? (s.next(new Tm({
                                        body: Be,
                                        headers: te,
                                        status: ee,
                                        statusText: _e,
                                        url: ye || void 0
                                    })), s.complete()) : s.error(new b6({
                                        error: Be,
                                        headers: te,
                                        status: ee,
                                        statusText: _e,
                                        url: ye || void 0
                                    }))
                                },
                                m = te => {
                                    const {
                                        url: ee
                                    } = u(), _e = new b6({
                                        error: te,
                                        status: o.status || 0,
                                        statusText: o.statusText || "Unknown Error",
                                        url: ee || void 0
                                    });
                                    s.error(_e)
                                };
                            let x = !1;
                            const D = te => {
                                    x || (s.next(u()), x = !0);
                                    let ee = {
                                        type: Cm.DownloadProgress,
                                        loaded: te.loaded
                                    };
                                    te.lengthComputable && (ee.total = te.total), "text" === e.responseType && o.responseText && (ee.partialText = o.responseText), s.next(ee)
                                },
                                V = te => {
                                    let ee = {
                                        type: Cm.UploadProgress,
                                        loaded: te.loaded
                                    };
                                    te.lengthComputable && (ee.total = te.total), s.next(ee)
                                };
                            return o.addEventListener("load", h), o.addEventListener("error", m), o.addEventListener("timeout", m), o.addEventListener("abort", m), e.reportProgress && (o.addEventListener("progress", D), null !== a && o.upload && o.upload.addEventListener("progress", V)), o.send(a), s.next({
                                type: Cm.Sent
                            }), () => {
                                o.removeEventListener("error", m), o.removeEventListener("abort", m), o.removeEventListener("load", h), o.removeEventListener("timeout", m), e.reportProgress && (o.removeEventListener("progress", D), null !== a && o.upload && o.upload.removeEventListener("progress", V)), o.readyState !== o.DONE && o.abort()
                            }
                        })))
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(iR))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const D2 = new nn("XSRF_ENABLED"),
                A6 = new nn("XSRF_COOKIE_NAME", {
                    providedIn: "root",
                    factory: () => "XSRF-TOKEN"
                }),
                k6 = new nn("XSRF_HEADER_NAME", {
                    providedIn: "root",
                    factory: () => "X-XSRF-TOKEN"
                });
            class M6 {}
            let WQ = (() => {
                class t {
                    constructor(e, i, r) {
                        this.doc = e, this.platform = i, this.cookieName = r, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0
                    }
                    getToken() {
                        if ("server" === this.platform) return null;
                        const e = this.doc.cookie || "";
                        return e !== this.lastCookieString && (this.parseCount++, this.lastToken = K5(e, this.cookieName), this.lastCookieString = e), this.lastToken
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Ss), _t(Bs), _t(A6))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();

            function GQ(t, n) {
                const e = t.url.toLowerCase();
                if (!vn(D2) || "GET" === t.method || "HEAD" === t.method || e.startsWith("http://") || e.startsWith("https://")) return n(t);
                const i = vn(M6).getToken(),
                    r = vn(k6);
                return null != i && !t.headers.has(r) && (t = t.clone({
                    headers: t.headers.set(r, i)
                })), n(t)
            }
            var rh = function(t) {
                return t[t.Interceptors = 0] = "Interceptors", t[t.LegacyInterceptors = 1] = "LegacyInterceptors", t[t.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", t[t.NoXsrfProtection = 3] = "NoXsrfProtection", t[t.JsonpSupport = 4] = "JsonpSupport", t[t.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", t[t.Fetch = 6] = "Fetch", t
            }(rh || {});

            function KQ(...t) {
                const n = [Ef, D6, S6, {
                    provide: Qb,
                    useExisting: S6
                }, {
                    provide: Jb,
                    useExisting: D6
                }, {
                    provide: Wy,
                    useValue: GQ,
                    multi: !0
                }, {
                    provide: D2,
                    useValue: !0
                }, {
                    provide: M6,
                    useClass: WQ
                }];
                for (const e of t) n.push(...e.\u0275providers);
                return function BC(t) {
                    return {\
                        u0275providers: t
                    }
                }(n)
            }
            const I6 = new nn("LEGACY_INTERCEPTOR_FN");

            function qQ() {
                return function Df(t, n) {
                    return {\
                        u0275kind: t,
                        \u0275providers: n
                    }
                }(rh.LegacyInterceptors, [{
                    provide: I6,
                    useFactory: NQ
                }, {
                    provide: Wy,
                    useExisting: I6,
                    multi: !0
                }])
            }
            let ZQ = (() => {
                class t {
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275mod = _i({
                        type: t
                    });
                    static# n = this.\u0275inj = wi({
                        providers: [KQ(qQ())]
                    })
                }
                return t
            })();
            class tJ {
                constructor(n, e = "/assets/i18n/", i = ".json") {
                    this.http = n, this.prefix = e, this.suffix = i
                }
                getTranslation(n) {
                    return this.http.get(`${this.prefix}${n}${this.suffix}`)
                }
            }

            function Af(t, n) {
                const e = F(t) ? t : () => t,
                    i = r => r.error(e());
                return new M(n ? r => n.schedule(i, 0, r) : i)
            }

            function Ui(t, n, e) {
                const i = F(t) || n || e ? {
                    next: t,
                    error: n,
                    complete: e
                } : t;
                return i ? R((r, s) => {
                    var o;
                    null === (o = i.subscribe) || void 0 === o || o.call(i);
                    let a = !0;
                    r.subscribe(Q(s, c => {
                        var u;
                        null === (u = i.next) || void 0 === u || u.call(i, c), s.next(c)
                    }, () => {
                        var c;
                        a = !1, null === (c = i.complete) || void 0 === c || c.call(i), s.complete()
                    }, c => {
                        var u;
                        a = !1, null === (u = i.error) || void 0 === u || u.call(i, c), s.error(c)
                    }, () => {
                        var c, u;
                        a && (null === (c = i.unsubscribe) || void 0 === c || c.call(i)), null === (u = i.finalize) || void 0 === u || u.call(i)
                    }))
                }) : $
            }

            function sh(t) {
                return R((n, e) => {
                    let s, i = null,
                        r = !1;
                    i = n.subscribe(Q(e, void 0, void 0, o => {
                        s = ji(t(o, sh(t)(n))), i ? (i.unsubscribe(), i = null, s.subscribe(e)) : r = !0
                    })), r && (i.unsubscribe(), i = null, s.subscribe(e))
                })
            }
            const nJ = ["*"];
            class nw {}
            let iJ = (() => {
                class t extends nw {
                    constructor(e) {
                        super(), this.http = e
                    }
                    getSvg(e) {
                        return this.http.get(e, {
                            responseType: "text"
                        })
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_t(Ef))
                }, t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const P6 = new nn("SERVER_URL");
            let iw = (() => {
                class t {
                    constructor(e, i, r, s) {
                        this.loader = e, this.platformId = i, this.serverUrl = r, this._document = s, this.iconsByUrl = new Map, this.iconsLoadingByUrl = new Map, this.document = this._document
                    }
                    addSvg(e, i) {
                        if (!this.iconsByUrl.has(e)) {
                            const r = this.document.createElement("DIV");
                            r.innerHTML = i;
                            const s = r.querySelector("svg");
                            this.iconsByUrl.set(e, s)
                        }
                    }
                    loadSvg(e, i = e) {
                        if (this.serverUrl && null === e.match(/^(http(s)?):/) && (i = e = this.serverUrl + e), this.iconsByUrl.has(i)) return Ve(this.iconsByUrl.get(i));
                        if (this.iconsLoadingByUrl.has(i)) return this.iconsLoadingByUrl.get(i);
                        const r = this.loader.getSvg(e).pipe(Fe(s => {
                            const o = this.document.createElement("DIV");
                            return o.innerHTML = s, o.querySelector("svg")
                        }), Ui(s => this.iconsByUrl.set(i, s)), sh(s => (console.error(s), Af(s))), xm(() => this.iconsLoadingByUrl.delete(i)), at());
                        return this.iconsLoadingByUrl.set(i, r), r
                    }
                    getSvgByName(e) {
                        return this.iconsByUrl.has(e) ? Ve(this.iconsByUrl.get(e)) : this.iconsLoadingByUrl.has(e) ? this.iconsLoadingByUrl.get(e) : Af(`No svg with name '${e}' has been loaded`)
                    }
                    unloadSvg(e) {
                        this.iconsByUrl.has(e) && this.iconsByUrl.delete(e)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_t(nw), _t(Bs), _t(P6, 8), _t(Ss, 8))
                }, t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const sJ = {
                provide: iw,
                deps: [
                    [new zl, new jd, iw], nw, [Bs],
                    [new zl, P6],
                    [new zl, Ss]
                ],
                useFactory: function rJ(t, n, e, i, r) {
                    return t || new iw(n, e, i, r)
                }
            };
            class O6 {
                constructor() {
                    this.loaded = !1
                }
            }
            let kf = (() => {
                    class t {
                        constructor(e, i, r, s, o) {
                            this.element = e, this.differs = i, this.renderer = r, this.iconReg = s, this.cdr = o, this.stretch = !1, this.applyClass = !1, this.applyCss = !1, this.helper = new O6, this._svgStyle = null
                        }
                        set svgStyle(e) {
                            this._svgStyle = e, !this.helper.differ && e && (this.helper.differ = this.differs.find(e).create())
                        }
                        ngOnInit() {
                            this.init()
                        }
                        ngOnDestroy() {
                            this.destroy()
                        }
                        ngOnChanges(e) {
                            const i = this.element.nativeElement.firstChild;
                            (e.src || e.name) && (this.helper.loaded && this.destroy(), this.init()), e.stretch && this.stylize(), e.applyClass && (this.applyClass ? this.setClass(i, null, this.klass) : this.setClass(i, this.klass, null)), e.svgClass && this.setClass(i, e.svgClass.previousValue, e.svgClass.currentValue), e.klass && (this.setClass(this.element.nativeElement, e.klass.previousValue, e.klass.currentValue), this.setClass(i, e.klass.previousValue, this.applyClass ? e.klass.currentValue : null)), e.viewBox && (this.helper.loaded && this.destroy(), this.init()), e.applyCss && (console.warn("applyCss deprecated since 9.1.0, will be removed in 10.0.0"), console.warn("use applyClass instead")), e.svgAriaLabel && this.doAria(e.svgAriaLabel.currentValue)
                        }
                        ngDoCheck() {
                            if (this.helper.svg && this.helper.differ) {
                                const e = this.helper.differ.diff(this._svgStyle);
                                e && this.applyChanges(e)
                            }
                        }
                        init() {
                            if (this.name) {
                                const e = this.iconReg.getSvgByName(this.name);
                                e && (this.helper.icnSub = e.subscribe(i => this.initSvg(i)))
                            } else if (this.src) {
                                const e = this.iconReg.loadSvg(this.src);
                                e && (this.helper.icnSub = e.subscribe(i => this.initSvg(i)))
                            } else this.element.nativeElement.innerHTML = "", this.cdr.markForCheck()
                        }
                        initSvg(e) {
                            !this.helper.loaded && e && (this.setSvg(e), this.resetDiffer())
                        }
                        destroy() {
                            this.helper.icnSub && this.helper.icnSub.unsubscribe(), this.helper = new O6
                        }
                        resetDiffer() {
                            this._svgStyle && !this.helper.differ && (this.helper.differ = this.differs.find(this._svgStyle).create())
                        }
                        setSvg(e) {
                            if (!this.helper.loaded && e) {
                                this.helper.svg = e;
                                const i = e.cloneNode(!0),
                                    r = this.element.nativeElement;
                                if (r.innerHTML = "", this.renderer.appendChild(r, i), this.helper.loaded = !0, this.copyNgContentAttribute(r, i), this.klass && this.applyClass && this.setClass(r.firstChild, null, this.klass), this.svgClass && this.setClass(r.firstChild, null, this.svgClass), this.viewBox)
                                    if ("auto" === this.viewBox) {
                                        const s = i.getAttribute("width"),
                                            o = i.getAttribute("height");
                                        o && s && (this.renderer.setAttribute(i, "viewBox", `0 0 ${s} ${o}`), this.renderer.removeAttribute(i, "width"), this.renderer.removeAttribute(i, "height"))
                                    } else "" !== this.viewBox && (this.renderer.setAttribute(i, "viewBox", this.viewBox), this.renderer.removeAttribute(i, "width"), this.renderer.removeAttribute(i, "height"));
                                this.stylize(), void 0 === this.svgAriaLabel && r.firstChild.hasAttribute("aria-label") || this.doAria(this.svgAriaLabel || ""), this.cdr.markForCheck()
                            }
                        }
                        copyNgContentAttribute(e, i) {
                            const r = e.attributes,
                                s = r.length;
                            for (let o = 0; o < s; o += 1) {
                                const a = r.item(o);
                                if (a && a.name.startsWith("_ngcontent")) {
                                    this.setNgContentAttribute(i, a.name);
                                    break
                                }
                            }
                        }
                        setNgContentAttribute(e, i) {
                            this.renderer.setAttribute(e, i, "");
                            const r = e.childNodes.length;
                            for (let s = 0; s < r; s += 1) {
                                const o = e.childNodes[s];
                                o instanceof Element && this.setNgContentAttribute(o, i)
                            }
                        }
                        stylize() {
                            if (this.helper.svg) {
                                const e = this.element.nativeElement.firstChild;
                                !0 === this.stretch ? this.renderer.setAttribute(e, "preserveAspectRatio", "none") : !1 === this.stretch && this.renderer.removeAttribute(e, "preserveAspectRatio")
                            }
                        }
                        applyChanges(e) {
                            e.forEachRemovedItem(i => this.setStyle(i.key, null)), e.forEachAddedItem(i => this.setStyle(i.key, i.currentValue)), e.forEachChangedItem(i => this.setStyle(i.key, i.currentValue))
                        }
                        setStyle(e, i) {
                            const [r, s] = e.split("."), o = this.element.nativeElement.firstChild;
                            null !== (i = null !== i && s ? `${i}${s}` : i) ? this.renderer.setStyle(o, r, i) : this.renderer.removeStyle(o, r)
                        }
                        setClass(e, i, r) {
                            if (e) {
                                if (i) {
                                    const s = (Array.isArray(i) ? i : i.split(" ")).filter(o => o);
                                    for (const o of s) this.renderer.removeClass(e, o)
                                }
                                if (r) {
                                    const s = (Array.isArray(r) ? r : r.split(" ")).filter(o => o);
                                    for (const o of s) this.renderer.addClass(e, o)
                                }
                            }
                        }
                        doAria(e) {
                            const i = this.element.nativeElement.firstChild;
                            i && ("" === e ? (this.renderer.setAttribute(i, "aria-hidden", "true"), this.renderer.removeAttribute(i, "aria-label")) : (this.renderer.removeAttribute(i, "aria-hidden"), this.renderer.setAttribute(i, "aria-label", e)))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(gm), We(Ks), We(iw), We(qa))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["svg-icon"]
                        ],
                        inputs: {
                            src: "src",
                            name: "name",
                            stretch: "stretch",
                            applyClass: "applyClass",
                            applyCss: "applyCss",
                            svgClass: "svgClass",
                            klass: ["class", "klass"],
                            viewBox: "viewBox",
                            svgAriaLabel: "svgAriaLabel",
                            svgStyle: "svgStyle"
                        },
                        features: [Xi],
                        ngContentSelectors: nJ,
                        decls: 1,
                        vars: 0,
                        template: function(e, i) {
                            1 & e && (Zd(), Ru(0))
                        },
                        encapsulation: 2
                    }), t
                })(),
                oJ = (() => {
                    class t {
                        static forRoot(e = {}) {
                            return {
                                ngModule: t,
                                providers: [sJ, e.loader || {
                                    provide: nw,
                                    useClass: iJ
                                }]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [mc]
                        ]
                    }), t
                })();
            class aJ {
                constructor(n, e) {
                    this.open = n, this.close = e || n
                }
                isManual() {
                    return "manual" === this.open || "manual" === this.close
                }
            }
            const cJ = {
                hover: ["mouseover", "mouseout"],
                focus: ["focusin", "focusout"]
            };
            const mo = typeof window < "u" && window || {},
                go = mo.document;
            var R6 = function(t) {
                return t.isBs4 = "bs4", t.isBs5 = "bs5", t
            }(R6 || {});
            let Wu;

            function B6() {
                const t = mo.document.createElement("span");
                t.innerText = "testing bs version", t.classList.add("d-none"), t.classList.add("pl-1"), mo.document.head.appendChild(t);
                const n = mo.getComputedStyle(t).paddingLeft;
                return n && parseFloat(n) ? (mo.document.head.removeChild(t), "bs4") : (mo.document.head.removeChild(t), "bs5")
            }

            function Gy() {
                return {
                    isBs4: (Wu || (Wu = B6()), "bs4" === Wu),
                    isBs5: (Wu || (Wu = B6()), "bs5" === Wu)
                }
            }
            class mJ {
                static reflow(n) {}
                static getStyles(n) {
                    let e = n.ownerDocument.defaultView;
                    return (!e || !e.opener) && (e = mo), e.getComputedStyle(n)
                }
                static stackOverflowConfig() {
                    const n = function pJ() {
                        const t = Gy(),
                            n = Object.keys(t).find(e => t[e]);
                        return R6[n]
                    }();
                    return {
                        crossorigin: "anonymous",
                        integrity: "bs5" === n ? "sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" : "sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2",
                        cdnLink: "bs5" === n ? "https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" : "https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
                    }
                }
            }
            typeof console > "u" || console;
            const yJ = ["addListener", "removeListener"],
                _J = ["addEventListener", "removeEventListener"],
                vJ = ["on", "off"];

            function Sm(t, n, e, i) {
                if (F(e) && (i = e, e = void 0), i) return Sm(t, n, e).pipe(g2(i));
                const [r, s] = function xJ(t) {
                    return F(t.addEventListener) && F(t.removeEventListener)
                }(t) ? _J.map(o => a => t[o](n, a, e)): function bJ(t) {
                    return F(t.addListener) && F(t.removeListener)
                }(t) ? yJ.map(F6(t, n)) : function wJ(t) {
                    return F(t.on) && F(t.off)
                }(t) ? vJ.map(F6(t, n)) : [];
                if (!r && wt(t)) return ke(o => Sm(o, n, e))(ji(t));
                if (!r) throw new TypeError("Invalid event target");
                return new M(o => {
                    const a = (...c) => o.next(1 < c.length ? c : c[0]);
                    return r(a), () => s(a)
                })
            }

            function F6(t, n) {
                return e => i => t[e](n, i)
            }
            class CJ extends S {
                constructor(n, e) {
                    super()
                }
                schedule(n, e = 0) {
                    return this
                }
            }
            const rw = {
                setInterval(t, n, ...e) {
                    const {
                        delegate: i
                    } = rw;
                    return i ? .setInterval ? i.setInterval(t, n, ...e) : setInterval(t, n, ...e)
                },
                clearInterval(t) {
                    const {
                        delegate: n
                    } = rw;
                    return (n ? .clearInterval || clearInterval)(t)
                },
                delegate: void 0
            };
            class V6 extends CJ {
                constructor(n, e) {
                    super(n, e), this.scheduler = n, this.work = e, this.pending = !1
                }
                schedule(n, e = 0) {
                    var i;
                    if (this.closed) return this;
                    this.state = n;
                    const r = this.id,
                        s = this.scheduler;
                    return null != r && (this.id = this.recycleAsyncId(s, r, e)), this.pending = !0, this.delay = e, this.id = null !== (i = this.id) && void 0 !== i ? i : this.requestAsyncId(s, this.id, e), this
                }
                requestAsyncId(n, e, i = 0) {
                    return rw.setInterval(n.flush.bind(n, this), i)
                }
                recycleAsyncId(n, e, i = 0) {
                    if (null != i && this.delay === i && !1 === this.pending) return e;
                    null != e && rw.clearInterval(e)
                }
                execute(n, e) {
                    if (this.closed) return new Error("executing a cancelled action");
                    this.pending = !1;
                    const i = this._execute(n, e);
                    if (i) return i;
                    !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
                }
                _execute(n, e) {
                    let r, i = !1;
                    try {
                        this.work(n)
                    } catch (s) {
                        i = !0, r = s || new Error("Scheduled action threw falsy error")
                    }
                    if (i) return this.unsubscribe(), r
                }
                unsubscribe() {
                    if (!this.closed) {
                        const {
                            id: n,
                            scheduler: e
                        } = this, {
                            actions: i
                        } = e;
                        this.work = this.state = this.scheduler = null, this.pending = !1, ne(i, this), null != n && (this.id = this.recycleAsyncId(e, n, null)), this.delay = null, super.unsubscribe()
                    }
                }
            }
            const Ky = {
                schedule(t) {
                    let n = requestAnimationFrame,
                        e = cancelAnimationFrame;
                    const {
                        delegate: i
                    } = Ky;
                    i && (n = i.requestAnimationFrame, e = i.cancelAnimationFrame);
                    const r = n(s => {
                        e = void 0, t(s)
                    });
                    return new S(() => e ? .(r))
                },
                requestAnimationFrame(...t) {
                    const {
                        delegate: n
                    } = Ky;
                    return (n ? .requestAnimationFrame || requestAnimationFrame)(...t)
                },
                cancelAnimationFrame(...t) {
                    const {
                        delegate: n
                    } = Ky;
                    return (n ? .cancelAnimationFrame || cancelAnimationFrame)(...t)
                },
                delegate: void 0
            };
            class qy {
                constructor(n, e = qy.now) {
                    this.schedulerActionCtor = n, this.now = e
                }
                schedule(n, e = 0, i) {
                    return new this.schedulerActionCtor(this, n).schedule(i, e)
                }
            }
            qy.now = y2.now;
            class U6 extends qy {
                constructor(n, e = qy.now) {
                    super(n, e), this.actions = [], this._active = !1
                }
                flush(n) {
                    const {
                        actions: e
                    } = this;
                    if (this._active) return void e.push(n);
                    let i;
                    this._active = !0;
                    do {
                        if (i = n.execute(n.state, n.delay)) break
                    } while (n = e.shift());
                    if (this._active = !1, i) {
                        for (; n = e.shift();) n.unsubscribe();
                        throw i
                    }
                }
            }
            const EJ = new class SJ extends U6 {
                flush(n) {
                    this._active = !0;
                    const e = this._scheduled;
                    this._scheduled = void 0;
                    const {
                        actions: i
                    } = this;
                    let r;
                    n = n || i.shift();
                    do {
                        if (r = n.execute(n.state, n.delay)) break
                    } while ((n = i[0]) && n.id === e && i.shift());
                    if (this._active = !1, r) {
                        for (;
                            (n = i[0]) && n.id === e && i.shift();) n.unsubscribe();
                        throw r
                    }
                }
            }(class TJ extends V6 {
                constructor(n, e) {
                    super(n, e), this.scheduler = n, this.work = e
                }
                requestAsyncId(n, e, i = 0) {
                    return null !== i && i > 0 ? super.requestAsyncId(n, e, i) : (n.actions.push(this), n._scheduled || (n._scheduled = Ky.requestAnimationFrame(() => n.flush(void 0))))
                }
                recycleAsyncId(n, e, i = 0) {
                    var r;
                    if (null != i ? i > 0 : this.delay > 0) return super.recycleAsyncId(n, e, i);
                    const {
                        actions: s
                    } = n;
                    null != e && (null === (r = s[s.length - 1]) || void 0 === r ? void 0 : r.id) !== e && (Ky.cancelAnimationFrame(e), n._scheduled = void 0)
                }
            });
            var H6 = function(t) {
                    return t.top = "top", t.bottom = "bottom", t.left = "left", t.right = "right", t.auto = "auto", t.end = "right", t.start = "left", t["top left"] = "top left", t["top right"] = "top right", t["right top"] = "right top", t["right bottom"] = "right bottom", t["bottom right"] = "bottom right", t["bottom left"] = "bottom left", t["left bottom"] = "left bottom", t["left top"] = "left top", t["top start"] = "top left", t["top end"] = "top right", t["end top"] = "right top", t["end bottom"] = "right bottom", t["bottom end"] = "bottom right", t["bottom start"] = "bottom left", t["start bottom"] = "start bottom", t["start top"] = "left top", t
                }(H6 || {}),
                A2 = function(t) {
                    return t.top = "top", t.bottom = "bottom", t.left = "start", t.right = "end", t.auto = "auto", t.end = "end", t.start = "start", t["top left"] = "top start", t["top right"] = "top end", t["right top"] = "end top", t["right bottom"] = "end bottom", t["bottom right"] = "bottom end", t["bottom left"] = "bottom start", t["left bottom"] = "start bottom", t["left top"] = "start top", t["top start"] = "top start", t["top end"] = "top end", t["end top"] = "end top", t["end bottom"] = "end bottom", t["bottom end"] = "bottom end", t["bottom start"] = "bottom start", t["start bottom"] = "start bottom", t["start top"] = "start top", t
                }(A2 || {});

            function Mf(t, n) {
                if (1 !== t.nodeType) return [];
                const i = t.ownerDocument.defaultView ? .getComputedStyle(t, null);
                return n ? i && i[n] : i
            }

            function k2(t) {
                if (!t) return document.documentElement;
                let i, e = t ? .offsetParent;
                for (; null === e && t.nextElementSibling && i !== t.nextElementSibling;) i = t.nextElementSibling, e = i.offsetParent;
                const r = e && e.nodeName;
                return r && "BODY" !== r && "HTML" !== r ? e && -1 !== ["TH", "TD", "TABLE"].indexOf(e.nodeName) && "static" === Mf(e, "position") ? k2(e) : e : i ? i.ownerDocument.documentElement : document.documentElement
            }

            function M2(t) {
                return null !== t.parentNode ? M2(t.parentNode) : t
            }

            function sw(t, n) {
                if (!(t && t.nodeType && n && n.nodeType)) return document.documentElement;
                const e = t.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_FOLLOWING,
                    i = e ? t : n,
                    r = e ? n : t,
                    s = document.createRange();
                s.setStart(i, 0), s.setEnd(r, 0);
                const o = s.commonAncestorContainer;
                if (t !== o && n !== o || i.contains(r)) return function DJ(t) {
                    const {
                        nodeName: n
                    } = t;
                    return "BODY" !== n && ("HTML" === n || k2(t.firstElementChild) === t)
                }(o) ? o : k2(o);
                const a = M2(t);
                return a.host ? sw(a.host, n) : sw(t, M2(n).host)
            }

            function $6(t) {
                if (!t || !t.parentElement) return document.documentElement;
                let n = t.parentElement;
                for (; n ? .parentElement && "none" === Mf(n, "transform");) n = n.parentElement;
                return n || document.documentElement
            }

            function z6(t, n) {
                const e = "x" === n ? "Left" : "Top",
                    i = "Left" === e ? "Right" : "Bottom";
                return parseFloat(t[`border${e}Width`]) + parseFloat(t[`border${i}Width`])
            }

            function j6(t, n, e, i) {
                return Math.max(n[`offset${t}`], n[`scroll${t}`], e[`client${t}`], e[`offset${t}`], e[`scroll${t}`], 0)
            }

            function W6(t) {
                const n = t.body,
                    e = t.documentElement;
                return {
                    height: j6("Height", n, e),
                    width: j6("Width", n, e)
                }
            }

            function Zy(t) {
                return { ...t,
                    right: (t.left || 0) + t.width,
                    bottom: (t.top || 0) + t.height
                }
            }

            function vs(t) {
                return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t)
            }

            function G6(t) {
                const n = t.getBoundingClientRect();
                if (!(n && vs(n.top) && vs(n.left) && vs(n.bottom) && vs(n.right))) return n;
                const e = {
                        left: n.left,
                        top: n.top,
                        width: n.right - n.left,
                        height: n.bottom - n.top
                    },
                    i = "HTML" === t.nodeName ? W6(t.ownerDocument) : void 0,
                    r = i ? .width || t.clientWidth || vs(n.right) && vs(e.left) && n.right - e.left || 0,
                    s = i ? .height || t.clientHeight || vs(n.bottom) && vs(e.top) && n.bottom - e.top || 0;
                let o = t.offsetWidth - r,
                    a = t.offsetHeight - s;
                if (o || a) {
                    const c = Mf(t);
                    o -= z6(c, "x"), a -= z6(c, "y"), e.width -= o, e.height -= a
                }
                return Zy(e)
            }

            function I2(t) {
                return "HTML" === t.nodeName ? t : t.parentNode || t.host
            }

            function P2(t) {
                if (!t) return document.body;
                switch (t.nodeName) {
                    case "HTML":
                    case "BODY":
                        return t.ownerDocument.body;
                    case "#document":
                        return t.body
                }
                const {
                    overflow: n,
                    overflowX: e,
                    overflowY: i
                } = Mf(t);
                return /(auto|scroll|overlay)/.test(String(n) + String(i) + String(e)) ? t : P2(I2(t))
            }

            function O2(t, n, e = !1) {
                const i = "HTML" === n.nodeName,
                    r = G6(t),
                    s = G6(n),
                    a = (P2(t), Mf(n)),
                    c = parseFloat(a.borderTopWidth),
                    u = parseFloat(a.borderLeftWidth);
                e && i && (s.top = Math.max(s.top ? ? 0, 0), s.left = Math.max(s.left ? ? 0, 0));
                const h = Zy({
                    top: (r.top ? ? 0) - (s.top ? ? 0) - c,
                    left: (r.left ? ? 0) - (s.left ? ? 0) - u,
                    width: r.width,
                    height: r.height
                });
                if (h.marginTop = 0, h.marginLeft = 0, i) {
                    const m = parseFloat(a.marginTop),
                        x = parseFloat(a.marginLeft);
                    vs(h.top) && (h.top -= c - m), vs(h.bottom) && (h.bottom -= c - m), vs(h.left) && (h.left -= u - x), vs(h.right) && (h.right -= u - x), h.marginTop = m, h.marginLeft = x
                }
                return h
            }

            function K6(t, n = "top") {
                const e = "top" === n ? "scrollTop" : "scrollLeft",
                    i = t.nodeName;
                return "BODY" === i || "HTML" === i ? (t.ownerDocument.scrollingElement || t.ownerDocument.documentElement)[e] : t[e]
            }

            function q6(t) {
                const n = t.nodeName;
                return "BODY" !== n && "HTML" !== n && ("fixed" === Mf(t, "position") || q6(I2(t)))
            }

            function L2(t, n, e = 0, i, r = !1) {
                let s = {
                    top: 0,
                    left: 0
                };
                const o = r ? $6(t) : sw(t, n);
                if ("viewport" === i) s = function kJ(t, n = !1) {
                    const e = t.ownerDocument.documentElement,
                        i = O2(t, e),
                        r = Math.max(e.clientWidth, window.innerWidth || 0),
                        s = Math.max(e.clientHeight, window.innerHeight || 0),
                        o = n ? 0 : K6(e),
                        a = n ? 0 : K6(e, "left");
                    return Zy({
                        top: o - Number(i ? .top) + Number(i ? .marginTop),
                        left: a - Number(i ? .left) + Number(i ? .marginLeft),
                        width: r,
                        height: s
                    })
                }(o, r);
                else {
                    let a;
                    "scrollParent" === i ? (a = P2(I2(n)), "BODY" === a.nodeName && (a = t.ownerDocument.documentElement)) : a = "window" === i ? t.ownerDocument.documentElement : i;
                    const c = O2(a, o, r);
                    if (c && "HTML" === a.nodeName && !q6(o)) {
                        const {
                            height: u,
                            width: h
                        } = W6(t.ownerDocument);
                        vs(s.top) && vs(c.top) && vs(c.marginTop) && (s.top += c.top - c.marginTop), vs(s.top) && (s.bottom = Number(u) + Number(c.top)), vs(s.left) && vs(c.left) && vs(c.marginLeft) && (s.left += c.left - c.marginLeft), vs(s.top) && (s.right = Number(h) + Number(c.left))
                    } else c && (s = c)
                }
                return vs(s.left) && (s.left += e), vs(s.top) && (s.top += e), vs(s.right) && (s.right -= e), vs(s.bottom) && (s.bottom -= e), s
            }

            function MJ({
                width: t,
                height: n
            }) {
                return t * n
            }

            function Z6(t, n, e, i, r = ["top", "bottom", "right", "left"], s = "viewport", o = 0) {
                if (-1 === t.indexOf("auto")) return t;
                const a = L2(e, i, o, s),
                    c = {
                        top: {
                            width: a ? .width ? ? 0,
                            height: (n ? .top ? ? 0) - (a ? .top ? ? 0)
                        },
                        right: {
                            width: (a ? .right ? ? 0) - (n ? .right ? ? 0),
                            height: a ? .height ? ? 0
                        },
                        bottom: {
                            width: a ? .width ? ? 0,
                            height: (a ? .bottom ? ? 0) - (n ? .bottom ? ? 0)
                        },
                        left: {
                            width: (n.left ? ? 0) - (a ? .left ? ? 0),
                            height: a ? .height ? ? 0
                        }
                    },
                    u = Object.keys(c).map(D => ({
                        position: D,
                        ...c[D],
                        area: MJ(c[D])
                    })).sort((D, V) => V.area - D.area);
                let h = u.filter(({
                    width: D,
                    height: V
                }) => D >= e.clientWidth && V >= e.clientHeight);
                h = h.filter(({
                    position: D
                }) => r.some(V => V === D));
                const m = h.length > 0 ? h[0].position : u[0].position,
                    x = t.split(" ")[1];
                return e.className = e.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${Gy().isBs5?A2[m]:m}`), m + (x ? `-${x}` : "")
            }
            const ow = (t, n = 0) => t ? parseFloat(t) : n;

            function Y6(t) {
                const e = t.ownerDocument.defaultView ? .getComputedStyle(t),
                    i = ow(e ? .marginTop) + ow(e ? .marginBottom),
                    r = ow(e ? .marginLeft) + ow(e ? .marginRight);
                return {
                    width: Number(t.offsetWidth) + r,
                    height: Number(t.offsetHeight) + i
                }
            }

            function X6(t, n, e) {
                return O2(n, e ? $6(t) : sw(t, n), e)
            }

            function R2(t, n, e) {
                const i = e.split(" ")[0],
                    r = Y6(t),
                    s = {
                        width: r.width,
                        height: r.height
                    },
                    o = -1 !== ["right", "left"].indexOf(i),
                    a = o ? "top" : "left",
                    c = o ? "left" : "top",
                    u = o ? "height" : "width",
                    h = o ? "width" : "height";
                return s[a] = (n[a] ? ? 0) + n[u] / 2 - r[u] / 2, s[c] = i === c ? (n[c] ? ? 0) - r[h] : n[function PJ(t) {
                    const n = {
                        left: "right",
                        right: "left",
                        bottom: "top",
                        top: "bottom"
                    };
                    return t.replace(/left|right|bottom|top/g, e => n[e])
                }(c)] ? ? 0, s
            }

            function Q6(t, n) {
                return !!t.modifiers[n] ? .enabled
            }
            const LJ = {
                top: ["top", "top start", "top end"],
                bottom: ["bottom", "bottom start", "bottom end"],
                start: ["start", "start top", "start bottom"],
                end: ["end", "end top", "end bottom"]
            };

            function aw(t, n) {
                return !!Gy().isBs5 && LJ[n].includes(t)
            }

            function J6(t, n, e) {
                !t || !n || Object.keys(n).forEach(i => {
                    let r = ""; - 1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(i) && function AJ(t) {
                        return "" !== t && !isNaN(parseFloat(t)) && isFinite(Number(t))
                    }(n[i]) && (r = "px"), e ? e.setStyle(t, i, `${String(n[i])}${r}`) : t.style[i] = String(n[i]) + r
                })
            }

            function NJ(t) {
                let n = t.offsets.target;
                const e = t.instance.target.querySelector(".arrow");
                if (!e) return t;
                const i = -1 !== ["left", "right"].indexOf(t.placement.split(" ")[0]),
                    r = i ? "height" : "width",
                    s = i ? "Top" : "Left",
                    o = s.toLowerCase(),
                    a = i ? "left" : "top",
                    c = i ? "bottom" : "right",
                    u = Y6(e)[r],
                    h = t.placement.split(" ")[1];
                (t.offsets.host[c] ? ? 0) - u < (n[o] ? ? 0) && (n[o] -= (n[o] ? ? 0) - ((t.offsets.host[c] ? ? 0) - u)), Number(t.offsets.host[o]) + Number(u) > (n[c] ? ? 0) && (n[o] += Number(t.offsets.host[o]) + Number(u) - Number(n[c])), n = Zy(n);
                const m = Mf(t.instance.target),
                    x = parseFloat(m[`margin${s}`]) || 0,
                    D = parseFloat(m[`border${s}Width`]) || 0;
                let V;
                if (h) {
                    const ee = parseFloat(m.borderRadius) || 0,
                        _e = Number(x + D + ee);
                    V = o === h ? Number(t.offsets.host[o]) + _e : Number(t.offsets.host[o]) + Number(t.offsets.host[r] - _e)
                } else V = Number(t.offsets.host[o]) + Number(t.offsets.host[r] / 2 - u / 2);
                let te = V - (n[o] ? ? 0) - x - D;
                return te = Math.max(Math.min(n[r] - (u + 5), te), 0), t.offsets.arrow = {
                    [o]: Math.round(te),
                    [a]: ""
                }, t.instance.arrow = e, t
            }

            function FJ(t) {
                if (t.offsets.target = Zy(t.offsets.target), !Q6(t.options, "flip")) return t.offsets.target = { ...t.offsets.target,
                    ...R2(t.instance.target, t.offsets.host, t.placement)
                }, t;
                const n = L2(t.instance.target, t.instance.host, 0, "viewport", !1);
                let e = t.placement.split(" ")[0],
                    i = t.placement.split(" ")[1] || "";
                const a = Z6("auto", t.offsets.host, t.instance.target, t.instance.host, t.options.allowedPositions),
                    c = [e, a];
                return c.forEach((u, h) => {
                    if (e !== u || c.length === h + 1) return;
                    e = t.placement.split(" ")[0];
                    const m = "left" === e && Math.floor(t.offsets.target.right ? ? 0) > Math.floor(t.offsets.host.left ? ? 0) || "right" === e && Math.floor(t.offsets.target.left ? ? 0) < Math.floor(t.offsets.host.right ? ? 0) || "top" === e && Math.floor(t.offsets.target.bottom ? ? 0) > Math.floor(t.offsets.host.top ? ? 0) || "bottom" === e && Math.floor(t.offsets.target.top ? ? 0) < Math.floor(t.offsets.host.bottom ? ? 0),
                        x = Math.floor(t.offsets.target.left ? ? 0) < Math.floor(n.left ? ? 0),
                        D = Math.floor(t.offsets.target.right ? ? 0) > Math.floor(n.right ? ? 0),
                        V = Math.floor(t.offsets.target.top ? ? 0) < Math.floor(n.top ? ? 0),
                        te = Math.floor(t.offsets.target.bottom ? ? 0) > Math.floor(n.bottom ? ? 0),
                        ee = "left" === e && x || "right" === e && D || "top" === e && V || "bottom" === e && te,
                        _e = -1 !== ["top", "bottom"].indexOf(e),
                        ye = _e && "left" === i && x || _e && "right" === i && D || !_e && "left" === i && V || !_e && "right" === i && te;
                    (m || ee || ye) && ((m || ee) && (e = c[h + 1]), ye && (i = function OJ(t) {
                        return "right" === t ? "left" : "left" === t ? "right" : t
                    }(i)), t.placement = e + (i ? ` ${i}` : ""), t.offsets.target = { ...t.offsets.target,
                        ...R2(t.instance.target, t.offsets.host, t.placement)
                    })
                }), t
            }

            function UJ(t) {
                if (!Q6(t.options, "preventOverflow")) return t;
                const n = "transform",
                    e = t.instance.target.style,
                    {
                        top: i,
                        left: r,
                        [n]: s
                    } = e;
                e.top = "", e.left = "", e[n] = "";
                const o = L2(t.instance.target, t.instance.host, 0, t.options.modifiers.preventOverflow ? .boundariesElement || "scrollParent", !1);
                e.top = i, e.left = r, e[n] = s;
                const c = {
                    primary(u) {
                        let h = t.offsets.target[u];
                        return (t.offsets.target[u] ? ? 0) < (o[u] ? ? 0) && (h = Math.max(t.offsets.target[u] ? ? 0, o[u] ? ? 0)), {
                            [u]: h
                        }
                    },
                    secondary(u) {
                        const h = "right" === u,
                            m = h ? "left" : "top";
                        let D = t.offsets.target[m];
                        return (t.offsets.target[u] ? ? 0) > (o[u] ? ? 0) && (D = Math.min(t.offsets.target[m] ? ? 0, (o[u] ? ? 0) - t.offsets.target[h ? "width" : "height"])), {
                            [m]: D
                        }
                    }
                };
                return ["left", "right", "top", "bottom"].forEach(u => {
                    const h = -1 !== ["left", "top", "start"].indexOf(u) ? c.primary : c.secondary;
                    t.offsets.target = { ...t.offsets.target,
                        ...h(u)
                    }
                }), t
            }

            function HJ(t) {
                const n = t.placement,
                    e = n.split(" ")[0],
                    i = n.split(" ")[1];
                if (i) {
                    const {
                        host: r,
                        target: s
                    } = t.offsets, o = -1 !== ["bottom", "top"].indexOf(e), a = o ? "left" : "top", c = o ? "width" : "height", u = {
                        start: {
                            [a]: r[a]
                        },
                        end: {
                            [a]: (r[a] ? ? 0) + r[c] - s[c]
                        }
                    };
                    t.offsets.target = { ...s,
                        [a]: a === i ? u.start[a] : u.end[a]
                    }
                }
                return t
            }
            const zJ = new class $J {
                position(n, e) {
                    return this.offset(n, e)
                }
                offset(n, e) {
                    return X6(e, n)
                }
                positionElements(n, e, i, r, s) {
                    const o = [FJ, HJ, UJ, NJ],
                        c = function VJ(t, n, e, i) {
                            if (!t || !n) return;
                            const r = X6(t, n);
                            !e.match(/^(auto)*\s*(left|right|top|bottom|start|end)*$/) && !e.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/) && (e = "auto");
                            const s = !!e.match(/auto/g);
                            let o = e.match(/auto\s(left|right|top|bottom|start|end)/) ? e.split(" ")[1] || "auto" : e;
                            const a = o.match(/^(left|right|top|bottom|start|end)* ?(?!\1)(left|right|top|bottom|start|end)?/);
                            return a && (o = a[1] + (a[2] ? ` ${a[2]}` : "")), -1 !== ["left right", "right left", "top bottom", "bottom top"].indexOf(o) && (o = "auto"), o = Z6(o, r, t, n, i ? i.allowedPositions : void 0), {
                                options: i || {
                                    modifiers: {}
                                },
                                instance: {
                                    target: t,
                                    host: n,
                                    arrow: void 0
                                },
                                offsets: {
                                    target: R2(t, r, o),
                                    host: r,
                                    arrow: void 0
                                },
                                positionFixed: !1,
                                placement: o,
                                placementAuto: s
                            }
                        }(e, n, H6[i], s);
                    if (c) return o.reduce((u, h) => h(u), c)
                }
            };

            function jJ(t, n, e, i, r, s) {
                const o = zJ.positionElements(t, n, e, i, r);
                if (!o) return;
                const a = function IJ(t) {
                    return {
                        width: t.offsets.target.width,
                        height: t.offsets.target.height,
                        left: Math.floor(t.offsets.target.left ? ? 0),
                        top: Math.round(t.offsets.target.top ? ? 0),
                        bottom: Math.round(t.offsets.target.bottom ? ? 0),
                        right: Math.floor(t.offsets.target.right ? ? 0)
                    }
                }(o);
                J6(n, {
                        "will-change": "transform",
                        top: "0px",
                        left: "0px",
                        transform: `translate3d(${a.left}px, ${a.top}px, 0px)`
                    }, s), o.instance.arrow && J6(o.instance.arrow, o.offsets.arrow, s),
                    function BJ(t, n) {
                        const e = t.instance.target;
                        let i = e.className;
                        const r = Gy().isBs5 ? A2[t.placement] : t.placement;
                        t.placementAuto && (i = i.replace(/bs-popover-auto/g, `bs-popover-${r}`), i = i.replace(/ms-2|me-2|mb-2|mt-2/g, ""), i = i.replace(/bs-tooltip-auto/g, `bs-tooltip-${r}`), i = i.replace(/\sauto/g, ` ${r}`), -1 !== i.indexOf("popover") && (i = i + " " + function RJ(t) {
                            return Gy().isBs5 ? aw(t, "end") ? "ms-2" : aw(t, "start") ? "me-2" : aw(t, "top") ? "mb-2" : aw(t, "bottom") ? "mt-2" : "" : ""
                        }(r)), -1 !== i.indexOf("popover") && -1 === i.indexOf("popover-auto") && (i += " popover-auto"), -1 !== i.indexOf("tooltip") && -1 === i.indexOf("tooltip-auto") && (i += " tooltip-auto")), i = i.replace(/left|right|top|bottom|end|start/g, `${r.split(" ")[0]}`), n ? n.setAttribute(e, "class", i) : e.className = i
                    }(o, s)
            }
            let Yy = (() => {
                class t {
                    constructor(e, i, r) {
                        this.update$$ = new A, this.positionElements = new Map, this.isDisabled = !1, gc(r) && e.runOutsideAngular(() => {
                            this.triggerEvent$ = Si(Sm(window, "scroll", {
                                passive: !0
                            }), Sm(window, "resize", {
                                passive: !0
                            }), Ve(0, EJ), this.update$$), this.triggerEvent$.subscribe(() => {
                                this.isDisabled || this.positionElements.forEach(s => {
                                    jJ(cw(s.target), cw(s.element), s.attachment, s.appendToBody, this.options, i.createRenderer(null, null))
                                })
                            })
                        })
                    }
                    position(e) {
                        this.addPositionElement(e)
                    }
                    get event$() {
                        return this.triggerEvent$
                    }
                    disable() {
                        this.isDisabled = !0
                    }
                    enable() {
                        this.isDisabled = !1
                    }
                    addPositionElement(e) {
                        this.positionElements.set(cw(e.element), e)
                    }
                    calcPosition() {
                        this.update$$.next(null)
                    }
                    deletePositionElement(e) {
                        this.positionElements.delete(cw(e))
                    }
                    setOptions(e) {
                        this.options = e
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_t(cr), _t(pf), _t(Bs))
                }, t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac,
                    providedIn: "root"
                }), t
            })();

            function cw(t) {
                return "string" == typeof t ? document.querySelector(t) : t instanceof ir ? t.nativeElement : t ? ? null
            }
            class Xy {
                constructor(n, e, i) {
                    this.nodes = n, this.viewRef = e, this.componentRef = i
                }
            }
            class WJ {
                constructor(n, e, i, r, s, o, a, c, u) {
                    this._viewContainerRef = n, this._renderer = e, this._elementRef = i, this._injector = r, this._componentFactoryResolver = s, this._ngZone = o, this._applicationRef = a, this._posService = c, this._document = u, this.onBeforeShow = new zt, this.onShown = new zt, this.onBeforeHide = new zt, this.onHidden = new zt, this._providers = [], this._isHiding = !1, this.containerDefaultSelector = "body", this._listenOpts = {}, this._globalListener = Function.prototype
                }
                get isShown() {
                    return !this._isHiding && !!this._componentRef
                }
                attach(n) {
                    return this._componentFactory = this._componentFactoryResolver.resolveComponentFactory(n), this
                }
                to(n) {
                    return this.container = n || this.container, this
                }
                position(n) {
                    return n ? (this.attachment = n.attachment || this.attachment, this._elementRef = n.target || this._elementRef, this) : this
                }
                provide(n) {
                    return this._providers.push(n), this
                }
                show(n = {}) {
                    if (this._subscribePositioning(), this._innerComponent = void 0, !this._componentRef) {
                        this.onBeforeShow.emit(), this._contentRef = this._getContentRef(n.content, n.context, n.initialState);
                        const e = Do.create({
                            providers: this._providers,
                            parent: this._injector
                        });
                        if (!this._componentFactory) return;
                        if (this._componentRef = this._componentFactory.create(e, this._contentRef.nodes), this._applicationRef.attachView(this._componentRef.hostView), this.instance = this._componentRef.instance, Object.assign(this._componentRef.instance, n), this.container instanceof ir && this.container.nativeElement.appendChild(this._componentRef.location.nativeElement), "string" == typeof this.container && typeof this._document < "u") {
                            const i = this._document.querySelector(this.container) || this._document.querySelector(this.containerDefaultSelector);
                            if (!i) return;
                            i.appendChild(this._componentRef.location.nativeElement)
                        }!this.container && this._elementRef && this._elementRef.nativeElement.parentElement && this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement), this._contentRef.componentRef && (this._innerComponent = this._contentRef.componentRef.instance, this._contentRef.componentRef.changeDetectorRef.markForCheck(), this._contentRef.componentRef.changeDetectorRef.detectChanges()), this._componentRef.changeDetectorRef.markForCheck(), this._componentRef.changeDetectorRef.detectChanges(), this.onShown.emit(n.id ? {
                            id: n.id
                        } : this._componentRef.instance)
                    }
                    return this._registerOutsideClick(), this._componentRef
                }
                hide(n) {
                    if (!this._componentRef) return this;
                    this._posService.deletePositionElement(this._componentRef.location), this.onBeforeHide.emit(this._componentRef.instance);
                    const e = this._componentRef.location.nativeElement;
                    return e.parentNode ? .removeChild(e), this._contentRef ? .componentRef ? .destroy(), this._viewContainerRef && this._contentRef ? .viewRef && this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef)), this._contentRef ? .viewRef ? .destroy(), this._contentRef = void 0, this._componentRef = void 0, this._removeGlobalListener(), this.onHidden.emit(n ? {
                        id: n
                    } : null), this
                }
                toggle() {
                    this.isShown ? this.hide() : this.show()
                }
                dispose() {
                    this.isShown && this.hide(), this._unsubscribePositioning(), this._unregisterListenersFn && this._unregisterListenersFn()
                }
                listen(n) {
                    this.triggers = n.triggers || this.triggers, this._listenOpts.outsideClick = n.outsideClick, this._listenOpts.outsideEsc = n.outsideEsc, n.target = n.target || this._elementRef ? .nativeElement;
                    const e = this._listenOpts.hide = () => n.hide ? n.hide() : void this.hide(),
                        i = this._listenOpts.show = s => {
                            n.show ? n.show(s) : this.show(s), s()
                        };
                    return this._renderer && (this._unregisterListenersFn = function lJ(t, n) {
                        const e = function L6(t, n = cJ) {
                                const e = (t || "").trim();
                                if (0 === e.length) return [];
                                const i = e.split(/\s+/).map(s => s.split(":")).map(s => {
                                        const o = n[s[0]] || s;
                                        return new aJ(o[0], o[1])
                                    }),
                                    r = i.filter(s => s.isManual());
                                if (r.length > 1) throw new Error("Triggers parse error: only one manual trigger is allowed");
                                if (1 === r.length && i.length > 1) throw new Error("Triggers parse error: manual trigger can't be mixed with other triggers");
                                return i
                            }(n.triggers),
                            i = n.target;
                        if (1 === e.length && e[0].isManual()) return Function.prototype;
                        const r = [],
                            s = [],
                            o = () => {
                                s.forEach(a => r.push(a())), s.length = 0
                            };
                        return e.forEach(a => {
                            const c = a.open === a.close,
                                u = c ? n.toggle : n.show;
                            if (!c && a.close && n.hide) {
                                const h = a.close,
                                    m = n.hide;
                                s.push(() => t.listen(i, h, m))
                            }
                            u && r.push(t.listen(i, a.open, () => u(o)))
                        }), () => {
                            r.forEach(a => a())
                        }
                    }(this._renderer, {
                        target: n.target,
                        triggers: n.triggers,
                        show: i,
                        hide: e,
                        toggle: s => {
                            this.isShown ? e() : i(s)
                        }
                    })), this
                }
                _removeGlobalListener() {
                    this._globalListener && (this._globalListener(), this._globalListener = Function.prototype)
                }
                attachInline(n, e) {
                    return n && e && (this._inlineViewRef = n.createEmbeddedView(e)), this
                }
                _registerOutsideClick() {
                    if (this._componentRef && this._componentRef.location) {
                        if (this._listenOpts.outsideClick) {
                            const n = this._componentRef.location.nativeElement;
                            setTimeout(() => {
                                this._renderer && this._elementRef && (this._globalListener = function uJ(t, n) {
                                    return n.outsideClick ? t.listen("document", "click", e => {
                                        n.target && n.target.contains(e.target) || n.targets && n.targets.some(i => i.contains(e.target)) || n.hide && n.hide()
                                    }) : Function.prototype
                                }(this._renderer, {
                                    targets: [n, this._elementRef.nativeElement],
                                    outsideClick: this._listenOpts.outsideClick,
                                    hide: () => this._listenOpts.hide && this._listenOpts.hide()
                                }))
                            })
                        }
                        this._listenOpts.outsideEsc && this._renderer && this._elementRef && (this._globalListener = function dJ(t, n) {
                            return n.outsideEsc ? t.listen("document", "keyup.esc", e => {
                                n.target && n.target.contains(e.target) || n.targets && n.targets.some(i => i.contains(e.target)) || n.hide && n.hide()
                            }) : Function.prototype
                        }(this._renderer, {
                            targets: [this._componentRef.location.nativeElement, this._elementRef.nativeElement],
                            outsideEsc: this._listenOpts.outsideEsc,
                            hide: () => this._listenOpts.hide && this._listenOpts.hide()
                        }))
                    }
                }
                getInnerComponent() {
                    return this._innerComponent
                }
                _subscribePositioning() {
                    this._zoneSubscription || !this.attachment || (this.onShown.subscribe(() => {
                        this._posService.position({
                            element: this._componentRef ? .location,
                            target: this._elementRef,
                            attachment: this.attachment,
                            appendToBody: "body" === this.container
                        })
                    }), this._zoneSubscription = this._ngZone.onStable.subscribe(() => {
                        this._componentRef && this._posService.calcPosition()
                    }))
                }
                _unsubscribePositioning() {
                    this._zoneSubscription && (this._zoneSubscription.unsubscribe(), this._zoneSubscription = void 0)
                }
                _getContentRef(n, e, i) {
                    if (!n) return new Xy([]);
                    if (n instanceof Hc) {
                        if (this._viewContainerRef) {
                            const o = this._viewContainerRef.createEmbeddedView(n, e);
                            return o.markForCheck(), new Xy([o.rootNodes], o)
                        }
                        const s = n.createEmbeddedView({});
                        return this._applicationRef.attachView(s), new Xy([s.rootNodes], s)
                    }
                    if ("function" == typeof n) {
                        const s = this._componentFactoryResolver.resolveComponentFactory(n),
                            o = Do.create({
                                providers: this._providers,
                                parent: this._injector
                            }),
                            a = s.create(o);
                        return Object.assign(a.instance, i), this._applicationRef.attachView(a.hostView), new Xy([
                            [a.location.nativeElement]
                        ], a.hostView, a)
                    }
                    const r = this._renderer ? [this._renderer.createText(`${n}`)] : [];
                    return new Xy([r])
                }
            }
            let Em = (() => {
                class t {
                    constructor(e, i, r, s, o, a) {
                        this._componentFactoryResolver = e, this._ngZone = i, this._injector = r, this._posService = s, this._applicationRef = o, this._document = a
                    }
                    createLoader(e, i, r) {
                        return new WJ(i, r, e, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService, this._document)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_t(Xp), _t(cr), _t(Do), _t(Yy), _t(Xl), _t(Ss))
                }, t.\u0275prov = Dt({
                    token: t,
                    factory: t.\u0275fac,
                    providedIn: "root"
                }), t
            })();
            const GJ = function(t) {
                    return {
                        dropdown: t
                    }
                },
                KJ = ["*"];
            let qJ = (() => {
                    class t {
                        constructor() {
                            this.autoClose = !0, this.insideClick = !1, this.isAnimated = !1, this.stopOnClickPropagation = !1
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                If = (() => {
                    class t {
                        constructor() {
                            this.direction = "down", this.autoClose = !0, this.insideClick = !1, this.isAnimated = !1, this.stopOnClickPropagation = !1, this.isOpenChange = new zt, this.isDisabledChange = new zt, this.toggleClick = new zt, this.counts = 0, this.dropdownMenu = new Promise(e => {
                                this.resolveDropdownMenu = e
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "platform"
                    }), t
                })();
            const eB = [ko({
                height: 0,
                overflow: "hidden"
            }), $u("220ms cubic-bezier(0, 0, 0.2, 1)", ko({
                height: "*",
                overflow: "hidden"
            }))];
            let F2, YJ = (() => {
                    class t {
                        constructor(e, i, r, s, o) {
                            this._state = e, this.cd = i, this._renderer = r, this._element = s, this.isOpen = !1, this._factoryDropDownAnimation = o.build(eB), this._subscription = e.isOpenChange.subscribe(a => {
                                this.isOpen = a;
                                const c = this._element.nativeElement.querySelector(".dropdown-menu");
                                this._renderer.addClass(this._element.nativeElement.querySelector("div"), "open"), c && (this._renderer.addClass(c, "show"), (c.classList.contains("dropdown-menu-right") || c.classList.contains("dropdown-menu-end")) && (this._renderer.setStyle(c, "left", "auto"), this._renderer.setStyle(c, "right", "0")), "up" === this.direction && (this._renderer.setStyle(c, "top", "auto"), this._renderer.setStyle(c, "transform", "translateY(-101%)"))), c && this._state.isAnimated && this._factoryDropDownAnimation.create(c).play(), this.cd.markForCheck(), this.cd.detectChanges()
                            })
                        }
                        get direction() {
                            return this._state.direction
                        }
                        _contains(e) {
                            return this._element.nativeElement.contains(e)
                        }
                        ngOnDestroy() {
                            this._subscription.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(If), We(qa), We(Ks), We(ir), We(By))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["bs-dropdown-container"]
                        ],
                        hostAttrs: [2, "display", "block", "position", "absolute", "z-index", "1040"],
                        ngContentSelectors: KJ,
                        decls: 2,
                        vars: 9,
                        consts: [
                            [3, "ngClass"]
                        ],
                        template: function(e, i) {
                            1 & e && (Zd(), J(0, "div", 0), Ru(1), ce()), 2 & e && (ja("dropup", "up" === i.direction)("show", i.isOpen)("open", i.isOpen), Re("ngClass", fi(7, GJ, "down" === i.direction)))
                        },
                        dependencies: [Jd],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                lw = (() => {
                    class t {
                        constructor(e, i, r, s, o, a, c) {
                            this._elementRef = e, this._renderer = i, this._viewContainerRef = r, this._cis = s, this._state = o, this._config = a, this.dropup = !1, this._isInlineOpen = !1, this._isDisabled = !1, this._subscriptions = [], this._isInited = !1, this._state.autoClose = this._config.autoClose, this._state.insideClick = this._config.insideClick, this._state.isAnimated = this._config.isAnimated, this._state.stopOnClickPropagation = this._config.stopOnClickPropagation, this._factoryDropDownAnimation = c.build(eB), this._dropdown = this._cis.createLoader(this._elementRef, this._viewContainerRef, this._renderer).provide({
                                provide: If,
                                useValue: this._state
                            }), this.onShown = this._dropdown.onShown, this.onHidden = this._dropdown.onHidden, this.isOpenChange = this._state.isOpenChange
                        }
                        set autoClose(e) {
                            this._state.autoClose = e
                        }
                        get autoClose() {
                            return this._state.autoClose
                        }
                        set isAnimated(e) {
                            this._state.isAnimated = e
                        }
                        get isAnimated() {
                            return this._state.isAnimated
                        }
                        set insideClick(e) {
                            this._state.insideClick = e
                        }
                        get insideClick() {
                            return this._state.insideClick
                        }
                        set isDisabled(e) {
                            this._isDisabled = e, this._state.isDisabledChange.emit(e), e && this.hide()
                        }
                        get isDisabled() {
                            return this._isDisabled
                        }
                        get isOpen() {
                            return this._showInline ? this._isInlineOpen : this._dropdown.isShown
                        }
                        set isOpen(e) {
                            e ? this.show() : this.hide()
                        }
                        get _showInline() {
                            return !this.container
                        }
                        ngOnInit() {
                            this._isInited || (this._isInited = !0, this._dropdown.listen({
                                outsideClick: !1,
                                triggers: this.triggers,
                                show: () => this.show()
                            }), this._subscriptions.push(this._state.toggleClick.subscribe(e => this.toggle(e))), this._subscriptions.push(this._state.isDisabledChange.pipe(ia(e => e)).subscribe(() => this.hide())))
                        }
                        show() {
                            if (!this.isOpen && !this.isDisabled) {
                                if (this._showInline) return this._inlinedMenu || this._state.dropdownMenu.then(e => {
                                    this._dropdown.attachInline(e.viewContainer, e.templateRef), this._inlinedMenu = this._dropdown._inlineViewRef, this.addBs4Polyfills(), this._inlinedMenu && this._renderer.addClass(this._inlinedMenu.rootNodes[0].parentNode, "open"), this.playAnimation()
                                }).catch(), this.addBs4Polyfills(), this._isInlineOpen = !0, this.onShown.emit(!0), this._state.isOpenChange.emit(!0), void this.playAnimation();
                                this._state.dropdownMenu.then(e => {
                                    const i = this.dropup || typeof this.dropup < "u" && this.dropup;
                                    this._state.direction = i ? "up" : "down";
                                    const r = this.placement || (i ? "top start" : "bottom start");
                                    this._dropdown.attach(YJ).to(this.container).position({
                                        attachment: r
                                    }).show({
                                        content: e.templateRef,
                                        placement: r
                                    }), this._state.isOpenChange.emit(!0)
                                }).catch()
                            }
                        }
                        hide() {
                            this.isOpen && (this._showInline ? (this.removeShowClass(), this.removeDropupStyles(), this._isInlineOpen = !1, this.onHidden.emit(!0)) : this._dropdown.hide(), this._state.isOpenChange.emit(!1))
                        }
                        toggle(e) {
                            return this.isOpen || !e ? this.hide() : this.show()
                        }
                        _contains(e) {
                            return this._elementRef.nativeElement.contains(e.target) || this._dropdown.instance && this._dropdown.instance._contains(e.target)
                        }
                        navigationClick(e) {
                            const i = this._elementRef.nativeElement.querySelector(".dropdown-menu");
                            if (!i) return;
                            const r = this._elementRef.nativeElement.ownerDocument.activeElement,
                                s = i.querySelectorAll(".dropdown-item");
                            switch (e.keyCode) {
                                case 38:
                                    this._state.counts > 0 && s[--this._state.counts].focus();
                                    break;
                                case 40:
                                    this._state.counts + 1 < s.length && (r.classList !== s[this._state.counts].classList ? s[this._state.counts].focus() : s[++this._state.counts].focus())
                            }
                            e.preventDefault()
                        }
                        ngOnDestroy() {
                            for (const e of this._subscriptions) e.unsubscribe();
                            this._dropdown.dispose()
                        }
                        addBs4Polyfills() {
                            this.addShowClass(), this.checkRightAlignment(), this.addDropupStyles()
                        }
                        playAnimation() {
                            this._state.isAnimated && this._inlinedMenu && setTimeout(() => {
                                this._inlinedMenu && this._factoryDropDownAnimation.create(this._inlinedMenu.rootNodes[0]).play()
                            })
                        }
                        addShowClass() {
                            this._inlinedMenu && this._inlinedMenu.rootNodes[0] && this._renderer.addClass(this._inlinedMenu.rootNodes[0], "show")
                        }
                        removeShowClass() {
                            this._inlinedMenu && this._inlinedMenu.rootNodes[0] && this._renderer.removeClass(this._inlinedMenu.rootNodes[0], "show")
                        }
                        checkRightAlignment() {
                            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                                const e = this._inlinedMenu.rootNodes[0].classList.contains("dropdown-menu-right") || this._inlinedMenu.rootNodes[0].classList.contains("dropdown-menu-end");
                                this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "left", e ? "auto" : "0"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "right", e ? "0" : "auto")
                            }
                        }
                        addDropupStyles() {
                            this._inlinedMenu && this._inlinedMenu.rootNodes[0] && (this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "top", this.dropup ? "auto" : "100%"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "transform", this.dropup ? "translateY(-101%)" : "translateY(0)"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "bottom", "auto"))
                        }
                        removeDropupStyles() {
                            this._inlinedMenu && this._inlinedMenu.rootNodes[0] && (this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "top"), this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "transform"), this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "bottom"))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(Ks), We(Ga), We(Em), We(If), We(qJ), We(By))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "bsDropdown", ""],
                            ["", "dropdown", ""]
                        ],
                        hostVars: 6,
                        hostBindings: function(e, i) {
                            1 & e && xt("keydown.arrowDown", function(s) {
                                return i.navigationClick(s)
                            })("keydown.arrowUp", function(s) {
                                return i.navigationClick(s)
                            }), 2 & e && ja("dropup", i.dropup)("open", i.isOpen)("show", i.isOpen)
                        },
                        inputs: {
                            placement: "placement",
                            triggers: "triggers",
                            container: "container",
                            dropup: "dropup",
                            autoClose: "autoClose",
                            isAnimated: "isAnimated",
                            insideClick: "insideClick",
                            isDisabled: "isDisabled",
                            isOpen: "isOpen"
                        },
                        outputs: {
                            isOpenChange: "isOpenChange",
                            onShown: "onShown",
                            onHidden: "onHidden"
                        },
                        exportAs: ["bs-dropdown"],
                        features: [Jr([If])]
                    }), t
                })(),
                B2 = (() => {
                    class t {
                        constructor(e, i, r) {
                            e.resolveDropdownMenu({
                                templateRef: r,
                                viewContainer: i
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(If), We(Ga), We(Hc))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "bsDropdownMenu", ""],
                            ["", "dropdownMenu", ""]
                        ],
                        exportAs: ["bs-dropdown-menu"]
                    }), t
                })(),
                N2 = (() => {
                    class t {
                        constructor(e, i, r, s, o) {
                            this._changeDetectorRef = e, this._dropdown = i, this._element = r, this._renderer = s, this._state = o, this.isOpen = !1, this._subscriptions = [], this._subscriptions.push(this._state.isOpenChange.subscribe(a => {
                                this.isOpen = a, a ? (this._documentClickListener = this._renderer.listen("document", "click", c => {
                                    this._state.autoClose && 2 !== c.button && !this._element.nativeElement.contains(c.target) && (!this._state.insideClick || !this._dropdown._contains(c)) && (this._state.toggleClick.emit(!1), this._changeDetectorRef.detectChanges())
                                }), this._escKeyUpListener = this._renderer.listen(this._element.nativeElement, "keyup.esc", () => {
                                    this._state.autoClose && (this._state.toggleClick.emit(!1), this._changeDetectorRef.detectChanges())
                                })) : (this._documentClickListener && this._documentClickListener(), this._escKeyUpListener && this._escKeyUpListener())
                            })), this._subscriptions.push(this._state.isDisabledChange.subscribe(a => this.isDisabled = a || void 0))
                        }
                        onClick(e) {
                            this._state.stopOnClickPropagation && e.stopPropagation(), !this.isDisabled && this._state.toggleClick.emit(!0)
                        }
                        ngOnDestroy() {
                            this._documentClickListener && this._documentClickListener(), this._escKeyUpListener && this._escKeyUpListener();
                            for (const e of this._subscriptions) e.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(qa), We(lw), We(ir), We(Ks), We(If))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "bsDropdownToggle", ""],
                            ["", "dropdownToggle", ""]
                        ],
                        hostVars: 3,
                        hostBindings: function(e, i) {
                            1 & e && xt("click", function(s) {
                                return i.onClick(s)
                            }), 2 & e && hi("aria-haspopup", !0)("disabled", i.isDisabled)("aria-expanded", i.isOpen)
                        },
                        exportAs: ["bs-dropdown-toggle"]
                    }), t
                })(),
                XJ = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: [Em, Yy, If]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [mc]
                    }), t
                })(),
                QJ = (() => {
                    class t {
                        constructor() {
                            this._focusTrapStack = []
                        }
                        register(e) {
                            this._focusTrapStack = this._focusTrapStack.filter(r => r !== e);
                            let i = this._focusTrapStack;
                            i.length && i[i.length - 1]._disable(), i.push(e), e._enable()
                        }
                        deregister(e) {
                            e._disable();
                            const i = this._focusTrapStack,
                                r = i.indexOf(e); - 1 !== r && (i.splice(r, 1), i.length && i[i.length - 1]._enable())
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })();
            try {
                F2 = typeof Intl < "u" && Intl.v8BreakIterator
            } catch {
                F2 = !1
            }
            let tB = (() => {
                    class t {
                        constructor(e) {
                            this._platformId = e, this.isBrowser = this._platformId ? gc(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !F2) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(Bs))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                nB = (() => {
                    class t {
                        constructor(e) {
                            this._platform = e
                        }
                        isDisabled(e) {
                            return e.hasAttribute("disabled")
                        }
                        isVisible(e) {
                            return function eee(t) {
                                return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length)
                            }(e) && "visible" === getComputedStyle(e).visibility
                        }
                        isTabbable(e) {
                            if (!this._platform.isBrowser) return !1;
                            const i = function JJ(t) {
                                try {
                                    return t.frameElement
                                } catch {
                                    return null
                                }
                            }(function cee(t) {
                                return t.ownerDocument && t.ownerDocument.defaultView || window
                            }(e));
                            if (i && (-1 === rB(i) || !this.isVisible(i))) return !1;
                            let r = e.nodeName.toLowerCase(),
                                s = rB(e);
                            return e.hasAttribute("contenteditable") ? -1 !== s : !("iframe" === r || "object" === r || this._platform.WEBKIT && this._platform.IOS && ! function oee(t) {
                                let n = t.nodeName.toLowerCase(),
                                    e = "input" === n && t.type;
                                return "text" === e || "password" === e || "select" === n || "textarea" === n
                            }(e)) && ("audio" === r ? !!e.hasAttribute("controls") && -1 !== s : "video" === r ? -1 !== s && (null !== s || this._platform.FIREFOX || e.hasAttribute("controls")) : e.tabIndex >= 0)
                        }
                        isFocusable(e, i) {
                            return function aee(t) {
                                return ! function nee(t) {
                                    return function ree(t) {
                                        return "input" == t.nodeName.toLowerCase()
                                    }(t) && "hidden" == t.type
                                }(t) && (function tee(t) {
                                    let n = t.nodeName.toLowerCase();
                                    return "input" === n || "select" === n || "button" === n || "textarea" === n
                                }(t) || function iee(t) {
                                    return function see(t) {
                                        return "a" == t.nodeName.toLowerCase()
                                    }(t) && t.hasAttribute("href")
                                }(t) || t.hasAttribute("contenteditable") || iB(t))
                            }(e) && !this.isDisabled(e) && (i ? .ignoreVisibility || this.isVisible(e))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(tB))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })();

            function iB(t) {
                if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1;
                let n = t.getAttribute("tabindex");
                return "-32768" != n && !(!n || isNaN(parseInt(n, 10)))
            }

            function rB(t) {
                if (!iB(t)) return null;
                const n = parseInt(t.getAttribute("tabindex") || "", 10);
                return isNaN(n) ? -1 : n
            }

            function sB(t) {
                return null != t && "false" != `${t}`
            }
            class lee {
                constructor(n, e, i, r, s = !1) {
                    this._element = n, this._checker = e, this._ngZone = i, this._document = r, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors()
                }
                get enabled() {
                    return this._enabled
                }
                set enabled(n) {
                    this._enabled = n, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor))
                }
                destroy() {
                    const n = this._startAnchor,
                        e = this._endAnchor;
                    n && (n.removeEventListener("focus", this.startAnchorListener), n.parentNode && n.parentNode.removeChild(n)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1
                }
                attachAnchors() {
                    return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => {
                        this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener))
                    }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached)
                }
                focusInitialElementWhenReady() {
                    return new Promise(n => {
                        this._executeOnStable(() => n(this.focusInitialElement()))
                    })
                }
                focusFirstTabbableElementWhenReady() {
                    return new Promise(n => {
                        this._executeOnStable(() => n(this.focusFirstTabbableElement()))
                    })
                }
                focusLastTabbableElementWhenReady() {
                    return new Promise(n => {
                        this._executeOnStable(() => n(this.focusLastTabbableElement()))
                    })
                }
                _getRegionBoundary(n) {
                    let e = this._element.querySelectorAll(`[cdk-focus-region-${n}], [cdkFocusRegion${n}], [cdk-focus-${n}]`);
                    for (let i = 0; i < e.length; i++) e[i].hasAttribute(`cdk-focus-${n}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${n}', use 'cdkFocusRegion${n}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]) : e[i].hasAttribute(`cdk-focus-region-${n}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${n}', use 'cdkFocusRegion${n}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]);
                    return "start" == n ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element)
                }
                focusInitialElement() {
                    const n = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
                    if (n) {
                        if (n.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", n), !this._checker.isFocusable(n)) {
                            const e = this._getFirstTabbableElement(n);
                            return e ? .focus(), !!e
                        }
                        return n.focus(), !0
                    }
                    return this.focusFirstTabbableElement()
                }
                focusFirstTabbableElement() {
                    const n = this._getRegionBoundary("start");
                    return n && n.focus(), !!n
                }
                focusLastTabbableElement() {
                    const n = this._getRegionBoundary("end");
                    return n && n.focus(), !!n
                }
                hasAttached() {
                    return this._hasAttached
                }
                _getFirstTabbableElement(n) {
                    if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n;
                    let e = n.children || n.childNodes;
                    for (let i = 0; i < e.length; i++) {
                        let r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null;
                        if (r) return r
                    }
                    return null
                }
                _getLastTabbableElement(n) {
                    if (this._checker.isFocusable(n) && this._checker.isTabbable(n)) return n;
                    let e = n.children || n.childNodes;
                    for (let i = e.length - 1; i >= 0; i--) {
                        let r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null;
                        if (r) return r
                    }
                    return null
                }
                _createAnchor() {
                    const n = this._document.createElement("div");
                    return this._toggleAnchorTabIndex(this._enabled, n), n.classList.add("cdk-visually-hidden"), n.classList.add("cdk-focus-trap-anchor"), n.setAttribute("aria-hidden", "true"), n
                }
                _toggleAnchorTabIndex(n, e) {
                    n ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex")
                }
                toggleAnchors(n) {
                    this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(n, this._startAnchor), this._toggleAnchorTabIndex(n, this._endAnchor))
                }
                _executeOnStable(n) {
                    this._ngZone.isStable ? n() : this._ngZone.onStable.pipe(Sa(1)).subscribe(n)
                }
            }
            let uee = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._checker = e, this._ngZone = i, this._document = r
                        }
                        create(e, i = !1) {
                            return new lee(e, this._checker, this._ngZone, this._document, i)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(nB), _t(cr), _t(Ss))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                dee = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._elementRef = e, this._focusTrapFactory = i, this._previouslyFocusedElement = null, this._autoCapture = !1, this._document = r, this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, !0)
                        }
                        get enabled() {
                            return this.focusTrap.enabled
                        }
                        set enabled(e) {
                            this.focusTrap.enabled = sB(e)
                        }
                        get autoCapture() {
                            return this._autoCapture
                        }
                        set autoCapture(e) {
                            this._autoCapture = sB(e)
                        }
                        ngOnDestroy() {
                            this.focusTrap.destroy(), this._previouslyFocusedElement && (this._previouslyFocusedElement.focus(), this._previouslyFocusedElement = null)
                        }
                        ngAfterContentInit() {
                            this.focusTrap.attachAnchors(), this.autoCapture && this._captureFocus()
                        }
                        ngDoCheck() {
                            this.focusTrap.hasAttached() || this.focusTrap.attachAnchors()
                        }
                        ngOnChanges(e) {
                            const i = e.autoCapture;
                            i && !i.firstChange && this.autoCapture && this.focusTrap.hasAttached() && this._captureFocus()
                        }
                        _captureFocus() {
                            this._previouslyFocusedElement = this._document.activeElement, this.focusTrap.focusInitialElementWhenReady()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(uee), We(Ss))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "focusTrap", ""]
                        ],
                        inputs: {
                            enabled: ["cdkTrapFocus", "enabled"],
                            autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture"]
                        },
                        exportAs: ["focusTrap"],
                        features: [Xi]
                    }), t
                })(),
                oB = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: [QJ, tB, nB]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [mc]
                    }), t
                })();
            const hee = ["*"];
            let Dm = (() => {
                    class t {
                        constructor() {
                            this.hide = () => {}, this.setClass = () => {}
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "platform"
                    }), t
                })(),
                aB = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "platform"
                    }), t
                })();
            const uw = {
                    backdrop: !0,
                    keyboard: !0,
                    focus: !0,
                    show: !1,
                    ignoreBackdropClick: !1,
                    class: "",
                    animated: !0,
                    initialState: {},
                    closeInterceptor: void 0
                },
                fee = new nn("override-default-config");
            let pee = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._element = i, this._renderer = r, this.isShown = !1, this.isAnimated = !1, this._focusEl = null, this.isModalHiding = !1, this.clickStartedInContent = !1, this.config = Object.assign({}, e)
                        }
                        ngOnInit() {
                            this._focusEl = go.activeElement, this.isAnimated && this._renderer.addClass(this._element.nativeElement, "fade"), this._renderer.setStyle(this._element.nativeElement, "display", "block"), setTimeout(() => {
                                this.isShown = !0, this._renderer.addClass(this._element.nativeElement, "show")
                            }, this.isAnimated ? 150 : 0), go && go.body && (this.bsModalService && 1 === this.bsModalService.getModalsCount() && (this.bsModalService.checkScrollbar(), this.bsModalService.setScrollbar()), this._renderer.addClass(go.body, "modal-open"), this._renderer.setStyle(go.body, "overflow-y", "hidden")), this._element.nativeElement && this._element.nativeElement.focus()
                        }
                        onClickStarted(e) {
                            this.clickStartedInContent = e.target !== this._element.nativeElement
                        }
                        onClickStop(e) {
                            this.config.ignoreBackdropClick || "static" === this.config.backdrop || e.target !== this._element.nativeElement || this.clickStartedInContent ? this.clickStartedInContent = !1 : (this.bsModalService ? .setDismissReason("backdrop-click"), this.hide())
                        }
                        onPopState() {
                            this.bsModalService ? .setDismissReason("browser-back-navigation-clicked"), this.hide()
                        }
                        onEsc(e) {
                            this.isShown && ((27 === e.keyCode || "Escape" === e.key) && e.preventDefault(), this.config.keyboard && this.level === this.bsModalService ? .getModalsCount() && (this.bsModalService ? .setDismissReason("esc"), this.hide()))
                        }
                        ngOnDestroy() {
                            this.isShown && this._hide()
                        }
                        hide() {
                            if (!this.isModalHiding) {
                                if (this.config.closeInterceptor) return void this.config.closeInterceptor().then(() => this._hide(), () => {});
                                this._hide()
                            }
                        }
                        _hide() {
                            this.isModalHiding = !0, this._renderer.removeClass(this._element.nativeElement, "show"), setTimeout(() => {
                                this.isShown = !1, go && go.body && 1 === this.bsModalService ? .getModalsCount() && (this._renderer.removeClass(go.body, "modal-open"), this._renderer.setStyle(go.body, "overflow-y", "")), this.bsModalService ? .hide(this.config.id), this.isModalHiding = !1, this._focusEl && this._focusEl.focus()
                            }, this.isAnimated ? 300 : 0)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(aB), We(ir), We(Ks))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["modal-container"]
                        ],
                        hostAttrs: ["role", "dialog", "tabindex", "-1", 1, "modal"],
                        hostVars: 3,
                        hostBindings: function(e, i) {
                            1 & e && xt("mousedown", function(s) {
                                return i.onClickStarted(s)
                            })("click", function(s) {
                                return i.onClickStop(s)
                            })("popstate", function() {
                                return i.onPopState()
                            }, !1, fl)("keydown.esc", function(s) {
                                return i.onEsc(s)
                            }, !1, fl), 2 & e && hi("aria-modal", !0)("aria-labelledby", i.config.ariaLabelledBy)("aria-describedby", i.config.ariaDescribedby)
                        },
                        ngContentSelectors: hee,
                        decls: 3,
                        vars: 2,
                        consts: [
                            ["role", "document", "focusTrap", ""],
                            [1, "modal-content"]
                        ],
                        template: function(e, i) {
                            1 & e && (Zd(), J(0, "div", 0)(1, "div", 1), Ru(2), ce()()), 2 & e && AT("modal-dialog" + (i.config.class ? " " + i.config.class : ""))
                        },
                        dependencies: [dee],
                        encapsulation: 2
                    }), t
                })(),
                mee = (() => {
                    class t {
                        constructor(e, i) {
                            this._isAnimated = !1, this._isShown = !1, this.element = e, this.renderer = i
                        }
                        get isAnimated() {
                            return this._isAnimated
                        }
                        set isAnimated(e) {
                            this._isAnimated = e
                        }
                        get isShown() {
                            return this._isShown
                        }
                        set isShown(e) {
                            this._isShown = e, e ? this.renderer.addClass(this.element.nativeElement, "show") : this.renderer.removeClass(this.element.nativeElement, "show")
                        }
                        ngOnInit() {
                            this.isAnimated && (this.renderer.addClass(this.element.nativeElement, "fade"), mJ.reflow(this.element.nativeElement)), this.isShown = !0
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(Ks))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["bs-modal-backdrop"]
                        ],
                        hostAttrs: [1, "modal-backdrop"],
                        decls: 0,
                        vars: 0,
                        template: function(e, i) {},
                        encapsulation: 2
                    }), t
                })(),
                gee = 1,
                oh = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.clf = i, this.modalDefaultOption = r, this.onShow = new zt, this.onShown = new zt, this.onHide = new zt, this.onHidden = new zt, this.isBodyOverflowing = !1, this.originalBodyPadding = 0, this.scrollbarWidth = 0, this.modalsCount = 0, this.loaders = [], this._focusEl = null, this._backdropLoader = this.clf.createLoader(), this._renderer = e.createRenderer(null, null), this.config = r ? Object.assign({}, uw, r) : uw
                        }
                        show(e, i) {
                            this._focusEl = go.activeElement, this.modalsCount++, this._createLoaders();
                            const r = i ? .id || gee++;
                            return this.config = this.modalDefaultOption ? Object.assign({}, uw, this.modalDefaultOption, i) : Object.assign({}, uw, i), this.config.id = r, this._showBackdrop(), this.lastDismissReason = void 0, this._showModal(e)
                        }
                        hide(e) {
                            (1 === this.modalsCount || null == e) && (this._hideBackdrop(), this.resetScrollbar()), this.modalsCount = this.modalsCount >= 1 && null != e ? this.modalsCount - 1 : 0, setTimeout(() => {
                                this._hideModal(e), this.removeLoaders(e)
                            }, this.config.animated ? 150 : 0), this._focusEl && this._focusEl.focus()
                        }
                        _showBackdrop() {
                            const e = !0 === this.config.backdrop || "static" === this.config.backdrop,
                                i = !this.backdropRef || !this.backdropRef.instance.isShown;
                            1 === this.modalsCount && (this.removeBackdrop(), e && i && (this._backdropLoader.attach(mee).to("body").show({
                                isAnimated: this.config.animated
                            }), this.backdropRef = this._backdropLoader._componentRef))
                        }
                        _hideBackdrop() {
                            this.backdropRef && (this.backdropRef.instance.isShown = !1, setTimeout(() => this.removeBackdrop(), this.config.animated ? 150 : 0))
                        }
                        _showModal(e) {
                            const i = this.loaders[this.loaders.length - 1];
                            if (this.config && this.config.providers)
                                for (const o of this.config.providers) i.provide(o);
                            const r = new Dm,
                                s = i.provide({
                                    provide: aB,
                                    useValue: this.config
                                }).provide({
                                    provide: Dm,
                                    useValue: r
                                }).attach(pee).to("body");
                            return r.hide = () => this.hide(r.id), r.setClass = o => {
                                s.instance && (s.instance.config.class = o)
                            }, r.onHidden = new zt, r.onHide = new zt, this.copyEvent(i.onBeforeHide, r.onHide), this.copyEvent(i.onHidden, r.onHidden), s.show({
                                content: e,
                                isAnimated: this.config.animated,
                                initialState: this.config.initialState,
                                bsModalService: this,
                                id: this.config.id
                            }), s.instance && (s.instance.level = this.getModalsCount(), r.content = i.getInnerComponent(), r.id = s.instance.config ? .id), r
                        }
                        _hideModal(e) {
                            if (null != e) {
                                const i = this.loaders.findIndex(s => s.instance ? .config.id === e),
                                    r = this.loaders[i];
                                r && r.hide(e)
                            } else this.loaders.forEach(i => {
                                i.instance && i.hide(i.instance.config.id)
                            })
                        }
                        getModalsCount() {
                            return this.modalsCount
                        }
                        setDismissReason(e) {
                            this.lastDismissReason = e
                        }
                        removeBackdrop() {
                            this._renderer.removeClass(go.body, "modal-open"), this._renderer.setStyle(go.body, "overflow-y", ""), this._backdropLoader.hide(), this.backdropRef = void 0
                        }
                        checkScrollbar() {
                            this.isBodyOverflowing = go.body.clientWidth < window.innerWidth, this.scrollbarWidth = this.getScrollbarWidth()
                        }
                        setScrollbar() {
                            go && (this.originalBodyPadding = parseInt(window.getComputedStyle(go.body).getPropertyValue("padding-right") || "0", 10), this.isBodyOverflowing && (go.body.style.paddingRight = `${this.originalBodyPadding+this.scrollbarWidth}px`))
                        }
                        resetScrollbar() {
                            go.body.style.paddingRight = `${this.originalBodyPadding}px`
                        }
                        getScrollbarWidth() {
                            const e = this._renderer.createElement("div");
                            this._renderer.addClass(e, "modal-scrollbar-measure"), this._renderer.appendChild(go.body, e);
                            const i = e.offsetWidth - e.clientWidth;
                            return this._renderer.removeChild(go.body, e), i
                        }
                        _createLoaders() {
                            const e = this.clf.createLoader();
                            this.copyEvent(e.onBeforeShow, this.onShow), this.copyEvent(e.onShown, this.onShown), this.copyEvent(e.onBeforeHide, this.onHide), this.copyEvent(e.onHidden, this.onHidden), this.loaders.push(e)
                        }
                        removeLoaders(e) {
                            if (null != e) {
                                const i = this.loaders.findIndex(r => r.instance ? .config.id === e);
                                i >= 0 && (this.loaders.splice(i, 1), this.loaders.forEach((r, s) => {
                                    r.instance && (r.instance.level = s + 1)
                                }))
                            } else this.loaders.splice(0, this.loaders.length)
                        }
                        copyEvent(e, i) {
                            e.subscribe(r => {
                                i.emit(this.lastDismissReason || r)
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(pf), _t(Em), _t(fee, 8))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "platform"
                    }), t
                })();
            oB.forRoot();
            let yee = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: [oh, Em, Yy]
                            }
                        }
                        static forChild() {
                            return {
                                ngModule: t,
                                providers: [oh, Em, Yy]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [oB]
                    }), t
                })(),
                cB = (() => {
                    class t {
                        constructor(e, i) {
                            this._renderer = e, this._elementRef = i, this.onChange = r => {}, this.onTouched = () => {}
                        }
                        setProperty(e, i) {
                            this._renderer.setProperty(this._elementRef.nativeElement, e, i)
                        }
                        registerOnTouched(e) {
                            this.onTouched = e
                        }
                        registerOnChange(e) {
                            this.onChange = e
                        }
                        setDisabledState(e) {
                            this.setProperty("disabled", e)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Ks), We(ir))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t
                        })
                    }
                    return t
                })(),
                Pf = (() => {
                    class t extends cB {
                        static# e = this.\u0275fac = function() {
                            let e;
                            return function(r) {
                                return (e || (e = ys(t)))(r || t)
                            }
                        }();
                        static# t = this.\u0275dir = Un({
                            type: t,
                            features: [Vr]
                        })
                    }
                    return t
                })();
            const tu = new nn("NgValueAccessor"),
                vee = {
                    provide: tu,
                    useExisting: Xn(() => Qy),
                    multi: !0
                },
                wee = new nn("CompositionEventMode");
            let Qy = (() => {
                class t extends cB {
                    constructor(e, i, r) {
                        super(e, i), this._compositionMode = r, this._composing = !1, null == this._compositionMode && (this._compositionMode = ! function bee() {
                            const t = Nu() ? Nu().getUserAgent() : "";
                            return /android (\d+)/.test(t.toLowerCase())
                        }())
                    }
                    writeValue(e) {
                        this.setProperty("value", e ? ? "")
                    }
                    _handleInput(e) {
                        (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e)
                    }
                    _compositionStart() {
                        this._composing = !0
                    }
                    _compositionEnd(e) {
                        this._composing = !1, this._compositionMode && this.onChange(e)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(We(Ks), We(ir), We(wee, 8))
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["input", "formControlName", "", 3, "type", "checkbox"],
                            ["textarea", "formControlName", ""],
                            ["input", "formControl", "", 3, "type", "checkbox"],
                            ["textarea", "formControl", ""],
                            ["input", "ngModel", "", 3, "type", "checkbox"],
                            ["textarea", "ngModel", ""],
                            ["", "ngDefaultControl", ""]
                        ],
                        hostBindings: function(i, r) {
                            1 & i && xt("input", function(o) {
                                return r._handleInput(o.target.value)
                            })("blur", function() {
                                return r.onTouched()
                            })("compositionstart", function() {
                                return r._compositionStart()
                            })("compositionend", function(o) {
                                return r._compositionEnd(o.target.value)
                            })
                        },
                        features: [Jr([vee]), Vr]
                    })
                }
                return t
            })();
            const ra = new nn("NgValidators"),
                ch = new nn("NgAsyncValidators");

            function _B(t) {
                if (!t) return hw;
                let n, e;
                return "string" == typeof t ? (e = "", "^" !== t.charAt(0) && (e += "^"), e += t, "$" !== t.charAt(t.length - 1) && (e += "$"), n = new RegExp(e)) : (e = t.toString(), n = t), i => {
                    if (function ah(t) {
                            return null == t || ("string" == typeof t || Array.isArray(t)) && 0 === t.length
                        }(i.value)) return null;
                    const r = i.value;
                    return n.test(r) ? null : {
                        pattern: {
                            requiredPattern: e,
                            actualValue: r
                        }
                    }
                }
            }

            function hw(t) {
                return null
            }

            function vB(t) {
                return null != t
            }

            function bB(t) {
                return _y(t) ? gn(t) : t
            }

            function wB(t) {
                let n = {};
                return t.forEach(e => {
                    n = null != e ? { ...n,
                        ...e
                    } : n
                }), 0 === Object.keys(n).length ? null : n
            }

            function xB(t, n) {
                return n.map(e => e(t))
            }

            function CB(t) {
                return t.map(n => function Cee(t) {
                    return !t.validate
                }(n) ? n : e => n.validate(e))
            }

            function U2(t) {
                return null != t ? function TB(t) {
                    if (!t) return null;
                    const n = t.filter(vB);
                    return 0 == n.length ? null : function(e) {
                        return wB(xB(e, n))
                    }
                }(CB(t)) : null
            }

            function H2(t) {
                return null != t ? function SB(t) {
                    if (!t) return null;
                    const n = t.filter(vB);
                    return 0 == n.length ? null : function(e) {
                        return c6(xB(e, n).map(bB)).pipe(Fe(wB))
                    }
                }(CB(t)) : null
            }

            function EB(t, n) {
                return null === t ? [n] : Array.isArray(t) ? [...t, n] : [t, n]
            }

            function $2(t) {
                return t ? Array.isArray(t) ? t : [t] : []
            }

            function fw(t, n) {
                return Array.isArray(t) ? t.includes(n) : t === n
            }

            function kB(t, n) {
                const e = $2(n);
                return $2(t).forEach(r => {
                    fw(e, r) || e.push(r)
                }), e
            }

            function MB(t, n) {
                return $2(n).filter(e => !fw(t, e))
            }
            class IB {
                constructor() {
                    this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = []
                }
                get value() {
                    return this.control ? this.control.value : null
                }
                get valid() {
                    return this.control ? this.control.valid : null
                }
                get invalid() {
                    return this.control ? this.control.invalid : null
                }
                get pending() {
                    return this.control ? this.control.pending : null
                }
                get disabled() {
                    return this.control ? this.control.disabled : null
                }
                get enabled() {
                    return this.control ? this.control.enabled : null
                }
                get errors() {
                    return this.control ? this.control.errors : null
                }
                get pristine() {
                    return this.control ? this.control.pristine : null
                }
                get dirty() {
                    return this.control ? this.control.dirty : null
                }
                get touched() {
                    return this.control ? this.control.touched : null
                }
                get status() {
                    return this.control ? this.control.status : null
                }
                get untouched() {
                    return this.control ? this.control.untouched : null
                }
                get statusChanges() {
                    return this.control ? this.control.statusChanges : null
                }
                get valueChanges() {
                    return this.control ? this.control.valueChanges : null
                }
                get path() {
                    return null
                }
                _setValidators(n) {
                    this._rawValidators = n || [], this._composedValidatorFn = U2(this._rawValidators)
                }
                _setAsyncValidators(n) {
                    this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = H2(this._rawAsyncValidators)
                }
                get validator() {
                    return this._composedValidatorFn || null
                }
                get asyncValidator() {
                    return this._composedAsyncValidatorFn || null
                }
                _registerOnDestroy(n) {
                    this._onDestroyCallbacks.push(n)
                }
                _invokeOnDestroyCallbacks() {
                    this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = []
                }
                reset(n = void 0) {
                    this.control && this.control.reset(n)
                }
                hasError(n, e) {
                    return !!this.control && this.control.hasError(n, e)
                }
                getError(n, e) {
                    return this.control ? this.control.getError(n, e) : null
                }
            }
            class Ea extends IB {
                get formDirective() {
                    return null
                }
                get path() {
                    return null
                }
            }
            class lh extends IB {
                constructor() {
                    super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null
                }
            }
            class PB {
                constructor(n) {
                    this._cd = n
                }
                get isTouched() {
                    return !!this._cd ? .control ? .touched
                }
                get isUntouched() {
                    return !!this._cd ? .control ? .untouched
                }
                get isPristine() {
                    return !!this._cd ? .control ? .pristine
                }
                get isDirty() {
                    return !!this._cd ? .control ? .dirty
                }
                get isValid() {
                    return !!this._cd ? .control ? .valid
                }
                get isInvalid() {
                    return !!this._cd ? .control ? .invalid
                }
                get isPending() {
                    return !!this._cd ? .control ? .pending
                }
                get isSubmitted() {
                    return !!this._cd ? .submitted
                }
            }
            let z2 = (() => {
                class t extends PB {
                    constructor(e) {
                        super(e)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(We(lh, 2))
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "formControlName", ""],
                            ["", "ngModel", ""],
                            ["", "formControl", ""]
                        ],
                        hostVars: 14,
                        hostBindings: function(i, r) {
                            2 & i && ja("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)
                        },
                        features: [Vr]
                    })
                }
                return t
            })();
            const Jy = "VALID",
                mw = "INVALID",
                Am = "PENDING",
                e0 = "DISABLED";

            function gw(t) {
                return null != t && !Array.isArray(t) && "object" == typeof t
            }
            class BB {
                constructor(n, e) {
                    this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => {}, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(e)
                }
                get validator() {
                    return this._composedValidatorFn
                }
                set validator(n) {
                    this._rawValidators = this._composedValidatorFn = n
                }
                get asyncValidator() {
                    return this._composedAsyncValidatorFn
                }
                set asyncValidator(n) {
                    this._rawAsyncValidators = this._composedAsyncValidatorFn = n
                }
                get parent() {
                    return this._parent
                }
                get valid() {
                    return this.status === Jy
                }
                get invalid() {
                    return this.status === mw
                }
                get pending() {
                    return this.status == Am
                }
                get disabled() {
                    return this.status === e0
                }
                get enabled() {
                    return this.status !== e0
                }
                get dirty() {
                    return !this.pristine
                }
                get untouched() {
                    return !this.touched
                }
                get updateOn() {
                    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
                }
                setValidators(n) {
                    this._assignValidators(n)
                }
                setAsyncValidators(n) {
                    this._assignAsyncValidators(n)
                }
                addValidators(n) {
                    this.setValidators(kB(n, this._rawValidators))
                }
                addAsyncValidators(n) {
                    this.setAsyncValidators(kB(n, this._rawAsyncValidators))
                }
                removeValidators(n) {
                    this.setValidators(MB(n, this._rawValidators))
                }
                removeAsyncValidators(n) {
                    this.setAsyncValidators(MB(n, this._rawAsyncValidators))
                }
                hasValidator(n) {
                    return fw(this._rawValidators, n)
                }
                hasAsyncValidator(n) {
                    return fw(this._rawAsyncValidators, n)
                }
                clearValidators() {
                    this.validator = null
                }
                clearAsyncValidators() {
                    this.asyncValidator = null
                }
                markAsTouched(n = {}) {
                    this.touched = !0, this._parent && !n.onlySelf && this._parent.markAsTouched(n)
                }
                markAllAsTouched() {
                    this.markAsTouched({
                        onlySelf: !0
                    }), this._forEachChild(n => n.markAllAsTouched())
                }
                markAsUntouched(n = {}) {
                    this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => {
                        e.markAsUntouched({
                            onlySelf: !0
                        })
                    }), this._parent && !n.onlySelf && this._parent._updateTouched(n)
                }
                markAsDirty(n = {}) {
                    this.pristine = !1, this._parent && !n.onlySelf && this._parent.markAsDirty(n)
                }
                markAsPristine(n = {}) {
                    this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => {
                        e.markAsPristine({
                            onlySelf: !0
                        })
                    }), this._parent && !n.onlySelf && this._parent._updatePristine(n)
                }
                markAsPending(n = {}) {
                    this.status = Am, !1 !== n.emitEvent && this.statusChanges.emit(this.status), this._parent && !n.onlySelf && this._parent.markAsPending(n)
                }
                disable(n = {}) {
                    const e = this._parentMarkedDirty(n.onlySelf);
                    this.status = e0, this.errors = null, this._forEachChild(i => {
                        i.disable({ ...n,
                            onlySelf: !0
                        })
                    }), this._updateValue(), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n,
                        skipPristineCheck: e
                    }), this._onDisabledChange.forEach(i => i(!0))
                }
                enable(n = {}) {
                    const e = this._parentMarkedDirty(n.onlySelf);
                    this.status = Jy, this._forEachChild(i => {
                        i.enable({ ...n,
                            onlySelf: !0
                        })
                    }), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: n.emitEvent
                    }), this._updateAncestors({ ...n,
                        skipPristineCheck: e
                    }), this._onDisabledChange.forEach(i => i(!1))
                }
                _updateAncestors(n) {
                    this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched())
                }
                setParent(n) {
                    this._parent = n
                }
                getRawValue() {
                    return this.value
                }
                updateValueAndValidity(n = {}) {
                    this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Jy || this.status === Am) && this._runAsyncValidator(n.emitEvent)), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n)
                }
                _updateTreeValidity(n = {
                    emitEvent: !0
                }) {
                    this._forEachChild(e => e._updateTreeValidity(n)), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: n.emitEvent
                    })
                }
                _setInitialStatus() {
                    this.status = this._allControlsDisabled() ? e0 : Jy
                }
                _runValidator() {
                    return this.validator ? this.validator(this) : null
                }
                _runAsyncValidator(n) {
                    if (this.asyncValidator) {
                        this.status = Am, this._hasOwnPendingAsyncValidator = !0;
                        const e = bB(this.asyncValidator(this));
                        this._asyncValidationSubscription = e.subscribe(i => {
                            this._hasOwnPendingAsyncValidator = !1, this.setErrors(i, {
                                emitEvent: n
                            })
                        })
                    }
                }
                _cancelExistingSubscription() {
                    this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1)
                }
                setErrors(n, e = {}) {
                    this.errors = n, this._updateControlsErrors(!1 !== e.emitEvent)
                }
                get(n) {
                    let e = n;
                    return null == e || (Array.isArray(e) || (e = e.split(".")), 0 === e.length) ? null : e.reduce((i, r) => i && i._find(r), this)
                }
                getError(n, e) {
                    const i = e ? this.get(e) : this;
                    return i && i.errors ? i.errors[n] : null
                }
                hasError(n, e) {
                    return !!this.getError(n, e)
                }
                get root() {
                    let n = this;
                    for (; n._parent;) n = n._parent;
                    return n
                }
                _updateControlsErrors(n) {
                    this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(n)
                }
                _initObservables() {
                    this.valueChanges = new zt, this.statusChanges = new zt
                }
                _calculateStatus() {
                    return this._allControlsDisabled() ? e0 : this.errors ? mw : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Am) ? Am : this._anyControlsHaveStatus(mw) ? mw : Jy
                }
                _anyControlsHaveStatus(n) {
                    return this._anyControls(e => e.status === n)
                }
                _anyControlsDirty() {
                    return this._anyControls(n => n.dirty)
                }
                _anyControlsTouched() {
                    return this._anyControls(n => n.touched)
                }
                _updatePristine(n = {}) {
                    this.pristine = !this._anyControlsDirty(), this._parent && !n.onlySelf && this._parent._updatePristine(n)
                }
                _updateTouched(n = {}) {
                    this.touched = this._anyControlsTouched(), this._parent && !n.onlySelf && this._parent._updateTouched(n)
                }
                _registerOnCollectionChange(n) {
                    this._onCollectionChange = n
                }
                _setUpdateStrategy(n) {
                    gw(n) && null != n.updateOn && (this._updateOn = n.updateOn)
                }
                _parentMarkedDirty(n) {
                    return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty()
                }
                _find(n) {
                    return null
                }
                _assignValidators(n) {
                    this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function Aee(t) {
                        return Array.isArray(t) ? U2(t) : t || null
                    }(this._rawValidators)
                }
                _assignAsyncValidators(n) {
                    this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function kee(t) {
                        return Array.isArray(t) ? H2(t) : t || null
                    }(this._rawAsyncValidators)
                }
            }
            const Of = new nn("CallSetDisabledState", {
                    providedIn: "root",
                    factory: () => t0
                }),
                t0 = "always";

            function n0(t, n, e = t0) {
                (function Z2(t, n) {
                    const e = function DB(t) {
                        return t._rawValidators
                    }(t);
                    null !== n.validator ? t.setValidators(EB(e, n.validator)) : "function" == typeof e && t.setValidators([e]);
                    const i = function AB(t) {
                        return t._rawAsyncValidators
                    }(t);
                    null !== n.asyncValidator ? t.setAsyncValidators(EB(i, n.asyncValidator)) : "function" == typeof i && t.setAsyncValidators([i]);
                    const r = () => t.updateValueAndValidity();
                    vw(n._rawValidators, r), vw(n._rawAsyncValidators, r)
                })(t, n), n.valueAccessor.writeValue(t.value), (t.disabled || "always" === e) && n.valueAccessor.setDisabledState ? .(t.disabled),
                    function Pee(t, n) {
                        n.valueAccessor.registerOnChange(e => {
                            t._pendingValue = e, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && NB(t, n)
                        })
                    }(t, n),
                    function Lee(t, n) {
                        const e = (i, r) => {
                            n.valueAccessor.writeValue(i), r && n.viewToModelUpdate(i)
                        };
                        t.registerOnChange(e), n._registerOnDestroy(() => {
                            t._unregisterOnChange(e)
                        })
                    }(t, n),
                    function Oee(t, n) {
                        n.valueAccessor.registerOnTouched(() => {
                            t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && NB(t, n), "submit" !== t.updateOn && t.markAsTouched()
                        })
                    }(t, n),
                    function Iee(t, n) {
                        if (n.valueAccessor.setDisabledState) {
                            const e = i => {
                                n.valueAccessor.setDisabledState(i)
                            };
                            t.registerOnDisabledChange(e), n._registerOnDestroy(() => {
                                t._unregisterOnDisabledChange(e)
                            })
                        }
                    }(t, n)
            }

            function vw(t, n) {
                t.forEach(e => {
                    e.registerOnValidatorChange && e.registerOnValidatorChange(n)
                })
            }

            function NB(t, n) {
                t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, {
                    emitModelToViewChange: !1
                }), n.viewToModelUpdate(t._pendingValue), t._pendingChange = !1
            }

            function UB(t, n) {
                const e = t.indexOf(n);
                e > -1 && t.splice(e, 1)
            }

            function HB(t) {
                return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t
            }
            const $B = class extends BB {
                    constructor(n = null, e, i) {
                        super(function G2(t) {
                            return (gw(t) ? t.validators : t) || null
                        }(e), function K2(t, n) {
                            return (gw(n) ? n.asyncValidators : t) || null
                        }(i, e)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({
                            onlySelf: !0,
                            emitEvent: !!this.asyncValidator
                        }), gw(e) && (e.nonNullable || e.initialValueIsDefault) && (this.defaultValue = HB(n) ? n.value : n)
                    }
                    setValue(n, e = {}) {
                        this.value = this._pendingValue = n, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(i => i(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e)
                    }
                    patchValue(n, e = {}) {
                        this.setValue(n, e)
                    }
                    reset(n = this.defaultValue, e = {}) {
                        this._applyFormState(n), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1
                    }
                    _updateValue() {}
                    _anyControls(n) {
                        return !1
                    }
                    _allControlsDisabled() {
                        return this.disabled
                    }
                    registerOnChange(n) {
                        this._onChange.push(n)
                    }
                    _unregisterOnChange(n) {
                        UB(this._onChange, n)
                    }
                    registerOnDisabledChange(n) {
                        this._onDisabledChange.push(n)
                    }
                    _unregisterOnDisabledChange(n) {
                        UB(this._onDisabledChange, n)
                    }
                    _forEachChild(n) {}
                    _syncPendingControls() {
                        return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, {
                            onlySelf: !0,
                            emitModelToViewChange: !1
                        }), 0))
                    }
                    _applyFormState(n) {
                        HB(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({
                            onlySelf: !0,
                            emitEvent: !1
                        }) : this.enable({
                            onlySelf: !0,
                            emitEvent: !1
                        })) : this.value = this._pendingValue = n
                    }
                },
                $ee = {
                    provide: lh,
                    useExisting: Xn(() => ww)
                },
                WB = (() => Promise.resolve())();
            let ww = (() => {
                    class t extends lh {
                        constructor(e, i, r, s, o, a) {
                            super(), this._changeDetectorRef = o, this.callSetDisabledState = a, this.control = new $B, this._registered = !1, this.name = "", this.update = new zt, this._parent = e, this._setValidators(i), this._setAsyncValidators(r), this.valueAccessor = function Q2(t, n) {
                                if (!n) return null;
                                let e, i, r;
                                return Array.isArray(n), n.forEach(s => {
                                    s.constructor === Qy ? e = s : function Nee(t) {
                                        return Object.getPrototypeOf(t.constructor) === Pf
                                    }(s) ? i = s : r = s
                                }), r || i || e || null
                            }(0, s)
                        }
                        ngOnChanges(e) {
                            if (this._checkForErrors(), !this._registered || "name" in e) {
                                if (this._registered && (this._checkName(), this.formDirective)) {
                                    const i = e.name.previousValue;
                                    this.formDirective.removeControl({
                                        name: i,
                                        path: this._getPath(i)
                                    })
                                }
                                this._setUpControl()
                            }
                            "isDisabled" in e && this._updateDisabled(e),
                                function X2(t, n) {
                                    if (!t.hasOwnProperty("model")) return !1;
                                    const e = t.model;
                                    return !!e.isFirstChange() || !Object.is(n, e.currentValue)
                                }(e, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model)
                        }
                        ngOnDestroy() {
                            this.formDirective && this.formDirective.removeControl(this)
                        }
                        get path() {
                            return this._getPath(this.name)
                        }
                        get formDirective() {
                            return this._parent ? this._parent.formDirective : null
                        }
                        viewToModelUpdate(e) {
                            this.viewModel = e, this.update.emit(e)
                        }
                        _setUpControl() {
                            this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0
                        }
                        _setUpdateStrategy() {
                            this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn)
                        }
                        _isStandalone() {
                            return !this._parent || !(!this.options || !this.options.standalone)
                        }
                        _setUpStandalone() {
                            n0(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({
                                emitEvent: !1
                            })
                        }
                        _checkForErrors() {
                            this._isStandalone() || this._checkParentType(), this._checkName()
                        }
                        _checkParentType() {}
                        _checkName() {
                            this.options && this.options.name && (this.name = this.options.name), this._isStandalone()
                        }
                        _updateValue(e) {
                            WB.then(() => {
                                this.control.setValue(e, {
                                    emitViewToModelChange: !1
                                }), this._changeDetectorRef ? .markForCheck()
                            })
                        }
                        _updateDisabled(e) {
                            const i = e.isDisabled.currentValue,
                                r = 0 !== i && ym(i);
                            WB.then(() => {
                                r && !this.control.disabled ? this.control.disable() : !r && this.control.disabled && this.control.enable(), this._changeDetectorRef ? .markForCheck()
                            })
                        }
                        _getPath(e) {
                            return this._parent ? function yw(t, n) {
                                return [...n.path, t]
                            }(e, this._parent) : [e]
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Ea, 9), We(ra, 10), We(ch, 10), We(tu, 10), We(qa, 8), We(Of, 8))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]
                            ],
                            inputs: {
                                name: "name",
                                isDisabled: ["disabled", "isDisabled"],
                                model: ["ngModel", "model"],
                                options: ["ngModelOptions", "options"]
                            },
                            outputs: {
                                update: "ngModelChange"
                            },
                            exportAs: ["ngModel"],
                            features: [Jr([$ee]), Vr, Xi]
                        })
                    }
                    return t
                })(),
                KB = (() => {
                    class t {
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({})
                    }
                    return t
                })();
            const eE = new nn("NgModelWithFormControlWarning");
            let Lf = (() => {
                class t {
                    constructor() {
                        this._validator = hw
                    }
                    ngOnChanges(e) {
                        if (this.inputName in e) {
                            const i = this.normalizeInput(e[this.inputName].currentValue);
                            this._enabled = this.enabled(i), this._validator = this._enabled ? this.createValidator(i) : hw, this._onChange && this._onChange()
                        }
                    }
                    validate(e) {
                        return this._validator(e)
                    }
                    registerOnValidatorChange(e) {
                        this._onChange = e
                    }
                    enabled(e) {
                        return null != e
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        features: [Xi]
                    })
                }
                return t
            })();
            const hte = {
                provide: ra,
                useExisting: Xn(() => aE),
                multi: !0
            };
            let aE = (() => {
                    class t extends Lf {
                        constructor() {
                            super(...arguments), this.inputName = "pattern", this.normalizeInput = e => e, this.createValidator = e => _B(e)
                        }
                        static# e = this.\u0275fac = function() {
                            let e;
                            return function(r) {
                                return (e || (e = ys(t)))(r || t)
                            }
                        }();
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "pattern", "", "formControlName", ""],
                                ["", "pattern", "", "formControl", ""],
                                ["", "pattern", "", "ngModel", ""]
                            ],
                            hostVars: 1,
                            hostBindings: function(i, r) {
                                2 & i && hi("pattern", r._enabled ? r.pattern : null)
                            },
                            inputs: {
                                pattern: "pattern"
                            },
                            features: [Jr([hte]), Vr]
                        })
                    }
                    return t
                })(),
                lN = (() => {
                    class t {
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({
                            imports: [KB]
                        })
                    }
                    return t
                })(),
                uN = (() => {
                    class t {
                        static withConfig(e) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: Of,
                                    useValue: e.callSetDisabledState ? ? t0
                                }]
                            }
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({
                            imports: [lN]
                        })
                    }
                    return t
                })(),
                pte = (() => {
                    class t {
                        static withConfig(e) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: eE,
                                    useValue: e.warnOnNgModelWithFormControl ? ? "always"
                                }, {
                                    provide: Of,
                                    useValue: e.callSetDisabledState ? ? t0
                                }]
                            }
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275mod = _i({
                            type: t
                        });
                        static# n = this.\u0275inj = wi({
                            imports: [lN]
                        })
                    }
                    return t
                })();
            const mte = new nn("WindowToken", typeof window < "u" && window.document ? {
                providedIn: "root",
                factory: () => window
            } : {
                providedIn: "root",
                factory: () => {}
            });
            let gte = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.ngZone = e, this.document = i, this.window = r, this.copySubject = new A, this.copyResponse$ = this.copySubject.asObservable(), this.config = {}
                        }
                        configure(e) {
                            this.config = e
                        }
                        copy(e) {
                            if (!this.isSupported || !e) return this.pushCopyResponse({
                                isSuccess: !1,
                                content: e
                            });
                            const i = this.copyFromContent(e);
                            return this.pushCopyResponse(i ? {
                                content: e,
                                isSuccess: i
                            } : {
                                isSuccess: !1,
                                content: e
                            })
                        }
                        get isSupported() {
                            return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported("copy") && !!this.window
                        }
                        isTargetValid(e) {
                            if (e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement) {
                                if (e.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                return !0
                            }
                            throw new Error("Target should be input or textarea")
                        }
                        copyFromInputElement(e, i = !0) {
                            try {
                                this.selectTarget(e);
                                const r = this.copyText();
                                return this.clearSelection(i ? e : void 0, this.window), r && this.isCopySuccessInIE11()
                            } catch {
                                return !1
                            }
                        }
                        isCopySuccessInIE11() {
                            const e = this.window.clipboardData;
                            return !(e && e.getData && !e.getData("Text"))
                        }
                        copyFromContent(e, i = this.document.body) {
                            if (this.tempTextArea && !i.contains(this.tempTextArea) && this.destroy(this.tempTextArea.parentElement || void 0), !this.tempTextArea) {
                                this.tempTextArea = this.createTempTextArea(this.document, this.window);
                                try {
                                    i.appendChild(this.tempTextArea)
                                } catch {
                                    throw new Error("Container should be a Dom element")
                                }
                            }
                            this.tempTextArea.value = e;
                            const r = this.copyFromInputElement(this.tempTextArea, !1);
                            return this.config.cleanUpAfterCopy && this.destroy(this.tempTextArea.parentElement || void 0), r
                        }
                        destroy(e = this.document.body) {
                            this.tempTextArea && (e.removeChild(this.tempTextArea), this.tempTextArea = void 0)
                        }
                        selectTarget(e) {
                            return e.select(), e.setSelectionRange(0, e.value.length), e.value.length
                        }
                        copyText() {
                            return this.document.execCommand("copy")
                        }
                        clearSelection(e, i) {
                            e && e.focus(), i.getSelection() ? .removeAllRanges()
                        }
                        createTempTextArea(e, i) {
                            const r = "rtl" === e.documentElement.getAttribute("dir");
                            let s;
                            return s = e.createElement("textarea"), s.style.fontSize = "12pt", s.style.border = "0", s.style.padding = "0", s.style.margin = "0", s.style.position = "absolute", s.style[r ? "right" : "left"] = "-9999px", s.style.top = (i.pageYOffset || e.documentElement.scrollTop) + "px", s.setAttribute("readonly", ""), s
                        }
                        pushCopyResponse(e) {
                            this.copySubject.observers.length > 0 && this.ngZone.run(() => {
                                this.copySubject.next(e)
                            })
                        }
                        pushCopyReponse(e) {
                            this.pushCopyResponse(e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(cr), _t(Ss), _t(mte, 8))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                yte = (() => {
                    class t {
                        constructor(e, i, r, s) {
                            this.ngZone = e, this.host = i, this.renderer = r, this.clipboardSrv = s, this.cbOnSuccess = new zt, this.cbOnError = new zt, this.onClick = o => {
                                this.clipboardSrv.isSupported ? this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm) ? this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, o) : this.cbContent && this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, o) : this.handleResult(!1, void 0, o)
                            }
                        }
                        ngOnInit() {
                            this.ngZone.runOutsideAngular(() => {
                                this.clickListener = this.renderer.listen(this.host.nativeElement, "click", this.onClick)
                            })
                        }
                        ngOnDestroy() {
                            this.clickListener && this.clickListener(), this.clipboardSrv.destroy(this.container)
                        }
                        handleResult(e, i, r) {
                            let s = {
                                isSuccess: e,
                                content: i,
                                successMessage: this.cbSuccessMsg,
                                event: r
                            };
                            e ? this.cbOnSuccess.observed && this.ngZone.run(() => {
                                this.cbOnSuccess.emit(s)
                            }) : this.cbOnError.observed && this.ngZone.run(() => {
                                this.cbOnError.emit(s)
                            }), this.clipboardSrv.pushCopyResponse(s)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(cr), We(ir), We(Ks), We(gte))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "ngxClipboard", ""]
                        ],
                        inputs: {
                            targetElm: ["ngxClipboard", "targetElm"],
                            container: "container",
                            cbContent: "cbContent",
                            cbSuccessMsg: "cbSuccessMsg"
                        },
                        outputs: {
                            cbOnSuccess: "cbOnSuccess",
                            cbOnError: "cbOnError"
                        }
                    }), t
                })(),
                _te = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [mc]
                        ]
                    }), t
                })();
            const xw = K(t => function() {
                t(this), this.name = "EmptyError", this.message = "no elements in sequence"
            });

            function Cw(t) {
                return R((n, e) => {
                    let i = !1;
                    n.subscribe(Q(e, r => {
                        i = !0, e.next(r)
                    }, () => {
                        i || e.next(t), e.complete()
                    }))
                })
            }

            function dN(t = vte) {
                return R((n, e) => {
                    let i = !1;
                    n.subscribe(Q(e, r => {
                        i = !0, e.next(r)
                    }, () => i ? e.complete() : e.error(t())))
                })
            }

            function vte() {
                return new xw
            }

            function nu(t, n) {
                const e = arguments.length >= 2;
                return i => i.pipe(t ? ia((r, s) => t(r, s, i)) : $, Sa(1), e ? Cw(n) : dN(() => new xw))
            }

            function hN(t) {
                return ia((n, e) => t <= e)
            }

            function fN(t, n, e, i, r) {
                return (s, o) => {
                    let a = e,
                        c = n,
                        u = 0;
                    s.subscribe(Q(o, h => {
                        const m = u++;
                        c = a ? t(c, h, m) : (a = !0, h), i && o.next(c)
                    }, r && (() => {
                        a && o.next(c), o.complete()
                    })))
                }
            }
            const wte = (t, n) => (t.push(n), t);
            const Tw = new U6(V6),
                Cte = Tw;

            function pN(t) {
                return Fe(() => t)
            }

            function mN(t, n) {
                return n ? e => wm(n.pipe(Sa(1), function Tte() {
                    return R((t, n) => {
                        t.subscribe(Q(n, le))
                    })
                }()), e.pipe(mN(t))) : ke((e, i) => ji(t(e, i)).pipe(Sa(1), pN(e)))
            }

            function gN(t = 0, n, e = Cte) {
                let i = -1;
                return null != n && (Kn(n) ? e = n : i = n), new M(r => {
                    let s = function Ste(t) {
                        return t instanceof Date && !isNaN(t)
                    }(t) ? +t - e.now() : t;
                    s < 0 && (s = 0);
                    let o = 0;
                    return e.schedule(function() {
                        r.closed || (r.next(o++), 0 <= i ? this.schedule(void 0, i) : r.complete())
                    }, s)
                })
            }

            function cE(...t) {
                const n = _n(t),
                    e = $n(t),
                    {
                        args: i,
                        keys: r
                    } = o6(t);
                if (0 === i.length) return gn([], n);
                const s = new M(function Dte(t, n, e = $) {
                    return i => {
                        yN(n, () => {
                            const {
                                length: r
                            } = t, s = new Array(r);
                            let o = r,
                                a = r;
                            for (let c = 0; c < r; c++) yN(n, () => {
                                const u = gn(t[c], n);
                                let h = !1;
                                u.subscribe(Q(i, m => {
                                    s[c] = m, h || (h = !0, a--), a || i.next(e(s.slice()))
                                }, () => {
                                    --o || i.complete()
                                }))
                            }, i)
                        }, i)
                    }
                }(i, n, r ? o => a6(r, o) : $));
                return e ? s.pipe(g2(e)) : s
            }

            function yN(t, n, e) {
                t ? O(e, t, n) : n()
            }

            function lE() {
                return R((t, n) => {
                    let e = null;
                    t._refCount++;
                    const i = Q(n, void 0, void 0, void 0, () => {
                        if (!t || t._refCount <= 0 || 0 < --t._refCount) return void(e = null);
                        const r = t._connection,
                            s = e;
                        e = null, r && (!s || r === s) && r.unsubscribe(), n.unsubscribe()
                    });
                    t.subscribe(i), i.closed || (e = t.connect())
                })
            }
            class _N extends M {
                constructor(n, e) {
                    super(), this.source = n, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, N(n) && (this.lift = n.lift)
                }
                _subscribe(n) {
                    return this.getSubject().subscribe(n)
                }
                getSubject() {
                    const n = this._subject;
                    return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject
                }
                _teardown() {
                    this._refCount = 0;
                    const {
                        _connection: n
                    } = this;
                    this._subject = this._connection = null, n ? .unsubscribe()
                }
                connect() {
                    let n = this._connection;
                    if (!n) {
                        n = this._connection = new S;
                        const e = this.getSubject();
                        n.add(this.source.subscribe(Q(e, void 0, () => {
                            this._teardown(), e.complete()
                        }, i => {
                            this._teardown(), e.error(i)
                        }, () => this._teardown()))), n.closed && (this._connection = null, n = S.EMPTY)
                    }
                    return n
                }
                refCount() {
                    return lE()(this)
                }
            }

            function uE(t) {
                return t <= 0 ? () => Qe : R((n, e) => {
                    let i = [];
                    n.subscribe(Q(e, r => {
                        i.push(r), t < i.length && i.shift()
                    }, () => {
                        for (const r of i) e.next(r);
                        e.complete()
                    }, void 0, () => {
                        i = null
                    }))
                })
            }

            function vN(t) {
                return R((n, e) => {
                    ji(t).subscribe(Q(e, () => e.complete(), le)), !e.closed && n.subscribe(e)
                })
            }
            const Hi = "primary",
                s0 = Symbol("RouteTitle");
            class Ite {
                constructor(n) {
                    this.params = n || {}
                }
                has(n) {
                    return Object.prototype.hasOwnProperty.call(this.params, n)
                }
                get(n) {
                    if (this.has(n)) {
                        const e = this.params[n];
                        return Array.isArray(e) ? e[0] : e
                    }
                    return null
                }
                getAll(n) {
                    if (this.has(n)) {
                        const e = this.params[n];
                        return Array.isArray(e) ? e : [e]
                    }
                    return []
                }
                get keys() {
                    return Object.keys(this.params)
                }
            }

            function km(t) {
                return new Ite(t)
            }

            function Pte(t, n, e) {
                const i = e.path.split("/");
                if (i.length > t.length || "full" === e.pathMatch && (n.hasChildren() || i.length < t.length)) return null;
                const r = {};
                for (let s = 0; s < i.length; s++) {
                    const o = i[s],
                        a = t[s];
                    if (o.startsWith(":")) r[o.substring(1)] = a;
                    else if (o !== a.path) return null
                }
                return {
                    consumed: t.slice(0, i.length),
                    posParams: r
                }
            }

            function iu(t, n) {
                const e = t ? Object.keys(t) : void 0,
                    i = n ? Object.keys(n) : void 0;
                if (!e || !i || e.length != i.length) return !1;
                let r;
                for (let s = 0; s < e.length; s++)
                    if (r = e[s], !bN(t[r], n[r])) return !1;
                return !0
            }

            function bN(t, n) {
                if (Array.isArray(t) && Array.isArray(n)) {
                    if (t.length !== n.length) return !1;
                    const e = [...t].sort(),
                        i = [...n].sort();
                    return e.every((r, s) => i[s] === r)
                }
                return t === n
            }

            function wN(t) {
                return t.length > 0 ? t[t.length - 1] : null
            }

            function uh(t) {
                return ju(t) ? t : _y(t) ? gn(Promise.resolve(t)) : Ve(t)
            }
            const Lte = {
                    exact: function TN(t, n, e) {
                        if (!Rf(t.segments, n.segments) || !Sw(t.segments, n.segments, e) || t.numberOfChildren !== n.numberOfChildren) return !1;
                        for (const i in n.children)
                            if (!t.children[i] || !TN(t.children[i], n.children[i], e)) return !1;
                        return !0
                    },
                    subset: SN
                },
                xN = {
                    exact: function Rte(t, n) {
                        return iu(t, n)
                    },
                    subset: function Bte(t, n) {
                        return Object.keys(n).length <= Object.keys(t).length && Object.keys(n).every(e => bN(t[e], n[e]))
                    },
                    ignored: () => !0
                };

            function CN(t, n, e) {
                return Lte[e.paths](t.root, n.root, e.matrixParams) && xN[e.queryParams](t.queryParams, n.queryParams) && !("exact" === e.fragment && t.fragment !== n.fragment)
            }

            function SN(t, n, e) {
                return EN(t, n, n.segments, e)
            }

            function EN(t, n, e, i) {
                if (t.segments.length > e.length) {
                    const r = t.segments.slice(0, e.length);
                    return !(!Rf(r, e) || n.hasChildren() || !Sw(r, e, i))
                }
                if (t.segments.length === e.length) {
                    if (!Rf(t.segments, e) || !Sw(t.segments, e, i)) return !1;
                    for (const r in n.children)
                        if (!t.children[r] || !SN(t.children[r], n.children[r], i)) return !1;
                    return !0
                } {
                    const r = e.slice(0, t.segments.length),
                        s = e.slice(t.segments.length);
                    return !!(Rf(t.segments, r) && Sw(t.segments, r, i) && t.children[Hi]) && EN(t.children[Hi], n, s, i)
                }
            }

            function Sw(t, n, e) {
                return n.every((i, r) => xN[e](t[r].parameters, i.parameters))
            }
            class Mm {
                constructor(n = new $r([], {}), e = {}, i = null) {
                    this.root = n, this.queryParams = e, this.fragment = i
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = km(this.queryParams)), this._queryParamMap
                }
                toString() {
                    return Vte.serialize(this)
                }
            }
            class $r {
                constructor(n, e) {
                    this.segments = n, this.children = e, this.parent = null, Object.values(e).forEach(i => i.parent = this)
                }
                hasChildren() {
                    return this.numberOfChildren > 0
                }
                get numberOfChildren() {
                    return Object.keys(this.children).length
                }
                toString() {
                    return Ew(this)
                }
            }
            class o0 {
                constructor(n, e) {
                    this.path = n, this.parameters = e
                }
                get parameterMap() {
                    return this._parameterMap || (this._parameterMap = km(this.parameters)), this._parameterMap
                }
                toString() {
                    return kN(this)
                }
            }

            function Rf(t, n) {
                return t.length === n.length && t.every((e, i) => e.path === n[i].path)
            }
            let a0 = (() => {
                class t {
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: function() {
                            return new dE
                        },
                        providedIn: "root"
                    })
                }
                return t
            })();
            class dE {
                parse(n) {
                    const e = new Yte(n);
                    return new Mm(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment())
                }
                serialize(n) {
                    const e = `/${c0(n.root,!0)}`,
                        i = function $te(t) {
                            const n = Object.keys(t).map(e => {
                                const i = t[e];
                                return Array.isArray(i) ? i.map(r => `${Dw(e)}=${Dw(r)}`).join("&") : `${Dw(e)}=${Dw(i)}`
                            }).filter(e => !!e);
                            return n.length ? `?${n.join("&")}` : ""
                        }(n.queryParams);
                    return `${e}${i}${"string"==typeof n.fragment?`#${function Ute(t){return encodeURI(t)}(n.fragment)}`:""}`
                }
            }
            const Vte = new dE;

            function Ew(t) {
                return t.segments.map(n => kN(n)).join("/")
            }

            function c0(t, n) {
                if (!t.hasChildren()) return Ew(t);
                if (n) {
                    const e = t.children[Hi] ? c0(t.children[Hi], !1) : "",
                        i = [];
                    return Object.entries(t.children).forEach(([r, s]) => {
                        r !== Hi && i.push(`${r}:${c0(s,!1)}`)
                    }), i.length > 0 ? `${e}(${i.join("//")})` : e
                } {
                    const e = function Fte(t, n) {
                        let e = [];
                        return Object.entries(t.children).forEach(([i, r]) => {
                            i === Hi && (e = e.concat(n(r, i)))
                        }), Object.entries(t.children).forEach(([i, r]) => {
                            i !== Hi && (e = e.concat(n(r, i)))
                        }), e
                    }(t, (i, r) => r === Hi ? [c0(t.children[Hi], !1)] : [`${r}:${c0(i,!1)}`]);
                    return 1 === Object.keys(t.children).length && null != t.children[Hi] ? `${Ew(t)}/${e[0]}` : `${Ew(t)}/(${e.join("//")})`
                }
            }

            function DN(t) {
                return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
            }

            function Dw(t) {
                return DN(t).replace(/%3B/gi, ";")
            }

            function hE(t) {
                return DN(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
            }

            function Aw(t) {
                return decodeURIComponent(t)
            }

            function AN(t) {
                return Aw(t.replace(/\+/g, "%20"))
            }

            function kN(t) {
                return `${hE(t.path)}${function Hte(t){return Object.keys(t).map(n=>`;${hE(n)}=${hE(t[n])}`).join("")}(t.parameters)}`
            }
            const zte = /^[^\/()?;#]+/;

            function fE(t) {
                const n = t.match(zte);
                return n ? n[0] : ""
            }
            const jte = /^[^\/()?;=#]+/,
                Gte = /^[^=?&#]+/,
                qte = /^[^&#]+/;
            class Yte {
                constructor(n) {
                    this.url = n, this.remaining = n
                }
                parseRootSegment() {
                    return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new $r([], {}) : new $r([], this.parseChildren())
                }
                parseQueryParams() {
                    const n = {};
                    if (this.consumeOptional("?"))
                        do {
                            this.parseQueryParam(n)
                        } while (this.consumeOptional("&"));
                    return n
                }
                parseFragment() {
                    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
                }
                parseChildren() {
                    if ("" === this.remaining) return {};
                    this.consumeOptional("/");
                    const n = [];
                    for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), n.push(this.parseSegment());
                    let e = {};
                    this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0));
                    let i = {};
                    return this.peekStartsWith("(") && (i = this.parseParens(!1)), (n.length > 0 || Object.keys(e).length > 0) && (i[Hi] = new $r(n, e)), i
                }
                parseSegment() {
                    const n = fE(this.remaining);
                    if ("" === n && this.peekStartsWith(";")) throw new mt(4009, !1);
                    return this.capture(n), new o0(Aw(n), this.parseMatrixParams())
                }
                parseMatrixParams() {
                    const n = {};
                    for (; this.consumeOptional(";");) this.parseParam(n);
                    return n
                }
                parseParam(n) {
                    const e = function Wte(t) {
                        const n = t.match(jte);
                        return n ? n[0] : ""
                    }(this.remaining);
                    if (!e) return;
                    this.capture(e);
                    let i = "";
                    if (this.consumeOptional("=")) {
                        const r = fE(this.remaining);
                        r && (i = r, this.capture(i))
                    }
                    n[Aw(e)] = Aw(i)
                }
                parseQueryParam(n) {
                    const e = function Kte(t) {
                        const n = t.match(Gte);
                        return n ? n[0] : ""
                    }(this.remaining);
                    if (!e) return;
                    this.capture(e);
                    let i = "";
                    if (this.consumeOptional("=")) {
                        const o = function Zte(t) {
                            const n = t.match(qte);
                            return n ? n[0] : ""
                        }(this.remaining);
                        o && (i = o, this.capture(i))
                    }
                    const r = AN(e),
                        s = AN(i);
                    if (n.hasOwnProperty(r)) {
                        let o = n[r];
                        Array.isArray(o) || (o = [o], n[r] = o), o.push(s)
                    } else n[r] = s
                }
                parseParens(n) {
                    const e = {};
                    for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
                        const i = fE(this.remaining),
                            r = this.remaining[i.length];
                        if ("/" !== r && ")" !== r && ";" !== r) throw new mt(4010, !1);
                        let s;
                        i.indexOf(":") > -1 ? (s = i.slice(0, i.indexOf(":")), this.capture(s), this.capture(":")) : n && (s = Hi);
                        const o = this.parseChildren();
                        e[s] = 1 === Object.keys(o).length ? o[Hi] : new $r([], o), this.consumeOptional("//")
                    }
                    return e
                }
                peekStartsWith(n) {
                    return this.remaining.startsWith(n)
                }
                consumeOptional(n) {
                    return !!this.peekStartsWith(n) && (this.remaining = this.remaining.substring(n.length), !0)
                }
                capture(n) {
                    if (!this.consumeOptional(n)) throw new mt(4011, !1)
                }
            }

            function MN(t) {
                return t.segments.length > 0 ? new $r([], {
                    [Hi]: t
                }) : t
            }

            function IN(t) {
                const n = {};
                for (const i of Object.keys(t.children)) {
                    const s = IN(t.children[i]);
                    if (i === Hi && 0 === s.segments.length && s.hasChildren())
                        for (const [o, a] of Object.entries(s.children)) n[o] = a;
                    else(s.segments.length > 0 || s.hasChildren()) && (n[i] = s)
                }
                return function Xte(t) {
                    if (1 === t.numberOfChildren && t.children[Hi]) {
                        const n = t.children[Hi];
                        return new $r(t.segments.concat(n.segments), n.children)
                    }
                    return t
                }(new $r(t.segments, n))
            }

            function Bf(t) {
                return t instanceof Mm
            }

            function PN(t) {
                let n;
                const r = MN(function e(s) {
                    const o = {};
                    for (const c of s.children) {
                        const u = e(c);
                        o[c.outlet] = u
                    }
                    const a = new $r(s.url, o);
                    return s === t && (n = a), a
                }(t.root));
                return n ? ? r
            }

            function ON(t, n, e, i) {
                let r = t;
                for (; r.parent;) r = r.parent;
                if (0 === n.length) return pE(r, r, r, e, i);
                const s = function Jte(t) {
                    if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new RN(!0, 0, t);
                    let n = 0,
                        e = !1;
                    const i = t.reduce((r, s, o) => {
                        if ("object" == typeof s && null != s) {
                            if (s.outlets) {
                                const a = {};
                                return Object.entries(s.outlets).forEach(([c, u]) => {
                                    a[c] = "string" == typeof u ? u.split("/") : u
                                }), [...r, {
                                    outlets: a
                                }]
                            }
                            if (s.segmentPath) return [...r, s.segmentPath]
                        }
                        return "string" != typeof s ? [...r, s] : 0 === o ? (s.split("/").forEach((a, c) => {
                            0 == c && "." === a || (0 == c && "" === a ? e = !0 : ".." === a ? n++ : "" != a && r.push(a))
                        }), r) : [...r, s]
                    }, []);
                    return new RN(e, n, i)
                }(n);
                if (s.toRoot()) return pE(r, r, new $r([], {}), e, i);
                const o = function ene(t, n, e) {
                        if (t.isAbsolute) return new Mw(n, !0, 0);
                        if (!e) return new Mw(n, !1, NaN);
                        if (null === e.parent) return new Mw(e, !0, 0);
                        const i = kw(t.commands[0]) ? 0 : 1;
                        return function tne(t, n, e) {
                            let i = t,
                                r = n,
                                s = e;
                            for (; s > r;) {
                                if (s -= r, i = i.parent, !i) throw new mt(4005, !1);
                                r = i.segments.length
                            }
                            return new Mw(i, !1, r - s)
                        }(e, e.segments.length - 1 + i, t.numberOfDoubleDots)
                    }(s, r, t),
                    a = o.processChildren ? u0(o.segmentGroup, o.index, s.commands) : BN(o.segmentGroup, o.index, s.commands);
                return pE(r, o.segmentGroup, a, e, i)
            }

            function kw(t) {
                return "object" == typeof t && null != t && !t.outlets && !t.segmentPath
            }

            function l0(t) {
                return "object" == typeof t && null != t && t.outlets
            }

            function pE(t, n, e, i, r) {
                let o, s = {};
                i && Object.entries(i).forEach(([c, u]) => {
                    s[c] = Array.isArray(u) ? u.map(h => `${h}`) : `${u}`
                }), o = t === n ? e : LN(t, n, e);
                const a = MN(IN(o));
                return new Mm(a, s, r)
            }

            function LN(t, n, e) {
                const i = {};
                return Object.entries(t.children).forEach(([r, s]) => {
                    i[r] = s === n ? e : LN(s, n, e)
                }), new $r(t.segments, i)
            }
            class RN {
                constructor(n, e, i) {
                    if (this.isAbsolute = n, this.numberOfDoubleDots = e, this.commands = i, n && i.length > 0 && kw(i[0])) throw new mt(4003, !1);
                    const r = i.find(l0);
                    if (r && r !== wN(i)) throw new mt(4004, !1)
                }
                toRoot() {
                    return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0]
                }
            }
            class Mw {
                constructor(n, e, i) {
                    this.segmentGroup = n, this.processChildren = e, this.index = i
                }
            }

            function BN(t, n, e) {
                if (t || (t = new $r([], {})), 0 === t.segments.length && t.hasChildren()) return u0(t, n, e);
                const i = function ine(t, n, e) {
                        let i = 0,
                            r = n;
                        const s = {
                            match: !1,
                            pathIndex: 0,
                            commandIndex: 0
                        };
                        for (; r < t.segments.length;) {
                            if (i >= e.length) return s;
                            const o = t.segments[r],
                                a = e[i];
                            if (l0(a)) break;
                            const c = `${a}`,
                                u = i < e.length - 1 ? e[i + 1] : null;
                            if (r > 0 && void 0 === c) break;
                            if (c && u && "object" == typeof u && void 0 === u.outlets) {
                                if (!FN(c, u, o)) return s;
                                i += 2
                            } else {
                                if (!FN(c, {}, o)) return s;
                                i++
                            }
                            r++
                        }
                        return {
                            match: !0,
                            pathIndex: r,
                            commandIndex: i
                        }
                    }(t, n, e),
                    r = e.slice(i.commandIndex);
                if (i.match && i.pathIndex < t.segments.length) {
                    const s = new $r(t.segments.slice(0, i.pathIndex), {});
                    return s.children[Hi] = new $r(t.segments.slice(i.pathIndex), t.children), u0(s, 0, r)
                }
                return i.match && 0 === r.length ? new $r(t.segments, {}) : i.match && !t.hasChildren() ? mE(t, n, e) : i.match ? u0(t, 0, r) : mE(t, n, e)
            }

            function u0(t, n, e) {
                if (0 === e.length) return new $r(t.segments, {}); {
                    const i = function nne(t) {
                            return l0(t[0]) ? t[0].outlets : {
                                [Hi]: t
                            }
                        }(e),
                        r = {};
                    if (Object.keys(i).some(s => s !== Hi) && t.children[Hi] && 1 === t.numberOfChildren && 0 === t.children[Hi].segments.length) {
                        const s = u0(t.children[Hi], n, e);
                        return new $r(t.segments, s.children)
                    }
                    return Object.entries(i).forEach(([s, o]) => {
                        "string" == typeof o && (o = [o]), null !== o && (r[s] = BN(t.children[s], n, o))
                    }), Object.entries(t.children).forEach(([s, o]) => {
                        void 0 === i[s] && (r[s] = o)
                    }), new $r(t.segments, r)
                }
            }

            function mE(t, n, e) {
                const i = t.segments.slice(0, n);
                let r = 0;
                for (; r < e.length;) {
                    const s = e[r];
                    if (l0(s)) {
                        const c = rne(s.outlets);
                        return new $r(i, c)
                    }
                    if (0 === r && kw(e[0])) {
                        i.push(new o0(t.segments[n].path, NN(e[0]))), r++;
                        continue
                    }
                    const o = l0(s) ? s.outlets[Hi] : `${s}`,
                        a = r < e.length - 1 ? e[r + 1] : null;
                    o && a && kw(a) ? (i.push(new o0(o, NN(a))), r += 2) : (i.push(new o0(o, {})), r++)
                }
                return new $r(i, {})
            }

            function rne(t) {
                const n = {};
                return Object.entries(t).forEach(([e, i]) => {
                    "string" == typeof i && (i = [i]), null !== i && (n[e] = mE(new $r([], {}), 0, i))
                }), n
            }

            function NN(t) {
                const n = {};
                return Object.entries(t).forEach(([e, i]) => n[e] = `${i}`), n
            }

            function FN(t, n, e) {
                return t == e.path && iu(n, e.parameters)
            }
            const d0 = "imperative";
            class ru {
                constructor(n, e) {
                    this.id = n, this.url = e
                }
            }
            class Iw extends ru {
                constructor(n, e, i = "imperative", r = null) {
                    super(n, e), this.type = 0, this.navigationTrigger = i, this.restoredState = r
                }
                toString() {
                    return `NavigationStart(id: ${this.id}, url: '${this.url}')`
                }
            }
            class dh extends ru {
                constructor(n, e, i) {
                    super(n, e), this.urlAfterRedirects = i, this.type = 1
                }
                toString() {
                    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
                }
            }
            class h0 extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.reason = i, this.code = r, this.type = 2
                }
                toString() {
                    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
                }
            }
            class Im extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.reason = i, this.code = r, this.type = 16
                }
            }
            class Pw extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.error = i, this.target = r, this.type = 3
                }
                toString() {
                    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
                }
            }
            class VN extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.urlAfterRedirects = i, this.state = r, this.type = 4
                }
                toString() {
                    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class sne extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.urlAfterRedirects = i, this.state = r, this.type = 7
                }
                toString() {
                    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class one extends ru {
                constructor(n, e, i, r, s) {
                    super(n, e), this.urlAfterRedirects = i, this.state = r, this.shouldActivate = s, this.type = 8
                }
                toString() {
                    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
                }
            }
            class ane extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.urlAfterRedirects = i, this.state = r, this.type = 5
                }
                toString() {
                    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class cne extends ru {
                constructor(n, e, i, r) {
                    super(n, e), this.urlAfterRedirects = i, this.state = r, this.type = 6
                }
                toString() {
                    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class lne {
                constructor(n) {
                    this.route = n, this.type = 9
                }
                toString() {
                    return `RouteConfigLoadStart(path: ${this.route.path})`
                }
            }
            class une {
                constructor(n) {
                    this.route = n, this.type = 10
                }
                toString() {
                    return `RouteConfigLoadEnd(path: ${this.route.path})`
                }
            }
            class dne {
                constructor(n) {
                    this.snapshot = n, this.type = 11
                }
                toString() {
                    return `ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class hne {
                constructor(n) {
                    this.snapshot = n, this.type = 12
                }
                toString() {
                    return `ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class fne {
                constructor(n) {
                    this.snapshot = n, this.type = 13
                }
                toString() {
                    return `ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class pne {
                constructor(n) {
                    this.snapshot = n, this.type = 14
                }
                toString() {
                    return `ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class UN {
                constructor(n, e, i) {
                    this.routerEvent = n, this.position = e, this.anchor = i, this.type = 15
                }
                toString() {
                    return `Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`
                }
            }
            class gE {}
            class yE {
                constructor(n) {
                    this.url = n
                }
            }
            class mne {
                constructor() {
                    this.outlet = null, this.route = null, this.injector = null, this.children = new f0, this.attachRef = null
                }
            }
            let f0 = (() => {
                class t {
                    constructor() {
                        this.contexts = new Map
                    }
                    onChildOutletCreated(e, i) {
                        const r = this.getOrCreateContext(e);
                        r.outlet = i, this.contexts.set(e, r)
                    }
                    onChildOutletDestroyed(e) {
                        const i = this.getContext(e);
                        i && (i.outlet = null, i.attachRef = null)
                    }
                    onOutletDeactivated() {
                        const e = this.contexts;
                        return this.contexts = new Map, e
                    }
                    onOutletReAttached(e) {
                        this.contexts = e
                    }
                    getOrCreateContext(e) {
                        let i = this.getContext(e);
                        return i || (i = new mne, this.contexts.set(e, i)), i
                    }
                    getContext(e) {
                        return this.contexts.get(e) || null
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            class HN {
                constructor(n) {
                    this._root = n
                }
                get root() {
                    return this._root.value
                }
                parent(n) {
                    const e = this.pathFromRoot(n);
                    return e.length > 1 ? e[e.length - 2] : null
                }
                children(n) {
                    const e = _E(n, this._root);
                    return e ? e.children.map(i => i.value) : []
                }
                firstChild(n) {
                    const e = _E(n, this._root);
                    return e && e.children.length > 0 ? e.children[0].value : null
                }
                siblings(n) {
                    const e = vE(n, this._root);
                    return e.length < 2 ? [] : e[e.length - 2].children.map(r => r.value).filter(r => r !== n)
                }
                pathFromRoot(n) {
                    return vE(n, this._root).map(e => e.value)
                }
            }

            function _E(t, n) {
                if (t === n.value) return n;
                for (const e of n.children) {
                    const i = _E(t, e);
                    if (i) return i
                }
                return null
            }

            function vE(t, n) {
                if (t === n.value) return [n];
                for (const e of n.children) {
                    const i = vE(t, e);
                    if (i.length) return i.unshift(n), i
                }
                return []
            }
            class Gu {
                constructor(n, e) {
                    this.value = n, this.children = e
                }
                toString() {
                    return `TreeNode(${this.value})`
                }
            }

            function Pm(t) {
                const n = {};
                return t && t.children.forEach(e => n[e.value.outlet] = e), n
            }
            class $N extends HN {
                constructor(n, e) {
                    super(n), this.snapshot = e, bE(this, n)
                }
                toString() {
                    return this.snapshot.toString()
                }
            }

            function zN(t, n) {
                const e = function gne(t, n) {
                        const o = new Ow([], {}, {}, "", {}, Hi, n, null, {});
                        return new WN("", new Gu(o, []))
                    }(0, n),
                    i = new qn([new o0("", {})]),
                    r = new qn({}),
                    s = new qn({}),
                    o = new qn({}),
                    a = new qn(""),
                    c = new hh(i, r, o, a, s, Hi, n, e.root);
                return c.snapshot = e.root, new $N(new Gu(c, []), e)
            }
            class hh {
                constructor(n, e, i, r, s, o, a, c) {
                    this.urlSubject = n, this.paramsSubject = e, this.queryParamsSubject = i, this.fragmentSubject = r, this.dataSubject = s, this.outlet = o, this.component = a, this._futureSnapshot = c, this.title = this.dataSubject ? .pipe(Fe(u => u[s0])) ? ? Ve(void 0), this.url = n, this.params = e, this.queryParams = i, this.fragment = r, this.data = s
                }
                get routeConfig() {
                    return this._futureSnapshot.routeConfig
                }
                get root() {
                    return this._routerState.root
                }
                get parent() {
                    return this._routerState.parent(this)
                }
                get firstChild() {
                    return this._routerState.firstChild(this)
                }
                get children() {
                    return this._routerState.children(this)
                }
                get pathFromRoot() {
                    return this._routerState.pathFromRoot(this)
                }
                get paramMap() {
                    return this._paramMap || (this._paramMap = this.params.pipe(Fe(n => km(n)))), this._paramMap
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(Fe(n => km(n)))), this._queryParamMap
                }
                toString() {
                    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
                }
            }

            function jN(t, n = "emptyOnly") {
                const e = t.pathFromRoot;
                let i = 0;
                if ("always" !== n)
                    for (i = e.length - 1; i >= 1;) {
                        const r = e[i],
                            s = e[i - 1];
                        if (r.routeConfig && "" === r.routeConfig.path) i--;
                        else {
                            if (s.component) break;
                            i--
                        }
                    }
                return function yne(t) {
                    return t.reduce((n, e) => ({
                        params: { ...n.params,
                            ...e.params
                        },
                        data: { ...n.data,
                            ...e.data
                        },
                        resolve: { ...e.data,
                            ...n.resolve,
                            ...e.routeConfig ? .data,
                            ...e._resolvedData
                        }
                    }), {
                        params: {},
                        data: {},
                        resolve: {}
                    })
                }(e.slice(i))
            }
            class Ow {
                get title() {
                    return this.data ? .[s0]
                }
                constructor(n, e, i, r, s, o, a, c, u) {
                    this.url = n, this.params = e, this.queryParams = i, this.fragment = r, this.data = s, this.outlet = o, this.component = a, this.routeConfig = c, this._resolve = u
                }
                get root() {
                    return this._routerState.root
                }
                get parent() {
                    return this._routerState.parent(this)
                }
                get firstChild() {
                    return this._routerState.firstChild(this)
                }
                get children() {
                    return this._routerState.children(this)
                }
                get pathFromRoot() {
                    return this._routerState.pathFromRoot(this)
                }
                get paramMap() {
                    return this._paramMap || (this._paramMap = km(this.params)), this._paramMap
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = km(this.queryParams)), this._queryParamMap
                }
                toString() {
                    return `Route(url:'${this.url.map(i=>i.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`
                }
            }
            class WN extends HN {
                constructor(n, e) {
                    super(e), this.url = n, bE(this, e)
                }
                toString() {
                    return GN(this._root)
                }
            }

            function bE(t, n) {
                n.value._routerState = t, n.children.forEach(e => bE(t, e))
            }

            function GN(t) {
                const n = t.children.length > 0 ? ` { ${t.children.map(GN).join(", ")} } ` : "";
                return `${t.value}${n}`
            }

            function wE(t) {
                if (t.snapshot) {
                    const n = t.snapshot,
                        e = t._futureSnapshot;
                    t.snapshot = e, iu(n.queryParams, e.queryParams) || t.queryParamsSubject.next(e.queryParams), n.fragment !== e.fragment && t.fragmentSubject.next(e.fragment), iu(n.params, e.params) || t.paramsSubject.next(e.params),
                        function Ote(t, n) {
                            if (t.length !== n.length) return !1;
                            for (let e = 0; e < t.length; ++e)
                                if (!iu(t[e], n[e])) return !1;
                            return !0
                        }(n.url, e.url) || t.urlSubject.next(e.url), iu(n.data, e.data) || t.dataSubject.next(e.data)
                } else t.snapshot = t._futureSnapshot, t.dataSubject.next(t._futureSnapshot.data)
            }

            function xE(t, n) {
                const e = iu(t.params, n.params) && function Nte(t, n) {
                    return Rf(t, n) && t.every((e, i) => iu(e.parameters, n[i].parameters))
                }(t.url, n.url);
                return e && !(!t.parent != !n.parent) && (!t.parent || xE(t.parent, n.parent))
            }
            let Lw = (() => {
                class t {
                    constructor() {
                        this.activated = null, this._activatedRoute = null, this.name = Hi, this.activateEvents = new zt, this.deactivateEvents = new zt, this.attachEvents = new zt, this.detachEvents = new zt, this.parentContexts = vn(f0), this.location = vn(Ga), this.changeDetector = vn(qa), this.environmentInjector = vn(hc), this.inputBinder = vn(Rw, {
                            optional: !0
                        }), this.supportsBindingToComponentInputs = !0
                    }
                    get activatedComponentRef() {
                        return this.activated
                    }
                    ngOnChanges(e) {
                        if (e.name) {
                            const {
                                firstChange: i,
                                previousValue: r
                            } = e.name;
                            if (i) return;
                            this.isTrackedInParentContexts(r) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(r)), this.initializeOutletWithName()
                        }
                    }
                    ngOnDestroy() {
                        this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder ? .unsubscribeFromRouteData(this)
                    }
                    isTrackedInParentContexts(e) {
                        return this.parentContexts.getContext(e) ? .outlet === this
                    }
                    ngOnInit() {
                        this.initializeOutletWithName()
                    }
                    initializeOutletWithName() {
                        if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return;
                        const e = this.parentContexts.getContext(this.name);
                        e ? .route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.injector))
                    }
                    get isActivated() {
                        return !!this.activated
                    }
                    get component() {
                        if (!this.activated) throw new mt(4012, !1);
                        return this.activated.instance
                    }
                    get activatedRoute() {
                        if (!this.activated) throw new mt(4012, !1);
                        return this._activatedRoute
                    }
                    get activatedRouteData() {
                        return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
                    }
                    detach() {
                        if (!this.activated) throw new mt(4012, !1);
                        this.location.detach();
                        const e = this.activated;
                        return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e
                    }
                    attach(e, i) {
                        this.activated = e, this._activatedRoute = i, this.location.insert(e.hostView), this.inputBinder ? .bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(e.instance)
                    }
                    deactivate() {
                        if (this.activated) {
                            const e = this.component;
                            this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e)
                        }
                    }
                    activateWith(e, i) {
                        if (this.isActivated) throw new mt(4013, !1);
                        this._activatedRoute = e;
                        const r = this.location,
                            o = e.snapshot.component,
                            a = this.parentContexts.getOrCreateContext(this.name).children,
                            c = new _ne(e, a, r.injector);
                        this.activated = r.createComponent(o, {
                            index: r.length,
                            injector: c,
                            environmentInjector: i ? ? this.environmentInjector
                        }), this.changeDetector.markForCheck(), this.inputBinder ? .bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["router-outlet"]
                        ],
                        inputs: {
                            name: "name"
                        },
                        outputs: {
                            activateEvents: "activate",
                            deactivateEvents: "deactivate",
                            attachEvents: "attach",
                            detachEvents: "detach"
                        },
                        exportAs: ["outlet"],
                        standalone: !0,
                        features: [Xi]
                    })
                }
                return t
            })();
            class _ne {
                constructor(n, e, i) {
                    this.route = n, this.childContexts = e, this.parent = i
                }
                get(n, e) {
                    return n === hh ? this.route : n === f0 ? this.childContexts : this.parent.get(n, e)
                }
            }
            const Rw = new nn("");
            let KN = (() => {
                class t {
                    constructor() {
                        this.outletDataSubscriptions = new Map
                    }
                    bindActivatedRouteToOutletComponent(e) {
                        this.unsubscribeFromRouteData(e), this.subscribeToRouteData(e)
                    }
                    unsubscribeFromRouteData(e) {
                        this.outletDataSubscriptions.get(e) ? .unsubscribe(), this.outletDataSubscriptions.delete(e)
                    }
                    subscribeToRouteData(e) {
                        const {
                            activatedRoute: i
                        } = e, r = cE([i.queryParams, i.params, i.data]).pipe(St(([s, o, a], c) => (a = { ...s,
                            ...o,
                            ...a
                        }, 0 === c ? Ve(a) : Promise.resolve(a)))).subscribe(s => {
                            if (!e.isActivated || !e.activatedComponentRef || e.activatedRoute !== i || null === i.component) return void this.unsubscribeFromRouteData(e);
                            const o = function XK(t) {
                                const n = Yi(t);
                                if (!n) return null;
                                const e = new fy(n);
                                return {
                                    get selector() {
                                        return e.selector
                                    },
                                    get type() {
                                        return e.componentType
                                    },
                                    get inputs() {
                                        return e.inputs
                                    },
                                    get outputs() {
                                        return e.outputs
                                    },
                                    get ngContentSelectors() {
                                        return e.ngContentSelectors
                                    },
                                    get isStandalone() {
                                        return n.standalone
                                    },
                                    get isSignal() {
                                        return n.signals
                                    }
                                }
                            }(i.component);
                            if (o)
                                for (const {
                                        templateName: a
                                    } of o.inputs) e.activatedComponentRef.setInput(a, s[a]);
                            else this.unsubscribeFromRouteData(e)
                        });
                        this.outletDataSubscriptions.set(e, r)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();

            function p0(t, n, e) {
                if (e && t.shouldReuseRoute(n.value, e.value.snapshot)) {
                    const i = e.value;
                    i._futureSnapshot = n.value;
                    const r = function bne(t, n, e) {
                        return n.children.map(i => {
                            for (const r of e.children)
                                if (t.shouldReuseRoute(i.value, r.value.snapshot)) return p0(t, i, r);
                            return p0(t, i)
                        })
                    }(t, n, e);
                    return new Gu(i, r)
                } {
                    if (t.shouldAttach(n.value)) {
                        const s = t.retrieve(n.value);
                        if (null !== s) {
                            const o = s.route;
                            return o.value._futureSnapshot = n.value, o.children = n.children.map(a => p0(t, a)), o
                        }
                    }
                    const i = function wne(t) {
                            return new hh(new qn(t.url), new qn(t.params), new qn(t.queryParams), new qn(t.fragment), new qn(t.data), t.outlet, t.component, t)
                        }(n.value),
                        r = n.children.map(s => p0(t, s));
                    return new Gu(i, r)
                }
            }
            const CE = "ngNavigationCancelingError";

            function qN(t, n) {
                const {
                    redirectTo: e,
                    navigationBehaviorOptions: i
                } = Bf(n) ? {
                    redirectTo: n,
                    navigationBehaviorOptions: void 0
                } : n, r = ZN(!1, 0, n);
                return r.url = e, r.navigationBehaviorOptions = i, r
            }

            function ZN(t, n, e) {
                const i = new Error("NavigationCancelingError: " + (t || ""));
                return i[CE] = !0, i.cancellationCode = n, e && (i.url = e), i
            }

            function YN(t) {
                return t && t[CE]
            }
            let XN = (() => {
                class t {
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["ng-component"]
                        ],
                        standalone: !0,
                        features: [l3],
                        decls: 1,
                        vars: 0,
                        template: function(i, r) {
                            1 & i && gt(0, "router-outlet")
                        },
                        dependencies: [Lw],
                        encapsulation: 2
                    })
                }
                return t
            })();

            function TE(t) {
                const n = t.children && t.children.map(TE),
                    e = n ? { ...t,
                        children: n
                    } : { ...t
                    };
                return !e.component && !e.loadComponent && (n || e.loadChildren) && e.outlet && e.outlet !== Hi && (e.component = XN), e
            }

            function xl(t) {
                return t.outlet || Hi
            }

            function m0(t) {
                if (!t) return null;
                if (t.routeConfig ? ._injector) return t.routeConfig._injector;
                for (let n = t.parent; n; n = n.parent) {
                    const e = n.routeConfig;
                    if (e ? ._loadedInjector) return e._loadedInjector;
                    if (e ? ._injector) return e._injector
                }
                return null
            }
            class kne {
                constructor(n, e, i, r, s) {
                    this.routeReuseStrategy = n, this.futureState = e, this.currState = i, this.forwardEvent = r, this.inputBindingEnabled = s
                }
                activate(n) {
                    const e = this.futureState._root,
                        i = this.currState ? this.currState._root : null;
                    this.deactivateChildRoutes(e, i, n), wE(this.futureState.root), this.activateChildRoutes(e, i, n)
                }
                deactivateChildRoutes(n, e, i) {
                    const r = Pm(e);
                    n.children.forEach(s => {
                        const o = s.value.outlet;
                        this.deactivateRoutes(s, r[o], i), delete r[o]
                    }), Object.values(r).forEach(s => {
                        this.deactivateRouteAndItsChildren(s, i)
                    })
                }
                deactivateRoutes(n, e, i) {
                    const r = n.value,
                        s = e ? e.value : null;
                    if (r === s)
                        if (r.component) {
                            const o = i.getContext(r.outlet);
                            o && this.deactivateChildRoutes(n, e, o.children)
                        } else this.deactivateChildRoutes(n, e, i);
                    else s && this.deactivateRouteAndItsChildren(e, i)
                }
                deactivateRouteAndItsChildren(n, e) {
                    n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, e) : this.deactivateRouteAndOutlet(n, e)
                }
                detachAndStoreRouteSubtree(n, e) {
                    const i = e.getContext(n.value.outlet),
                        r = i && n.value.component ? i.children : e,
                        s = Pm(n);
                    for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], r);
                    if (i && i.outlet) {
                        const o = i.outlet.detach(),
                            a = i.children.onOutletDeactivated();
                        this.routeReuseStrategy.store(n.value.snapshot, {
                            componentRef: o,
                            route: n,
                            contexts: a
                        })
                    }
                }
                deactivateRouteAndOutlet(n, e) {
                    const i = e.getContext(n.value.outlet),
                        r = i && n.value.component ? i.children : e,
                        s = Pm(n);
                    for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], r);
                    i && (i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated()), i.attachRef = null, i.route = null)
                }
                activateChildRoutes(n, e, i) {
                    const r = Pm(e);
                    n.children.forEach(s => {
                        this.activateRoutes(s, r[s.value.outlet], i), this.forwardEvent(new pne(s.value.snapshot))
                    }), n.children.length && this.forwardEvent(new hne(n.value.snapshot))
                }
                activateRoutes(n, e, i) {
                    const r = n.value,
                        s = e ? e.value : null;
                    if (wE(r), r === s)
                        if (r.component) {
                            const o = i.getOrCreateContext(r.outlet);
                            this.activateChildRoutes(n, e, o.children)
                        } else this.activateChildRoutes(n, e, i);
                    else if (r.component) {
                        const o = i.getOrCreateContext(r.outlet);
                        if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
                            const a = this.routeReuseStrategy.retrieve(r.snapshot);
                            this.routeReuseStrategy.store(r.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), wE(a.route.value), this.activateChildRoutes(n, null, o.children)
                        } else {
                            const a = m0(r.snapshot);
                            o.attachRef = null, o.route = r, o.injector = a, o.outlet && o.outlet.activateWith(r, o.injector), this.activateChildRoutes(n, null, o.children)
                        }
                    } else this.activateChildRoutes(n, null, i)
                }
            }
            class QN {
                constructor(n) {
                    this.path = n, this.route = this.path[this.path.length - 1]
                }
            }
            class Bw {
                constructor(n, e) {
                    this.component = n, this.route = e
                }
            }

            function Mne(t, n, e) {
                const i = t._root;
                return g0(i, n ? n._root : null, e, [i.value])
            }

            function Om(t, n) {
                const e = Symbol(),
                    i = n.get(t, e);
                return i === e ? "function" != typeof t || function _u(t) {
                    return null !== Ac(t)
                }(t) ? n.get(t) : t : i
            }

            function g0(t, n, e, i, r = {
                canDeactivateChecks: [],
                canActivateChecks: []
            }) {
                const s = Pm(n);
                return t.children.forEach(o => {
                    (function Pne(t, n, e, i, r = {
                        canDeactivateChecks: [],
                        canActivateChecks: []
                    }) {
                        const s = t.value,
                            o = n ? n.value : null,
                            a = e ? e.getContext(t.value.outlet) : null;
                        if (o && s.routeConfig === o.routeConfig) {
                            const c = function One(t, n, e) {
                                if ("function" == typeof e) return e(t, n);
                                switch (e) {
                                    case "pathParamsChange":
                                        return !Rf(t.url, n.url);
                                    case "pathParamsOrQueryParamsChange":
                                        return !Rf(t.url, n.url) || !iu(t.queryParams, n.queryParams);
                                    case "always":
                                        return !0;
                                    case "paramsOrQueryParamsChange":
                                        return !xE(t, n) || !iu(t.queryParams, n.queryParams);
                                    default:
                                        return !xE(t, n)
                                }
                            }(o, s, s.routeConfig.runGuardsAndResolvers);
                            c ? r.canActivateChecks.push(new QN(i)) : (s.data = o.data, s._resolvedData = o._resolvedData), g0(t, n, s.component ? a ? a.children : null : e, i, r), c && a && a.outlet && a.outlet.isActivated && r.canDeactivateChecks.push(new Bw(a.outlet.component, o))
                        } else o && y0(n, a, r), r.canActivateChecks.push(new QN(i)), g0(t, null, s.component ? a ? a.children : null : e, i, r)
                    })(o, s[o.value.outlet], e, i.concat([o.value]), r), delete s[o.value.outlet]
                }), Object.entries(s).forEach(([o, a]) => y0(a, e.getContext(o), r)), r
            }

            function y0(t, n, e) {
                const i = Pm(t),
                    r = t.value;
                Object.entries(i).forEach(([s, o]) => {
                    y0(o, r.component ? n ? n.children.getContext(s) : null : n, e)
                }), e.canDeactivateChecks.push(new Bw(r.component && n && n.outlet && n.outlet.isActivated ? n.outlet.component : null, r))
            }

            function _0(t) {
                return "function" == typeof t
            }

            function JN(t) {
                return t instanceof xw || "EmptyError" === t ? .name
            }
            const Nw = Symbol("INITIAL_VALUE");

            function Lm() {
                return St(t => cE(t.map(n => n.pipe(Sa(1), function Ate(...t) {
                    const n = _n(t);
                    return R((e, i) => {
                        (n ? wm(t, e, n) : wm(t, e)).subscribe(i)
                    })
                }(Nw)))).pipe(Fe(n => {
                    for (const e of n)
                        if (!0 !== e) {
                            if (e === Nw) return Nw;
                            if (!1 === e || e instanceof Mm) return e
                        }
                    return !0
                }), ia(n => n !== Nw), Sa(1)))
            }

            function eF(t) {
                return function f(...t) {
                    return v(t)
                }(Ui(n => {
                    if (Bf(n)) throw qN(0, n)
                }), Fe(n => !0 === n))
            }
            class Fw {
                constructor(n) {
                    this.segmentGroup = n || null
                }
            }
            class tF {
                constructor(n) {
                    this.urlTree = n
                }
            }

            function Rm(t) {
                return Af(new Fw(t))
            }

            function nF(t) {
                return Af(new tF(t))
            }
            class Jne {
                constructor(n, e) {
                    this.urlSerializer = n, this.urlTree = e
                }
                noMatchError(n) {
                    return new mt(4002, !1)
                }
                lineralizeSegments(n, e) {
                    let i = [],
                        r = e.root;
                    for (;;) {
                        if (i = i.concat(r.segments), 0 === r.numberOfChildren) return Ve(i);
                        if (r.numberOfChildren > 1 || !r.children[Hi]) return Af(new mt(4e3, !1));
                        r = r.children[Hi]
                    }
                }
                applyRedirectCommands(n, e, i) {
                    return this.applyRedirectCreateUrlTree(e, this.urlSerializer.parse(e), n, i)
                }
                applyRedirectCreateUrlTree(n, e, i, r) {
                    const s = this.createSegmentGroup(n, e.root, i, r);
                    return new Mm(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment)
                }
                createQueryParams(n, e) {
                    const i = {};
                    return Object.entries(n).forEach(([r, s]) => {
                        if ("string" == typeof s && s.startsWith(":")) {
                            const a = s.substring(1);
                            i[r] = e[a]
                        } else i[r] = s
                    }), i
                }
                createSegmentGroup(n, e, i, r) {
                    const s = this.createSegments(n, e.segments, i, r);
                    let o = {};
                    return Object.entries(e.children).forEach(([a, c]) => {
                        o[a] = this.createSegmentGroup(n, c, i, r)
                    }), new $r(s, o)
                }
                createSegments(n, e, i, r) {
                    return e.map(s => s.path.startsWith(":") ? this.findPosParam(n, s, r) : this.findOrReturn(s, i))
                }
                findPosParam(n, e, i) {
                    const r = i[e.path.substring(1)];
                    if (!r) throw new mt(4001, !1);
                    return r
                }
                findOrReturn(n, e) {
                    let i = 0;
                    for (const r of e) {
                        if (r.path === n.path) return e.splice(i), r;
                        i++
                    }
                    return n
                }
            }
            const SE = {
                matched: !1,
                consumedSegments: [],
                remainingSegments: [],
                parameters: {},
                positionalParamSegments: {}
            };

            function eie(t, n, e, i, r) {
                const s = EE(t, n, e);
                return s.matched ? (i = function Cne(t, n) {
                    return t.providers && !t._injector && (t._injector = VT(t.providers, n, `Route: ${t.path}`)), t._injector ? ? n
                }(n, i), function Yne(t, n, e, i) {
                    const r = n.canMatch;
                    return r && 0 !== r.length ? Ve(r.map(o => {
                        const a = Om(o, t);
                        return uh(function Vne(t) {
                            return t && _0(t.canMatch)
                        }(a) ? a.canMatch(n, e) : t.runInContext(() => a(n, e)))
                    })).pipe(Lm(), eF()) : Ve(!0)
                }(i, n, e).pipe(Fe(o => !0 === o ? s : { ...SE
                }))) : Ve(s)
            }

            function EE(t, n, e) {
                if ("" === n.path) return "full" === n.pathMatch && (t.hasChildren() || e.length > 0) ? { ...SE
                } : {
                    matched: !0,
                    consumedSegments: [],
                    remainingSegments: e,
                    parameters: {},
                    positionalParamSegments: {}
                };
                const r = (n.matcher || Pte)(e, t, n);
                if (!r) return { ...SE
                };
                const s = {};
                Object.entries(r.posParams ? ? {}).forEach(([a, c]) => {
                    s[a] = c.path
                });
                const o = r.consumed.length > 0 ? { ...s,
                    ...r.consumed[r.consumed.length - 1].parameters
                } : s;
                return {
                    matched: !0,
                    consumedSegments: r.consumed,
                    remainingSegments: e.slice(r.consumed.length),
                    parameters: o,
                    positionalParamSegments: r.posParams ? ? {}
                }
            }

            function iF(t, n, e, i) {
                return e.length > 0 && function iie(t, n, e) {
                    return e.some(i => Vw(t, n, i) && xl(i) !== Hi)
                }(t, e, i) ? {
                    segmentGroup: new $r(n, nie(i, new $r(e, t.children))),
                    slicedSegments: []
                } : 0 === e.length && function rie(t, n, e) {
                    return e.some(i => Vw(t, n, i))
                }(t, e, i) ? {
                    segmentGroup: new $r(t.segments, tie(t, 0, e, i, t.children)),
                    slicedSegments: e
                } : {
                    segmentGroup: new $r(t.segments, t.children),
                    slicedSegments: e
                }
            }

            function tie(t, n, e, i, r) {
                const s = {};
                for (const o of i)
                    if (Vw(t, e, o) && !r[xl(o)]) {
                        const a = new $r([], {});
                        s[xl(o)] = a
                    }
                return { ...r,
                    ...s
                }
            }

            function nie(t, n) {
                const e = {};
                e[Hi] = n;
                for (const i of t)
                    if ("" === i.path && xl(i) !== Hi) {
                        const r = new $r([], {});
                        e[xl(i)] = r
                    }
                return e
            }

            function Vw(t, n, e) {
                return (!(t.hasChildren() || n.length > 0) || "full" !== e.pathMatch) && "" === e.path
            }
            class cie {
                constructor(n, e, i, r, s, o, a) {
                    this.injector = n, this.configLoader = e, this.rootComponentType = i, this.config = r, this.urlTree = s, this.paramsInheritanceStrategy = o, this.urlSerializer = a, this.allowRedirects = !0, this.applyRedirects = new Jne(this.urlSerializer, this.urlTree)
                }
                noMatchError(n) {
                    return new mt(4002, !1)
                }
                recognize() {
                    const n = iF(this.urlTree.root, [], [], this.config).segmentGroup;
                    return this.processSegmentGroup(this.injector, this.config, n, Hi).pipe(sh(e => {
                        if (e instanceof tF) return this.allowRedirects = !1, this.urlTree = e.urlTree, this.match(e.urlTree);
                        throw e instanceof Fw ? this.noMatchError(e) : e
                    }), Fe(e => {
                        const i = new Ow([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams
                            }), this.urlTree.fragment, {}, Hi, this.rootComponentType, null, {}),
                            r = new Gu(i, e),
                            s = new WN("", r),
                            o = function Qte(t, n, e = null, i = null) {
                                return ON(PN(t), n, e, i)
                            }(i, [], this.urlTree.queryParams, this.urlTree.fragment);
                        return o.queryParams = this.urlTree.queryParams, s.url = this.urlSerializer.serialize(o), this.inheritParamsAndData(s._root), {
                            state: s,
                            tree: o
                        }
                    }))
                }
                match(n) {
                    return this.processSegmentGroup(this.injector, this.config, n.root, Hi).pipe(sh(i => {
                        throw i instanceof Fw ? this.noMatchError(i) : i
                    }))
                }
                inheritParamsAndData(n) {
                    const e = n.value,
                        i = jN(e, this.paramsInheritanceStrategy);
                    e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), n.children.forEach(r => this.inheritParamsAndData(r))
                }
                processSegmentGroup(n, e, i, r) {
                    return 0 === i.segments.length && i.hasChildren() ? this.processChildren(n, e, i) : this.processSegment(n, e, i, i.segments, r, !0)
                }
                processChildren(n, e, i) {
                    const r = [];
                    for (const s of Object.keys(i.children)) "primary" === s ? r.unshift(s) : r.push(s);
                    return gn(r).pipe(Tf(s => {
                        const o = i.children[s],
                            a = function Dne(t, n) {
                                const e = t.filter(i => xl(i) === n);
                                return e.push(...t.filter(i => xl(i) !== n)), e
                            }(e, s);
                        return this.processSegmentGroup(n, a, o, s)
                    }), function kte(t, n) {
                        return R(fN(t, n, arguments.length >= 2, !0))
                    }((s, o) => (s.push(...o), s)), Cw(null), function Mte(t, n) {
                        const e = arguments.length >= 2;
                        return i => i.pipe(t ? ia((r, s) => t(r, s, i)) : $, uE(1), e ? Cw(n) : dN(() => new xw))
                    }(), ke(s => {
                        if (null === s) return Rm(i);
                        const o = rF(s);
                        return function lie(t) {
                            t.sort((n, e) => n.value.outlet === Hi ? -1 : e.value.outlet === Hi ? 1 : n.value.outlet.localeCompare(e.value.outlet))
                        }(o), Ve(o)
                    }))
                }
                processSegment(n, e, i, r, s, o) {
                    return gn(e).pipe(Tf(a => this.processSegmentAgainstRoute(a._injector ? ? n, e, a, i, r, s, o).pipe(sh(c => {
                        if (c instanceof Fw) return Ve(null);
                        throw c
                    }))), nu(a => !!a), sh(a => {
                        if (JN(a)) return function oie(t, n, e) {
                            return 0 === n.length && !t.children[e]
                        }(i, r, s) ? Ve([]) : Rm(i);
                        throw a
                    }))
                }
                processSegmentAgainstRoute(n, e, i, r, s, o, a) {
                    return function sie(t, n, e, i) {
                        return !!(xl(t) === i || i !== Hi && Vw(n, e, t)) && ("**" === t.path || EE(n, t, e).matched)
                    }(i, r, s, o) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(n, r, i, s, o, a) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(n, r, e, i, s, o) : Rm(r) : Rm(r)
                }
                expandSegmentAgainstRouteUsingRedirect(n, e, i, r, s, o) {
                    return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(n, i, r, o) : this.expandRegularSegmentAgainstRouteUsingRedirect(n, e, i, r, s, o)
                }
                expandWildCardWithParamsAgainstRouteUsingRedirect(n, e, i, r) {
                    const s = this.applyRedirects.applyRedirectCommands([], i.redirectTo, {});
                    return i.redirectTo.startsWith("/") ? nF(s) : this.applyRedirects.lineralizeSegments(i, s).pipe(ke(o => {
                        const a = new $r(o, {});
                        return this.processSegment(n, e, a, o, r, !1)
                    }))
                }
                expandRegularSegmentAgainstRouteUsingRedirect(n, e, i, r, s, o) {
                    const {
                        matched: a,
                        consumedSegments: c,
                        remainingSegments: u,
                        positionalParamSegments: h
                    } = EE(e, r, s);
                    if (!a) return Rm(e);
                    const m = this.applyRedirects.applyRedirectCommands(c, r.redirectTo, h);
                    return r.redirectTo.startsWith("/") ? nF(m) : this.applyRedirects.lineralizeSegments(r, m).pipe(ke(x => this.processSegment(n, i, e, x.concat(u), o, !1)))
                }
                matchSegmentAgainstRoute(n, e, i, r, s, o) {
                    let a;
                    if ("**" === i.path) {
                        const c = r.length > 0 ? wN(r).parameters : {};
                        a = Ve({
                            snapshot: new Ow(r, c, Object.freeze({ ...this.urlTree.queryParams
                            }), this.urlTree.fragment, sF(i), xl(i), i.component ? ? i._loadedComponent ? ? null, i, oF(i)),
                            consumedSegments: [],
                            remainingSegments: []
                        }), e.children = {}
                    } else a = eie(e, i, r, n).pipe(Fe(({
                        matched: c,
                        consumedSegments: u,
                        remainingSegments: h,
                        parameters: m
                    }) => c ? {
                        snapshot: new Ow(u, m, Object.freeze({ ...this.urlTree.queryParams
                        }), this.urlTree.fragment, sF(i), xl(i), i.component ? ? i._loadedComponent ? ? null, i, oF(i)),
                        consumedSegments: u,
                        remainingSegments: h
                    } : null));
                    return a.pipe(St(c => null === c ? Rm(e) : this.getChildConfig(n = i._injector ? ? n, i, r).pipe(St(({
                        routes: u
                    }) => {
                        const h = i._loadedInjector ? ? n,
                            {
                                snapshot: m,
                                consumedSegments: x,
                                remainingSegments: D
                            } = c,
                            {
                                segmentGroup: V,
                                slicedSegments: te
                            } = iF(e, x, D, u);
                        if (0 === te.length && V.hasChildren()) return this.processChildren(h, u, V).pipe(Fe(_e => null === _e ? null : [new Gu(m, _e)]));
                        if (0 === u.length && 0 === te.length) return Ve([new Gu(m, [])]);
                        const ee = xl(i) === s;
                        return this.processSegment(h, u, V, te, ee ? Hi : s, !0).pipe(Fe(_e => [new Gu(m, _e)]))
                    }))))
                }
                getChildConfig(n, e, i) {
                    return e.children ? Ve({
                        routes: e.children,
                        injector: n
                    }) : e.loadChildren ? void 0 !== e._loadedRoutes ? Ve({
                        routes: e._loadedRoutes,
                        injector: e._loadedInjector
                    }) : function Zne(t, n, e, i) {
                        const r = n.canLoad;
                        return void 0 === r || 0 === r.length ? Ve(!0) : Ve(r.map(o => {
                            const a = Om(o, t);
                            return uh(function Rne(t) {
                                return t && _0(t.canLoad)
                            }(a) ? a.canLoad(n, e) : t.runInContext(() => a(n, e)))
                        })).pipe(Lm(), eF())
                    }(n, e, i).pipe(ke(r => r ? this.configLoader.loadChildren(n, e).pipe(Ui(s => {
                        e._loadedRoutes = s.routes, e._loadedInjector = s.injector
                    })) : function Qne(t) {
                        return Af(ZN(!1, 3))
                    }())) : Ve({
                        routes: [],
                        injector: n
                    })
                }
            }

            function uie(t) {
                const n = t.value.routeConfig;
                return n && "" === n.path
            }

            function rF(t) {
                const n = [],
                    e = new Set;
                for (const i of t) {
                    if (!uie(i)) {
                        n.push(i);
                        continue
                    }
                    const r = n.find(s => i.value.routeConfig === s.value.routeConfig);
                    void 0 !== r ? (r.children.push(...i.children), e.add(r)) : n.push(i)
                }
                for (const i of e) {
                    const r = rF(i.children);
                    n.push(new Gu(i.value, r))
                }
                return n.filter(i => !e.has(i))
            }

            function sF(t) {
                return t.data || {}
            }

            function oF(t) {
                return t.resolve || {}
            }

            function aF(t) {
                return "string" == typeof t.title || null === t.title
            }

            function DE(t) {
                return St(n => {
                    const e = t(n);
                    return e ? gn(e).pipe(Fe(() => n)) : Ve(n)
                })
            }
            const Bm = new nn("ROUTES");
            let AE = (() => {
                class t {
                    constructor() {
                        this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = vn(e5)
                    }
                    loadComponent(e) {
                        if (this.componentLoaders.get(e)) return this.componentLoaders.get(e);
                        if (e._loadedComponent) return Ve(e._loadedComponent);
                        this.onLoadStartListener && this.onLoadStartListener(e);
                        const i = uh(e.loadComponent()).pipe(Fe(cF), Ui(s => {
                                this.onLoadEndListener && this.onLoadEndListener(e), e._loadedComponent = s
                            }), xm(() => {
                                this.componentLoaders.delete(e)
                            })),
                            r = new _N(i, () => new A).pipe(lE());
                        return this.componentLoaders.set(e, r), r
                    }
                    loadChildren(e, i) {
                        if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
                        if (i._loadedRoutes) return Ve({
                            routes: i._loadedRoutes,
                            injector: i._loadedInjector
                        });
                        this.onLoadStartListener && this.onLoadStartListener(i);
                        const s = function _ie(t, n, e, i) {
                                return uh(t.loadChildren()).pipe(Fe(cF), ke(r => r instanceof a3 || Array.isArray(r) ? Ve(r) : gn(n.compileModuleAsync(r))), Fe(r => {
                                    i && i(t);
                                    let s, o, a = !1;
                                    return Array.isArray(r) ? (o = r, !0) : (s = r.create(e).injector, o = s.get(Bm, [], {
                                        optional: !0,
                                        self: !0
                                    }).flat()), {
                                        routes: o.map(TE),
                                        injector: s
                                    }
                                }))
                            }(i, this.compiler, e, this.onLoadEndListener).pipe(xm(() => {
                                this.childrenLoaders.delete(i)
                            })),
                            o = new _N(s, () => new A).pipe(lE());
                        return this.childrenLoaders.set(i, o), o
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();

            function cF(t) {
                return function vie(t) {
                    return t && "object" == typeof t && "default" in t
                }(t) ? t.default : t
            }
            let Uw = (() => {
                class t {
                    get hasRequestedNavigation() {
                        return 0 !== this.navigationId
                    }
                    constructor() {
                        this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new A, this.transitionAbortSubject = new A, this.configLoader = vn(AE), this.environmentInjector = vn(hc), this.urlSerializer = vn(a0), this.rootContexts = vn(f0), this.inputBindingEnabled = null !== vn(Rw, {
                            optional: !0
                        }), this.navigationId = 0, this.afterPreactivation = () => Ve(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = r => this.events.next(new une(r)), this.configLoader.onLoadStartListener = r => this.events.next(new lne(r))
                    }
                    complete() {
                        this.transitions ? .complete()
                    }
                    handleNavigationRequest(e) {
                        const i = ++this.navigationId;
                        this.transitions ? .next({ ...this.transitions.value,
                            ...e,
                            id: i
                        })
                    }
                    setupNavigations(e, i, r) {
                        return this.transitions = new qn({
                            id: 0,
                            currentUrlTree: i,
                            currentRawUrl: i,
                            currentBrowserUrl: i,
                            extractedUrl: e.urlHandlingStrategy.extract(i),
                            urlAfterRedirects: e.urlHandlingStrategy.extract(i),
                            rawUrl: i,
                            extras: {},
                            resolve: null,
                            reject: null,
                            promise: Promise.resolve(!0),
                            source: d0,
                            restoredState: null,
                            currentSnapshot: r.snapshot,
                            targetSnapshot: null,
                            currentRouterState: r,
                            targetRouterState: null,
                            guards: {
                                canActivateChecks: [],
                                canDeactivateChecks: []
                            },
                            guardsResult: null
                        }), this.transitions.pipe(ia(s => 0 !== s.id), Fe(s => ({ ...s,
                            extractedUrl: e.urlHandlingStrategy.extract(s.rawUrl)
                        })), St(s => {
                            this.currentTransition = s;
                            let o = !1,
                                a = !1;
                            return Ve(s).pipe(Ui(c => {
                                this.currentNavigation = {
                                    id: c.id,
                                    initialUrl: c.rawUrl,
                                    extractedUrl: c.extractedUrl,
                                    trigger: c.source,
                                    extras: c.extras,
                                    previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation,
                                        previousNavigation: null
                                    } : null
                                }
                            }), St(c => {
                                const u = c.currentBrowserUrl.toString(),
                                    h = !e.navigated || c.extractedUrl.toString() !== u || u !== c.currentUrlTree.toString();
                                if (!h && "reload" !== (c.extras.onSameUrlNavigation ? ? e.onSameUrlNavigation)) {
                                    const x = "";
                                    return this.events.next(new Im(c.id, this.urlSerializer.serialize(c.rawUrl), x, 0)), c.resolve(null), Qe
                                }
                                if (e.urlHandlingStrategy.shouldProcessUrl(c.rawUrl)) return Ve(c).pipe(St(x => {
                                    const D = this.transitions ? .getValue();
                                    return this.events.next(new Iw(x.id, this.urlSerializer.serialize(x.extractedUrl), x.source, x.restoredState)), D !== this.transitions ? .getValue() ? Qe : Promise.resolve(x)
                                }), function die(t, n, e, i, r, s) {
                                    return ke(o => function aie(t, n, e, i, r, s, o = "emptyOnly") {
                                        return new cie(t, n, e, i, r, o, s).recognize()
                                    }(t, n, e, i, o.extractedUrl, r, s).pipe(Fe(({
                                        state: a,
                                        tree: c
                                    }) => ({ ...o,
                                        targetSnapshot: a,
                                        urlAfterRedirects: c
                                    }))))
                                }(this.environmentInjector, this.configLoader, this.rootComponentType, e.config, this.urlSerializer, e.paramsInheritanceStrategy), Ui(x => {
                                    s.targetSnapshot = x.targetSnapshot, s.urlAfterRedirects = x.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation,
                                        finalUrl: x.urlAfterRedirects
                                    };
                                    const D = new VN(x.id, this.urlSerializer.serialize(x.extractedUrl), this.urlSerializer.serialize(x.urlAfterRedirects), x.targetSnapshot);
                                    this.events.next(D)
                                }));
                                if (h && e.urlHandlingStrategy.shouldProcessUrl(c.currentRawUrl)) {
                                    const {
                                        id: x,
                                        extractedUrl: D,
                                        source: V,
                                        restoredState: te,
                                        extras: ee
                                    } = c, _e = new Iw(x, this.urlSerializer.serialize(D), V, te);
                                    this.events.next(_e);
                                    const ye = zN(0, this.rootComponentType).snapshot;
                                    return this.currentTransition = s = { ...c,
                                        targetSnapshot: ye,
                                        urlAfterRedirects: D,
                                        extras: { ...ee,
                                            skipLocationChange: !1,
                                            replaceUrl: !1
                                        }
                                    }, Ve(s)
                                } {
                                    const x = "";
                                    return this.events.next(new Im(c.id, this.urlSerializer.serialize(c.extractedUrl), x, 1)), c.resolve(null), Qe
                                }
                            }), Ui(c => {
                                const u = new sne(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot);
                                this.events.next(u)
                            }), Fe(c => (this.currentTransition = s = { ...c,
                                guards: Mne(c.targetSnapshot, c.currentSnapshot, this.rootContexts)
                            }, s)), function Hne(t, n) {
                                return ke(e => {
                                    const {
                                        targetSnapshot: i,
                                        currentSnapshot: r,
                                        guards: {
                                            canActivateChecks: s,
                                            canDeactivateChecks: o
                                        }
                                    } = e;
                                    return 0 === o.length && 0 === s.length ? Ve({ ...e,
                                        guardsResult: !0
                                    }) : function $ne(t, n, e, i) {
                                        return gn(t).pipe(ke(r => function qne(t, n, e, i, r) {
                                            const s = n && n.routeConfig ? n.routeConfig.canDeactivate : null;
                                            return s && 0 !== s.length ? Ve(s.map(a => {
                                                const c = m0(n) ? ? r,
                                                    u = Om(a, c);
                                                return uh(function Fne(t) {
                                                    return t && _0(t.canDeactivate)
                                                }(u) ? u.canDeactivate(t, n, e, i) : c.runInContext(() => u(t, n, e, i))).pipe(nu())
                                            })).pipe(Lm()) : Ve(!0)
                                        }(r.component, r.route, e, n, i)), nu(r => !0 !== r, !0))
                                    }(o, i, r, t).pipe(ke(a => a && function Lne(t) {
                                        return "boolean" == typeof t
                                    }(a) ? function zne(t, n, e, i) {
                                        return gn(n).pipe(Tf(r => wm(function Wne(t, n) {
                                            return null !== t && n && n(new dne(t)), Ve(!0)
                                        }(r.route.parent, i), function jne(t, n) {
                                            return null !== t && n && n(new fne(t)), Ve(!0)
                                        }(r.route, i), function Kne(t, n, e) {
                                            const i = n[n.length - 1],
                                                s = n.slice(0, n.length - 1).reverse().map(o => function Ine(t) {
                                                    const n = t.routeConfig ? t.routeConfig.canActivateChild : null;
                                                    return n && 0 !== n.length ? {
                                                        node: t,
                                                        guards: n
                                                    } : null
                                                }(o)).filter(o => null !== o).map(o => Zb(() => Ve(o.guards.map(c => {
                                                    const u = m0(o.node) ? ? e,
                                                        h = Om(c, u);
                                                    return uh(function Nne(t) {
                                                        return t && _0(t.canActivateChild)
                                                    }(h) ? h.canActivateChild(i, t) : u.runInContext(() => h(i, t))).pipe(nu())
                                                })).pipe(Lm())));
                                            return Ve(s).pipe(Lm())
                                        }(t, r.path, e), function Gne(t, n, e) {
                                            const i = n.routeConfig ? n.routeConfig.canActivate : null;
                                            if (!i || 0 === i.length) return Ve(!0);
                                            const r = i.map(s => Zb(() => {
                                                const o = m0(n) ? ? e,
                                                    a = Om(s, o);
                                                return uh(function Bne(t) {
                                                    return t && _0(t.canActivate)
                                                }(a) ? a.canActivate(n, t) : o.runInContext(() => a(n, t))).pipe(nu())
                                            }));
                                            return Ve(r).pipe(Lm())
                                        }(t, r.route, e))), nu(r => !0 !== r, !0))
                                    }(i, s, t, n) : Ve(a)), Fe(a => ({ ...e,
                                        guardsResult: a
                                    })))
                                })
                            }(this.environmentInjector, c => this.events.next(c)), Ui(c => {
                                if (s.guardsResult = c.guardsResult, Bf(c.guardsResult)) throw qN(0, c.guardsResult);
                                const u = new one(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot, !!c.guardsResult);
                                this.events.next(u)
                            }), ia(c => !!c.guardsResult || (this.cancelNavigationTransition(c, "", 3), !1)), DE(c => {
                                if (c.guards.canActivateChecks.length) return Ve(c).pipe(Ui(u => {
                                    const h = new ane(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot);
                                    this.events.next(h)
                                }), St(u => {
                                    let h = !1;
                                    return Ve(u).pipe(function hie(t, n) {
                                        return ke(e => {
                                            const {
                                                targetSnapshot: i,
                                                guards: {
                                                    canActivateChecks: r
                                                }
                                            } = e;
                                            if (!r.length) return Ve(e);
                                            let s = 0;
                                            return gn(r).pipe(Tf(o => function fie(t, n, e, i) {
                                                const r = t.routeConfig,
                                                    s = t._resolve;
                                                return void 0 !== r ? .title && !aF(r) && (s[s0] = r.title),
                                                    function mie(t, n, e, i) {
                                                        const r = function gie(t) {
                                                            return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)]
                                                        }(t);
                                                        if (0 === r.length) return Ve({});
                                                        const s = {};
                                                        return gn(r).pipe(ke(o => function yie(t, n, e, i) {
                                                            const r = m0(n) ? ? i,
                                                                s = Om(t, r);
                                                            return uh(s.resolve ? s.resolve(n, e) : r.runInContext(() => s(n, e)))
                                                        }(t[o], n, e, i).pipe(nu(), Ui(a => {
                                                            s[o] = a
                                                        }))), uE(1), pN(s), sh(o => JN(o) ? Qe : Af(o)))
                                                    }(s, t, n, i).pipe(Fe(o => (t._resolvedData = o, t.data = jN(t, e).resolve, r && aF(r) && (t.data[s0] = r.title), null)))
                                            }(o.route, i, t, n)), Ui(() => s++), uE(1), ke(o => s === r.length ? Ve(e) : Qe))
                                        })
                                    }(e.paramsInheritanceStrategy, this.environmentInjector), Ui({
                                        next: () => h = !0,
                                        complete: () => {
                                            h || this.cancelNavigationTransition(u, "", 2)
                                        }
                                    }))
                                }), Ui(u => {
                                    const h = new cne(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot);
                                    this.events.next(h)
                                }))
                            }), DE(c => {
                                const u = h => {
                                    const m = [];
                                    h.routeConfig ? .loadComponent && !h.routeConfig._loadedComponent && m.push(this.configLoader.loadComponent(h.routeConfig).pipe(Ui(x => {
                                        h.component = x
                                    }), Fe(() => {})));
                                    for (const x of h.children) m.push(...u(x));
                                    return m
                                };
                                return cE(u(c.targetSnapshot.root)).pipe(Cw(), Sa(1))
                            }), DE(() => this.afterPreactivation()), Fe(c => {
                                const u = function vne(t, n, e) {
                                    const i = p0(t, n._root, e ? e._root : void 0);
                                    return new $N(i, n)
                                }(e.routeReuseStrategy, c.targetSnapshot, c.currentRouterState);
                                return this.currentTransition = s = { ...c,
                                    targetRouterState: u
                                }, s
                            }), Ui(() => {
                                this.events.next(new gE)
                            }), ((t, n, e, i) => Fe(r => (new kne(n, r.targetRouterState, r.currentRouterState, e, i).activate(t), r)))(this.rootContexts, e.routeReuseStrategy, c => this.events.next(c), this.inputBindingEnabled), Sa(1), Ui({
                                next: c => {
                                    o = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new dh(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects))), e.titleStrategy ? .updateTitle(c.targetRouterState.snapshot), c.resolve(!0)
                                },
                                complete: () => {
                                    o = !0
                                }
                            }), vN(this.transitionAbortSubject.pipe(Ui(c => {
                                throw c
                            }))), xm(() => {
                                o || a || this.cancelNavigationTransition(s, "", 1), this.currentNavigation ? .id === s.id && (this.currentNavigation = null)
                            }), sh(c => {
                                if (a = !0, YN(c)) this.events.next(new h0(s.id, this.urlSerializer.serialize(s.extractedUrl), c.message, c.cancellationCode)),
                                    function xne(t) {
                                        return YN(t) && Bf(t.url)
                                    }(c) ? this.events.next(new yE(c.url)) : s.resolve(!1);
                                else {
                                    this.events.next(new Pw(s.id, this.urlSerializer.serialize(s.extractedUrl), c, s.targetSnapshot ? ? void 0));
                                    try {
                                        s.resolve(e.errorHandler(c))
                                    } catch (u) {
                                        s.reject(u)
                                    }
                                }
                                return Qe
                            }))
                        }))
                    }
                    cancelNavigationTransition(e, i, r) {
                        const s = new h0(e.id, this.urlSerializer.serialize(e.extractedUrl), i, r);
                        this.events.next(s), e.resolve(!1)
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();

            function lF(t) {
                return t !== d0
            }
            let uF = (() => {
                    class t {
                        buildTitle(e) {
                            let i, r = e.root;
                            for (; void 0 !== r;) i = this.getResolvedTitleForRoute(r) ? ? i, r = r.children.find(s => s.outlet === Hi);
                            return i
                        }
                        getResolvedTitleForRoute(e) {
                            return e.data[s0]
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: function() {
                                return vn(bie)
                            },
                            providedIn: "root"
                        })
                    }
                    return t
                })(),
                bie = (() => {
                    class t extends uF {
                        constructor(e) {
                            super(), this.title = e
                        }
                        updateTitle(e) {
                            const i = this.buildTitle(e);
                            void 0 !== i && this.title.setTitle(i)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(_t(zS))
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "root"
                        })
                    }
                    return t
                })(),
                wie = (() => {
                    class t {
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: function() {
                                return vn(Cie)
                            },
                            providedIn: "root"
                        })
                    }
                    return t
                })();
            class xie {
                shouldDetach(n) {
                    return !1
                }
                store(n, e) {}
                shouldAttach(n) {
                    return !1
                }
                retrieve(n) {
                    return null
                }
                shouldReuseRoute(n, e) {
                    return n.routeConfig === e.routeConfig
                }
            }
            let Cie = (() => {
                class t extends xie {
                    static# e = this.\u0275fac = function() {
                        let e;
                        return function(r) {
                            return (e || (e = ys(t)))(r || t)
                        }
                    }();
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            const Hw = new nn("", {
                providedIn: "root",
                factory: () => ({})
            });
            let Tie = (() => {
                    class t {
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: function() {
                                return vn(Sie)
                            },
                            providedIn: "root"
                        })
                    }
                    return t
                })(),
                Sie = (() => {
                    class t {
                        shouldProcessUrl(e) {
                            return !0
                        }
                        extract(e) {
                            return e
                        }
                        merge(e, i) {
                            return e
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)
                        };
                        static# t = this.\u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "root"
                        })
                    }
                    return t
                })();
            var v0 = function(t) {
                return t[t.COMPLETE = 0] = "COMPLETE", t[t.FAILED = 1] = "FAILED", t[t.REDIRECTING = 2] = "REDIRECTING", t
            }(v0 || {});

            function dF(t, n) {
                t.events.pipe(ia(e => e instanceof dh || e instanceof h0 || e instanceof Pw || e instanceof Im), Fe(e => e instanceof dh || e instanceof Im ? v0.COMPLETE : e instanceof h0 && (0 === e.code || 1 === e.code) ? v0.REDIRECTING : v0.FAILED), ia(e => e !== v0.REDIRECTING), Sa(1)).subscribe(() => {
                    n()
                })
            }

            function Eie(t) {
                throw t
            }

            function Die(t, n, e) {
                return n.parse("/")
            }
            const Aie = {
                    paths: "exact",
                    fragment: "ignored",
                    matrixParams: "ignored",
                    queryParams: "exact"
                },
                kie = {
                    paths: "subset",
                    fragment: "ignored",
                    matrixParams: "ignored",
                    queryParams: "subset"
                };
            let Za = (() => {
                class t {
                    get navigationId() {
                        return this.navigationTransitions.navigationId
                    }
                    get browserPageId() {
                        return "computed" !== this.canceledNavigationResolution ? this.currentPageId : this.location.getState() ? .\u0275routerPageId ? ? this.currentPageId
                    }
                    get events() {
                        return this._events
                    }
                    constructor() {
                        this.disposed = !1, this.currentPageId = 0, this.console = vn(J3), this.isNgZoneEnabled = !1, this._events = new A, this.options = vn(Hw, {
                            optional: !0
                        }) || {}, this.pendingTasks = vn(hb), this.errorHandler = this.options.errorHandler || Eie, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || Die, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = vn(Tie), this.routeReuseStrategy = vn(wie), this.titleStrategy = vn(uF), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = vn(Bm, {
                            optional: !0
                        }) ? .flat() ? ? [], this.navigationTransitions = vn(Uw), this.urlSerializer = vn(a0), this.location = vn(bb), this.componentInputBindingEnabled = !!vn(Rw, {
                            optional: !0
                        }), this.eventsSubscription = new S, this.isNgZoneEnabled = vn(cr) instanceof cr && cr.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Mm, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = zN(0, null), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe(e => {
                            this.lastSuccessfulId = e.id, this.currentPageId = this.browserPageId
                        }, e => {
                            this.console.warn(`Unhandled Navigation Error: ${e}`)
                        }), this.subscribeToNavigationEvents()
                    }
                    subscribeToNavigationEvents() {
                        const e = this.navigationTransitions.events.subscribe(i => {
                            try {
                                const {
                                    currentTransition: r
                                } = this.navigationTransitions;
                                if (null === r) return void(hF(i) && this._events.next(i));
                                if (i instanceof Iw) lF(r.source) && (this.browserUrlTree = r.extractedUrl);
                                else if (i instanceof Im) this.rawUrlTree = r.rawUrl;
                                else if (i instanceof VN) {
                                    if ("eager" === this.urlUpdateStrategy) {
                                        if (!r.extras.skipLocationChange) {
                                            const s = this.urlHandlingStrategy.merge(r.urlAfterRedirects, r.rawUrl);
                                            this.setBrowserUrl(s, r)
                                        }
                                        this.browserUrlTree = r.urlAfterRedirects
                                    }
                                } else if (i instanceof gE) this.currentUrlTree = r.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(r.urlAfterRedirects, r.rawUrl), this.routerState = r.targetRouterState, "deferred" === this.urlUpdateStrategy && (r.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, r), this.browserUrlTree = r.urlAfterRedirects);
                                else if (i instanceof h0) 0 !== i.code && 1 !== i.code && (this.navigated = !0), (3 === i.code || 2 === i.code) && this.restoreHistory(r);
                                else if (i instanceof yE) {
                                    const s = this.urlHandlingStrategy.merge(i.url, r.currentRawUrl),
                                        o = {
                                            skipLocationChange: r.extras.skipLocationChange,
                                            replaceUrl: "eager" === this.urlUpdateStrategy || lF(r.source)
                                        };
                                    this.scheduleNavigation(s, d0, null, o, {
                                        resolve: r.resolve,
                                        reject: r.reject,
                                        promise: r.promise
                                    })
                                }
                                i instanceof Pw && this.restoreHistory(r, !0), i instanceof dh && (this.navigated = !0), hF(i) && this._events.next(i)
                            } catch (r) {
                                this.navigationTransitions.transitionAbortSubject.next(r)
                            }
                        });
                        this.eventsSubscription.add(e)
                    }
                    resetRootComponentType(e) {
                        this.routerState.root.component = e, this.navigationTransitions.rootComponentType = e
                    }
                    initialNavigation() {
                        if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) {
                            const e = this.location.getState();
                            this.navigateToSyncWithBrowser(this.location.path(!0), d0, e)
                        }
                    }
                    setUpLocationChangeListener() {
                        this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => {
                            const i = "popstate" === e.type ? "popstate" : "hashchange";
                            "popstate" === i && setTimeout(() => {
                                this.navigateToSyncWithBrowser(e.url, i, e.state)
                            }, 0)
                        }))
                    }
                    navigateToSyncWithBrowser(e, i, r) {
                        const s = {
                                replaceUrl: !0
                            },
                            o = r ? .navigationId ? r : null;
                        if (r) {
                            const c = { ...r
                            };
                            delete c.navigationId, delete c.\u0275routerPageId, 0 !== Object.keys(c).length && (s.state = c)
                        }
                        const a = this.parseUrl(e);
                        this.scheduleNavigation(a, i, o, s)
                    }
                    get url() {
                        return this.serializeUrl(this.currentUrlTree)
                    }
                    getCurrentNavigation() {
                        return this.navigationTransitions.currentNavigation
                    }
                    get lastSuccessfulNavigation() {
                        return this.navigationTransitions.lastSuccessfulNavigation
                    }
                    resetConfig(e) {
                        this.config = e.map(TE), this.navigated = !1, this.lastSuccessfulId = -1
                    }
                    ngOnDestroy() {
                        this.dispose()
                    }
                    dispose() {
                        this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe()
                    }
                    createUrlTree(e, i = {}) {
                        const {
                            relativeTo: r,
                            queryParams: s,
                            fragment: o,
                            queryParamsHandling: a,
                            preserveFragment: c
                        } = i, u = c ? this.currentUrlTree.fragment : o;
                        let m, h = null;
                        switch (a) {
                            case "merge":
                                h = { ...this.currentUrlTree.queryParams,
                                    ...s
                                };
                                break;
                            case "preserve":
                                h = this.currentUrlTree.queryParams;
                                break;
                            default:
                                h = s || null
                        }
                        null !== h && (h = this.removeEmptyProps(h));
                        try {
                            m = PN(r ? r.snapshot : this.routerState.snapshot.root)
                        } catch {
                            ("string" != typeof e[0] || !e[0].startsWith("/")) && (e = []), m = this.currentUrlTree.root
                        }
                        return ON(m, e, h, u ? ? null)
                    }
                    navigateByUrl(e, i = {
                        skipLocationChange: !1
                    }) {
                        const r = Bf(e) ? e : this.parseUrl(e),
                            s = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
                        return this.scheduleNavigation(s, d0, null, i)
                    }
                    navigate(e, i = {
                        skipLocationChange: !1
                    }) {
                        return function Mie(t) {
                            for (let n = 0; n < t.length; n++)
                                if (null == t[n]) throw new mt(4008, !1)
                        }(e), this.navigateByUrl(this.createUrlTree(e, i), i)
                    }
                    serializeUrl(e) {
                        return this.urlSerializer.serialize(e)
                    }
                    parseUrl(e) {
                        let i;
                        try {
                            i = this.urlSerializer.parse(e)
                        } catch (r) {
                            i = this.malformedUriErrorHandler(r, this.urlSerializer, e)
                        }
                        return i
                    }
                    isActive(e, i) {
                        let r;
                        if (r = !0 === i ? { ...Aie
                            } : !1 === i ? { ...kie
                            } : i, Bf(e)) return CN(this.currentUrlTree, e, r);
                        const s = this.parseUrl(e);
                        return CN(this.currentUrlTree, s, r)
                    }
                    removeEmptyProps(e) {
                        return Object.keys(e).reduce((i, r) => {
                            const s = e[r];
                            return null != s && (i[r] = s), i
                        }, {})
                    }
                    scheduleNavigation(e, i, r, s, o) {
                        if (this.disposed) return Promise.resolve(!1);
                        let a, c, u;
                        o ? (a = o.resolve, c = o.reject, u = o.promise) : u = new Promise((m, x) => {
                            a = m, c = x
                        });
                        const h = this.pendingTasks.add();
                        return dF(this, () => {
                            queueMicrotask(() => this.pendingTasks.remove(h))
                        }), this.navigationTransitions.handleNavigationRequest({
                            source: i,
                            restoredState: r,
                            currentUrlTree: this.currentUrlTree,
                            currentRawUrl: this.currentUrlTree,
                            currentBrowserUrl: this.browserUrlTree,
                            rawUrl: e,
                            extras: s,
                            resolve: a,
                            reject: c,
                            promise: u,
                            currentSnapshot: this.routerState.snapshot,
                            currentRouterState: this.routerState
                        }), u.catch(m => Promise.reject(m))
                    }
                    setBrowserUrl(e, i) {
                        const r = this.urlSerializer.serialize(e);
                        if (this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl) {
                            const o = { ...i.extras.state,
                                ...this.generateNgRouterState(i.id, this.browserPageId)
                            };
                            this.location.replaceState(r, "", o)
                        } else {
                            const s = { ...i.extras.state,
                                ...this.generateNgRouterState(i.id, this.browserPageId + 1)
                            };
                            this.location.go(r, "", s)
                        }
                    }
                    restoreHistory(e, i = !1) {
                        if ("computed" === this.canceledNavigationResolution) {
                            const s = this.currentPageId - this.browserPageId;
                            0 !== s ? this.location.historyGo(s) : this.currentUrlTree === this.getCurrentNavigation() ? .finalUrl && 0 === s && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree())
                        } else "replace" === this.canceledNavigationResolution && (i && this.resetState(e), this.resetUrlToCurrentUrlTree())
                    }
                    resetState(e) {
                        this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl)
                    }
                    resetUrlToCurrentUrlTree() {
                        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
                    }
                    generateNgRouterState(e, i) {
                        return "computed" === this.canceledNavigationResolution ? {
                            navigationId: e,
                            \u0275routerPageId: i
                        } : {
                            navigationId: e
                        }
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();

            function hF(t) {
                return !(t instanceof gE || t instanceof yE)
            }
            let $w = (() => {
                    class t {
                        constructor(e, i, r, s, o, a) {
                            this.router = e, this.route = i, this.tabIndexAttribute = r, this.renderer = s, this.el = o, this.locationStrategy = a, this.href = null, this.commands = null, this.onChanges = new A, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1;
                            const c = o.nativeElement.tagName ? .toLowerCase();
                            this.isAnchorElement = "a" === c || "area" === c, this.isAnchorElement ? this.subscription = e.events.subscribe(u => {
                                u instanceof dh && this.updateHref()
                            }) : this.setTabIndexIfNotOnNativeEl("0")
                        }
                        setTabIndexIfNotOnNativeEl(e) {
                            null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", e)
                        }
                        ngOnChanges(e) {
                            this.isAnchorElement && this.updateHref(), this.onChanges.next(this)
                        }
                        set routerLink(e) {
                            null != e ? (this.commands = Array.isArray(e) ? e : [e], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null))
                        }
                        onClick(e, i, r, s, o) {
                            return !!(null === this.urlTree || this.isAnchorElement && (0 !== e || i || r || s || o || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, {
                                skipLocationChange: this.skipLocationChange,
                                replaceUrl: this.replaceUrl,
                                state: this.state
                            }), !this.isAnchorElement)
                        }
                        ngOnDestroy() {
                            this.subscription ? .unsubscribe()
                        }
                        updateHref() {
                            this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy ? .prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;
                            const e = null === this.href ? null : function dP(t, n, e) {
                                return function S$(t, n) {
                                    return "src" === n && ("embed" === t || "frame" === t || "iframe" === t || "media" === t || "script" === t) || "href" === n && ("base" === t || "link" === t) ? uP : fo
                                }(n, e)(t)
                            }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href");
                            this.applyAttributeValue("href", e)
                        }
                        applyAttributeValue(e, i) {
                            const r = this.renderer,
                                s = this.el.nativeElement;
                            null !== i ? r.setAttribute(s, e, i) : r.removeAttribute(s, e)
                        }
                        get urlTree() {
                            return null === this.commands ? null : this.router.createUrlTree(this.commands, {
                                relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route,
                                queryParams: this.queryParams,
                                fragment: this.fragment,
                                queryParamsHandling: this.queryParamsHandling,
                                preserveFragment: this.preserveFragment
                            })
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Za), We(hh), function Nd(t) {
                                return function nv(t, n) {
                                    if ("class" === n) return t.classes;
                                    if ("style" === n) return t.styles;
                                    const e = t.attrs;
                                    if (e) {
                                        const i = e.length;
                                        let r = 0;
                                        for (; r < i;) {
                                            const s = e[r];
                                            if (Bo(s)) break;
                                            if (0 === s) r += 2;
                                            else if ("number" == typeof s)
                                                for (r++; r < i && "string" == typeof e[r];) r++;
                                            else {
                                                if (s === n) return e[r + 1];
                                                r += 2
                                            }
                                        }
                                    }
                                    return null
                                }(Cs(), t)
                            }("tabindex"), We(Ks), We(ir), We(bf))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "routerLink", ""]
                            ],
                            hostVars: 1,
                            hostBindings: function(i, r) {
                                1 & i && xt("click", function(o) {
                                    return r.onClick(o.button, o.ctrlKey, o.shiftKey, o.altKey, o.metaKey)
                                }), 2 & i && hi("target", r.target)
                            },
                            inputs: {
                                target: "target",
                                queryParams: "queryParams",
                                fragment: "fragment",
                                queryParamsHandling: "queryParamsHandling",
                                state: "state",
                                relativeTo: "relativeTo",
                                preserveFragment: ["preserveFragment", "preserveFragment", ym],
                                skipLocationChange: ["skipLocationChange", "skipLocationChange", ym],
                                replaceUrl: ["replaceUrl", "replaceUrl", ym],
                                routerLink: "routerLink"
                            },
                            standalone: !0,
                            features: [SO, Xi]
                        })
                    }
                    return t
                })(),
                fF = (() => {
                    class t {
                        get isActive() {
                            return this._isActive
                        }
                        constructor(e, i, r, s, o) {
                            this.router = e, this.element = i, this.renderer = r, this.cdr = s, this.link = o, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = {
                                exact: !1
                            }, this.isActiveChange = new zt, this.routerEventsSubscription = e.events.subscribe(a => {
                                a instanceof dh && this.update()
                            })
                        }
                        ngAfterContentInit() {
                            Ve(this.links.changes, Ve(null)).pipe(je()).subscribe(e => {
                                this.update(), this.subscribeToEachLinkOnChanges()
                            })
                        }
                        subscribeToEachLinkOnChanges() {
                            this.linkInputChangesSubscription ? .unsubscribe();
                            const e = [...this.links.toArray(), this.link].filter(i => !!i).map(i => i.onChanges);
                            this.linkInputChangesSubscription = gn(e).pipe(je()).subscribe(i => {
                                this._isActive !== this.isLinkActive(this.router)(i) && this.update()
                            })
                        }
                        set routerLinkActive(e) {
                            const i = Array.isArray(e) ? e : e.split(" ");
                            this.classes = i.filter(r => !!r)
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        ngOnDestroy() {
                            this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription ? .unsubscribe()
                        }
                        update() {
                            !this.links || !this.router.navigated || queueMicrotask(() => {
                                const e = this.hasActiveLinks();
                                this._isActive !== e && (this._isActive = e, this.cdr.markForCheck(), this.classes.forEach(i => {
                                    e ? this.renderer.addClass(this.element.nativeElement, i) : this.renderer.removeClass(this.element.nativeElement, i)
                                }), e && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(e))
                            })
                        }
                        isLinkActive(e) {
                            const i = function Iie(t) {
                                return !!t.paths
                            }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1;
                            return r => !!r.urlTree && e.isActive(r.urlTree, i)
                        }
                        hasActiveLinks() {
                            const e = this.isLinkActive(this.router);
                            return this.link && e(this.link) || this.links.some(e)
                        }
                        static# e = this.\u0275fac = function(i) {
                            return new(i || t)(We(Za), We(ir), We(Ks), We(qa), We($w, 8))
                        };
                        static# t = this.\u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "routerLinkActive", ""]
                            ],
                            contentQueries: function(i, r, s) {
                                if (1 & i && ub(s, $w, 5), 2 & i) {
                                    let o;
                                    wa(o = xa()) && (r.links = o)
                                }
                            },
                            inputs: {
                                routerLinkActiveOptions: "routerLinkActiveOptions",
                                ariaCurrentWhenActive: "ariaCurrentWhenActive",
                                routerLinkActive: "routerLinkActive"
                            },
                            outputs: {
                                isActiveChange: "isActiveChange"
                            },
                            exportAs: ["routerLinkActive"],
                            standalone: !0,
                            features: [Xi]
                        })
                    }
                    return t
                })();
            class pF {}
            let Pie = (() => {
                class t {
                    constructor(e, i, r, s, o) {
                        this.router = e, this.injector = r, this.preloadingStrategy = s, this.loader = o
                    }
                    setUpPreloading() {
                        this.subscription = this.router.events.pipe(ia(e => e instanceof dh), Tf(() => this.preload())).subscribe(() => {})
                    }
                    preload() {
                        return this.processRoutes(this.injector, this.router.config)
                    }
                    ngOnDestroy() {
                        this.subscription && this.subscription.unsubscribe()
                    }
                    processRoutes(e, i) {
                        const r = [];
                        for (const s of i) {
                            s.providers && !s._injector && (s._injector = VT(s.providers, e, `Route: ${s.path}`));
                            const o = s._injector ? ? e,
                                a = s._loadedInjector ? ? o;
                            (s.loadChildren && !s._loadedRoutes && void 0 === s.canLoad || s.loadComponent && !s._loadedComponent) && r.push(this.preloadConfig(o, s)), (s.children || s._loadedRoutes) && r.push(this.processRoutes(a, s.children ? ? s._loadedRoutes))
                        }
                        return gn(r).pipe(je())
                    }
                    preloadConfig(e, i) {
                        return this.preloadingStrategy.preload(i, () => {
                            let r;
                            r = i.loadChildren && void 0 === i.canLoad ? this.loader.loadChildren(e, i) : Ve(null);
                            const s = r.pipe(ke(o => null === o ? Ve(void 0) : (i._loadedRoutes = o.routes, i._loadedInjector = o.injector, this.processRoutes(o.injector ? ? e, o.routes))));
                            return i.loadComponent && !i._loadedComponent ? gn([s, this.loader.loadComponent(i)]).pipe(je()) : s
                        })
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Za), _t(e5), _t(hc), _t(pF), _t(AE))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            const kE = new nn("");
            let mF = (() => {
                class t {
                    constructor(e, i, r, s, o = {}) {
                        this.urlSerializer = e, this.transitions = i, this.viewportScroller = r, this.zone = s, this.options = o, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, o.scrollPositionRestoration = o.scrollPositionRestoration || "disabled", o.anchorScrolling = o.anchorScrolling || "disabled"
                    }
                    init() {
                        "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents()
                    }
                    createScrollEvents() {
                        return this.transitions.events.subscribe(e => {
                            e instanceof Iw ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof dh ? (this.lastId = e.id, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment)) : e instanceof Im && 0 === e.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment))
                        })
                    }
                    consumeScrollEvents() {
                        return this.transitions.events.subscribe(e => {
                            e instanceof UN && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0]))
                        })
                    }
                    scheduleScrollEvent(e, i) {
                        this.zone.runOutsideAngular(() => {
                            setTimeout(() => {
                                this.zone.run(() => {
                                    this.transitions.events.next(new UN(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, i))
                                })
                            }, 0)
                        })
                    }
                    ngOnDestroy() {
                        this.routerEventsSubscription ? .unsubscribe(), this.scrollEventsSubscription ? .unsubscribe()
                    }
                    static# e = this.\u0275fac = function(i) {
                        ! function QP() {
                            throw new Error("invalid")
                        }()
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();

            function Ku(t, n) {
                return {\
                    u0275kind: t,
                    \u0275providers: n
                }
            }

            function yF() {
                const t = vn(Do);
                return n => {
                    const e = t.get(Xl);
                    if (n !== e.components[0]) return;
                    const i = t.get(Za),
                        r = t.get(_F);
                    1 === t.get(ME) && i.initialNavigation(), t.get(vF, null, kt.Optional) ? .setUpPreloading(), t.get(kE, null, kt.Optional) ? .init(), i.resetRootComponentType(e.componentTypes[0]), r.closed || (r.next(), r.complete(), r.unsubscribe())
                }
            }
            const _F = new nn("", {
                    factory: () => new A
                }),
                ME = new nn("", {
                    providedIn: "root",
                    factory: () => 1
                }),
                vF = new nn("");

            function Bie(t) {
                return Ku(0, [{
                    provide: vF,
                    useExisting: Pie
                }, {
                    provide: pF,
                    useExisting: t
                }])
            }
            const bF = new nn("ROUTER_FORROOT_GUARD"),
                Fie = [bb, {
                    provide: a0,
                    useClass: dE
                }, Za, f0, {
                    provide: hh,
                    useFactory: function gF(t) {
                        return t.routerState.root
                    },
                    deps: [Za]
                }, AE, []];

            function Vie() {
                return new a5("Router", Za)
            }
            let wF = (() => {
                class t {
                    constructor(e) {}
                    static forRoot(e, i) {
                        return {
                            ngModule: t,
                            providers: [Fie, [], {
                                    provide: Bm,
                                    multi: !0,
                                    useValue: e
                                }, {
                                    provide: bF,
                                    useFactory: zie,
                                    deps: [
                                        [Za, new zl, new jd]
                                    ]
                                }, {
                                    provide: Hw,
                                    useValue: i || {}
                                }, i ? .useHash ? {
                                    provide: bf,
                                    useClass: nq
                                } : {
                                    provide: bf,
                                    useClass: N5
                                }, {
                                    provide: kE,
                                    useFactory: () => {
                                        const t = vn(vZ),
                                            n = vn(cr),
                                            e = vn(Hw),
                                            i = vn(Uw),
                                            r = vn(a0);
                                        return e.scrollOffset && t.setOffset(e.scrollOffset), new mF(r, i, t, n, e)
                                    }
                                }, i ? .preloadingStrategy ? Bie(i.preloadingStrategy).\u0275providers : [], {
                                    provide: a5,
                                    multi: !0,
                                    useFactory: Vie
                                }, i ? .initialNavigation ? jie(i) : [], i ? .bindToComponentInputs ? Ku(8, [KN, {
                                    provide: Rw,
                                    useExisting: KN
                                }]).\u0275providers : [],
                                [{
                                    provide: xF,
                                    useFactory: yF
                                }, {
                                    provide: cS,
                                    multi: !0,
                                    useExisting: xF
                                }]
                            ]
                        }
                    }
                    static forChild(e) {
                        return {
                            ngModule: t,
                            providers: [{
                                provide: Bm,
                                multi: !0,
                                useValue: e
                            }]
                        }
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(bF, 8))
                    };
                    static# t = this.\u0275mod = _i({
                        type: t
                    });
                    static# n = this.\u0275inj = wi({})
                }
                return t
            })();

            function zie(t) {
                return "guarded"
            }

            function jie(t) {
                return ["disabled" === t.initialNavigation ? Ku(3, [{
                    provide: eS,
                    multi: !0,
                    useFactory: () => {
                        const n = vn(Za);
                        return () => {
                            n.setUpLocationChangeListener()
                        }
                    }
                }, {
                    provide: ME,
                    useValue: 2
                }]).\u0275providers : [], "enabledBlocking" === t.initialNavigation ? Ku(2, [{
                    provide: ME,
                    useValue: 0
                }, {
                    provide: eS,
                    multi: !0,
                    deps: [Do],
                    useFactory: n => {
                        const e = n.get(eq, Promise.resolve());
                        return () => e.then(() => new Promise(i => {
                            const r = n.get(Za),
                                s = n.get(_F);
                            dF(r, () => {
                                i(!0)
                            }), n.get(Uw).afterPreactivation = () => (i(!0), s.closed ? Ve(void 0) : s), r.initialNavigation()
                        }))
                    }
                }]).\u0275providers : []]
            }
            const xF = new nn("");

            function Gie(t, n) {}
            const Kie = function(t, n) {
                return {
                    $implicit: t,
                    index: n
                }
            };

            function qie(t, n) {
                if (1 & t && tt(0, Gie, 0, 0, "ng-template", 4), 2 & t) {
                    const e = Ke(),
                        i = e.$implicit,
                        r = e.index,
                        s = Ke();
                    Re("ngTemplateOutlet", i.tplRef)("ngTemplateOutletContext", yl(2, Kie, s.preparePublicSlide(i), r))
                }
            }
            const Zie = function(t, n, e, i) {
                return {
                    width: t,
                    "margin-left": n,
                    "margin-right": e,
                    left: i
                }
            };

            function Yie(t, n) {
                if (1 & t) {
                    const e = On();
                    Kl(0), J(1, "div", 2), xt("animationend", function() {
                        const s = Nt(e).$implicit;
                        return Ft(Ke().clear(s.id))
                    }), tt(2, qie, 1, 5, null, 3), ce(), ql()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    he(1), Re("ngClass", e.classes)("ngStyle", y3(4, Zie, e.width + "px", e.marginL ? e.marginL + "px" : "", e.marginR ? e.marginR + "px" : "", e.left))("@autoHeight", e.heightState), he(1), Re("ngIf", e.load)
                }
            }
            const Xie = function(t, n, e, i, r) {
                    return {
                        width: t,
                        transform: n,
                        transition: e,
                        "padding-left": i,
                        "padding-right": r
                    }
                },
                Qie = function(t, n) {
                    return {
                        isMouseDragable: t,
                        isTouchDragable: n
                    }
                };

            function Jie(t, n) {
                if (1 & t && (J(0, "div", 4), gt(1, "owl-stage", 5), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("owlDraggable", yl(3, Qie, null == e.owlDOMData ? null : e.owlDOMData.isMouseDragable, null == e.owlDOMData ? null : e.owlDOMData.isTouchDragable))("stageData", e.stageData)("slidesData", e.slidesData)
                }
            }
            const ere = function(t, n) {
                return {
                    active: t,
                    "owl-dot-text": n
                }
            };

            function tre(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 11), xt("click", function() {
                        const s = Nt(e).$implicit;
                        return Ft(Ke(2).moveByDot(s.id))
                    }), gt(1, "span", 12), ce()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    Re("ngClass", yl(2, ere, e.active, e.showInnerContent)), he(1), Re("innerHTML", e.innerContent, iy)
                }
            }
            const zw = function(t) {
                return {
                    disabled: t
                }
            };

            function nre(t, n) {
                if (1 & t) {
                    const e = On();
                    Kl(0), J(1, "div", 6)(2, "div", 7), xt("click", function() {
                        return Nt(e), Ft(Ke().prev())
                    }), ce(), J(3, "div", 8), xt("click", function() {
                        return Nt(e), Ft(Ke().next())
                    }), ce()(), J(4, "div", 9), tt(5, tre, 2, 5, "div", 10), ce(), ql()
                }
                if (2 & t) {
                    const e = Ke();
                    he(1), Re("ngClass", fi(7, zw, null == e.navData ? null : e.navData.disabled)), he(1), Re("ngClass", fi(9, zw, null == e.navData || null == e.navData.prev ? null : e.navData.prev.disabled))("innerHTML", null == e.navData || null == e.navData.prev ? null : e.navData.prev.htmlText, iy), he(1), Re("ngClass", fi(11, zw, null == e.navData || null == e.navData.next ? null : e.navData.next.disabled))("innerHTML", null == e.navData || null == e.navData.next ? null : e.navData.next.htmlText, iy), he(1), Re("ngClass", fi(13, zw, null == e.dotsData ? null : e.dotsData.disabled)), he(1), Re("ngForOf", null == e.dotsData ? null : e.dotsData.dots)
                }
            }
            const ire = function(t, n, e, i, r) {
                return {
                    "owl-rtl": t,
                    "owl-loaded": n,
                    "owl-responsive": e,
                    "owl-drag": i,
                    "owl-grab": r
                }
            };
            class rre {
                items = 3;
                skip_validateItems = !1;
                loop = !1;
                center = !1;
                rewind = !1;
                mouseDrag = !0;
                touchDrag = !0;
                pullDrag = !0;
                freeDrag = !1;
                margin = 0;
                stagePadding = 0;
                merge = !1;
                mergeFit = !0;
                autoWidth = !1;
                startPosition = 0;
                rtl = !1;
                smartSpeed = 250;
                fluidSpeed = !1;
                dragEndSpeed = !1;
                responsive = {};
                responsiveRefreshRate = 200;
                nav = !1;
                navText = ["prev", "next"];
                navSpeed = !1;
                slideBy = 1;
                dots = !0;
                dotsEach = !1;
                dotsData = !1;
                dotsSpeed = !1;
                autoplay = !1;
                autoplayTimeout = 5e3;
                autoplayHoverPause = !1;
                autoplaySpeed = !1;
                autoplayMouseleaveTimeout = 1;
                lazyLoad = !1;
                lazyLoadEager = 0;
                slideTransition = "";
                animateOut = !1;
                animateIn = !1;
                autoHeight = !1;
                URLhashListener = !1;
                constructor() {}
            }
            class sre {
                items = "number";
                skip_validateItems = "boolean";
                loop = "boolean";
                center = "boolean";
                rewind = "boolean";
                mouseDrag = "boolean";
                touchDrag = "boolean";
                pullDrag = "boolean";
                freeDrag = "boolean";
                margin = "number";
                stagePadding = "number";
                merge = "boolean";
                mergeFit = "boolean";
                autoWidth = "boolean";
                startPosition = "number|string";
                rtl = "boolean";
                smartSpeed = "number";
                fluidSpeed = "boolean";
                dragEndSpeed = "number|boolean";
                responsive = {};
                responsiveRefreshRate = "number";
                nav = "boolean";
                navText = "string[]";
                navSpeed = "number|boolean";
                slideBy = "number|string";
                dots = "boolean";
                dotsEach = "number|boolean";
                dotsData = "boolean";
                dotsSpeed = "number|boolean";
                autoplay = "boolean";
                autoplayTimeout = "number";
                autoplayHoverPause = "boolean";
                autoplaySpeed = "number|boolean";
                autoplayMouseleaveTimeout = "number";
                lazyLoad = "boolean";
                lazyLoadEager = "number";
                slideTransition = "string";
                animateOut = "string|boolean";
                animateIn = "string|boolean";
                autoHeight = "boolean";
                URLhashListener = "boolean";
                constructor() {}
            }
            let IE = (() => {
                class t {
                    errorHandler;
                    constructor(e) {
                        this.errorHandler = e
                    }
                    log(e, ...i) {}
                    error(e) {
                        this.errorHandler.handleError(e)
                    }
                    warn(e, ...i) {
                        console.warn(e, ...i)
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(_t(jl))
                    };
                    static\ u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            var CF = function(t) {
                    return t.Event = "event", t.State = "state", t
                }(CF || {}),
                jw = function(t) {
                    return t.Default = "default", t.Inner = "inner", t.Outer = "outer", t
                }(jw || {});
            let qu = (() => {
                    class t {
                        logger;
                        _viewSettingsShipper$ = new A;
                        _initializedCarousel$ = new A;
                        _changeSettingsCarousel$ = new A;
                        _changedSettingsCarousel$ = new A;
                        _translateCarousel$ = new A;
                        _translatedCarousel$ = new A;
                        _resizeCarousel$ = new A;
                        _resizedCarousel$ = new A;
                        _refreshCarousel$ = new A;
                        _refreshedCarousel$ = new A;
                        _dragCarousel$ = new A;
                        _draggedCarousel$ = new A;
                        settings = {
                            items: 0
                        };
                        owlDOMData = {
                            rtl: !1,
                            isResponsive: !1,
                            isRefreshed: !1,
                            isLoaded: !1,
                            isLoading: !1,
                            isMouseDragable: !1,
                            isGrab: !1,
                            isTouchDragable: !1
                        };
                        stageData = {
                            transform: "translate3d(0px,0px,0px)",
                            transition: "0s",
                            width: 0,
                            paddingL: 0,
                            paddingR: 0
                        };
                        slidesData;
                        navData;
                        dotsData;
                        _width;
                        _items = [];
                        _widths = [];
                        _supress = {};
                        _plugins = {};
                        _current = null;
                        _clones = [];
                        _mergers = [];
                        _speed = null;
                        _coordinates = [];
                        _breakpoint = null;
                        clonedIdPrefix = "cloned-";
                        _options = {};
                        _invalidated = {};
                        get invalidated() {
                            return this._invalidated
                        }
                        _states = {
                            current: {},
                            tags: {
                                initializing: ["busy"],
                                animating: ["busy"],
                                dragging: ["interacting"]
                            }
                        };
                        get states() {
                            return this._states
                        }
                        _pipe = [{
                            filter: ["width", "items", "settings"],
                            run: e => {
                                e.current = this._items && this._items[this.relative(this._current)] ? .id
                            }
                        }, {
                            filter: ["width", "items", "settings"],
                            run: e => {
                                const i = this.settings.margin || "",
                                    s = this.settings.rtl,
                                    o = {
                                        "margin-left": s ? i : "",
                                        "margin-right": s ? "" : i
                                    };
                                !this.settings.autoWidth || this.slidesData.forEach(a => {
                                    a.marginL = o["margin-left"], a.marginR = o["margin-right"]
                                }), e.css = o
                            }
                        }, {
                            filter: ["width", "items", "settings"],
                            run: e => {
                                const i = +(this.width() / this.settings.items).toFixed(3) - this.settings.margin,
                                    r = !this.settings.autoWidth,
                                    s = [];
                                let o = null,
                                    a = this._items.length;
                                for (e.items = {
                                        merge: !1,
                                        width: i
                                    }; a-- > 0;) o = this._mergers[a], o = this.settings.mergeFit && Math.min(o, this.settings.items) || o, e.items.merge = o > 1 || e.items.merge, s[a] = r ? i * o : this._items[a].width ? this._items[a].width : i;
                                this._widths = s, this.slidesData.forEach((c, u) => {
                                    c.width = this._widths[u], c.marginR = e.css["margin-right"], c.marginL = e.css["margin-left"]
                                })
                            }
                        }, {
                            filter: ["items", "settings"],
                            run: () => {
                                const e = [],
                                    i = this._items,
                                    r = this.settings,
                                    s = Math.max(2 * r.items, 4),
                                    o = 2 * Math.ceil(i.length / 2);
                                let a = [],
                                    c = [],
                                    u = r.loop && i.length ? r.rewind ? s : Math.max(s, o) : 0;
                                for (u /= 2; u-- > 0;) e.push(this.normalize(e.length / 2, !0)), a.push({ ...this.slidesData[e[e.length - 1]]
                                }), e.push(this.normalize(i.length - 1 - (e.length - 1) / 2, !0)), c.unshift({ ...this.slidesData[e[e.length - 1]]
                                });
                                this._clones = e, a = a.map(h => (h.id = `${this.clonedIdPrefix}${h.id}`, h.isActive = !1, h.isCloned = !0, h)), c = c.map(h => (h.id = `${this.clonedIdPrefix}${h.id}`, h.isActive = !1, h.isCloned = !0, h)), this.slidesData = c.concat(this.slidesData).concat(a)
                            }
                        }, {
                            filter: ["width", "items", "settings"],
                            run: () => {
                                const e = this.settings.rtl ? 1 : -1,
                                    i = this._clones.length + this._items.length,
                                    r = [];
                                let s = -1,
                                    o = 0,
                                    a = 0;
                                for (; ++s < i;) o = r[s - 1] || 0, a = this._widths[this.relative(s)] + this.settings.margin, r.push(o + a * e);
                                this._coordinates = r
                            }
                        }, {
                            filter: ["width", "items", "settings"],
                            run: () => {
                                const e = this.settings.stagePadding,
                                    i = this._coordinates,
                                    r = {
                                        width: Math.ceil(Math.abs(i[i.length - 1])) + 2 * e,
                                        "padding-left": e || "",
                                        "padding-right": e || ""
                                    };
                                this.stageData.width = r.width, this.stageData.paddingL = r["padding-left"], this.stageData.paddingR = r["padding-right"]
                            }
                        }, {
                            filter: ["width", "items", "settings"],
                            run: e => {
                                let i = e.current ? this.slidesData.findIndex(r => r.id === e.current) : 0;
                                i = Math.max(this.minimum(), Math.min(this.maximum(), i)), this.reset(i)
                            }
                        }, {
                            filter: ["position"],
                            run: () => {
                                this.animate(this.coordinates(this._current))
                            }
                        }, {
                            filter: ["width", "position", "items", "settings"],
                            run: () => {
                                const e = this.settings.rtl ? 1 : -1,
                                    i = 2 * this.settings.stagePadding,
                                    r = [];
                                let s, o, a, c, u, h;
                                if (s = this.coordinates(this.current()), "number" == typeof s ? s += i : s = 0, o = s + this.width() * e, -1 === e && this.settings.center) {
                                    const m = this._coordinates.filter(x => this.settings.items % 2 == 1 ? x >= s : x > s);
                                    s = m.length ? m[m.length - 1] : s
                                }
                                for (u = 0, h = this._coordinates.length; u < h; u++) a = Math.ceil(this._coordinates[u - 1] || 0), c = Math.ceil(Math.abs(this._coordinates[u]) + i * e), (this._op(a, "<=", s) && this._op(a, ">", o) || this._op(c, "<", s) && this._op(c, ">", o)) && r.push(u);
                                this.slidesData.forEach(m => (m.isActive = !1, m)), r.forEach(m => {
                                    this.slidesData[m].isActive = !0
                                }), this.settings.center && (this.slidesData.forEach(m => (m.isCentered = !1, m)), this.slidesData[this.current()].isCentered = !0)
                            }
                        }];
                        constructor(e) {
                            this.logger = e
                        }
                        getViewCurSettings() {
                            return this._viewSettingsShipper$.asObservable()
                        }
                        getInitializedState() {
                            return this._initializedCarousel$.asObservable()
                        }
                        getChangeState() {
                            return this._changeSettingsCarousel$.asObservable()
                        }
                        getChangedState() {
                            return this._changedSettingsCarousel$.asObservable()
                        }
                        getTranslateState() {
                            return this._translateCarousel$.asObservable()
                        }
                        getTranslatedState() {
                            return this._translatedCarousel$.asObservable()
                        }
                        getResizeState() {
                            return this._resizeCarousel$.asObservable()
                        }
                        getResizedState() {
                            return this._resizedCarousel$.asObservable()
                        }
                        getRefreshState() {
                            return this._refreshCarousel$.asObservable()
                        }
                        getRefreshedState() {
                            return this._refreshedCarousel$.asObservable()
                        }
                        getDragState() {
                            return this._dragCarousel$.asObservable()
                        }
                        getDraggedState() {
                            return this._draggedCarousel$.asObservable()
                        }
                        setOptions(e) {
                            const i = new rre,
                                r = this._validateOptions(e, i);
                            this._options = { ...i,
                                ...r
                            }
                        }
                        _validateOptions(e, i) {
                            const r = { ...e
                                },
                                s = new sre,
                                o = (a, c) => (this.logger.log(`options.${c} must be type of ${a}; ${c}=${e[c]} skipped to defaults: ${c}=${i[c]}`), i[c]);
                            for (const a in r)
                                if (r.hasOwnProperty(a))
                                    if ("number" === s[a]) this._isNumeric(r[a]) ? (r[a] = +r[a], r[a] = "items" === a ? this._validateItems(r[a], r.skip_validateItems) : r[a]) : r[a] = o(s[a], a);
                                    else if ("boolean" === s[a] && "boolean" != typeof r[a]) r[a] = o(s[a], a);
                            else if ("number|boolean" !== s[a] || this._isNumberOrBoolean(r[a]))
                                if ("number|string" !== s[a] || this._isNumberOrString(r[a]))
                                    if ("string|boolean" !== s[a] || this._isStringOrBoolean(r[a])) {
                                        if ("string[]" === s[a])
                                            if (Array.isArray(r[a])) {
                                                let c = !1;
                                                r[a].forEach(u => {
                                                    c = "string" == typeof u
                                                }), c || (r[a] = o(s[a], a))
                                            } else r[a] = o(s[a], a)
                                    } else r[a] = o(s[a], a);
                            else r[a] = o(s[a], a);
                            else r[a] = o(s[a], a);
                            return r
                        }
                        _validateItems(e, i) {
                            let r = e;
                            return e > this._items.length ? i ? this.logger.log("The option 'items' in your options is bigger than the number of slides. The navigation got disabled") : (r = this._items.length, this.logger.log("The option 'items' in your options is bigger than the number of slides. This option is updated to the current number of slides and the navigation got disabled")) : e === this._items.length && (this.settings.dots || this.settings.nav) && this.logger.log("Option 'items' in your options is equal to the number of slides. So the navigation got disabled"), r
                        }
                        setCarouselWidth(e) {
                            this._width = e
                        }
                        setup(e, i, r) {
                            this.setCarouselWidth(e), this.setItems(i), this._defineSlidesData(), this.setOptions(r), this.settings = { ...this._options
                            }, this.setOptionsForViewport(), this._trigger("change", {
                                property: {
                                    name: "settings",
                                    value: this.settings
                                }
                            }), this.invalidate("settings"), this._trigger("changed", {
                                property: {
                                    name: "settings",
                                    value: this.settings
                                }
                            })
                        }
                        setOptionsForViewport() {
                            const e = this._width,
                                i = this._options.responsive;
                            let r = -1;
                            if (!Object.keys(i).length) return;
                            if (!e) return void(this.settings.items = 1);
                            for (const o in i) i.hasOwnProperty(o) && +o <= e && +o > r && (r = Number(o));
                            this.settings = { ...this._options,
                                ...i[r],
                                items: i[r] && i[r].items ? this._validateItems(i[r].items, this._options.skip_validateItems) : this._options.items
                            }, delete this.settings.responsive, this.owlDOMData.isResponsive = !0, this.owlDOMData.isMouseDragable = this.settings.mouseDrag, this.owlDOMData.isTouchDragable = this.settings.touchDrag;
                            const s = [];
                            this._items.forEach(o => {
                                s.push(this.settings.merge ? o.dataMerge : 1)
                            }), this._mergers = s, this._breakpoint = r, this.invalidate("settings")
                        }
                        initialize(e) {
                            this.enter("initializing"), this.owlDOMData.rtl = this.settings.rtl, this._mergers.length && (this._mergers = []), e.forEach(i => {
                                this._mergers.push(this.settings.merge ? i.dataMerge : 1)
                            }), this._clones = [], this.reset(this._isNumeric(this.settings.startPosition) ? +this.settings.startPosition : 0), this.invalidate("items"), this.refresh(), this.owlDOMData.isLoaded = !0, this.owlDOMData.isMouseDragable = this.settings.mouseDrag, this.owlDOMData.isTouchDragable = this.settings.touchDrag, this.sendChanges(), this.leave("initializing"), this._trigger("initialized")
                        }
                        sendChanges() {
                            this._viewSettingsShipper$.next({
                                owlDOMData: this.owlDOMData,
                                stageData: this.stageData,
                                slidesData: this.slidesData,
                                navData: this.navData,
                                dotsData: this.dotsData
                            })
                        }
                        _optionsLogic() {
                            this.settings.autoWidth && (this.settings.stagePadding = 0, this.settings.merge = !1)
                        }
                        update() {
                            let e = 0;
                            const i = this._pipe.length,
                                r = o => this._invalidated[o],
                                s = {};
                            for (; e < i;) {
                                const o = this._pipe[e].filter.filter(r);
                                (this._invalidated.all || o.length > 0) && this._pipe[e].run(s), e++
                            }
                            this.slidesData.forEach(o => o.classes = this.setCurSlideClasses(o)), this.sendChanges(), this._invalidated = {}, this.is("valid") || this.enter("valid")
                        }
                        width(e) {
                            switch (e = e || jw.Default) {
                                case jw.Inner:
                                case jw.Outer:
                                    return this._width;
                                default:
                                    return this._width - 2 * this.settings.stagePadding + this.settings.margin
                            }
                        }
                        refresh() {
                            this.enter("refreshing"), this._trigger("refresh"), this._defineSlidesData(), this.setOptionsForViewport(), this._optionsLogic(), this.update(), this.leave("refreshing"), this._trigger("refreshed")
                        }
                        onResize(e) {
                            if (!this._items.length) return !1;
                            this.setCarouselWidth(e), this.enter("resizing"), this._trigger("resize"), this.invalidate("width"), this.refresh(), this.leave("resizing"), this._trigger("resized")
                        }
                        prepareDragging(e) {
                            let r, i = null;
                            return r = this.stageData.transform.replace(/.*\(|\)| |[^,-\d]\w|\)/g, "").split(","), i = {
                                x: +r[0],
                                y: +r[1]
                            }, this.is("animating") && this.invalidate("position"), "mousedown" === e.type && (this.owlDOMData.isGrab = !0), this.speed(0), i
                        }
                        enterDragging() {
                            this.enter("dragging"), this._trigger("drag")
                        }
                        defineNewCoordsDrag(e, i) {
                            let r = null,
                                s = null,
                                o = null;
                            const a = this.difference(i.pointer, this.pointer(e)),
                                c = this.difference(i.stage.start, a);
                            return !!this.is("dragging") && (this.settings.loop ? (r = this.coordinates(this.minimum()), s = +this.coordinates(this.maximum() + 1) - r, c.x = ((c.x - r) % s + s) % s + r) : (r = this.coordinates(this.settings.rtl ? this.maximum() : this.minimum()), s = this.coordinates(this.settings.rtl ? this.minimum() : this.maximum()), o = this.settings.pullDrag ? -1 * a.x / 5 : 0, c.x = Math.max(Math.min(c.x, r + o), s + o)), c)
                        }
                        finishDragging(e, i, r) {
                            const o = this.difference(i.pointer, this.pointer(e)),
                                a = i.stage.current,
                                c = ["right", "left"][+(this.settings.rtl ? o.x < +this.settings.rtl : o.x > +this.settings.rtl)];
                            let u, h, m;
                            (0 !== o.x && this.is("dragging") || !this.is("valid")) && (this.speed(+this.settings.dragEndSpeed || this.settings.smartSpeed), u = this.closest(a.x, 0 !== o.x ? c : i.direction), h = this.current(), m = this.current(-1 === u ? void 0 : u), h !== m && (this.invalidate("position"), this.update()), i.direction = c, (Math.abs(o.x) > 3 || (new Date).getTime() - i.time > 300) && r()), this.is("dragging") && (this.leave("dragging"), this._trigger("dragged"))
                        }
                        closest(e, i) {
                            const s = this.width();
                            let o = this.coordinates(),
                                a = -1;
                            this.settings.center && (o = o.map(c => (0 === c && (c += 1e-6), c)));
                            for (let c = 0; c < o.length && ("left" === i && e > o[c] - 30 && e < o[c] + 30 ? a = c : "right" === i && e > o[c] - s - 30 && e < o[c] - s + 30 ? a = c + 1 : this._op(e, "<", o[c]) && this._op(e, ">", o[c + 1] || o[c] - s) ? a = "left" === i ? c + 1 : c : null === i && e > o[c] - 30 && e < o[c] + 30 && (a = c), -1 === a); c++);
                            return this.settings.loop || (this._op(e, ">", o[this.minimum()]) ? a = e = this.minimum() : this._op(e, "<", o[this.maximum()]) && (a = e = this.maximum())), a
                        }
                        animate(e) {
                            const i = this.speed() > 0;
                            this.is("animating") && this.onTransitionEnd(), i && (this.enter("animating"), this._trigger("translate")), this.stageData.transform = "translate3d(" + e + "px,0px,0px)", this.stageData.transition = this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "")
                        }
                        is(e) {
                            return this._states.current[e] && this._states.current[e] > 0
                        }
                        current(e) {
                            return void 0 === e ? this._current : 0 !== this._items.length ? (e = this.normalize(e), this._current !== e && (this._trigger("change", {
                                property: {
                                    name: "position",
                                    value: e
                                }
                            }), this._current = e, this.invalidate("position"), this._trigger("changed", {
                                property: {
                                    name: "position",
                                    value: this._current
                                }
                            })), this._current) : void 0
                        }
                        invalidate(e) {
                            return "string" == typeof e && (this._invalidated[e] = !0, this.is("valid") && this.leave("valid")), Object.keys(this._invalidated)
                        }
                        reset(e) {
                            void 0 !== (e = this.normalize(e)) && (this._speed = 0, this._current = e, this._suppress(["translate", "translated"]), this.animate(this.coordinates(e)), this._release(["translate", "translated"]))
                        }
                        normalize(e, i) {
                            const r = this._items.length,
                                s = i ? 0 : this._clones.length;
                            return !this._isNumeric(e) || r < 1 ? e = void 0 : (e < 0 || e >= r + s) && (e = ((e - s / 2) % r + r) % r + s / 2), e
                        }
                        relative(e) {
                            return this.normalize(e -= this._clones.length / 2, !0)
                        }
                        maximum(e = !1) {
                            const i = this.settings;
                            let s, o, a, r = this._coordinates.length;
                            if (i.loop) r = this._clones.length / 2 + this._items.length - 1;
                            else if (i.autoWidth || i.merge) {
                                for (s = this._items.length, o = this.slidesData[--s].width, a = this._width; s-- > 0 && (o += +this.slidesData[s].width + this.settings.margin, !(o > a)););
                                r = s + 1
                            } else r = i.center ? this._items.length - 1 : this._items.length - i.items;
                            return e && (r -= this._clones.length / 2), Math.max(r, 0)
                        }
                        minimum(e = !1) {
                            return e ? 0 : this._clones.length / 2
                        }
                        items(e) {
                            return void 0 === e ? this._items.slice() : (e = this.normalize(e, !0), [this._items[e]])
                        }
                        mergers(e) {
                            return void 0 === e ? this._mergers.slice() : (e = this.normalize(e, !0), this._mergers[e])
                        }
                        clones(e) {
                            const i = this._clones.length / 2,
                                r = i + this._items.length,
                                s = o => o % 2 == 0 ? r + o / 2 : i - (o + 1) / 2;
                            return void 0 === e ? this._clones.map((o, a) => s(a)) : this._clones.map((o, a) => o === e ? s(a) : null).filter(o => o)
                        }
                        speed(e) {
                            return void 0 !== e && (this._speed = e), this._speed
                        }
                        coordinates(e) {
                            let s, o, i = 1,
                                r = e - 1;
                            return void 0 === e ? (o = this._coordinates.map((a, c) => this.coordinates(c)), o) : (this.settings.center ? (this.settings.rtl && (i = -1, r = e + 1), s = this._coordinates[e], s += (this.width() - s + (this._coordinates[r] || 0)) / 2 * i) : s = this._coordinates[r] || 0, s = Math.ceil(s), s)
                        }
                        _duration(e, i, r) {
                            return 0 === r ? 0 : Math.min(Math.max(Math.abs(i - e), 1), 6) * Math.abs(+r || this.settings.smartSpeed)
                        }
                        to(e, i) {
                            let r = this.current(),
                                s = null,
                                o = e - this.relative(r),
                                a = this.maximum(),
                                c = 0;
                            const u = +(o > 0) - +(o < 0),
                                h = this._items.length,
                                m = this.minimum();
                            this.settings.loop ? (!this.settings.rewind && Math.abs(o) > h / 2 && (o += -1 * u * h), s = (((e = r + o) - m) % h + h) % h + m, s !== e && s - o <= a && s - o > 0 && (r = s - o, e = s, c = 30, this.reset(r), this.sendChanges())) : this.settings.rewind ? (a += 1, e = (e % a + a) % a) : e = Math.max(m, Math.min(a, e)), setTimeout(() => {
                                this.speed(this._duration(r, e, i)), this.current(e), this.update()
                            }, c)
                        }
                        next(e) {
                            e = e || !1, this.to(this.relative(this.current()) + 1, e)
                        }
                        prev(e) {
                            e = e || !1, this.to(this.relative(this.current()) - 1, e)
                        }
                        onTransitionEnd(e) {
                            if (void 0 !== e) return !1;
                            this.leave("animating"), this._trigger("translated")
                        }
                        _viewport() {
                            let e;
                            return this._width ? e = this._width : this.logger.log("Can not detect viewport width."), e
                        }
                        setItems(e) {
                            this._items = e
                        }
                        _defineSlidesData() {
                            let e;
                            this.slidesData && this.slidesData.length && (e = new Map, this.slidesData.forEach(i => {
                                i.load && e.set(i.id, i.load)
                            })), this.slidesData = this._items.map(i => ({
                                id: `${i.id}`,
                                isActive: !1,
                                tplRef: i.tplRef,
                                dataMerge: i.dataMerge,
                                width: 0,
                                isCloned: !1,
                                load: !!e && e.get(i.id),
                                hashFragment: i.dataHash
                            }))
                        }
                        setCurSlideClasses(e) {
                            const i = {
                                active: e.isActive,
                                center: e.isCentered,
                                cloned: e.isCloned,
                                animated: e.isAnimated,
                                "owl-animated-in": e.isDefAnimatedIn,
                                "owl-animated-out": e.isDefAnimatedOut
                            };
                            return this.settings.animateIn && (i[this.settings.animateIn] = e.isCustomAnimatedIn), this.settings.animateOut && (i[this.settings.animateOut] = e.isCustomAnimatedOut), i
                        }
                        _op(e, i, r) {
                            const s = this.settings.rtl;
                            switch (i) {
                                case "<":
                                    return s ? e > r : e < r;
                                case ">":
                                    return s ? e < r : e > r;
                                case ">=":
                                    return s ? e <= r : e >= r;
                                case "<=":
                                    return s ? e >= r : e <= r
                            }
                        }
                        _trigger(e, i, r, s, o) {
                            switch (e) {
                                case "initialized":
                                    this._initializedCarousel$.next(e);
                                    break;
                                case "change":
                                    this._changeSettingsCarousel$.next(i);
                                    break;
                                case "changed":
                                    this._changedSettingsCarousel$.next(i);
                                    break;
                                case "drag":
                                    this._dragCarousel$.next(e);
                                    break;
                                case "dragged":
                                    this._draggedCarousel$.next(e);
                                    break;
                                case "resize":
                                    this._resizeCarousel$.next(e);
                                    break;
                                case "resized":
                                    this._resizedCarousel$.next(e);
                                    break;
                                case "refresh":
                                    this._refreshCarousel$.next(e);
                                    break;
                                case "refreshed":
                                    this._refreshedCarousel$.next(e);
                                    break;
                                case "translate":
                                    this._translateCarousel$.next(e);
                                    break;
                                case "translated":
                                    this._translatedCarousel$.next(e)
                            }
                        }
                        enter(e) {
                            [e].concat(this._states.tags[e] || []).forEach(i => {
                                void 0 === this._states.current[i] && (this._states.current[i] = 0), this._states.current[i]++
                            })
                        }
                        leave(e) {
                            [e].concat(this._states.tags[e] || []).forEach(i => {
                                (0 === this._states.current[i] || this._states.current[i]) && this._states.current[i]--
                            })
                        }
                        register(e) {
                            e.type === CF.State && (this._states.tags[e.name] = this._states.tags[e.name] ? this._states.tags[e.name].concat(e.tags) : e.tags, this._states.tags[e.name] = this._states.tags[e.name].filter((i, r) => this._states.tags[e.name].indexOf(i) === r))
                        }
                        _suppress(e) {
                            e.forEach(i => {
                                this._supress[i] = !0
                            })
                        }
                        _release(e) {
                            e.forEach(i => {
                                delete this._supress[i]
                            })
                        }
                        pointer(e) {
                            const i = {
                                x: null,
                                y: null
                            };
                            return (e = (e = e.originalEvent || e || window.event).touches && e.touches.length ? e.touches[0] : e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e).pageX ? (i.x = e.pageX, i.y = e.pageY) : (i.x = e.clientX, i.y = e.clientY), i
                        }
                        _isNumeric(e) {
                            return !isNaN(parseFloat(e))
                        }
                        _isNumberOrBoolean(e) {
                            return this._isNumeric(e) || "boolean" == typeof e
                        }
                        _isNumberOrString(e) {
                            return this._isNumeric(e) || "string" == typeof e
                        }
                        _isStringOrBoolean(e) {
                            return "string" == typeof e || "boolean" == typeof e
                        }
                        difference(e, i) {
                            return null === e || null === i ? {
                                x: 0,
                                y: 0
                            } : {
                                x: e.x - i.x,
                                y: e.y - i.y
                            }
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(IE))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                TF = (() => {
                    class t {
                        carouselService;
                        navSubscription;
                        _initialized = !1;
                        _pages = [];
                        _navData = {
                            disabled: !1,
                            prev: {
                                disabled: !1,
                                htmlText: ""
                            },
                            next: {
                                disabled: !1,
                                htmlText: ""
                            }
                        };
                        _dotsData = {
                            disabled: !1,
                            dots: []
                        };
                        constructor(e) {
                            this.carouselService = e, this.spyDataStreams()
                        }
                        ngOnDestroy() {
                            this.navSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const s = Si(this.carouselService.getInitializedState().pipe(Ui(o => {
                                this.initialize(), this._updateNavPages(), this.draw(), this.update(), this.carouselService.sendChanges()
                            })), this.carouselService.getChangedState().pipe(ia(o => "position" === o.property.name), Ui(o => {
                                this.update()
                            })), this.carouselService.getRefreshedState().pipe(Ui(() => {
                                this._updateNavPages(), this.draw(), this.update(), this.carouselService.sendChanges()
                            })));
                            this.navSubscription = s.subscribe(() => {})
                        }
                        initialize() {
                            this._navData.disabled = !0, this._navData.prev.htmlText = this.carouselService.settings.navText[0], this._navData.next.htmlText = this.carouselService.settings.navText[1], this._dotsData.disabled = !0, this.carouselService.navData = this._navData, this.carouselService.dotsData = this._dotsData
                        }
                        _updateNavPages() {
                            let e, i, r;
                            const s = this.carouselService.clones().length / 2,
                                o = s + this.carouselService.items().length,
                                a = this.carouselService.maximum(!0),
                                c = [],
                                u = this.carouselService.settings;
                            let h = u.center || u.autoWidth || u.dotsData ? 1 : Math.floor(Number(u.dotsEach)) || Math.floor(u.items);
                            if (h = +h, "page" !== u.slideBy && (u.slideBy = Math.min(+u.slideBy, u.items)), u.dots || "page" === u.slideBy)
                                for (e = s, i = 0, r = 0; e < o; e++) {
                                    if (i >= h || 0 === i) {
                                        if (c.push({
                                                start: Math.min(a, e - s),
                                                end: e - s + h - 1
                                            }), Math.min(a, e - s) === a) break;
                                        i = 0, ++r
                                    }
                                    i += this.carouselService.mergers(this.carouselService.relative(e))
                                }
                            this._pages = c
                        }
                        draw() {
                            let e;
                            const i = this.carouselService.settings,
                                r = this.carouselService.items(),
                                s = r.length <= i.items;
                            if (this._navData.disabled = !i.nav || s, this._dotsData.disabled = !i.dots || s, i.dots)
                                if (e = this._pages.length - this._dotsData.dots.length, i.dotsData && 0 !== e) this._dotsData.dots = [], r.forEach(o => {
                                    this._dotsData.dots.push({
                                        active: !1,
                                        id: `dot-${o.id}`,
                                        innerContent: o.dotContent,
                                        showInnerContent: !0
                                    })
                                });
                                else if (e > 0) {
                                const o = this._dotsData.dots.length > 0 ? this._dotsData.dots.length : 0;
                                for (let a = 0; a < e; a++) this._dotsData.dots.push({
                                    active: !1,
                                    id: `dot-${a+o}`,
                                    innerContent: "",
                                    showInnerContent: !1
                                })
                            } else e < 0 && this._dotsData.dots.splice(e, Math.abs(e));
                            this.carouselService.navData = this._navData, this.carouselService.dotsData = this._dotsData
                        }
                        update() {
                            this._updateNavButtons(), this._updateDots()
                        }
                        _updateNavButtons() {
                            const e = this.carouselService.settings,
                                i = e.loop || e.rewind,
                                r = this.carouselService.relative(this.carouselService.current());
                            e.nav && (this._navData.prev.disabled = !i && r <= this.carouselService.minimum(!0), this._navData.next.disabled = !i && r >= this.carouselService.maximum(!0)), this.carouselService.navData = this._navData
                        }
                        _updateDots() {
                            let e;
                            this.carouselService.settings.dots && (this._dotsData.dots.forEach(i => {
                                !0 === i.active && (i.active = !1)
                            }), e = this._current(), this._dotsData.dots.length && (this._dotsData.dots[e].active = !0), this.carouselService.dotsData = this._dotsData)
                        }
                        _current() {
                            const e = this.carouselService.relative(this.carouselService.current());
                            let i;
                            const r = this._pages.filter((s, o) => s.start <= e && s.end >= e).pop();
                            return i = this._pages.findIndex(s => s.start === r.start && s.end === r.end), i
                        }
                        _getPosition(e) {
                            let i, r;
                            const s = this.carouselService.settings;
                            return "page" === s.slideBy ? (i = this._current(), r = this._pages.length, e ? ++i : --i, i = this._pages[(i % r + r) % r].start) : (i = this.carouselService.relative(this.carouselService.current()), r = this.carouselService.items().length, e ? i += +s.slideBy : i -= +s.slideBy), i
                        }
                        next(e) {
                            this.carouselService.to(this._getPosition(!0), e)
                        }
                        prev(e) {
                            this.carouselService.to(this._getPosition(!1), e)
                        }
                        to(e, i, r) {
                            let s;
                            !r && this._pages.length ? (s = this._pages.length, this.carouselService.to(this._pages[(e % s + s) % s].start, i)) : this.carouselService.to(e, i)
                        }
                        moveByDot(e) {
                            const i = this._dotsData.dots.findIndex(r => e === r.id);
                            this.to(i, this.carouselService.settings.dotsSpeed)
                        }
                        toSlideById(e) {
                            const i = this.carouselService.slidesData.findIndex(r => r.id === e && !1 === r.isCloned); - 1 === i || i === this.carouselService.current() || this.carouselService.to(this.carouselService.relative(i), !1)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })();
            const PE = new nn("WindowToken");
            class OE {
                get nativeWindow() {
                    throw new Error("Not implemented.")
                }
            }
            let ore = (() => {
                class t extends OE {
                    constructor() {
                        super()
                    }
                    get nativeWindow() {
                        return window
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const cre = [{
                    provide: OE,
                    useClass: ore
                }, {
                    provide: PE,
                    useFactory: function are(t, n) {
                        return gc(n) ? t.nativeWindow : {
                            setTimeout: (i, r) => {},
                            clearTimeout: i => {}
                        }
                    },
                    deps: [OE, Bs]
                }],
                LE = new nn("DocumentToken");
            class RE {
                get nativeDocument() {
                    throw new Error("Not implemented.")
                }
            }
            let lre = (() => {
                class t extends RE {
                    constructor() {
                        super()
                    }
                    get nativeDocument() {
                        return document
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    })
                }
                return t
            })();
            const dre = [{
                provide: RE,
                useClass: lre
            }, {
                provide: LE,
                useFactory: function ure(t, n) {
                    return gc(n) ? t.nativeDocument : {
                        hidden: !1,
                        visibilityState: "visible"
                    }
                },
                deps: [RE, Bs]
            }];
            let SF = (() => {
                    class t {
                        carouselService;
                        ngZone;
                        autoplaySubscription;
                        _timeout = null;
                        _paused = !1;
                        _isArtificialAutoplayTimeout;
                        _isAutoplayStopped = !1;
                        get isAutoplayStopped() {
                            return this._isAutoplayStopped
                        }
                        set isAutoplayStopped(e) {
                            this._isAutoplayStopped = e
                        }
                        winRef;
                        docRef;
                        constructor(e, i, r, s) {
                            this.carouselService = e, this.ngZone = s, this.winRef = i, this.docRef = r, this.spyDataStreams()
                        }
                        ngOnDestroy() {
                            this.autoplaySubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const s = Si(this.carouselService.getInitializedState().pipe(Ui(() => {
                                this.carouselService.settings.autoplay && this.play()
                            })), this.carouselService.getChangedState().pipe(Ui(o => {
                                this._handleChangeObservable(o)
                            })), this.carouselService.getResizedState().pipe(Ui(() => {
                                this.carouselService.settings.autoplay && !this._isAutoplayStopped ? this.play() : this.stop()
                            })));
                            this.autoplaySubscription = s.subscribe(() => {})
                        }
                        play(e, i) {
                            this._paused && (this._paused = !1, this._setAutoPlayInterval(this.carouselService.settings.autoplayMouseleaveTimeout)), !this.carouselService.is("rotating") && (this.carouselService.enter("rotating"), this._setAutoPlayInterval())
                        }
                        _getNextTimeout(e, i) {
                            return this._timeout && this.winRef.clearTimeout(this._timeout), this._isArtificialAutoplayTimeout = !!e, this.ngZone.runOutsideAngular(() => this.winRef.setTimeout(() => {
                                this.ngZone.run(() => {
                                    this._paused || this.carouselService.is("busy") || this.carouselService.is("interacting") || this.docRef.hidden || this.carouselService.next(i || this.carouselService.settings.autoplaySpeed)
                                })
                            }, e || this.carouselService.settings.autoplayTimeout))
                        }
                        _setAutoPlayInterval(e) {
                            this._timeout = this._getNextTimeout(e)
                        }
                        stop() {
                            this.carouselService.is("rotating") && (this._paused = !0, this.winRef.clearTimeout(this._timeout), this.carouselService.leave("rotating"))
                        }
                        pause() {
                            this.carouselService.is("rotating") && (this._paused = !0)
                        }
                        _handleChangeObservable(e) {
                            "settings" === e.property.name ? this.carouselService.settings.autoplay ? this.play() : this.stop() : "position" === e.property.name && this.carouselService.settings.autoplay && this._setAutoPlayInterval()
                        }
                        _playAfterTranslated() {
                            Ve("translated").pipe(St(e => this.carouselService.getTranslatedState()), nu(), ia(() => this._isArtificialAutoplayTimeout), Ui(() => this._setAutoPlayInterval())).subscribe(() => {})
                        }
                        startPausing() {
                            this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && this.pause()
                        }
                        startPlayingMouseLeave() {
                            this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && (this.play(), this._playAfterTranslated())
                        }
                        startPlayingTouchEnd() {
                            this.carouselService.settings.autoplayHoverPause && this.carouselService.is("rotating") && (this.play(), this._playAfterTranslated())
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu), _t(PE), _t(LE), _t(cr))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                EF = (() => {
                    class t {
                        carouselService;
                        lazyLoadSubscription;
                        constructor(e) {
                            this.carouselService = e, this.spyDataStreams()
                        }
                        ngOnDestroy() {
                            this.lazyLoadSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const s = Si(this.carouselService.getInitializedState().pipe(Ui(() => {
                                const o = this.carouselService.settings && !this.carouselService.settings.lazyLoad;
                                this.carouselService.slidesData.forEach(a => a.load = !!o)
                            })), this.carouselService.getChangeState(), this.carouselService.getResizedState()).pipe(Ui(o => this._defineLazyLoadSlides(o)));
                            this.lazyLoadSubscription = s.subscribe(() => {})
                        }
                        _defineLazyLoadSlides(e) {
                            if (this.carouselService.settings && this.carouselService.settings.lazyLoad && (e.property && "position" === e.property.name || "initialized" === e || "resized" === e)) {
                                const i = this.carouselService.settings,
                                    r = this.carouselService.clones().length;
                                let s = i.center && Math.ceil(i.items / 2) || i.items,
                                    o = i.center && -1 * s || 0,
                                    a = (e.property && void 0 !== e.property.value ? e.property.value : this.carouselService.current()) + o;
                                for (i.lazyLoadEager > 0 && (s += i.lazyLoadEager, i.loop && (a -= i.lazyLoadEager, s++)); o++ < s;) this._load(r / 2 + this.carouselService.relative(a)), r && this.carouselService.clones(this.carouselService.relative(a)).forEach(c => this._load(c)), a++
                            }
                        }
                        _load(e) {
                            this.carouselService.slidesData[e].load || (this.carouselService.slidesData[e].load = !0)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                BE = (() => {
                    class t {
                        carouselService;
                        animateSubscription;
                        swapping = !0;
                        previous = void 0;
                        next = void 0;
                        constructor(e) {
                            this.carouselService = e, this.spyDataStreams()
                        }
                        ngOnDestroy() {
                            this.animateSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const e = this.carouselService.getChangeState().pipe(Ui(u => {
                                    "position" === u.property.name && (this.previous = this.carouselService.current(), this.next = u.property.value)
                                })),
                                o = Si(this.carouselService.getDragState(), this.carouselService.getDraggedState(), this.carouselService.getTranslatedState()).pipe(Ui(u => this.swapping = "translated" === u)),
                                c = Si(e, this.carouselService.getTranslateState().pipe(Ui(u => {
                                    this.swapping && (this.carouselService._options.animateOut || this.carouselService._options.animateIn) && this._swap()
                                })), o).pipe();
                            this.animateSubscription = c.subscribe(() => {})
                        }
                        _swap() {
                            if (1 !== this.carouselService.settings.items) return;
                            let e;
                            this.carouselService.speed(0);
                            const i = this.carouselService.slidesData[this.previous],
                                r = this.carouselService.slidesData[this.next],
                                s = this.carouselService.settings.animateIn,
                                o = this.carouselService.settings.animateOut;
                            this.carouselService.current() !== this.previous && (o && (e = +this.carouselService.coordinates(this.previous) - +this.carouselService.coordinates(this.next), this.carouselService.slidesData.forEach(a => {
                                a.id === i.id && (a.left = `${e}px`, a.isAnimated = !0, a.isDefAnimatedOut = !0, a.isCustomAnimatedOut = !0)
                            })), s && this.carouselService.slidesData.forEach(a => {
                                a.id === r.id && (a.isAnimated = !0, a.isDefAnimatedIn = !0, a.isCustomAnimatedIn = !0)
                            }))
                        }
                        clear(e) {
                            this.carouselService.slidesData.forEach(i => {
                                i.id === e && (i.left = "", i.isAnimated = !1, i.isDefAnimatedOut = !1, i.isCustomAnimatedOut = !1, i.isDefAnimatedIn = !1, i.isCustomAnimatedIn = !1, i.classes = this.carouselService.setCurSlideClasses(i))
                            }), this.carouselService.onTransitionEnd()
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                DF = (() => {
                    class t {
                        carouselService;
                        autoHeightSubscription;
                        constructor(e) {
                            this.carouselService = e, this.spyDataStreams()
                        }
                        ngOnDestroy() {
                            this.autoHeightSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const s = Si(this.carouselService.getInitializedState().pipe(Ui(o => {
                                this.carouselService.settings.autoHeight ? this.update() : this.carouselService.slidesData.forEach(a => a.heightState = "full")
                            })), this.carouselService.getChangedState().pipe(Ui(o => {
                                this.carouselService.settings.autoHeight && "position" === o.property.name && this.update()
                            })), this.carouselService.getRefreshedState().pipe(Ui(o => {
                                this.carouselService.settings.autoHeight && this.update()
                            })));
                            this.autoHeightSubscription = s.subscribe(() => {})
                        }
                        update() {
                            const e = this.carouselService.settings.items;
                            let i = this.carouselService.current(),
                                r = i + e;
                            this.carouselService.settings.center && (i = e % 2 == 1 ? i - (e - 1) / 2 : i - e / 2, r = e % 2 == 1 ? i + e : i + e + 1), this.carouselService.slidesData.forEach((s, o) => {
                                s.heightState = o >= i && o < r ? "full" : "nulled"
                            })
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                AF = (() => {
                    class t {
                        carouselService;
                        route;
                        router;
                        hashSubscription;
                        currentHashFragment;
                        constructor(e, i, r) {
                            this.carouselService = e, this.route = i, this.router = r, this.spyDataStreams(), this.route || (this.route = {
                                fragment: Ve("no route").pipe(Sa(1))
                            }), this.router || (this.router = {
                                navigate: (s, o) => {}
                            })
                        }
                        ngOnDestroy() {
                            this.hashSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            const r = Si(this.carouselService.getInitializedState().pipe(Ui(() => this.listenToRoute())), this.carouselService.getChangedState().pipe(Ui(s => {
                                if (this.carouselService.settings.URLhashListener && "position" === s.property.name) {
                                    const o = this.carouselService.current(),
                                        a = this.carouselService.slidesData[o].hashFragment;
                                    if (!a || a === this.currentHashFragment) return;
                                    this.router.navigate(["./"], {
                                        fragment: a,
                                        relativeTo: this.route
                                    })
                                }
                            })));
                            this.hashSubscription = r.subscribe(() => {})
                        }
                        rewind(e) {
                            const i = this.carouselService.slidesData.findIndex(r => r.hashFragment === e && !1 === r.isCloned); - 1 === i || i === this.carouselService.current() || this.carouselService.to(this.carouselService.relative(i), !1)
                        }
                        listenToRoute() {
                            this.route.fragment.pipe(hN("URLHash" === this.carouselService.settings.startPosition ? 0 : 2)).subscribe(i => {
                                this.currentHashFragment = i, this.rewind(i)
                            })
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(qu), _t(hh, 8), _t(Za, 8))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                hre = 0,
                kF = (() => {
                    class t {
                        tplRef;
                        id = "owl-slide-" + hre++;
                        _dataMerge = 1;
                        set dataMerge(e) {
                            this._dataMerge = this.isNumeric(e) ? e : 1
                        }
                        get dataMerge() {
                            return this._dataMerge
                        }
                        width = 0;
                        dotContent = "";
                        dataHash = "";
                        constructor(e) {
                            this.tplRef = e
                        }
                        isNumeric(e) {
                            return !isNaN(parseFloat(e))
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(Hc))
                        };
                        static\ u0275dir = Un({
                            type: t,
                            selectors: [
                                ["ng-template", "carouselSlide", ""]
                            ],
                            inputs: {
                                id: "id",
                                dataMerge: "dataMerge",
                                width: "width",
                                dotContent: "dotContent",
                                dataHash: "dataHash"
                            }
                        })
                    }
                    return t
                })(),
                MF = (() => {
                    class t {
                        resizeObservable$;
                        get onResize$() {
                            return this.resizeObservable$
                        }
                        constructor(e, i) {
                            this.resizeObservable$ = gc(i) ? Sm(e, "resize") : (new A).asObservable()
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(PE), _t(Bs))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac
                        })
                    }
                    return t
                })(),
                fre = (() => {
                    class t {
                        zone;
                        el;
                        renderer;
                        carouselService;
                        animateService;
                        owlDraggable;
                        stageData;
                        slidesData;
                        listenerMouseMove;
                        listenerTouchMove;
                        listenerOneMouseMove;
                        listenerOneTouchMove;
                        listenerMouseUp;
                        listenerTouchEnd;
                        listenerOneClick;
                        listenerATag;
                        _drag = {
                            time: null,
                            target: null,
                            pointer: null,
                            stage: {
                                start: null,
                                current: null
                            },
                            direction: null,
                            active: !1,
                            moving: !1
                        };
                        _oneDragMove$ = new A;
                        _oneMoveSubsription;
                        preparePublicSlide = e => {
                            const i = { ...e
                            };
                            return delete i.tplRef, i
                        };
                        constructor(e, i, r, s, o) {
                            this.zone = e, this.el = i, this.renderer = r, this.carouselService = s, this.animateService = o
                        }
                        onMouseDown(e) {
                            this.owlDraggable.isMouseDragable && this._onDragStart(e)
                        }
                        onTouchStart(e) {
                            if (e.targetTouches.length >= 2) return !1;
                            this.owlDraggable.isTouchDragable && this._onDragStart(e)
                        }
                        onTouchCancel(e) {
                            this._onDragEnd(e)
                        }
                        onDragStart() {
                            if (this.owlDraggable.isMouseDragable) return !1
                        }
                        onSelectStart() {
                            if (this.owlDraggable.isMouseDragable) return !1
                        }
                        ngOnInit() {
                            this._oneMoveSubsription = this._oneDragMove$.pipe(nu()).subscribe(() => {
                                this._sendChanges()
                            })
                        }
                        ngOnDestroy() {
                            this._oneMoveSubsription.unsubscribe()
                        }
                        bindOneMouseTouchMove = e => {
                            this._oneMouseTouchMove(e)
                        };
                        bindOnDragMove = e => {
                            this._onDragMove(e)
                        };
                        bindOnDragEnd = e => {
                            this._onDragEnd(e)
                        };
                        _onDragStart(e) {
                            let i = null;
                            3 !== e.which && (i = this._prepareDragging(e), this._drag.time = (new Date).getTime(), this._drag.target = e.target, this._drag.stage.start = i, this._drag.stage.current = i, this._drag.pointer = this._pointer(e), this.listenerMouseUp = this.renderer.listen(document, "mouseup", this.bindOnDragEnd), this.listenerTouchEnd = this.renderer.listen(document, "touchend", this.bindOnDragEnd), this.zone.runOutsideAngular(() => {
                                this.listenerOneMouseMove = this.renderer.listen(document, "mousemove", this.bindOneMouseTouchMove), this.listenerOneTouchMove = this.renderer.listen(document, "touchmove", this.bindOneMouseTouchMove)
                            }))
                        }
                        _oneMouseTouchMove(e) {
                            const i = this._difference(this._drag.pointer, this._pointer(e));
                            this.listenerATag && this.listenerATag(), !(Math.abs(i.x) < 3 && Math.abs(i.y) < 3 && this._is("valid")) && (Math.abs(i.x) < 3 && Math.abs(i.x) < Math.abs(i.y) && this._is("valid") || (this.listenerOneMouseMove(), this.listenerOneTouchMove(), this._drag.moving = !0, this.blockClickAnchorInDragging(e), this.listenerMouseMove = this.renderer.listen(document, "mousemove", this.bindOnDragMove), this.listenerTouchMove = this.renderer.listen(document, "touchmove", this.bindOnDragMove), e.preventDefault(), this._enterDragging(), this._oneDragMove$.next(e)))
                        }
                        blockClickAnchorInDragging(e) {
                            let i = e.target;
                            for (; i && !(i instanceof HTMLAnchorElement);) i = i.parentElement;
                            i instanceof HTMLAnchorElement && (this.listenerATag = this.renderer.listen(i, "click", () => !1))
                        }
                        _onDragMove(e) {
                            let i;
                            const r = this.carouselService.defineNewCoordsDrag(e, this._drag);
                            !1 !== r && (i = r, e.preventDefault(), this._drag.stage.current = i, this._animate(i.x - this._drag.stage.start.x))
                        }
                        _animate(e) {
                            this.renderer.setStyle(this.el.nativeElement.children[0], "transform", `translate3d(${e}px,0px,0px`), this.renderer.setStyle(this.el.nativeElement.children[0], "transition", "0s")
                        }
                        _onDragEnd(e) {
                            this.carouselService.owlDOMData.isGrab = !1, this.listenerOneMouseMove(), this.listenerOneTouchMove(), this._drag.moving && (this.renderer.setStyle(this.el.nativeElement.children[0], "transform", ""), this.renderer.setStyle(this.el.nativeElement.children[0], "transition", this.carouselService.speed(+this.carouselService.settings.dragEndSpeed || this.carouselService.settings.smartSpeed) / 1e3 + "s"), this._finishDragging(e), this.listenerMouseMove(), this.listenerTouchMove()), this._drag = {
                                time: null,
                                target: null,
                                pointer: null,
                                stage: {
                                    start: null,
                                    current: null
                                },
                                direction: null,
                                active: !1,
                                moving: !1
                            }, this.listenerMouseUp(), this.listenerTouchEnd()
                        }
                        _prepareDragging(e) {
                            return this.carouselService.prepareDragging(e)
                        }
                        _oneClickHandler = () => {
                            this.listenerOneClick = this.renderer.listen(this._drag.target, "click", () => !1), this.listenerOneClick()
                        };
                        _finishDragging(e) {
                            this.carouselService.finishDragging(e, this._drag, this._oneClickHandler)
                        }
                        _pointer(e) {
                            return this.carouselService.pointer(e)
                        }
                        _difference(e, i) {
                            return this.carouselService.difference(e, i)
                        }
                        _is(e) {
                            return this.carouselService.is(e)
                        }
                        _enter(e) {
                            this.carouselService.enter(e)
                        }
                        _sendChanges() {
                            this.carouselService.sendChanges()
                        }
                        onTransitionEnd() {
                            this.carouselService.onTransitionEnd()
                        }
                        _enterDragging() {
                            this.carouselService.enterDragging()
                        }
                        clear(e) {
                            this.animateService.clear(e)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(cr), We(ir), We(Ks), We(qu), We(BE))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["owl-stage"]
                            ],
                            hostBindings: function(i, r) {
                                1 & i && xt("mousedown", function(o) {
                                    return r.onMouseDown(o)
                                })("touchstart", function(o) {
                                    return r.onTouchStart(o)
                                })("touchcancel", function(o) {
                                    return r.onTouchCancel(o)
                                })("dragstart", function() {
                                    return r.onDragStart()
                                })("selectstart", function() {
                                    return r.onSelectStart()
                                })
                            },
                            inputs: {
                                owlDraggable: "owlDraggable",
                                stageData: "stageData",
                                slidesData: "slidesData"
                            },
                            decls: 3,
                            vars: 8,
                            consts: [
                                [1, "owl-stage", 3, "ngStyle", "transitionend"],
                                [4, "ngFor", "ngForOf"],
                                [1, "owl-item", 3, "ngClass", "ngStyle", "animationend"],
                                [4, "ngIf"],
                                [3, "ngTemplateOutlet", "ngTemplateOutletContext"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "div")(1, "div", 0), xt("transitionend", function() {
                                    return r.onTransitionEnd()
                                }), tt(2, Yie, 3, 9, "ng-container", 1), ce()()), 2 & i && (he(1), Re("ngStyle", HT(2, Xie, r.stageData.width + "px", r.stageData.transform, r.stageData.transition, r.stageData.paddingL ? r.stageData.paddingL + "px" : "", r.stageData.paddingR ? r.stageData.paddingR + "px" : "")), he(1), Re("ngForOf", r.slidesData))
                            },
                            dependencies: [Jd, Ao, ts, MS, J5],
                            encapsulation: 2,
                            data: {
                                animation: [Lb("autoHeight", [SR("nulled", ko({
                                    height: 0
                                })), SR("full", ko({
                                    height: "*"
                                })), vm("full => nulled", [$u("700ms 350ms")]), vm("nulled => full", [$u(350)])])]
                            }
                        })
                    }
                    return t
                })(),
                pre = (() => {
                    class t {
                        el;
                        resizeService;
                        carouselService;
                        navigationService;
                        autoplayService;
                        lazyLoadService;
                        animateService;
                        autoHeightService;
                        hashService;
                        logger;
                        changeDetectorRef;
                        slides;
                        translated = new zt;
                        dragging = new zt;
                        change = new zt;
                        changed = new zt;
                        initialized = new zt;
                        carouselWindowWidth;
                        resizeSubscription;
                        _allObservSubscription;
                        _slidesChangesSubscription;
                        owlDOMData;
                        stageData;
                        slidesData = [];
                        navData;
                        dotsData;
                        slidesOutputData;
                        carouselLoaded = !1;
                        options;
                        prevOptions;
                        _viewCurSettings$;
                        _translatedCarousel$;
                        _draggingCarousel$;
                        _changeCarousel$;
                        _changedCarousel$;
                        _initializedCarousel$;
                        _carouselMerge$;
                        docRef;
                        constructor(e, i, r, s, o, a, c, u, h, m, x, D) {
                            this.el = e, this.resizeService = i, this.carouselService = r, this.navigationService = s, this.autoplayService = o, this.lazyLoadService = a, this.animateService = c, this.autoHeightService = u, this.hashService = h, this.logger = m, this.changeDetectorRef = x, this.docRef = D
                        }
                        onVisibilityChange(e) {
                            if (this.carouselService.settings.autoplay) switch (this.docRef.visibilityState) {
                                case "visible":
                                    !this.autoplayService.isAutoplayStopped && this.autoplayService.play();
                                    break;
                                case "hidden":
                                    this.autoplayService.pause()
                            }
                        }
                        ngOnInit() {
                            this.spyDataStreams(), this.carouselWindowWidth = this.el.nativeElement.querySelector(".owl-carousel").clientWidth
                        }
                        ngOnChanges() {
                            this.prevOptions !== this.options && (this.prevOptions && this.slides ? .toArray().length ? (this.carouselService.setup(this.carouselWindowWidth, this.slides.toArray(), this.options), this.carouselService.initialize(this.slides.toArray())) : this.prevOptions && !this.slides ? .toArray().length ? (this.carouselLoaded = !1, this.logger.log("There are no slides to show. So the carousel won't be re-rendered")) : this.carouselLoaded = !1, this.prevOptions = this.options)
                        }
                        ngAfterContentInit() {
                            this.slides.toArray().length ? (this.carouselService.setup(this.carouselWindowWidth, this.slides.toArray(), this.options), this.carouselService.initialize(this.slides.toArray()), this._winResizeWatcher()) : this.logger.log("There are no slides to show. So the carousel won't be rendered"), this._slidesChangesSubscription = this.slides.changes.pipe(Ui(e => {
                                this.carouselService.setup(this.carouselWindowWidth, e.toArray(), this.options), this.carouselService.initialize(e.toArray()), e.toArray().length || (this.carouselLoaded = !1), e.toArray().length && !this.resizeSubscription && this._winResizeWatcher()
                            })).subscribe(() => {})
                        }
                        ngOnDestroy() {
                            this.resizeSubscription && this.resizeSubscription.unsubscribe(), this._slidesChangesSubscription && this._slidesChangesSubscription.unsubscribe(), this._allObservSubscription && this._allObservSubscription.unsubscribe()
                        }
                        spyDataStreams() {
                            this._viewCurSettings$ = this.carouselService.getViewCurSettings().pipe(Ui(e => {
                                this.owlDOMData = e.owlDOMData, this.stageData = e.stageData, this.slidesData = e.slidesData, this.carouselLoaded || (this.carouselLoaded = !0), this.navData = e.navData, this.dotsData = e.dotsData, this.changeDetectorRef.markForCheck()
                            })), this._initializedCarousel$ = this.carouselService.getInitializedState().pipe(Ui(() => {
                                this.gatherTranslatedData(), this.initialized.emit(this.slidesOutputData)
                            })), this._translatedCarousel$ = this.carouselService.getTranslatedState().pipe(Ui(() => {
                                this.gatherTranslatedData(), this.translated.emit(this.slidesOutputData)
                            })), this._changeCarousel$ = this.carouselService.getChangeState().pipe(Ui(() => {
                                this.gatherTranslatedData(), this.change.emit(this.slidesOutputData)
                            })), this._changedCarousel$ = this.carouselService.getChangeState().pipe(St(e => Si(Ve(e).pipe(ia(() => "position" === e.property.name), St(() => gn(this.slidesData)), hN(e.property.value), Sa(this.carouselService.settings.items), Fe(r => {
                                const s = this.carouselService.clonedIdPrefix,
                                    o = r.id.indexOf(s) >= 0 ? r.id.slice(s.length) : r.id;
                                return { ...r,
                                    id: o,
                                    isActive: !0
                                }
                            }), function xte() {
                                return R((t, n) => {
                                    (function bte(t, n) {
                                        return R(fN(t, n, arguments.length >= 2, !1, !0))
                                    })(wte, [])(t).subscribe(n)
                                })
                            }(), Fe(r => ({
                                slides: r,
                                startPosition: this.carouselService.relative(e.property.value)
                            }))))), Ui(e => {
                                this.gatherTranslatedData(), this.changed.emit(e.slides.length ? e : this.slidesOutputData)
                            })), this._draggingCarousel$ = this.carouselService.getDragState().pipe(Ui(() => {
                                this.gatherTranslatedData(), this.dragging.emit({
                                    dragging: !0,
                                    data: this.slidesOutputData
                                })
                            }), St(() => this.carouselService.getDraggedState().pipe(Fe(() => !!this.carouselService.is("animating")))), St(e => e ? this.carouselService.getTranslatedState().pipe(nu()) : Ve("not animating")), Ui(() => {
                                this.dragging.emit({
                                    dragging: !1,
                                    data: this.slidesOutputData
                                })
                            })), this._carouselMerge$ = Si(this._viewCurSettings$, this._translatedCarousel$, this._draggingCarousel$, this._changeCarousel$, this._changedCarousel$, this._initializedCarousel$), this._allObservSubscription = this._carouselMerge$.subscribe(() => {})
                        }
                        _winResizeWatcher() {
                            Object.keys(this.carouselService._options.responsive).length && (this.resizeSubscription = this.resizeService.onResize$.pipe(ia(() => this.carouselWindowWidth !== this.el.nativeElement.querySelector(".owl-carousel").clientWidth), function Ete(t, n = Tw) {
                                const e = gN(t, n);
                                return mN(() => e)
                            }(this.carouselService.settings.responsiveRefreshRate)).subscribe(() => {
                                this.carouselService.onResize(this.el.nativeElement.querySelector(".owl-carousel").clientWidth), this.carouselWindowWidth = this.el.nativeElement.querySelector(".owl-carousel").clientWidth
                            }))
                        }
                        onTransitionEnd() {
                            this.carouselService.onTransitionEnd()
                        }
                        next() {
                            this.carouselLoaded && this.navigationService.next(this.carouselService.settings.navSpeed)
                        }
                        prev() {
                            this.carouselLoaded && this.navigationService.prev(this.carouselService.settings.navSpeed)
                        }
                        moveByDot(e) {
                            this.carouselLoaded && this.navigationService.moveByDot(e)
                        }
                        to(e) {
                            this.carouselLoaded && this.navigationService.toSlideById(e)
                        }
                        gatherTranslatedData() {
                            let e;
                            const i = this.carouselService.clonedIdPrefix,
                                r = this.slidesData.filter(s => !0 === s.isActive).map(s => ({
                                    id: s.id.indexOf(i) >= 0 ? s.id.slice(i.length) : s.id,
                                    width: s.width,
                                    marginL: s.marginL,
                                    marginR: s.marginR,
                                    center: s.isCentered
                                }));
                            e = this.carouselService.relative(this.carouselService.current()), this.slidesOutputData = {
                                startPosition: e,
                                slides: r
                            }
                        }
                        startPausing() {
                            this.autoplayService.startPausing()
                        }
                        startPlayML() {
                            this.autoplayService.startPlayingMouseLeave()
                        }
                        startPlayTE() {
                            this.autoplayService.startPlayingTouchEnd()
                        }
                        stopAutoplay() {
                            this.autoplayService.isAutoplayStopped = !0, this.autoplayService.stop()
                        }
                        startAutoplay() {
                            this.autoplayService.isAutoplayStopped = !1, this.autoplayService.play()
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(ir), We(MF), We(qu), We(TF), We(SF), We(EF), We(BE), We(DF), We(AF), We(IE), We(qa), We(LE))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["owl-carousel-o"]
                            ],
                            contentQueries: function(i, r, s) {
                                if (1 & i && ub(s, kF, 4), 2 & i) {
                                    let o;
                                    wa(o = xa()) && (r.slides = o)
                                }
                            },
                            hostBindings: function(i, r) {
                                1 & i && xt("visibilitychange", function(o) {
                                    return r.onVisibilityChange(o)
                                }, 0, FP)
                            },
                            inputs: {
                                options: "options"
                            },
                            outputs: {
                                translated: "translated",
                                dragging: "dragging",
                                change: "change",
                                changed: "changed",
                                initialized: "initialized"
                            },
                            features: [Jr([TF, SF, qu, EF, BE, DF, AF]), Xi],
                            decls: 4,
                            vars: 9,
                            consts: [
                                [1, "owl-carousel", "owl-theme", 3, "ngClass", "mouseover", "mouseleave", "touchstart", "touchend"],
                                ["owlCarousel", ""],
                                ["class", "owl-stage-outer", 4, "ngIf"],
                                [4, "ngIf"],
                                [1, "owl-stage-outer"],
                                [3, "owlDraggable", "stageData", "slidesData"],
                                [1, "owl-nav", 3, "ngClass"],
                                [1, "owl-prev", 3, "ngClass", "innerHTML", "click"],
                                [1, "owl-next", 3, "ngClass", "innerHTML", "click"],
                                [1, "owl-dots", 3, "ngClass"],
                                ["class", "owl-dot", 3, "ngClass", "click", 4, "ngFor", "ngForOf"],
                                [1, "owl-dot", 3, "ngClass", "click"],
                                [3, "innerHTML"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "div", 0, 1), xt("mouseover", function() {
                                    return r.startPausing()
                                })("mouseleave", function() {
                                    return r.startPlayML()
                                })("touchstart", function() {
                                    return r.startPausing()
                                })("touchend", function() {
                                    return r.startPlayTE()
                                }), tt(2, Jie, 2, 6, "div", 2), tt(3, nre, 6, 15, "ng-container", 3), ce()), 2 & i && (Re("ngClass", HT(3, ire, null == r.owlDOMData ? null : r.owlDOMData.rtl, null == r.owlDOMData ? null : r.owlDOMData.isLoaded, null == r.owlDOMData ? null : r.owlDOMData.isResponsive, null == r.owlDOMData ? null : r.owlDOMData.isMouseDragable, null == r.owlDOMData ? null : r.owlDOMData.isGrab)), he(2), Re("ngIf", r.carouselLoaded), he(1), Re("ngIf", r.slides.toArray().length))
                            },
                            dependencies: [Jd, Ao, ts, fre],
                            styles: [".owl-theme[_ngcontent-%COMP%]{display:block}"],
                            changeDetection: 0
                        })
                    }
                    return t
                })(),
                mre = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275mod = _i({
                            type: t
                        });
                        static\ u0275inj = wi({
                            providers: [cre, MF, dre, IE],
                            imports: [mc]
                        })
                    }
                    return t
                })();
            class NE {
                attach(n) {
                    return this._attachedHost = n, n.attach(this)
                }
                detach() {
                    let n = this._attachedHost;
                    null != n && (this._attachedHost = null, n.detach())
                }
                get isAttached() {
                    return null != this._attachedHost
                }
                setAttachedHost(n) {
                    this._attachedHost = n
                }
            }
            class IF extends NE {
                constructor(n, e, i, r, s) {
                    super(), this.component = n, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = r, this.projectableNodes = s
                }
            }
            class gre extends NE {
                constructor(n, e, i, r) {
                    super(), this.templateRef = n, this.viewContainerRef = e, this.context = i, this.injector = r
                }
                get origin() {
                    return this.templateRef.elementRef
                }
                attach(n, e = this.context) {
                    return this.context = e, super.attach(n)
                }
                detach() {
                    return this.context = void 0, super.detach()
                }
            }
            class yre extends NE {
                constructor(n) {
                    super(), this.element = n instanceof ir ? n.nativeElement : n
                }
            }
            class _re {
                constructor() {
                    this._isDisposed = !1, this.attachDomPortal = null
                }
                hasAttached() {
                    return !!this._attachedPortal
                }
                attach(n) {
                    return n instanceof IF ? (this._attachedPortal = n, this.attachComponentPortal(n)) : n instanceof gre ? (this._attachedPortal = n, this.attachTemplatePortal(n)) : this.attachDomPortal && n instanceof yre ? (this._attachedPortal = n, this.attachDomPortal(n)) : void 0
                }
                detach() {
                    this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn()
                }
                dispose() {
                    this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0
                }
                setDisposeFn(n) {
                    this._disposeFn = n
                }
                _invokeDisposeFn() {
                    this._disposeFn && (this._disposeFn(), this._disposeFn = null)
                }
            }
            class vre extends _re {
                constructor(n, e, i, r, s) {
                    super(), this.outletElement = n, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = r, this.attachDomPortal = o => {
                        const a = o.element,
                            c = this._document.createComment("dom-portal");
                        a.parentNode.insertBefore(c, a), this.outletElement.appendChild(a), this._attachedPortal = o, super.setDisposeFn(() => {
                            c.parentNode && c.parentNode.replaceChild(a, c)
                        })
                    }, this._document = s
                }
                attachComponentPortal(n) {
                    const i = (n.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(n.component);
                    let r;
                    return n.viewContainerRef ? (r = n.viewContainerRef.createComponent(i, n.viewContainerRef.length, n.injector || n.viewContainerRef.injector, n.projectableNodes || void 0), this.setDisposeFn(() => r.destroy())) : (r = i.create(n.injector || this._defaultInjector || Do.NULL), this._appRef.attachView(r.hostView), this.setDisposeFn(() => {
                        this._appRef.viewCount > 0 && this._appRef.detachView(r.hostView), r.destroy()
                    })), this.outletElement.appendChild(this._getComponentRootNode(r)), this._attachedPortal = n, r
                }
                attachTemplatePortal(n) {
                    let e = n.viewContainerRef,
                        i = e.createEmbeddedView(n.templateRef, n.context, {
                            injector: n.injector
                        });
                    return i.rootNodes.forEach(r => this.outletElement.appendChild(r)), i.detectChanges(), this.setDisposeFn(() => {
                        let r = e.indexOf(i); - 1 !== r && e.remove(r)
                    }), this._attachedPortal = n, i
                }
                dispose() {
                    super.dispose(), this.outletElement.remove()
                }
                _getComponentRootNode(n) {
                    return n.hostView.rootNodes[0]
                }
            }

            function FE(t, n = Tw) {
                return R((e, i) => {
                    let r = null,
                        s = null,
                        o = null;
                    const a = () => {
                        if (r) {
                            r.unsubscribe(), r = null;
                            const u = s;
                            s = null, i.next(u)
                        }
                    };

                    function c() {
                        const u = o + t,
                            h = n.now();
                        if (h < u) return r = this.schedule(void 0, u - h), void i.add(r);
                        a()
                    }
                    e.subscribe(Q(i, u => {
                        s = u, o = n.now(), r || (r = n.schedule(c, t), i.add(r))
                    }, () => {
                        a(), i.complete()
                    }, void 0, () => {
                        s = r = null
                    }))
                })
            }

            function bre() {}

            function VE(t) {
                return null == t ? bre : function() {
                    return this.querySelector(t)
                }
            }

            function Cre() {
                return []
            }

            function PF(t) {
                return null == t ? Cre : function() {
                    return this.querySelectorAll(t)
                }
            }

            function OF(t) {
                return function() {
                    return this.matches(t)
                }
            }

            function LF(t) {
                return function(n) {
                    return n.matches(t)
                }
            }
            var Ere = Array.prototype.find;

            function Are() {
                return this.firstElementChild
            }
            var Mre = Array.prototype.filter;

            function Ire() {
                return Array.from(this.children)
            }

            function RF(t) {
                return new Array(t.length)
            }

            function Ww(t, n) {
                this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = n
            }

            function Nre(t, n, e, i, r, s) {
                for (var a, o = 0, c = n.length, u = s.length; o < u; ++o)(a = n[o]) ? (a.__data__ = s[o], i[o] = a) : e[o] = new Ww(t, s[o]);
                for (; o < c; ++o)(a = n[o]) && (r[o] = a)
            }

            function Fre(t, n, e, i, r, s, o) {
                var a, c, D, u = new Map,
                    h = n.length,
                    m = s.length,
                    x = new Array(h);
                for (a = 0; a < h; ++a)(c = n[a]) && (x[a] = D = o.call(c, c.__data__, a, n) + "", u.has(D) ? r[a] = c : u.set(D, c));
                for (a = 0; a < m; ++a) D = o.call(t, s[a], a, s) + "", (c = u.get(D)) ? (i[a] = c, c.__data__ = s[a], u.delete(D)) : e[a] = new Ww(t, s[a]);
                for (a = 0; a < h; ++a)(c = n[a]) && u.get(x[a]) === c && (r[a] = c)
            }

            function Vre(t) {
                return t.__data__
            }

            function Hre(t) {
                return "object" == typeof t && "length" in t ? t : Array.from(t)
            }

            function Kre(t, n) {
                return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN
            }
            Ww.prototype = {
                constructor: Ww,
                appendChild: function(t) {
                    return this._parent.insertBefore(t, this._next)
                },
                insertBefore: function(t, n) {
                    return this._parent.insertBefore(t, n)
                },
                querySelector: function(t) {
                    return this._parent.querySelector(t)
                },
                querySelectorAll: function(t) {
                    return this._parent.querySelectorAll(t)
                }
            };
            var UE = "http://www.w3.org/1999/xhtml";
            const BF = {
                svg: "http://www.w3.org/2000/svg",
                xhtml: UE,
                xlink: "http://www.w3.org/1999/xlink",
                xml: "http://www.w3.org/XML/1998/namespace",
                xmlns: "http://www.w3.org/2000/xmlns/"
            };

            function Gw(t) {
                var n = t += "",
                    e = n.indexOf(":");
                return e >= 0 && "xmlns" !== (n = t.slice(0, e)) && (t = t.slice(e + 1)), BF.hasOwnProperty(n) ? {
                    space: BF[n],
                    local: t
                } : t
            }

            function ese(t) {
                return function() {
                    this.removeAttribute(t)
                }
            }

            function tse(t) {
                return function() {
                    this.removeAttributeNS(t.space, t.local)
                }
            }

            function nse(t, n) {
                return function() {
                    this.setAttribute(t, n)
                }
            }

            function ise(t, n) {
                return function() {
                    this.setAttributeNS(t.space, t.local, n)
                }
            }

            function rse(t, n) {
                return function() {
                    var e = n.apply(this, arguments);
                    null == e ? this.removeAttribute(t) : this.setAttribute(t, e)
                }
            }

            function sse(t, n) {
                return function() {
                    var e = n.apply(this, arguments);
                    null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e)
                }
            }

            function NF(t) {
                return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView
            }

            function ase(t) {
                return function() {
                    this.style.removeProperty(t)
                }
            }

            function cse(t, n, e) {
                return function() {
                    this.style.setProperty(t, n, e)
                }
            }

            function lse(t, n, e) {
                return function() {
                    var i = n.apply(this, arguments);
                    null == i ? this.style.removeProperty(t) : this.style.setProperty(t, i, e)
                }
            }

            function Nm(t, n) {
                return t.style.getPropertyValue(n) || NF(t).getComputedStyle(t, null).getPropertyValue(n)
            }

            function dse(t) {
                return function() {
                    delete this[t]
                }
            }

            function hse(t, n) {
                return function() {
                    this[t] = n
                }
            }

            function fse(t, n) {
                return function() {
                    var e = n.apply(this, arguments);
                    null == e ? delete this[t] : this[t] = e
                }
            }

            function FF(t) {
                return t.trim().split(/^|\s+/)
            }

            function HE(t) {
                return t.classList || new VF(t)
            }

            function VF(t) {
                this._node = t, this._names = FF(t.getAttribute("class") || "")
            }

            function UF(t, n) {
                for (var e = HE(t), i = -1, r = n.length; ++i < r;) e.add(n[i])
            }

            function HF(t, n) {
                for (var e = HE(t), i = -1, r = n.length; ++i < r;) e.remove(n[i])
            }

            function mse(t) {
                return function() {
                    UF(this, t)
                }
            }

            function gse(t) {
                return function() {
                    HF(this, t)
                }
            }

            function yse(t, n) {
                return function() {
                    (n.apply(this, arguments) ? UF : HF)(this, t)
                }
            }

            function vse() {
                this.textContent = ""
            }

            function bse(t) {
                return function() {
                    this.textContent = t
                }
            }

            function wse(t) {
                return function() {
                    var n = t.apply(this, arguments);
                    this.textContent = n ? ? ""
                }
            }

            function Cse() {
                this.innerHTML = ""
            }

            function Tse(t) {
                return function() {
                    this.innerHTML = t
                }
            }

            function Sse(t) {
                return function() {
                    var n = t.apply(this, arguments);
                    this.innerHTML = n ? ? ""
                }
            }

            function Dse() {
                this.nextSibling && this.parentNode.appendChild(this)
            }

            function kse() {
                this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
            }

            function Ise(t) {
                return function() {
                    var n = this.ownerDocument,
                        e = this.namespaceURI;
                    return e === UE && n.documentElement.namespaceURI === UE ? n.createElement(t) : n.createElementNS(e, t)
                }
            }

            function Pse(t) {
                return function() {
                    return this.ownerDocument.createElementNS(t.space, t.local)
                }
            }

            function $F(t) {
                var n = Gw(t);
                return (n.local ? Pse : Ise)(n)
            }

            function Lse() {
                return null
            }

            function Bse() {
                var t = this.parentNode;
                t && t.removeChild(this)
            }

            function Fse() {
                var t = this.cloneNode(!1),
                    n = this.parentNode;
                return n ? n.insertBefore(t, this.nextSibling) : t
            }

            function Vse() {
                var t = this.cloneNode(!0),
                    n = this.parentNode;
                return n ? n.insertBefore(t, this.nextSibling) : t
            }

            function jse(t) {
                return function() {
                    var n = this.__on;
                    if (n) {
                        for (var s, e = 0, i = -1, r = n.length; e < r; ++e) s = n[e], t.type && s.type !== t.type || s.name !== t.name ? n[++i] = s : this.removeEventListener(s.type, s.listener, s.options);
                        ++i ? n.length = i : delete this.__on
                    }
                }
            }

            function Wse(t, n, e) {
                return function() {
                    var r, i = this.__on,
                        s = function $se(t) {
                            return function(n) {
                                t.call(this, n, this.__data__)
                            }
                        }(n);
                    if (i)
                        for (var o = 0, a = i.length; o < a; ++o)
                            if ((r = i[o]).type === t.type && r.name === t.name) return this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = e), void(r.value = n);
                    this.addEventListener(t.type, s, e), r = {
                        type: t.type,
                        name: t.name,
                        value: n,
                        listener: s,
                        options: e
                    }, i ? i.push(r) : this.__on = [r]
                }
            }

            function zF(t, n, e) {
                var i = NF(t),
                    r = i.CustomEvent;
                "function" == typeof r ? r = new r(n, e) : (r = i.document.createEvent("Event"), e ? (r.initEvent(n, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(n, !1, !1)), t.dispatchEvent(r)
            }

            function Kse(t, n) {
                return function() {
                    return zF(this, t, n)
                }
            }

            function qse(t, n) {
                return function() {
                    return zF(this, t, n.apply(this, arguments))
                }
            }
            VF.prototype = {
                add: function(t) {
                    this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")))
                },
                remove: function(t) {
                    var n = this._names.indexOf(t);
                    n >= 0 && (this._names.splice(n, 1), this._node.setAttribute("class", this._names.join(" ")))
                },
                contains: function(t) {
                    return this._names.indexOf(t) >= 0
                }
            };
            var jF = [null];

            function wc(t, n) {
                this._groups = t, this._parents = n
            }

            function WF() {
                return new wc([
                    [document.documentElement]
                ], jF)
            }
            wc.prototype = WF.prototype = {
                constructor: wc,
                select: function wre(t) {
                    "function" != typeof t && (t = VE(t));
                    for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
                        for (var c, u, s = n[r], o = s.length, a = i[r] = new Array(o), h = 0; h < o; ++h)(c = s[h]) && (u = t.call(c, c.__data__, h, s)) && ("__data__" in c && (u.__data__ = c.__data__), a[h] = u);
                    return new wc(i, this._parents)
                },
                selectAll: function Sre(t) {
                    t = "function" == typeof t ? function Tre(t) {
                        return function() {
                            return function xre(t) {
                                return null == t ? [] : Array.isArray(t) ? t : Array.from(t)
                            }(t.apply(this, arguments))
                        }
                    }(t) : PF(t);
                    for (var n = this._groups, e = n.length, i = [], r = [], s = 0; s < e; ++s)
                        for (var c, o = n[s], a = o.length, u = 0; u < a; ++u)(c = o[u]) && (i.push(t.call(c, c.__data__, u, o)), r.push(c));
                    return new wc(i, r)
                },
                selectChild: function kre(t) {
                    return this.select(null == t ? Are : function Dre(t) {
                        return function() {
                            return Ere.call(this.children, t)
                        }
                    }("function" == typeof t ? t : LF(t)))
                },
                selectChildren: function Ore(t) {
                    return this.selectAll(null == t ? Ire : function Pre(t) {
                        return function() {
                            return Mre.call(this.children, t)
                        }
                    }("function" == typeof t ? t : LF(t)))
                },
                filter: function Lre(t) {
                    "function" != typeof t && (t = OF(t));
                    for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
                        for (var c, s = n[r], o = s.length, a = i[r] = [], u = 0; u < o; ++u)(c = s[u]) && t.call(c, c.__data__, u, s) && a.push(c);
                    return new wc(i, this._parents)
                },
                data: function Ure(t, n) {
                    if (!arguments.length) return Array.from(this, Vre);
                    var e = n ? Fre : Nre,
                        i = this._parents,
                        r = this._groups;
                    "function" != typeof t && (t = function Bre(t) {
                        return function() {
                            return t
                        }
                    }(t));
                    for (var s = r.length, o = new Array(s), a = new Array(s), c = new Array(s), u = 0; u < s; ++u) {
                        var h = i[u],
                            m = r[u],
                            x = m.length,
                            D = Hre(t.call(h, h && h.__data__, u, i)),
                            V = D.length,
                            te = a[u] = new Array(V),
                            ee = o[u] = new Array(V);
                        e(h, m, te, ee, c[u] = new Array(x), D, n);
                        for (var ze, Xe, ye = 0, Be = 0; ye < V; ++ye)
                            if (ze = te[ye]) {
                                for (ye >= Be && (Be = ye + 1); !(Xe = ee[Be]) && ++Be < V;);
                                ze._next = Xe || null
                            }
                    }
                    return (o = new wc(o, i))._enter = a, o._exit = c, o
                },
                enter: function Rre() {
                    return new wc(this._enter || this._groups.map(RF), this._parents)
                },
                exit: function $re() {
                    return new wc(this._exit || this._groups.map(RF), this._parents)
                },
                join: function zre(t, n, e) {
                    var i = this.enter(),
                        r = this,
                        s = this.exit();
                    return "function" == typeof t ? (i = t(i)) && (i = i.selection()) : i = i.append(t + ""), null != n && (r = n(r)) && (r = r.selection()), null == e ? s.remove() : e(s), i && r ? i.merge(r).order() : r
                },
                merge: function jre(t) {
                    for (var n = t.selection ? t.selection() : t, e = this._groups, i = n._groups, r = e.length, o = Math.min(r, i.length), a = new Array(r), c = 0; c < o; ++c)
                        for (var D, u = e[c], h = i[c], m = u.length, x = a[c] = new Array(m), V = 0; V < m; ++V)(D = u[V] || h[V]) && (x[V] = D);
                    for (; c < r; ++c) a[c] = e[c];
                    return new wc(a, this._parents)
                },
                selection: function Xse() {
                    return this
                },
                order: function Wre() {
                    for (var t = this._groups, n = -1, e = t.length; ++n < e;)
                        for (var o, i = t[n], r = i.length - 1, s = i[r]; --r >= 0;)(o = i[r]) && (s && 4 ^ o.compareDocumentPosition(s) && s.parentNode.insertBefore(o, s), s = o);
                    return this
                },
                sort: function Gre(t) {
                    function n(m, x) {
                        return m && x ? t(m.__data__, x.__data__) : !m - !x
                    }
                    t || (t = Kre);
                    for (var e = this._groups, i = e.length, r = new Array(i), s = 0; s < i; ++s) {
                        for (var u, o = e[s], a = o.length, c = r[s] = new Array(a), h = 0; h < a; ++h)(u = o[h]) && (c[h] = u);
                        c.sort(n)
                    }
                    return new wc(r, this._parents).order()
                },
                call: function qre() {
                    var t = arguments[0];
                    return arguments[0] = this, t.apply(null, arguments), this
                },
                nodes: function Zre() {
                    return Array.from(this)
                },
                node: function Yre() {
                    for (var t = this._groups, n = 0, e = t.length; n < e; ++n)
                        for (var i = t[n], r = 0, s = i.length; r < s; ++r) {
                            var o = i[r];
                            if (o) return o
                        }
                    return null
                },
                size: function Xre() {
                    let t = 0;
                    for (const n of this) ++t;
                    return t
                },
                empty: function Qre() {
                    return !this.node()
                },
                each: function Jre(t) {
                    for (var n = this._groups, e = 0, i = n.length; e < i; ++e)
                        for (var a, r = n[e], s = 0, o = r.length; s < o; ++s)(a = r[s]) && t.call(a, a.__data__, s, r);
                    return this
                },
                attr: function ose(t, n) {
                    var e = Gw(t);
                    if (arguments.length < 2) {
                        var i = this.node();
                        return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e)
                    }
                    return this.each((null == n ? e.local ? tse : ese : "function" == typeof n ? e.local ? sse : rse : e.local ? ise : nse)(e, n))
                },
                style: function use(t, n, e) {
                    return arguments.length > 1 ? this.each((null == n ? ase : "function" == typeof n ? lse : cse)(t, n, e ? ? "")) : Nm(this.node(), t)
                },
                property: function pse(t, n) {
                    return arguments.length > 1 ? this.each((null == n ? dse : "function" == typeof n ? fse : hse)(t, n)) : this.node()[t]
                },
                classed: function _se(t, n) {
                    var e = FF(t + "");
                    if (arguments.length < 2) {
                        for (var i = HE(this.node()), r = -1, s = e.length; ++r < s;)
                            if (!i.contains(e[r])) return !1;
                        return !0
                    }
                    return this.each(("function" == typeof n ? yse : n ? mse : gse)(e, n))
                },
                text: function xse(t) {
                    return arguments.length ? this.each(null == t ? vse : ("function" == typeof t ? wse : bse)(t)) : this.node().textContent
                },
                html: function Ese(t) {
                    return arguments.length ? this.each(null == t ? Cse : ("function" == typeof t ? Sse : Tse)(t)) : this.node().innerHTML
                },
                raise: function Ase() {
                    return this.each(Dse)
                },
                lower: function Mse() {
                    return this.each(kse)
                },
                append: function Ose(t) {
                    var n = "function" == typeof t ? t : $F(t);
                    return this.select(function() {
                        return this.appendChild(n.apply(this, arguments))
                    })
                },
                insert: function Rse(t, n) {
                    var e = "function" == typeof t ? t : $F(t),
                        i = null == n ? Lse : "function" == typeof n ? n : VE(n);
                    return this.select(function() {
                        return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null)
                    })
                },
                remove: function Nse() {
                    return this.each(Bse)
                },
                clone: function Use(t) {
                    return this.select(t ? Vse : Fse)
                },
                datum: function Hse(t) {
                    return arguments.length ? this.property("__data__", t) : this.node().__data__
                },
                on: function Gse(t, n, e) {
                    var r, o, i = function zse(t) {
                            return t.trim().split(/^|\s+/).map(function(n) {
                                var e = "",
                                    i = n.indexOf(".");
                                return i >= 0 && (e = n.slice(i + 1), n = n.slice(0, i)), {
                                    type: n,
                                    name: e
                                }
                            })
                        }(t + ""),
                        s = i.length;
                    if (!(arguments.length < 2)) {
                        for (a = n ? Wse : jse, r = 0; r < s; ++r) this.each(a(i[r], n, e));
                        return this
                    }
                    var a = this.node().__on;
                    if (a)
                        for (var h, c = 0, u = a.length; c < u; ++c)
                            for (r = 0, h = a[c]; r < s; ++r)
                                if ((o = i[r]).type === h.type && o.name === h.name) return h.value
                },
                dispatch: function Zse(t, n) {
                    return this.each(("function" == typeof n ? qse : Kse)(t, n))
                },
                [Symbol.iterator]: function* Yse() {
                    for (var t = this._groups, n = 0, e = t.length; n < e; ++n)
                        for (var o, i = t[n], r = 0, s = i.length; r < s; ++r)(o = i[r]) && (yield o)
                }
            };
            const b0 = WF;
            var Qse = {
                value: () => {}
            };

            function GF() {
                for (var i, t = 0, n = arguments.length, e = {}; t < n; ++t) {
                    if (!(i = arguments[t] + "") || i in e || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
                    e[i] = []
                }
                return new Kw(e)
            }

            function Kw(t) {
                this._ = t
            }

            function eoe(t, n) {
                for (var r, e = 0, i = t.length; e < i; ++e)
                    if ((r = t[e]).name === n) return r.value
            }

            function KF(t, n, e) {
                for (var i = 0, r = t.length; i < r; ++i)
                    if (t[i].name === n) {
                        t[i] = Qse, t = t.slice(0, i).concat(t.slice(i + 1));
                        break
                    }
                return null != e && t.push({
                    name: n,
                    value: e
                }), t
            }
            Kw.prototype = GF.prototype = {
                constructor: Kw,
                on: function(t, n) {
                    var r, e = this._,
                        i = function Jse(t, n) {
                            return t.trim().split(/^|\s+/).map(function(e) {
                                var i = "",
                                    r = e.indexOf(".");
                                if (r >= 0 && (i = e.slice(r + 1), e = e.slice(0, r)), e && !n.hasOwnProperty(e)) throw new Error("unknown type: " + e);
                                return {
                                    type: e,
                                    name: i
                                }
                            })
                        }(t + "", e),
                        s = -1,
                        o = i.length;
                    if (!(arguments.length < 2)) {
                        if (null != n && "function" != typeof n) throw new Error("invalid callback: " + n);
                        for (; ++s < o;)
                            if (r = (t = i[s]).type) e[r] = KF(e[r], t.name, n);
                            else if (null == n)
                            for (r in e) e[r] = KF(e[r], t.name, null);
                        return this
                    }
                    for (; ++s < o;)
                        if ((r = (t = i[s]).type) && (r = eoe(e[r], t.name))) return r
                },
                copy: function() {
                    var t = {},
                        n = this._;
                    for (var e in n) t[e] = n[e].slice();
                    return new Kw(t)
                },
                call: function(t, n) {
                    if ((r = arguments.length - 2) > 0)
                        for (var r, s, e = new Array(r), i = 0; i < r; ++i) e[i] = arguments[i + 2];
                    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
                    for (i = 0, r = (s = this._[t]).length; i < r; ++i) s[i].value.apply(n, e)
                },
                apply: function(t, n, e) {
                    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
                    for (var i = this._[t], r = 0, s = i.length; r < s; ++r) i[r].value.apply(n, e)
                }
            };
            const qF = GF;

            function jE(t, n, e) {
                t.prototype = n.prototype = e, e.constructor = t
            }

            function ZF(t, n) {
                var e = Object.create(t.prototype);
                for (var i in n) e[i] = n[i];
                return e
            }

            function w0() {}
            var qw = 1 / .7,
                Fm = "\\s*([+-]?\\d+)\\s*",
                C0 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
                su = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
                ioe = /^#([0-9a-f]{3,8})$/,
                roe = new RegExp(`^rgb\\(${Fm},${Fm},${Fm}\\)$`),
                soe = new RegExp(`^rgb\\(${su},${su},${su}\\)$`),
                ooe = new RegExp(`^rgba\\(${Fm},${Fm},${Fm},${C0}\\)$`),
                aoe = new RegExp(`^rgba\\(${su},${su},${su},${C0}\\)$`),
                coe = new RegExp(`^hsl\\(${C0},${su},${su}\\)$`),
                loe = new RegExp(`^hsla\\(${C0},${su},${su},${C0}\\)$`),
                YF = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };

            function XF() {
                return this.rgb().formatHex()
            }

            function QF() {
                return this.rgb().formatRgb()
            }

            function Nf(t) {
                var n, e;
                return t = (t + "").trim().toLowerCase(), (n = ioe.exec(t)) ? (e = n[1].length, n = parseInt(n[1], 16), 6 === e ? JF(n) : 3 === e ? new Ya(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1) : 8 === e ? Zw(n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, (255 & n) / 255) : 4 === e ? Zw(n >> 12 & 15 | n >> 8 & 240, n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, ((15 & n) << 4 | 15 & n) / 255) : null) : (n = roe.exec(t)) ? new Ya(n[1], n[2], n[3], 1) : (n = soe.exec(t)) ? new Ya(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = ooe.exec(t)) ? Zw(n[1], n[2], n[3], n[4]) : (n = aoe.exec(t)) ? Zw(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = coe.exec(t)) ? n4(n[1], n[2] / 100, n[3] / 100, 1) : (n = loe.exec(t)) ? n4(n[1], n[2] / 100, n[3] / 100, n[4]) : YF.hasOwnProperty(t) ? JF(YF[t]) : "transparent" === t ? new Ya(NaN, NaN, NaN, 0) : null
            }

            function JF(t) {
                return new Ya(t >> 16 & 255, t >> 8 & 255, 255 & t, 1)
            }

            function Zw(t, n, e, i) {
                return i <= 0 && (t = n = e = NaN), new Ya(t, n, e, i)
            }

            function Yw(t, n, e, i) {
                return 1 === arguments.length ? function hoe(t) {
                    return t instanceof w0 || (t = Nf(t)), t ? new Ya((t = t.rgb()).r, t.g, t.b, t.opacity) : new Ya
                }(t) : new Ya(t, n, e, i ? ? 1)
            }

            function Ya(t, n, e, i) {
                this.r = +t, this.g = +n, this.b = +e, this.opacity = +i
            }

            function e4() {
                return `#${Vf(this.r)}${Vf(this.g)}${Vf(this.b)}`
            }

            function t4() {
                const t = Xw(this.opacity);
                return `${1===t?"rgb(":"rgba("}${Ff(this.r)}, ${Ff(this.g)}, ${Ff(this.b)}${1===t?")":`, ${t})`}`
            }

            function Xw(t) {
                return isNaN(t) ? 1 : Math.max(0, Math.min(1, t))
            }

            function Ff(t) {
                return Math.max(0, Math.min(255, Math.round(t) || 0))
            }

            function Vf(t) {
                return ((t = Ff(t)) < 16 ? "0" : "") + t.toString(16)
            }

            function n4(t, n, e, i) {
                return i <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new Cl(t, n, e, i)
            }

            function i4(t) {
                if (t instanceof Cl) return new Cl(t.h, t.s, t.l, t.opacity);
                if (t instanceof w0 || (t = Nf(t)), !t) return new Cl;
                if (t instanceof Cl) return t;
                var n = (t = t.rgb()).r / 255,
                    e = t.g / 255,
                    i = t.b / 255,
                    r = Math.min(n, e, i),
                    s = Math.max(n, e, i),
                    o = NaN,
                    a = s - r,
                    c = (s + r) / 2;
                return a ? (o = n === s ? (e - i) / a + 6 * (e < i) : e === s ? (i - n) / a + 2 : (n - e) / a + 4, a /= c < .5 ? s + r : 2 - s - r, o *= 60) : a = c > 0 && c < 1 ? 0 : o, new Cl(o, a, c, t.opacity)
            }

            function Cl(t, n, e, i) {
                this.h = +t, this.s = +n, this.l = +e, this.opacity = +i
            }

            function r4(t) {
                return (t = (t || 0) % 360) < 0 ? t + 360 : t
            }

            function Qw(t) {
                return Math.max(0, Math.min(1, t || 0))
            }

            function WE(t, n, e) {
                return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n)
            }

            function s4(t, n, e, i, r) {
                var s = t * t,
                    o = s * t;
                return ((1 - 3 * t + 3 * s - o) * n + (4 - 6 * s + 3 * o) * e + (1 + 3 * t + 3 * s - 3 * o) * i + o * r) / 6
            }
            jE(w0, Nf, {
                copy(t) {
                    return Object.assign(new this.constructor, this, t)
                },
                displayable() {
                    return this.rgb().displayable()
                },
                hex: XF,
                formatHex: XF,
                formatHex8: function uoe() {
                    return this.rgb().formatHex8()
                },
                formatHsl: function doe() {
                    return i4(this).formatHsl()
                },
                formatRgb: QF,
                toString: QF
            }), jE(Ya, Yw, ZF(w0, {
                brighter(t) {
                    return t = null == t ? qw : Math.pow(qw, t), new Ya(this.r * t, this.g * t, this.b * t, this.opacity)
                },
                darker(t) {
                    return t = null == t ? .7 : Math.pow(.7, t), new Ya(this.r * t, this.g * t, this.b * t, this.opacity)
                },
                rgb() {
                    return this
                },
                clamp() {
                    return new Ya(Ff(this.r), Ff(this.g), Ff(this.b), Xw(this.opacity))
                },
                displayable() {
                    return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
                },
                hex: e4,
                formatHex: e4,
                formatHex8: function foe() {
                    return `#${Vf(this.r)}${Vf(this.g)}${Vf(this.b)}${Vf(255*(isNaN(this.opacity)?1:this.opacity))}`
                },
                formatRgb: t4,
                toString: t4
            })), jE(Cl, function poe(t, n, e, i) {
                return 1 === arguments.length ? i4(t) : new Cl(t, n, e, i ? ? 1)
            }, ZF(w0, {
                brighter(t) {
                    return t = null == t ? qw : Math.pow(qw, t), new Cl(this.h, this.s, this.l * t, this.opacity)
                },
                darker(t) {
                    return t = null == t ? .7 : Math.pow(.7, t), new Cl(this.h, this.s, this.l * t, this.opacity)
                },
                rgb() {
                    var t = this.h % 360 + 360 * (this.h < 0),
                        n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
                        e = this.l,
                        i = e + (e < .5 ? e : 1 - e) * n,
                        r = 2 * e - i;
                    return new Ya(WE(t >= 240 ? t - 240 : t + 120, r, i), WE(t, r, i), WE(t < 120 ? t + 240 : t - 120, r, i), this.opacity)
                },
                clamp() {
                    return new Cl(r4(this.h), Qw(this.s), Qw(this.l), Xw(this.opacity))
                },
                displayable() {
                    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
                },
                formatHsl() {
                    const t = Xw(this.opacity);
                    return `${1===t?"hsl(":"hsla("}${r4(this.h)}, ${100*Qw(this.s)}%, ${100*Qw(this.l)}%${1===t?")":`, ${t})`}`
                }
            }));
            const GE = t => () => t;

            function a4(t, n) {
                var e = n - t;
                return e ? function o4(t, n) {
                    return function(e) {
                        return t + e * n
                    }
                }(t, e) : GE(isNaN(t) ? n : t)
            }
            const Jw = function t(n) {
                var e = function _oe(t) {
                    return 1 == (t = +t) ? a4 : function(n, e) {
                        return e - n ? function yoe(t, n, e) {
                            return t = Math.pow(t, e), n = Math.pow(n, e) - t, e = 1 / e,
                                function(i) {
                                    return Math.pow(t + i * n, e)
                                }
                        }(n, e, t) : GE(isNaN(n) ? e : n)
                    }
                }(n);

                function i(r, s) {
                    var o = e((r = Yw(r)).r, (s = Yw(s)).r),
                        a = e(r.g, s.g),
                        c = e(r.b, s.b),
                        u = a4(r.opacity, s.opacity);
                    return function(h) {
                        return r.r = o(h), r.g = a(h), r.b = c(h), r.opacity = u(h), r + ""
                    }
                }
                return i.gamma = t, i
            }(1);

            function c4(t) {
                return function(n) {
                    var o, a, e = n.length,
                        i = new Array(e),
                        r = new Array(e),
                        s = new Array(e);
                    for (o = 0; o < e; ++o) a = Yw(n[o]), i[o] = a.r || 0, r[o] = a.g || 0, s[o] = a.b || 0;
                    return i = t(i), r = t(r), s = t(s), a.opacity = 1,
                        function(c) {
                            return a.r = i(c), a.g = r(c), a.b = s(c), a + ""
                        }
                }
            }

            function l4(t, n) {
                var o, e = n ? n.length : 0,
                    i = t ? Math.min(e, t.length) : 0,
                    r = new Array(i),
                    s = new Array(e);
                for (o = 0; o < i; ++o) r[o] = ex(t[o], n[o]);
                for (; o < e; ++o) s[o] = n[o];
                return function(a) {
                    for (o = 0; o < i; ++o) s[o] = r[o](a);
                    return s
                }
            }

            function voe(t, n) {
                var e = new Date;
                return t = +t, n = +n,
                    function(i) {
                        return e.setTime(t * (1 - i) + n * i), e
                    }
            }

            function Tl(t, n) {
                return t = +t, n = +n,
                    function(e) {
                        return t * (1 - e) + n * e
                    }
            }

            function boe(t, n) {
                var r, e = {},
                    i = {};
                for (r in (null === t || "object" != typeof t) && (t = {}), (null === n || "object" != typeof n) && (n = {}), n) r in t ? e[r] = ex(t[r], n[r]) : i[r] = n[r];
                return function(s) {
                    for (r in e) i[r] = e[r](s);
                    return i
                }
            }
            c4(function moe(t) {
                var n = t.length - 1;
                return function(e) {
                    var i = e <= 0 ? e = 0 : e >= 1 ? (e = 1, n - 1) : Math.floor(e * n),
                        r = t[i],
                        s = t[i + 1];
                    return s4((e - i / n) * n, i > 0 ? t[i - 1] : 2 * r - s, r, s, i < n - 1 ? t[i + 2] : 2 * s - r)
                }
            }), c4(function goe(t) {
                var n = t.length;
                return function(e) {
                    var i = Math.floor(((e %= 1) < 0 ? ++e : e) * n);
                    return s4((e - i / n) * n, t[(i + n - 1) % n], t[i % n], t[(i + 1) % n], t[(i + 2) % n])
                }
            });
            var KE = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
                qE = new RegExp(KE.source, "g");

            function u4(t, n) {
                var i, r, s, e = KE.lastIndex = qE.lastIndex = 0,
                    o = -1,
                    a = [],
                    c = [];
                for (t += "", n += "";
                    (i = KE.exec(t)) && (r = qE.exec(n));)(s = r.index) > e && (s = n.slice(e, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({
                    i: o,
                    x: Tl(i, r)
                })), e = qE.lastIndex;
                return e < n.length && (s = n.slice(e), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? c[0] ? function xoe(t) {
                    return function(n) {
                        return t(n) + ""
                    }
                }(c[0].x) : function woe(t) {
                    return function() {
                        return t
                    }
                }(n) : (n = c.length, function(u) {
                    for (var m, h = 0; h < n; ++h) a[(m = c[h]).i] = m.x(u);
                    return a.join("")
                })
            }

            function Coe(t, n) {
                n || (n = []);
                var r, e = t ? Math.min(n.length, t.length) : 0,
                    i = n.slice();
                return function(s) {
                    for (r = 0; r < e; ++r) i[r] = t[r] * (1 - s) + n[r] * s;
                    return i
                }
            }

            function ex(t, n) {
                var i, e = typeof n;
                return null == n || "boolean" === e ? GE(n) : ("number" === e ? Tl : "string" === e ? (i = Nf(n)) ? (n = i, Jw) : u4 : n instanceof Nf ? Jw : n instanceof Date ? voe : function Toe(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                }(n) ? Coe : Array.isArray(n) ? l4 : "function" != typeof n.valueOf && "function" != typeof n.toString || isNaN(n) ? boe : Tl)(t, n)
            }
            var tx, E0, Vm = 0,
                T0 = 0,
                S0 = 0,
                h4 = 1e3,
                nx = 0,
                Uf = 0,
                ix = 0,
                D0 = "object" == typeof performance && performance.now ? performance : Date,
                f4 = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
                    setTimeout(t, 17)
                };

            function ZE() {
                return Uf || (f4(Eoe), Uf = D0.now() + ix)
            }

            function Eoe() {
                Uf = 0
            }

            function rx() {
                this._call = this._time = this._next = null
            }

            function p4(t, n, e) {
                var i = new rx;
                return i.restart(t, n, e), i
            }

            function m4() {
                Uf = (nx = D0.now()) + ix, Vm = T0 = 0;
                try {
                    ! function Doe() {
                        ZE(), ++Vm;
                        for (var n, t = tx; t;)(n = Uf - t._time) >= 0 && t._call.call(void 0, n), t = t._next;
                        --Vm
                    }()
                } finally {
                    Vm = 0,
                        function koe() {
                            for (var t, e, n = tx, i = 1 / 0; n;) n._call ? (i > n._time && (i = n._time), t = n, n = n._next) : (e = n._next, n._next = null, n = t ? t._next = e : tx = e);
                            E0 = t, YE(i)
                        }(), Uf = 0
                }
            }

            function Aoe() {
                var t = D0.now(),
                    n = t - nx;
                n > h4 && (ix -= n, nx = t)
            }

            function YE(t) {
                Vm || (T0 && (T0 = clearTimeout(T0)), t - Uf > 24 ? (t < 1 / 0 && (T0 = setTimeout(m4, t - D0.now() - ix)), S0 && (S0 = clearInterval(S0))) : (S0 || (nx = D0.now(), S0 = setInterval(Aoe, h4)), Vm = 1, f4(m4)))
            }

            function g4(t, n, e) {
                var i = new rx;
                return i.restart(r => {
                    i.stop(), t(r + n)
                }, n = null == n ? 0 : +n, e), i
            }
            rx.prototype = p4.prototype = {
                constructor: rx,
                restart: function(t, n, e) {
                    if ("function" != typeof t) throw new TypeError("callback is not a function");
                    e = (null == e ? ZE() : +e) + (null == n ? 0 : +n), !this._next && E0 !== this && (E0 ? E0._next = this : tx = this, E0 = this), this._call = t, this._time = e, YE()
                },
                stop: function() {
                    this._call && (this._call = null, this._time = 1 / 0, YE())
                }
            };
            var Moe = qF("start", "end", "cancel", "interrupt"),
                Ioe = [],
                y4 = 0,
                sx = 3;

            function ax(t, n, e, i, r, s) {
                var o = t.__transition;
                if (o) {
                    if (e in o) return
                } else t.__transition = {};
                ! function Poe(t, n, e) {
                    var r, i = t.__transition;

                    function o(u) {
                        var h, m, x, D;
                        if (1 !== e.state) return c();
                        for (h in i)
                            if ((D = i[h]).name === e.name) {
                                if (D.state === sx) return g4(o);
                                4 === D.state ? (D.state = 6, D.timer.stop(), D.on.call("interrupt", t, t.__data__, D.index, D.group), delete i[h]) : +h < n && (D.state = 6, D.timer.stop(), D.on.call("cancel", t, t.__data__, D.index, D.group), delete i[h])
                            }
                        if (g4(function() {
                                e.state === sx && (e.state = 4, e.timer.restart(a, e.delay, e.time), a(u))
                            }), e.state = 2, e.on.call("start", t, t.__data__, e.index, e.group), 2 === e.state) {
                            for (e.state = sx, r = new Array(x = e.tween.length), h = 0, m = -1; h < x; ++h)(D = e.tween[h].value.call(t, t.__data__, e.index, e.group)) && (r[++m] = D);
                            r.length = m + 1
                        }
                    }

                    function a(u) {
                        for (var h = u < e.duration ? e.ease.call(null, u / e.duration) : (e.timer.restart(c), e.state = 5, 1), m = -1, x = r.length; ++m < x;) r[m].call(t, h);
                        5 === e.state && (e.on.call("end", t, t.__data__, e.index, e.group), c())
                    }

                    function c() {
                        for (var u in e.state = 6, e.timer.stop(), delete i[n], i) return;
                        delete t.__transition
                    }
                    i[n] = e, e.timer = p4(function s(u) {
                        e.state = 1, e.timer.restart(o, e.delay, e.time), e.delay <= u && o(u - e.delay)
                    }, 0, e.time)
                }(t, e, {
                    name: n,
                    index: i,
                    group: r,
                    on: Moe,
                    tween: Ioe,
                    time: s.time,
                    delay: s.delay,
                    duration: s.duration,
                    ease: s.ease,
                    timer: null,
                    state: y4
                })
            }

            function JE(t, n) {
                var e = Sl(t, n);
                if (e.state > y4) throw new Error("too late; already scheduled");
                return e
            }

            function ou(t, n) {
                var e = Sl(t, n);
                if (e.state > sx) throw new Error("too late; already running");
                return e
            }

            function Sl(t, n) {
                var e = t.__transition;
                if (!e || !(e = e[n])) throw new Error("transition not found");
                return e
            }
            var cx, b4 = 180 / Math.PI,
                tD = {
                    translateX: 0,
                    translateY: 0,
                    rotate: 0,
                    skewX: 0,
                    scaleX: 1,
                    scaleY: 1
                };

            function w4(t, n, e, i, r, s) {
                var o, a, c;
                return (o = Math.sqrt(t * t + n * n)) && (t /= o, n /= o), (c = t * e + n * i) && (e -= t * c, i -= n * c), (a = Math.sqrt(e * e + i * i)) && (e /= a, i /= a, c /= a), t * i < n * e && (t = -t, n = -n, c = -c, o = -o), {
                    translateX: r,
                    translateY: s,
                    rotate: Math.atan2(n, t) * b4,
                    skewX: Math.atan(c) * b4,
                    scaleX: o,
                    scaleY: a
                }
            }

            function x4(t, n, e, i) {
                function r(u) {
                    return u.length ? u.pop() + " " : ""
                }
                return function(u, h) {
                    var m = [],
                        x = [];
                    return u = t(u), h = t(h),
                        function s(u, h, m, x, D, V) {
                            if (u !== m || h !== x) {
                                var te = D.push("translate(", null, n, null, e);
                                V.push({
                                    i: te - 4,
                                    x: Tl(u, m)
                                }, {
                                    i: te - 2,
                                    x: Tl(h, x)
                                })
                            } else(m || x) && D.push("translate(" + m + n + x + e)
                        }(u.translateX, u.translateY, h.translateX, h.translateY, m, x),
                        function o(u, h, m, x) {
                            u !== h ? (u - h > 180 ? h += 360 : h - u > 180 && (u += 360), x.push({
                                i: m.push(r(m) + "rotate(", null, i) - 2,
                                x: Tl(u, h)
                            })) : h && m.push(r(m) + "rotate(" + h + i)
                        }(u.rotate, h.rotate, m, x),
                        function a(u, h, m, x) {
                            u !== h ? x.push({
                                i: m.push(r(m) + "skewX(", null, i) - 2,
                                x: Tl(u, h)
                            }) : h && m.push(r(m) + "skewX(" + h + i)
                        }(u.skewX, h.skewX, m, x),
                        function c(u, h, m, x, D, V) {
                            if (u !== m || h !== x) {
                                var te = D.push(r(D) + "scale(", null, ",", null, ")");
                                V.push({
                                    i: te - 4,
                                    x: Tl(u, m)
                                }, {
                                    i: te - 2,
                                    x: Tl(h, x)
                                })
                            } else(1 !== m || 1 !== x) && D.push(r(D) + "scale(" + m + "," + x + ")")
                        }(u.scaleX, u.scaleY, h.scaleX, h.scaleY, m, x), u = h = null,
                        function(D) {
                            for (var ee, V = -1, te = x.length; ++V < te;) m[(ee = x[V]).i] = ee.x(D);
                            return m.join("")
                        }
                }
            }
            var Boe = x4(function Loe(t) {
                    const n = new("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(t + "");
                    return n.isIdentity ? tD : w4(n.a, n.b, n.c, n.d, n.e, n.f)
                }, "px, ", "px)", "deg)"),
                Noe = x4(function Roe(t) {
                    return null != t && (cx || (cx = document.createElementNS("http://www.w3.org/2000/svg", "g")), cx.setAttribute("transform", t), t = cx.transform.baseVal.consolidate()) ? w4((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : tD
                }, ", ", ")", ")");

            function Foe(t, n) {
                var e, i;
                return function() {
                    var r = ou(this, t),
                        s = r.tween;
                    if (s !== e)
                        for (var o = 0, a = (i = e = s).length; o < a; ++o)
                            if (i[o].name === n) {
                                (i = i.slice()).splice(o, 1);
                                break
                            }
                    r.tween = i
                }
            }

            function Voe(t, n, e) {
                var i, r;
                if ("function" != typeof e) throw new Error;
                return function() {
                    var s = ou(this, t),
                        o = s.tween;
                    if (o !== i) {
                        r = (i = o).slice();
                        for (var a = {
                                name: n,
                                value: e
                            }, c = 0, u = r.length; c < u; ++c)
                            if (r[c].name === n) {
                                r[c] = a;
                                break
                            }
                        c === u && r.push(a)
                    }
                    s.tween = r
                }
            }

            function nD(t, n, e) {
                var i = t._id;
                return t.each(function() {
                        var r = ou(this, i);
                        (r.value || (r.value = {}))[n] = e.apply(this, arguments)
                    }),
                    function(r) {
                        return Sl(r, i).value[n]
                    }
            }

            function C4(t, n) {
                var e;
                return ("number" == typeof n ? Tl : n instanceof Nf ? Jw : (e = Nf(n)) ? (n = e, Jw) : u4)(t, n)
            }

            function Hoe(t) {
                return function() {
                    this.removeAttribute(t)
                }
            }

            function $oe(t) {
                return function() {
                    this.removeAttributeNS(t.space, t.local)
                }
            }

            function zoe(t, n, e) {
                var i, s, r = e + "";
                return function() {
                    var o = this.getAttribute(t);
                    return o === r ? null : o === i ? s : s = n(i = o, e)
                }
            }

            function joe(t, n, e) {
                var i, s, r = e + "";
                return function() {
                    var o = this.getAttributeNS(t.space, t.local);
                    return o === r ? null : o === i ? s : s = n(i = o, e)
                }
            }

            function Woe(t, n, e) {
                var i, r, s;
                return function() {
                    var o, c, a = e(this);
                    return null == a ? void this.removeAttribute(t) : (o = this.getAttribute(t)) === (c = a + "") ? null : o === i && c === r ? s : (r = c, s = n(i = o, a))
                }
            }

            function Goe(t, n, e) {
                var i, r, s;
                return function() {
                    var o, c, a = e(this);
                    return null == a ? void this.removeAttributeNS(t.space, t.local) : (o = this.getAttributeNS(t.space, t.local)) === (c = a + "") ? null : o === i && c === r ? s : (r = c, s = n(i = o, a))
                }
            }

            function Yoe(t, n) {
                var e, i;

                function r() {
                    var s = n.apply(this, arguments);
                    return s !== i && (e = (i = s) && function Zoe(t, n) {
                        return function(e) {
                            this.setAttributeNS(t.space, t.local, n.call(this, e))
                        }
                    }(t, s)), e
                }
                return r._value = n, r
            }

            function Xoe(t, n) {
                var e, i;

                function r() {
                    var s = n.apply(this, arguments);
                    return s !== i && (e = (i = s) && function qoe(t, n) {
                        return function(e) {
                            this.setAttribute(t, n.call(this, e))
                        }
                    }(t, s)), e
                }
                return r._value = n, r
            }

            function Joe(t, n) {
                return function() {
                    JE(this, t).delay = +n.apply(this, arguments)
                }
            }

            function eae(t, n) {
                return n = +n,
                    function() {
                        JE(this, t).delay = n
                    }
            }

            function nae(t, n) {
                return function() {
                    ou(this, t).duration = +n.apply(this, arguments)
                }
            }

            function iae(t, n) {
                return n = +n,
                    function() {
                        ou(this, t).duration = n
                    }
            }
            var _ae = b0.prototype.constructor;

            function T4(t) {
                return function() {
                    this.style.removeProperty(t)
                }
            }
            var Bae = 0;

            function Zu(t, n, e, i) {
                this._groups = t, this._parents = n, this._name = e, this._id = i
            }

            function S4() {
                return ++Bae
            }
            var Yu = b0.prototype;
            Zu.prototype = function Nae(t) {
                return b0().transition(t)
            }.prototype = {
                constructor: Zu,
                select: function gae(t) {
                    var n = this._name,
                        e = this._id;
                    "function" != typeof t && (t = VE(t));
                    for (var i = this._groups, r = i.length, s = new Array(r), o = 0; o < r; ++o)
                        for (var h, m, a = i[o], c = a.length, u = s[o] = new Array(c), x = 0; x < c; ++x)(h = a[x]) && (m = t.call(h, h.__data__, x, a)) && ("__data__" in h && (m.__data__ = h.__data__), u[x] = m, ax(u[x], n, e, x, u, Sl(h, e)));
                    return new Zu(s, this._parents, n, e)
                },
                selectAll: function yae(t) {
                    var n = this._name,
                        e = this._id;
                    "function" != typeof t && (t = PF(t));
                    for (var i = this._groups, r = i.length, s = [], o = [], a = 0; a < r; ++a)
                        for (var h, c = i[a], u = c.length, m = 0; m < u; ++m)
                            if (h = c[m]) {
                                for (var D, x = t.call(h, h.__data__, m, c), V = Sl(h, e), te = 0, ee = x.length; te < ee; ++te)(D = x[te]) && ax(D, n, e, te, x, V);
                                s.push(x), o.push(h)
                            }
                    return new Zu(s, o, n, e)
                },
                selectChild: Yu.selectChild,
                selectChildren: Yu.selectChildren,
                filter: function lae(t) {
                    "function" != typeof t && (t = OF(t));
                    for (var n = this._groups, e = n.length, i = new Array(e), r = 0; r < e; ++r)
                        for (var c, s = n[r], o = s.length, a = i[r] = [], u = 0; u < o; ++u)(c = s[u]) && t.call(c, c.__data__, u, s) && a.push(c);
                    return new Zu(i, this._parents, this._name, this._id)
                },
                merge: function uae(t) {
                    if (t._id !== this._id) throw new Error;
                    for (var n = this._groups, e = t._groups, i = n.length, s = Math.min(i, e.length), o = new Array(i), a = 0; a < s; ++a)
                        for (var x, c = n[a], u = e[a], h = c.length, m = o[a] = new Array(h), D = 0; D < h; ++D)(x = c[D] || u[D]) && (m[D] = x);
                    for (; a < i; ++a) o[a] = n[a];
                    return new Zu(o, this._parents, this._name, this._id)
                },
                selection: function vae() {
                    return new _ae(this._groups, this._parents)
                },
                transition: function Lae() {
                    for (var t = this._name, n = this._id, e = S4(), i = this._groups, r = i.length, s = 0; s < r; ++s)
                        for (var c, o = i[s], a = o.length, u = 0; u < a; ++u)
                            if (c = o[u]) {
                                var h = Sl(c, n);
                                ax(c, t, e, u, o, {
                                    time: h.time + h.delay + h.duration,
                                    delay: 0,
                                    duration: h.duration,
                                    ease: h.ease
                                })
                            }
                    return new Zu(i, this._parents, t, e)
                },
                call: Yu.call,
                nodes: Yu.nodes,
                node: Yu.node,
                size: Yu.size,
                empty: Yu.empty,
                each: Yu.each,
                on: function fae(t, n) {
                    var e = this._id;
                    return arguments.length < 2 ? Sl(this.node(), e).on.on(t) : this.each(function hae(t, n, e) {
                        var i, r, s = function dae(t) {
                            return (t + "").trim().split(/^|\s+/).every(function(n) {
                                var e = n.indexOf(".");
                                return e >= 0 && (n = n.slice(0, e)), !n || "start" === n
                            })
                        }(n) ? JE : ou;
                        return function() {
                            var o = s(this, t),
                                a = o.on;
                            a !== i && (r = (i = a).copy()).on(n, e), o.on = r
                        }
                    }(e, t, n))
                },
                attr: function Koe(t, n) {
                    var e = Gw(t),
                        i = "transform" === e ? Noe : C4;
                    return this.attrTween(t, "function" == typeof n ? (e.local ? Goe : Woe)(e, i, nD(this, "attr." + t, n)) : null == n ? (e.local ? $oe : Hoe)(e) : (e.local ? joe : zoe)(e, i, n))
                },
                attrTween: function Qoe(t, n) {
                    var e = "attr." + t;
                    if (arguments.length < 2) return (e = this.tween(e)) && e._value;
                    if (null == n) return this.tween(e, null);
                    if ("function" != typeof n) throw new Error;
                    var i = Gw(t);
                    return this.tween(e, (i.local ? Yoe : Xoe)(i, n))
                },
                style: function Tae(t, n, e) {
                    var i = "transform" == (t += "") ? Boe : C4;
                    return null == n ? this.styleTween(t, function bae(t, n) {
                        var e, i, r;
                        return function() {
                            var s = Nm(this, t),
                                o = (this.style.removeProperty(t), Nm(this, t));
                            return s === o ? null : s === e && o === i ? r : r = n(e = s, i = o)
                        }
                    }(t, i)).on("end.style." + t, T4(t)) : "function" == typeof n ? this.styleTween(t, function xae(t, n, e) {
                        var i, r, s;
                        return function() {
                            var o = Nm(this, t),
                                a = e(this),
                                c = a + "";
                            return null == a && (this.style.removeProperty(t), c = a = Nm(this, t)), o === c ? null : o === i && c === r ? s : (r = c, s = n(i = o, a))
                        }
                    }(t, i, nD(this, "style." + t, n))).each(function Cae(t, n) {
                        var e, i, r, a, s = "style." + n,
                            o = "end." + s;
                        return function() {
                            var c = ou(this, t),
                                u = c.on,
                                h = null == c.value[s] ? a || (a = T4(n)) : void 0;
                            (u !== e || r !== h) && (i = (e = u).copy()).on(o, r = h), c.on = i
                        }
                    }(this._id, t)) : this.styleTween(t, function wae(t, n, e) {
                        var i, s, r = e + "";
                        return function() {
                            var o = Nm(this, t);
                            return o === r ? null : o === i ? s : s = n(i = o, e)
                        }
                    }(t, i, n), e).on("end.style." + t, null)
                },
                styleTween: function Dae(t, n, e) {
                    var i = "style." + (t += "");
                    if (arguments.length < 2) return (i = this.tween(i)) && i._value;
                    if (null == n) return this.tween(i, null);
                    if ("function" != typeof n) throw new Error;
                    return this.tween(i, function Eae(t, n, e) {
                        var i, r;

                        function s() {
                            var o = n.apply(this, arguments);
                            return o !== r && (i = (r = o) && function Sae(t, n, e) {
                                return function(i) {
                                    this.style.setProperty(t, n.call(this, i), e)
                                }
                            }(t, o, e)), i
                        }
                        return s._value = n, s
                    }(t, n, e ? ? ""))
                },
                text: function Mae(t) {
                    return this.tween("text", "function" == typeof t ? function kae(t) {
                        return function() {
                            var n = t(this);
                            this.textContent = n ? ? ""
                        }
                    }(nD(this, "text", t)) : function Aae(t) {
                        return function() {
                            this.textContent = t
                        }
                    }(null == t ? "" : t + ""))
                },
                textTween: function Oae(t) {
                    var n = "text";
                    if (arguments.length < 1) return (n = this.tween(n)) && n._value;
                    if (null == t) return this.tween(n, null);
                    if ("function" != typeof t) throw new Error;
                    return this.tween(n, function Pae(t) {
                        var n, e;

                        function i() {
                            var r = t.apply(this, arguments);
                            return r !== e && (n = (e = r) && function Iae(t) {
                                return function(n) {
                                    this.textContent = t.call(this, n)
                                }
                            }(r)), n
                        }
                        return i._value = t, i
                    }(t))
                },
                remove: function mae() {
                    return this.on("end.remove", function pae(t) {
                        return function() {
                            var n = this.parentNode;
                            for (var e in this.__transition)
                                if (+e !== t) return;
                            n && n.removeChild(this)
                        }
                    }(this._id))
                },
                tween: function Uoe(t, n) {
                    var e = this._id;
                    if (t += "", arguments.length < 2) {
                        for (var o, i = Sl(this.node(), e).tween, r = 0, s = i.length; r < s; ++r)
                            if ((o = i[r]).name === t) return o.value;
                        return null
                    }
                    return this.each((null == n ? Foe : Voe)(e, t, n))
                },
                delay: function tae(t) {
                    var n = this._id;
                    return arguments.length ? this.each(("function" == typeof t ? Joe : eae)(n, t)) : Sl(this.node(), n).delay
                },
                duration: function rae(t) {
                    var n = this._id;
                    return arguments.length ? this.each(("function" == typeof t ? nae : iae)(n, t)) : Sl(this.node(), n).duration
                },
                ease: function oae(t) {
                    var n = this._id;
                    return arguments.length ? this.each(function sae(t, n) {
                        if ("function" != typeof n) throw new Error;
                        return function() {
                            ou(this, t).ease = n
                        }
                    }(n, t)) : Sl(this.node(), n).ease
                },
                easeVarying: function cae(t) {
                    if ("function" != typeof t) throw new Error;
                    return this.each(function aae(t, n) {
                        return function() {
                            var e = n.apply(this, arguments);
                            if ("function" != typeof e) throw new Error;
                            ou(this, t).ease = e
                        }
                    }(this._id, t))
                },
                end: function Rae() {
                    var t, n, e = this,
                        i = e._id,
                        r = e.size();
                    return new Promise(function(s, o) {
                        var a = {
                                value: o
                            },
                            c = {
                                value: function() {
                                    0 == --r && s()
                                }
                            };
                        e.each(function() {
                            var u = ou(this, i),
                                h = u.on;
                            h !== t && ((n = (t = h).copy())._.cancel.push(a), n._.interrupt.push(a), n._.end.push(c)), u.on = n
                        }), 0 === r && s()
                    })
                },
                [Symbol.iterator]: Yu[Symbol.iterator]
            };
            var Vae = {
                time: null,
                delay: 0,
                duration: 250,
                ease: function Fae(t) {
                    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2
                }
            };

            function Uae(t, n) {
                for (var e; !(e = t.__transition) || !(e = e[n]);)
                    if (!(t = t.parentNode)) throw new Error(`transition ${n} not found`);
                return e
            }
            b0.prototype.interrupt = function Ooe(t) {
                return this.each(function() {
                    ! function eD(t, n) {
                        var i, r, o, e = t.__transition,
                            s = !0;
                        if (e) {
                            for (o in n = null == n ? null : n + "", e)(i = e[o]).name === n ? (r = i.state > 2 && i.state < 5, i.state = 6, i.timer.stop(), i.on.call(r ? "interrupt" : "cancel", t, t.__data__, i.index, i.group), delete e[o]) : s = !1;
                            s && delete t.__transition
                        }
                    }(this, t)
                })
            }, b0.prototype.transition = function Hae(t) {
                var n, e;
                t instanceof Zu ? (n = t._id, t = t._name) : (n = S4(), (e = Vae).time = ZE(), t = null == t ? null : t + "");
                for (var i = this._groups, r = i.length, s = 0; s < r; ++s)
                    for (var c, o = i[s], a = o.length, u = 0; u < a; ++u)(c = o[u]) && ax(c, t, n, u, o, e || Uae(c, n));
                return new Zu(i, this._parents, t, n)
            };
            Math;

            function A0(t) {
                return {
                    type: t
                }
            }

            function k0(t, n) {
                return null == t || null == n ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN
            }

            function Qae(t, n) {
                return null == t || null == n ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN
            }

            function lD(t) {
                let n, e, i;

                function r(a, c, u = 0, h = a.length) {
                    if (u < h) {
                        if (0 !== n(c, c)) return h;
                        do {
                            const m = u + h >>> 1;
                            e(a[m], c) < 0 ? u = m + 1 : h = m
                        } while (u < h)
                    }
                    return u
                }
                return 2 !== t.length ? (n = k0, e = (a, c) => k0(t(a), c), i = (a, c) => t(a) - c) : (n = t === k0 || t === Qae ? t : Jae, e = t, i = t), {
                    left: r,
                    center: function o(a, c, u = 0, h = a.length) {
                        const m = r(a, c, u, h - 1);
                        return m > u && i(a[m - 1], c) > -i(a[m], c) ? m - 1 : m
                    },
                    right: function s(a, c, u = 0, h = a.length) {
                        if (u < h) {
                            if (0 !== n(c, c)) return h;
                            do {
                                const m = u + h >>> 1;
                                e(a[m], c) <= 0 ? u = m + 1 : h = m
                            } while (u < h)
                        }
                        return u
                    }
                }
            }

            function Jae() {
                return 0
            }["w", "e"].map(A0), ["n", "s"].map(A0), ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(A0);
            const ece = Math.sqrt(50),
                tce = Math.sqrt(10),
                nce = Math.sqrt(2);

            function dx(t, n, e) {
                const i = (n - t) / Math.max(0, e),
                    r = Math.floor(Math.log10(i)),
                    s = i / Math.pow(10, r),
                    o = s >= ece ? 10 : s >= tce ? 5 : s >= nce ? 2 : 1;
                let a, c, u;
                return r < 0 ? (u = Math.pow(10, -r) / o, a = Math.round(t * u), c = Math.round(n * u), a / u < t && ++a, c / u > n && --c, u = -u) : (u = Math.pow(10, r) * o, a = Math.round(t / u), c = Math.round(n / u), a * u < t && ++a, c * u > n && --c), c < a && .5 <= e && e < 2 ? dx(t, n, 2 * e) : [a, c, u]
            }

            function uD(t, n, e) {
                return dx(t = +t, n = +n, e = +e)[2]
            }

            function dD(t, n, e) {
                e = +e;
                const i = (n = +n) < (t = +t),
                    r = i ? uD(n, t, e) : uD(t, n, e);
                return (i ? -1 : 1) * (r < 0 ? 1 / -r : r)
            }
            const Qu = 1e3,
                Kc = 6e4,
                Ju = 60 * Kc,
                ed = 24 * Ju,
                hD = 7 * ed,
                I4 = 30 * ed,
                fD = 365 * ed,
                pD = new Date,
                mD = new Date;

            function yo(t, n, e, i) {
                function r(s) {
                    return t(s = 0 === arguments.length ? new Date : new Date(+s)), s
                }
                return r.floor = s => (t(s = new Date(+s)), s), r.ceil = s => (t(s = new Date(s - 1)), n(s, 1), t(s), s), r.round = s => {
                    const o = r(s),
                        a = r.ceil(s);
                    return s - o < a - s ? o : a
                }, r.offset = (s, o) => (n(s = new Date(+s), null == o ? 1 : Math.floor(o)), s), r.range = (s, o, a) => {
                    const c = [];
                    if (s = r.ceil(s), a = null == a ? 1 : Math.floor(a), !(s < o && a > 0)) return c;
                    let u;
                    do {
                        c.push(u = new Date(+s)), n(s, a), t(s)
                    } while (u < s && s < o);
                    return c
                }, r.filter = s => yo(o => {
                    if (o >= o)
                        for (; t(o), !s(o);) o.setTime(o - 1)
                }, (o, a) => {
                    if (o >= o)
                        if (a < 0)
                            for (; ++a <= 0;)
                                for (; n(o, -1), !s(o););
                        else
                            for (; --a >= 0;)
                                for (; n(o, 1), !s(o););
                }), e && (r.count = (s, o) => (pD.setTime(+s), mD.setTime(+o), t(pD), t(mD), Math.floor(e(pD, mD))), r.every = s => (s = Math.floor(s), isFinite(s) && s > 0 ? s > 1 ? r.filter(i ? o => i(o) % s == 0 : o => r.count(0, o) % s == 0) : r : null)), r
            }
            const hx = yo(() => {}, (t, n) => {
                t.setTime(+t + n)
            }, (t, n) => n - t);
            hx.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? yo(n => {
                n.setTime(Math.floor(n / t) * t)
            }, (n, e) => {
                n.setTime(+n + e * t)
            }, (n, e) => (e - n) / t) : hx : null);
            const $m = yo(t => {
                    t.setTime(t - t.getMilliseconds())
                }, (t, n) => {
                    t.setTime(+t + n * Qu)
                }, (t, n) => (n - t) / Qu, t => t.getUTCSeconds()),
                gD = yo(t => {
                    t.setTime(t - t.getMilliseconds() - t.getSeconds() * Qu)
                }, (t, n) => {
                    t.setTime(+t + n * Kc)
                }, (t, n) => (n - t) / Kc, t => t.getMinutes()),
                P4 = yo(t => {
                    t.setUTCSeconds(0, 0)
                }, (t, n) => {
                    t.setTime(+t + n * Kc)
                }, (t, n) => (n - t) / Kc, t => t.getUTCMinutes()),
                yD = yo(t => {
                    t.setTime(t - t.getMilliseconds() - t.getSeconds() * Qu - t.getMinutes() * Kc)
                }, (t, n) => {
                    t.setTime(+t + n * Ju)
                }, (t, n) => (n - t) / Ju, t => t.getHours()),
                O4 = yo(t => {
                    t.setUTCMinutes(0, 0, 0)
                }, (t, n) => {
                    t.setTime(+t + n * Ju)
                }, (t, n) => (n - t) / Ju, t => t.getUTCHours()),
                _D = yo(t => t.setHours(0, 0, 0, 0), (t, n) => t.setDate(t.getDate() + n), (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Kc) / ed, t => t.getDate() - 1),
                L4 = (yo(t => {
                    t.setUTCHours(0, 0, 0, 0)
                }, (t, n) => {
                    t.setUTCDate(t.getUTCDate() + n)
                }, (t, n) => (n - t) / ed, t => t.getUTCDate() - 1), yo(t => {
                    t.setUTCHours(0, 0, 0, 0)
                }, (t, n) => {
                    t.setUTCDate(t.getUTCDate() + n)
                }, (t, n) => (n - t) / ed, t => Math.floor(t / ed)));

            function Hf(t) {
                return yo(n => {
                    n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0)
                }, (n, e) => {
                    n.setDate(n.getDate() + 7 * e)
                }, (n, e) => (e - n - (e.getTimezoneOffset() - n.getTimezoneOffset()) * Kc) / hD)
            }
            const vD = Hf(0);

            function $f(t) {
                return yo(n => {
                    n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0)
                }, (n, e) => {
                    n.setUTCDate(n.getUTCDate() + 7 * e)
                }, (n, e) => (e - n) / hD)
            }
            Hf(1), Hf(2), Hf(3), Hf(4), Hf(5), Hf(6);
            const R4 = $f(0),
                bD = ($f(1), $f(2), $f(3), $f(4), $f(5), $f(6), yo(t => {
                    t.setDate(1), t.setHours(0, 0, 0, 0)
                }, (t, n) => {
                    t.setMonth(t.getMonth() + n)
                }, (t, n) => n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear()), t => t.getMonth())),
                B4 = yo(t => {
                    t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0)
                }, (t, n) => {
                    t.setUTCMonth(t.getUTCMonth() + n)
                }, (t, n) => n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear()), t => t.getUTCMonth()),
                fx = yo(t => {
                    t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
                }, (t, n) => {
                    t.setFullYear(t.getFullYear() + n)
                }, (t, n) => n.getFullYear() - t.getFullYear(), t => t.getFullYear());
            fx.every = t => isFinite(t = Math.floor(t)) && t > 0 ? yo(n => {
                n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0)
            }, (n, e) => {
                n.setFullYear(n.getFullYear() + e * t)
            }) : null;
            const wD = yo(t => {
                t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
            }, (t, n) => {
                t.setUTCFullYear(t.getUTCFullYear() + n)
            }, (t, n) => n.getUTCFullYear() - t.getUTCFullYear(), t => t.getUTCFullYear());

            function N4(t, n, e, i, r, s) {
                const o = [
                    [$m, 1, Qu],
                    [$m, 5, 5e3],
                    [$m, 15, 15e3],
                    [$m, 30, 3e4],
                    [s, 1, Kc],
                    [s, 5, 5 * Kc],
                    [s, 15, 15 * Kc],
                    [s, 30, 30 * Kc],
                    [r, 1, Ju],
                    [r, 3, 3 * Ju],
                    [r, 6, 6 * Ju],
                    [r, 12, 12 * Ju],
                    [i, 1, ed],
                    [i, 2, 2 * ed],
                    [e, 1, hD],
                    [n, 1, I4],
                    [n, 3, 3 * I4],
                    [t, 1, fD]
                ];

                function c(u, h, m) {
                    const x = Math.abs(h - u) / m,
                        D = lD(([, , ee]) => ee).right(o, x);
                    if (D === o.length) return t.every(dD(u / fD, h / fD, m));
                    if (0 === D) return hx.every(Math.max(dD(u, h, m), 1));
                    const [V, te] = o[x / o[D - 1][2] < o[D][2] / x ? D - 1 : D];
                    return V.every(te)
                }
                return [function a(u, h, m) {
                    const x = h < u;
                    x && ([u, h] = [h, u]);
                    const D = m && "function" == typeof m.range ? m : c(u, h, m),
                        V = D ? D.range(u, +h + 1) : [];
                    return x ? V.reverse() : V
                }, c]
            }
            wD.every = t => isFinite(t = Math.floor(t)) && t > 0 ? yo(n => {
                n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0)
            }, (n, e) => {
                n.setUTCFullYear(n.getUTCFullYear() + e * t)
            }) : null;
            const [MAe, IAe] = N4(wD, B4, R4, L4, O4, P4), [gce, yce] = N4(fx, bD, vD, _D, yD, gD);
            var xD = new Date,
                CD = new Date;

            function td(t, n, e, i) {
                function r(s) {
                    return t(s = 0 === arguments.length ? new Date : new Date(+s)), s
                }
                return r.floor = function(s) {
                    return t(s = new Date(+s)), s
                }, r.ceil = function(s) {
                    return t(s = new Date(s - 1)), n(s, 1), t(s), s
                }, r.round = function(s) {
                    var o = r(s),
                        a = r.ceil(s);
                    return s - o < a - s ? o : a
                }, r.offset = function(s, o) {
                    return n(s = new Date(+s), null == o ? 1 : Math.floor(o)), s
                }, r.range = function(s, o, a) {
                    var u, c = [];
                    if (s = r.ceil(s), a = null == a ? 1 : Math.floor(a), !(s < o && a > 0)) return c;
                    do {
                        c.push(u = new Date(+s)), n(s, a), t(s)
                    } while (u < s && s < o);
                    return c
                }, r.filter = function(s) {
                    return td(function(o) {
                        if (o >= o)
                            for (; t(o), !s(o);) o.setTime(o - 1)
                    }, function(o, a) {
                        if (o >= o)
                            if (a < 0)
                                for (; ++a <= 0;)
                                    for (; n(o, -1), !s(o););
                            else
                                for (; --a >= 0;)
                                    for (; n(o, 1), !s(o););
                    })
                }, e && (r.count = function(s, o) {
                    return xD.setTime(+s), CD.setTime(+o), t(xD), t(CD), Math.floor(e(xD, CD))
                }, r.every = function(s) {
                    return s = Math.floor(s), isFinite(s) && s > 0 ? s > 1 ? r.filter(i ? function(o) {
                        return i(o) % s == 0
                    } : function(o) {
                        return r.count(0, o) % s == 0
                    }) : r : null
                }), r
            }
            const M0 = 864e5,
                F4 = 7 * M0;

            function zf(t) {
                return td(function(n) {
                    n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0)
                }, function(n, e) {
                    n.setUTCDate(n.getUTCDate() + 7 * e)
                }, function(n, e) {
                    return (e - n) / F4
                })
            }
            var V4 = zf(0),
                px = zf(1),
                zm = (zf(2), zf(3), zf(4)),
                U4 = (zf(5), zf(6), td(function(t) {
                    t.setUTCHours(0, 0, 0, 0)
                }, function(t, n) {
                    t.setUTCDate(t.getUTCDate() + n)
                }, function(t, n) {
                    return (n - t) / M0
                }, function(t) {
                    return t.getUTCDate() - 1
                }));
            const H4 = U4;

            function jf(t) {
                return td(function(n) {
                    n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0)
                }, function(n, e) {
                    n.setDate(n.getDate() + 7 * e)
                }, function(n, e) {
                    return (e - n - 6e4 * (e.getTimezoneOffset() - n.getTimezoneOffset())) / F4
                })
            }
            var $4 = jf(0),
                mx = jf(1),
                jm = (jf(2), jf(3), jf(4)),
                z4 = (jf(5), jf(6), td(t => t.setHours(0, 0, 0, 0), (t, n) => t.setDate(t.getDate() + n), (t, n) => (n - t - 6e4 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / M0, t => t.getDate() - 1));
            const j4 = z4;
            var SD = td(function(t) {
                t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
            }, function(t, n) {
                t.setFullYear(t.getFullYear() + n)
            }, function(t, n) {
                return n.getFullYear() - t.getFullYear()
            }, function(t) {
                return t.getFullYear()
            });
            SD.every = function(t) {
                return isFinite(t = Math.floor(t)) && t > 0 ? td(function(n) {
                    n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0)
                }, function(n, e) {
                    n.setFullYear(n.getFullYear() + e * t)
                }) : null
            };
            const I0 = SD;
            var ED = td(function(t) {
                t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
            }, function(t, n) {
                t.setUTCFullYear(t.getUTCFullYear() + n)
            }, function(t, n) {
                return n.getUTCFullYear() - t.getUTCFullYear()
            }, function(t) {
                return t.getUTCFullYear()
            });
            ED.every = function(t) {
                return isFinite(t = Math.floor(t)) && t > 0 ? td(function(n) {
                    n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0)
                }, function(n, e) {
                    n.setUTCFullYear(n.getUTCFullYear() + e * t)
                }) : null
            };
            const P0 = ED;

            function DD(t) {
                if (0 <= t.y && t.y < 100) {
                    var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
                    return n.setFullYear(t.y), n
                }
                return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L)
            }

            function AD(t) {
                if (0 <= t.y && t.y < 100) {
                    var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
                    return n.setUTCFullYear(t.y), n
                }
                return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L))
            }

            function O0(t, n, e) {
                return {
                    y: t,
                    m: n,
                    d: e,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0
                }
            }
            var W4 = {
                    "-": "",
                    _: " ",
                    0: "0"
                },
                Mo = /^\s*\d+/,
                Dce = /^%/,
                Ace = /[\\^$*+?|[\]().{}]/g;

            function Ar(t, n, e) {
                var i = t < 0 ? "-" : "",
                    r = (i ? -t : t) + "",
                    s = r.length;
                return i + (s < e ? new Array(e - s + 1).join(n) + r : r)
            }

            function kce(t) {
                return t.replace(Ace, "\\$&")
            }

            function L0(t) {
                return new RegExp("^(?:" + t.map(kce).join("|") + ")", "i")
            }

            function R0(t) {
                return new Map(t.map((n, e) => [n.toLowerCase(), e]))
            }

            function Mce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 1));
                return i ? (t.w = +i[0], e + i[0].length) : -1
            }

            function Ice(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 1));
                return i ? (t.u = +i[0], e + i[0].length) : -1
            }

            function Pce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.U = +i[0], e + i[0].length) : -1
            }

            function Oce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.V = +i[0], e + i[0].length) : -1
            }

            function Lce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.W = +i[0], e + i[0].length) : -1
            }

            function G4(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 4));
                return i ? (t.y = +i[0], e + i[0].length) : -1
            }

            function K4(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), e + i[0].length) : -1
            }

            function Rce(t, n, e) {
                var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6));
                return i ? (t.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), e + i[0].length) : -1
            }

            function Bce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 1));
                return i ? (t.q = 3 * i[0] - 3, e + i[0].length) : -1
            }

            function Nce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.m = i[0] - 1, e + i[0].length) : -1
            }

            function q4(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.d = +i[0], e + i[0].length) : -1
            }

            function Fce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 3));
                return i ? (t.m = 0, t.d = +i[0], e + i[0].length) : -1
            }

            function Z4(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.H = +i[0], e + i[0].length) : -1
            }

            function Vce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.M = +i[0], e + i[0].length) : -1
            }

            function Uce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 2));
                return i ? (t.S = +i[0], e + i[0].length) : -1
            }

            function Hce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 3));
                return i ? (t.L = +i[0], e + i[0].length) : -1
            }

            function $ce(t, n, e) {
                var i = Mo.exec(n.slice(e, e + 6));
                return i ? (t.L = Math.floor(i[0] / 1e3), e + i[0].length) : -1
            }

            function zce(t, n, e) {
                var i = Dce.exec(n.slice(e, e + 1));
                return i ? e + i[0].length : -1
            }

            function jce(t, n, e) {
                var i = Mo.exec(n.slice(e));
                return i ? (t.Q = +i[0], e + i[0].length) : -1
            }

            function Wce(t, n, e) {
                var i = Mo.exec(n.slice(e));
                return i ? (t.s = +i[0], e + i[0].length) : -1
            }

            function Y4(t, n) {
                return Ar(t.getDate(), n, 2)
            }

            function Gce(t, n) {
                return Ar(t.getHours(), n, 2)
            }

            function Kce(t, n) {
                return Ar(t.getHours() % 12 || 12, n, 2)
            }

            function qce(t, n) {
                return Ar(1 + j4.count(I0(t), t), n, 3)
            }

            function X4(t, n) {
                return Ar(t.getMilliseconds(), n, 3)
            }

            function Zce(t, n) {
                return X4(t, n) + "000"
            }

            function Yce(t, n) {
                return Ar(t.getMonth() + 1, n, 2)
            }

            function Xce(t, n) {
                return Ar(t.getMinutes(), n, 2)
            }

            function Qce(t, n) {
                return Ar(t.getSeconds(), n, 2)
            }

            function Jce(t) {
                var n = t.getDay();
                return 0 === n ? 7 : n
            }

            function ele(t, n) {
                return Ar($4.count(I0(t) - 1, t), n, 2)
            }

            function Q4(t) {
                var n = t.getDay();
                return n >= 4 || 0 === n ? jm(t) : jm.ceil(t)
            }

            function tle(t, n) {
                return t = Q4(t), Ar(jm.count(I0(t), t) + (4 === I0(t).getDay()), n, 2)
            }

            function nle(t) {
                return t.getDay()
            }

            function ile(t, n) {
                return Ar(mx.count(I0(t) - 1, t), n, 2)
            }

            function rle(t, n) {
                return Ar(t.getFullYear() % 100, n, 2)
            }

            function sle(t, n) {
                return Ar((t = Q4(t)).getFullYear() % 100, n, 2)
            }

            function ole(t, n) {
                return Ar(t.getFullYear() % 1e4, n, 4)
            }

            function ale(t, n) {
                var e = t.getDay();
                return Ar((t = e >= 4 || 0 === e ? jm(t) : jm.ceil(t)).getFullYear() % 1e4, n, 4)
            }

            function cle(t) {
                var n = t.getTimezoneOffset();
                return (n > 0 ? "-" : (n *= -1, "+")) + Ar(n / 60 | 0, "0", 2) + Ar(n % 60, "0", 2)
            }

            function J4(t, n) {
                return Ar(t.getUTCDate(), n, 2)
            }

            function lle(t, n) {
                return Ar(t.getUTCHours(), n, 2)
            }

            function ule(t, n) {
                return Ar(t.getUTCHours() % 12 || 12, n, 2)
            }

            function dle(t, n) {
                return Ar(1 + H4.count(P0(t), t), n, 3)
            }

            function e8(t, n) {
                return Ar(t.getUTCMilliseconds(), n, 3)
            }

            function hle(t, n) {
                return e8(t, n) + "000"
            }

            function fle(t, n) {
                return Ar(t.getUTCMonth() + 1, n, 2)
            }

            function ple(t, n) {
                return Ar(t.getUTCMinutes(), n, 2)
            }

            function mle(t, n) {
                return Ar(t.getUTCSeconds(), n, 2)
            }

            function gle(t) {
                var n = t.getUTCDay();
                return 0 === n ? 7 : n
            }

            function yle(t, n) {
                return Ar(V4.count(P0(t) - 1, t), n, 2)
            }

            function t8(t) {
                var n = t.getUTCDay();
                return n >= 4 || 0 === n ? zm(t) : zm.ceil(t)
            }

            function _le(t, n) {
                return t = t8(t), Ar(zm.count(P0(t), t) + (4 === P0(t).getUTCDay()), n, 2)
            }

            function vle(t) {
                return t.getUTCDay()
            }

            function ble(t, n) {
                return Ar(px.count(P0(t) - 1, t), n, 2)
            }

            function wle(t, n) {
                return Ar(t.getUTCFullYear() % 100, n, 2)
            }

            function xle(t, n) {
                return Ar((t = t8(t)).getUTCFullYear() % 100, n, 2)
            }

            function Cle(t, n) {
                return Ar(t.getUTCFullYear() % 1e4, n, 4)
            }

            function Tle(t, n) {
                var e = t.getUTCDay();
                return Ar((t = e >= 4 || 0 === e ? zm(t) : zm.ceil(t)).getUTCFullYear() % 1e4, n, 4)
            }

            function Sle() {
                return "+0000"
            }

            function n8() {
                return "%"
            }

            function i8(t) {
                return +t
            }

            function r8(t) {
                return Math.floor(+t / 1e3)
            }

            function o8(t) {
                return null === t ? NaN : +t
            }! function kle(t) {
                (function Ece(t) {
                    var n = t.dateTime,
                        e = t.date,
                        i = t.time,
                        r = t.periods,
                        s = t.days,
                        o = t.shortDays,
                        a = t.months,
                        c = t.shortMonths,
                        u = L0(r),
                        h = R0(r),
                        m = L0(s),
                        x = R0(s),
                        D = L0(o),
                        V = R0(o),
                        te = L0(a),
                        ee = R0(a),
                        _e = L0(c),
                        ye = R0(c),
                        Be = {
                            a: function Gt(yn) {
                                return o[yn.getDay()]
                            },
                            A: function cn(yn) {
                                return s[yn.getDay()]
                            },
                            b: function Qt(yn) {
                                return c[yn.getMonth()]
                            },
                            B: function Ri(yn) {
                                return a[yn.getMonth()]
                            },
                            c: null,
                            d: Y4,
                            e: Y4,
                            f: Zce,
                            g: sle,
                            G: ale,
                            H: Gce,
                            I: Kce,
                            j: qce,
                            L: X4,
                            m: Yce,
                            M: Xce,
                            p: function sr(yn) {
                                return r[+(yn.getHours() >= 12)]
                            },
                            q: function tr(yn) {
                                return 1 + ~~(yn.getMonth() / 3)
                            },
                            Q: i8,
                            s: r8,
                            S: Qce,
                            u: Jce,
                            U: ele,
                            V: tle,
                            w: nle,
                            W: ile,
                            x: null,
                            X: null,
                            y: rle,
                            Y: ole,
                            Z: cle,
                            "%": n8
                        },
                        ze = {
                            a: function tc(yn) {
                                return o[yn.getUTCDay()]
                            },
                            A: function Ur(yn) {
                                return s[yn.getUTCDay()]
                            },
                            b: function dd(yn) {
                                return c[yn.getUTCMonth()]
                            },
                            B: function kh(yn) {
                                return a[yn.getUTCMonth()]
                            },
                            c: null,
                            d: J4,
                            e: J4,
                            f: hle,
                            g: xle,
                            G: Tle,
                            H: lle,
                            I: ule,
                            j: dle,
                            L: e8,
                            m: fle,
                            M: ple,
                            p: function Sr(yn) {
                                return r[+(yn.getUTCHours() >= 12)]
                            },
                            q: function Ma(yn) {
                                return 1 + ~~(yn.getUTCMonth() / 3)
                            },
                            Q: i8,
                            s: r8,
                            S: mle,
                            u: gle,
                            U: yle,
                            V: _le,
                            w: vle,
                            W: ble,
                            x: null,
                            X: null,
                            y: wle,
                            Y: Cle,
                            Z: Sle,
                            "%": n8
                        },
                        Xe = {
                            a: function Xt(yn, Ci, nr) {
                                var Zt = D.exec(Ci.slice(nr));
                                return Zt ? (yn.w = V.get(Zt[0].toLowerCase()), nr + Zt[0].length) : -1
                            },
                            A: function Rt(yn, Ci, nr) {
                                var Zt = m.exec(Ci.slice(nr));
                                return Zt ? (yn.w = x.get(Zt[0].toLowerCase()), nr + Zt[0].length) : -1
                            },
                            b: function wr(yn, Ci, nr) {
                                var Zt = _e.exec(Ci.slice(nr));
                                return Zt ? (yn.m = ye.get(Zt[0].toLowerCase()), nr + Zt[0].length) : -1
                            },
                            B: function xi(yn, Ci, nr) {
                                var Zt = te.exec(Ci.slice(nr));
                                return Zt ? (yn.m = ee.get(Zt[0].toLowerCase()), nr + Zt[0].length) : -1
                            },
                            c: function ut(yn, Ci, nr) {
                                return jt(yn, n, Ci, nr)
                            },
                            d: q4,
                            e: q4,
                            f: $ce,
                            g: K4,
                            G: G4,
                            H: Z4,
                            I: Z4,
                            j: Fce,
                            L: Hce,
                            m: Nce,
                            M: Vce,
                            p: function Cn(yn, Ci, nr) {
                                var Zt = u.exec(Ci.slice(nr));
                                return Zt ? (yn.p = h.get(Zt[0].toLowerCase()), nr + Zt[0].length) : -1
                            },
                            q: Bce,
                            Q: jce,
                            s: Wce,
                            S: Uce,
                            u: Ice,
                            U: Pce,
                            V: Oce,
                            w: Mce,
                            W: Lce,
                            x: function Ht(yn, Ci, nr) {
                                return jt(yn, e, Ci, nr)
                            },
                            X: function Et(yn, Ci, nr) {
                                return jt(yn, i, Ci, nr)
                            },
                            y: K4,
                            Y: G4,
                            Z: Rce,
                            "%": zce
                        };

                    function ht(yn, Ci) {
                        return function(nr) {
                            var Pa, bi, Hs, Zt = [],
                                Us = -1,
                                jr = 0,
                                Ia = yn.length;
                            for (nr instanceof Date || (nr = new Date(+nr)); ++Us < Ia;) 37 === yn.charCodeAt(Us) && (Zt.push(yn.slice(jr, Us)), null != (bi = W4[Pa = yn.charAt(++Us)]) ? Pa = yn.charAt(++Us) : bi = "e" === Pa ? " " : "0", (Hs = Ci[Pa]) && (Pa = Hs(nr, bi)), Zt.push(Pa), jr = Us + 1);
                            return Zt.push(yn.slice(jr, Us)), Zt.join("")
                        }
                    }

                    function vt(yn, Ci) {
                        return function(nr) {
                            var jr, Ia, Zt = O0(1900, void 0, 1);
                            if (jt(Zt, yn, nr += "", 0) != nr.length) return null;
                            if ("Q" in Zt) return new Date(Zt.Q);
                            if ("s" in Zt) return new Date(1e3 * Zt.s + ("L" in Zt ? Zt.L : 0));
                            if (Ci && !("Z" in Zt) && (Zt.Z = 0), "p" in Zt && (Zt.H = Zt.H % 12 + 12 * Zt.p), void 0 === Zt.m && (Zt.m = "q" in Zt ? Zt.q : 0), "V" in Zt) {
                                if (Zt.V < 1 || Zt.V > 53) return null;
                                "w" in Zt || (Zt.w = 1), "Z" in Zt ? (Ia = (jr = AD(O0(Zt.y, 0, 1))).getUTCDay(), jr = Ia > 4 || 0 === Ia ? px.ceil(jr) : px(jr), jr = H4.offset(jr, 7 * (Zt.V - 1)), Zt.y = jr.getUTCFullYear(), Zt.m = jr.getUTCMonth(), Zt.d = jr.getUTCDate() + (Zt.w + 6) % 7) : (Ia = (jr = DD(O0(Zt.y, 0, 1))).getDay(), jr = Ia > 4 || 0 === Ia ? mx.ceil(jr) : mx(jr), jr = j4.offset(jr, 7 * (Zt.V - 1)), Zt.y = jr.getFullYear(), Zt.m = jr.getMonth(), Zt.d = jr.getDate() + (Zt.w + 6) % 7)
                            } else("W" in Zt || "U" in Zt) && ("w" in Zt || (Zt.w = "u" in Zt ? Zt.u % 7 : "W" in Zt ? 1 : 0), Ia = "Z" in Zt ? AD(O0(Zt.y, 0, 1)).getUTCDay() : DD(O0(Zt.y, 0, 1)).getDay(), Zt.m = 0, Zt.d = "W" in Zt ? (Zt.w + 6) % 7 + 7 * Zt.W - (Ia + 5) % 7 : Zt.w + 7 * Zt.U - (Ia + 6) % 7);
                            return "Z" in Zt ? (Zt.H += Zt.Z / 100 | 0, Zt.M += Zt.Z % 100, AD(Zt)) : DD(Zt)
                        }
                    }

                    function jt(yn, Ci, nr, Zt) {
                        for (var Pa, bi, Us = 0, jr = Ci.length, Ia = nr.length; Us < jr;) {
                            if (Zt >= Ia) return -1;
                            if (37 === (Pa = Ci.charCodeAt(Us++))) {
                                if (Pa = Ci.charAt(Us++), !(bi = Xe[Pa in W4 ? Ci.charAt(Us++) : Pa]) || (Zt = bi(yn, nr, Zt)) < 0) return -1
                            } else if (Pa != nr.charCodeAt(Zt++)) return -1
                        }
                        return Zt
                    }
                    return Be.x = ht(e, Be), Be.X = ht(i, Be), Be.c = ht(n, Be), ze.x = ht(e, ze), ze.X = ht(i, ze), ze.c = ht(n, ze), {
                        format: function(yn) {
                            var Ci = ht(yn += "", Be);
                            return Ci.toString = function() {
                                return yn
                            }, Ci
                        },
                        parse: function(yn) {
                            var Ci = vt(yn += "", !1);
                            return Ci.toString = function() {
                                return yn
                            }, Ci
                        },
                        utcFormat: function(yn) {
                            var Ci = ht(yn += "", ze);
                            return Ci.toString = function() {
                                return yn
                            }, Ci
                        },
                        utcParse: function(yn) {
                            var Ci = vt(yn += "", !0);
                            return Ci.toString = function() {
                                return yn
                            }, Ci
                        }
                    }
                })(t)
            }({
                dateTime: "%x, %X",
                date: "%-m/%-d/%Y",
                time: "%-I:%M:%S %p",
                periods: ["AM", "PM"],
                days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
            });
            const Mle = lD(k0).right,
                c8 = (lD(o8), Mle);

            function Ile(t, n) {
                return t = +t, n = +n,
                    function(e) {
                        return Math.round(t * (1 - e) + n * e)
                    }
            }

            function Ole(t) {
                return +t
            }
            var l8 = [0, 1];

            function Gm(t) {
                return t
            }

            function kD(t, n) {
                return (n -= t = +t) ? function(e) {
                    return (e - t) / n
                } : function Ple(t) {
                    return function() {
                        return t
                    }
                }(isNaN(n) ? NaN : .5)
            }

            function Rle(t, n, e) {
                var i = t[0],
                    r = t[1],
                    s = n[0],
                    o = n[1];
                return r < i ? (i = kD(r, i), s = e(o, s)) : (i = kD(i, r), s = e(s, o)),
                    function(a) {
                        return s(i(a))
                    }
            }

            function Ble(t, n, e) {
                var i = Math.min(t.length, n.length) - 1,
                    r = new Array(i),
                    s = new Array(i),
                    o = -1;
                for (t[i] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++o < i;) r[o] = kD(t[o], t[o + 1]), s[o] = e(n[o], n[o + 1]);
                return function(a) {
                    var c = c8(t, a, 1, i) - 1;
                    return s[c](r[c](a))
                }
            }

            function d8() {
                return function Nle() {
                    var i, r, s, a, c, u, t = l8,
                        n = l8,
                        e = ex,
                        o = Gm;

                    function h() {
                        var x = Math.min(t.length, n.length);
                        return o !== Gm && (o = function Lle(t, n) {
                            var e;
                            return t > n && (e = t, t = n, n = e),
                                function(i) {
                                    return Math.max(t, Math.min(n, i))
                                }
                        }(t[0], t[x - 1])), a = x > 2 ? Ble : Rle, c = u = null, m
                    }

                    function m(x) {
                        return null == x || isNaN(x = +x) ? s : (c || (c = a(t.map(i), n, e)))(i(o(x)))
                    }
                    return m.invert = function(x) {
                            return o(r((u || (u = a(n, t.map(i), Tl)))(x)))
                        }, m.domain = function(x) {
                            return arguments.length ? (t = Array.from(x, Ole), h()) : t.slice()
                        }, m.range = function(x) {
                            return arguments.length ? (n = Array.from(x), h()) : n.slice()
                        }, m.rangeRound = function(x) {
                            return n = Array.from(x), e = Ile, h()
                        }, m.clamp = function(x) {
                            return arguments.length ? (o = !!x || Gm, h()) : o !== Gm
                        }, m.interpolate = function(x) {
                            return arguments.length ? (e = x, h()) : e
                        }, m.unknown = function(x) {
                            return arguments.length ? (s = x, m) : s
                        },
                        function(x, D) {
                            return i = x, r = D, h()
                        }
                }()(Gm, Gm)
            }

            function B0(t, n) {
                switch (arguments.length) {
                    case 0:
                        break;
                    case 1:
                        this.range(t);
                        break;
                    default:
                        this.range(n).domain(t)
                }
                return this
            }
            var f8, $le = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

            function gx(t) {
                if (!(n = $le.exec(t))) throw new Error("invalid format: " + t);
                var n;
                return new MD({
                    fill: n[1],
                    align: n[2],
                    sign: n[3],
                    symbol: n[4],
                    zero: n[5],
                    width: n[6],
                    comma: n[7],
                    precision: n[8] && n[8].slice(1),
                    trim: n[9],
                    type: n[10]
                })
            }

            function MD(t) {
                this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + ""
            }

            function yx(t, n) {
                if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null;
                var e, i = t.slice(0, e);
                return [i.length > 1 ? i[0] + i.slice(2) : i, +t.slice(e + 1)]
            }

            function Km(t) {
                return (t = yx(Math.abs(t))) ? t[1] : NaN
            }

            function p8(t, n) {
                var e = yx(t, n);
                if (!e) return t + "";
                var i = e[0],
                    r = e[1];
                return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0")
            }
            gx.prototype = MD.prototype, MD.prototype.toString = function() {
                return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type
            };
            const m8 = {
                "%": (t, n) => (100 * t).toFixed(n),
                b: t => Math.round(t).toString(2),
                c: t => t + "",
                d: function zle(t) {
                    return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10)
                },
                e: (t, n) => t.toExponential(n),
                f: (t, n) => t.toFixed(n),
                g: (t, n) => t.toPrecision(n),
                o: t => Math.round(t).toString(8),
                p: (t, n) => p8(100 * t, n),
                r: p8,
                s: function qle(t, n) {
                    var e = yx(t, n);
                    if (!e) return t + "";
                    var i = e[0],
                        r = e[1],
                        s = r - (f8 = 3 * Math.max(-8, Math.min(8, Math.floor(r / 3)))) + 1,
                        o = i.length;
                    return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + yx(t, Math.max(0, n + s - 1))[0]
                },
                X: t => Math.round(t).toString(16).toUpperCase(),
                x: t => Math.round(t).toString(16)
            };

            function g8(t) {
                return t
            }
            var _x, v8, b8, y8 = Array.prototype.map,
                _8 = ["y", "z", "a", "f", "p", "n", "\xb5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

            function eue(t) {
                var n = t.domain;
                return t.ticks = function(e) {
                    var i = n();
                    return function ice(t, n, e) {
                        if (!((e = +e) > 0)) return [];
                        if ((t = +t) == (n = +n)) return [t];
                        const i = n < t,
                            [r, s, o] = i ? dx(n, t, e) : dx(t, n, e);
                        if (!(s >= r)) return [];
                        const a = s - r + 1,
                            c = new Array(a);
                        if (i)
                            if (o < 0)
                                for (let u = 0; u < a; ++u) c[u] = (s - u) / -o;
                            else
                                for (let u = 0; u < a; ++u) c[u] = (s - u) * o;
                        else if (o < 0)
                            for (let u = 0; u < a; ++u) c[u] = (r + u) / -o;
                        else
                            for (let u = 0; u < a; ++u) c[u] = (r + u) * o;
                        return c
                    }(i[0], i[i.length - 1], e ? ? 10)
                }, t.tickFormat = function(e, i) {
                    var r = n();
                    return function Jle(t, n, e, i) {
                        var s, r = dD(t, n, e);
                        switch ((i = gx(i ? ? ",f")).type) {
                            case "s":
                                var o = Math.max(Math.abs(t), Math.abs(n));
                                return null == i.precision && !isNaN(s = function jle(t, n) {
                                    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Km(n) / 3))) - Km(Math.abs(t)))
                                }(r, o)) && (i.precision = s), b8(i, o);
                            case "":
                            case "e":
                            case "g":
                            case "p":
                            case "r":
                                null == i.precision && !isNaN(s = function Xle(t, n) {
                                    return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Km(n) - Km(t)) + 1
                                }(r, Math.max(Math.abs(t), Math.abs(n)))) && (i.precision = s - ("e" === i.type));
                                break;
                            case "f":
                            case "%":
                                null == i.precision && !isNaN(s = function Qle(t) {
                                    return Math.max(0, -Km(Math.abs(t)))
                                }(r)) && (i.precision = s - 2 * ("%" === i.type))
                        }
                        return v8(i)
                    }(r[0], r[r.length - 1], e ? ? 10, i)
                }, t.nice = function(e) {
                    null == e && (e = 10);
                    var c, u, i = n(),
                        r = 0,
                        s = i.length - 1,
                        o = i[r],
                        a = i[s],
                        h = 10;
                    for (a < o && (u = o, o = a, a = u, u = r, r = s, s = u); h-- > 0;) {
                        if ((u = uD(o, a, e)) === c) return i[r] = o, i[s] = a, n(i);
                        if (u > 0) o = Math.floor(o / u) * u, a = Math.ceil(a / u) * u;
                        else {
                            if (!(u < 0)) break;
                            o = Math.ceil(o * u) / u, a = Math.floor(a * u) / u
                        }
                        c = u
                    }
                    return t
                }, t
            }

            function qm() {
                var t = d8();
                return t.copy = function() {
                    return function u8(t, n) {
                        return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())
                    }(t, qm())
                }, B0.apply(t, arguments), eue(t)
            }

            function w8(t, n, e) {
                t = +t, n = +n, e = (r = arguments.length) < 2 ? (n = t, t = 0, 1) : r < 3 ? 1 : +e;
                for (var i = -1, r = 0 | Math.max(0, Math.ceil((n - t) / e)), s = new Array(r); ++i < r;) s[i] = t + i * e;
                return s
            }! function Yle(t) {
                _x = function Zle(t) {
                    var n = void 0 === t.grouping || void 0 === t.thousands ? g8 : function Wle(t, n) {
                            return function(e, i) {
                                for (var r = e.length, s = [], o = 0, a = t[0], c = 0; r > 0 && a > 0 && (c + a + 1 > i && (a = Math.max(1, i - c)), s.push(e.substring(r -= a, r + a)), !((c += a + 1) > i));) a = t[o = (o + 1) % t.length];
                                return s.reverse().join(n)
                            }
                        }(y8.call(t.grouping, Number), t.thousands + ""),
                        e = void 0 === t.currency ? "" : t.currency[0] + "",
                        i = void 0 === t.currency ? "" : t.currency[1] + "",
                        r = void 0 === t.decimal ? "." : t.decimal + "",
                        s = void 0 === t.numerals ? g8 : function Gle(t) {
                            return function(n) {
                                return n.replace(/[0-9]/g, function(e) {
                                    return t[+e]
                                })
                            }
                        }(y8.call(t.numerals, String)),
                        o = void 0 === t.percent ? "%" : t.percent + "",
                        a = void 0 === t.minus ? "\u2212" : t.minus + "",
                        c = void 0 === t.nan ? "NaN" : t.nan + "";

                    function u(m) {
                        var x = (m = gx(m)).fill,
                            D = m.align,
                            V = m.sign,
                            te = m.symbol,
                            ee = m.zero,
                            _e = m.width,
                            ye = m.comma,
                            Be = m.precision,
                            ze = m.trim,
                            Xe = m.type;
                        "n" === Xe ? (ye = !0, Xe = "g") : m8[Xe] || (void 0 === Be && (Be = 12), ze = !0, Xe = "g"), (ee || "0" === x && "=" === D) && (ee = !0, x = "0", D = "=");
                        var ht = "$" === te ? e : "#" === te && /[boxX]/.test(Xe) ? "0" + Xe.toLowerCase() : "",
                            vt = "$" === te ? i : /[%p]/.test(Xe) ? o : "",
                            jt = m8[Xe],
                            Cn = /[defgprs%]/.test(Xe);

                        function Xt(Rt) {
                            var ut, Ht, Et, wr = ht,
                                xi = vt;
                            if ("c" === Xe) xi = jt(Rt) + xi, Rt = "";
                            else {
                                var Gt = (Rt = +Rt) < 0 || 1 / Rt < 0;
                                if (Rt = isNaN(Rt) ? c : jt(Math.abs(Rt), Be), ze && (Rt = function Kle(t) {
                                        e: for (var r, n = t.length, e = 1, i = -1; e < n; ++e) switch (t[e]) {
                                            case ".":
                                                i = r = e;
                                                break;
                                            case "0":
                                                0 === i && (i = e), r = e;
                                                break;
                                            default:
                                                if (!+t[e]) break e;
                                                i > 0 && (i = 0)
                                        }
                                        return i > 0 ? t.slice(0, i) + t.slice(r + 1) : t
                                    }(Rt)), Gt && 0 == +Rt && "+" !== V && (Gt = !1), wr = (Gt ? "(" === V ? V : a : "-" === V || "(" === V ? "" : V) + wr, xi = ("s" === Xe ? _8[8 + f8 / 3] : "") + xi + (Gt && "(" === V ? ")" : ""), Cn)
                                    for (ut = -1, Ht = Rt.length; ++ut < Ht;)
                                        if (48 > (Et = Rt.charCodeAt(ut)) || Et > 57) {
                                            xi = (46 === Et ? r + Rt.slice(ut + 1) : Rt.slice(ut)) + xi, Rt = Rt.slice(0, ut);
                                            break
                                        }
                            }
                            ye && !ee && (Rt = n(Rt, 1 / 0));
                            var cn = wr.length + Rt.length + xi.length,
                                Qt = cn < _e ? new Array(_e - cn + 1).join(x) : "";
                            switch (ye && ee && (Rt = n(Qt + Rt, Qt.length ? _e - xi.length : 1 / 0), Qt = ""), D) {
                                case "<":
                                    Rt = wr + Rt + xi + Qt;
                                    break;
                                case "=":
                                    Rt = wr + Qt + Rt + xi;
                                    break;
                                case "^":
                                    Rt = Qt.slice(0, cn = Qt.length >> 1) + wr + Rt + xi + Qt.slice(cn);
                                    break;
                                default:
                                    Rt = Qt + wr + Rt + xi
                            }
                            return s(Rt)
                        }
                        return Be = void 0 === Be ? 6 : /[gprs]/.test(Xe) ? Math.max(1, Math.min(21, Be)) : Math.max(0, Math.min(20, Be)), Xt.toString = function() {
                            return m + ""
                        }, Xt
                    }
                    return {
                        format: u,
                        formatPrefix: function h(m, x) {
                            var D = u(((m = gx(m)).type = "f", m)),
                                V = 3 * Math.max(-8, Math.min(8, Math.floor(Km(x) / 3))),
                                te = Math.pow(10, -V),
                                ee = _8[8 + V / 3];
                            return function(_e) {
                                return D(te * _e) + ee
                            }
                        }
                    }
                }(t), v8 = _x.format, b8 = _x.formatPrefix
            }({
                thousands: ",",
                grouping: [3],
                currency: ["$", ""]
            });
            class x8 extends Map {
                constructor(n, e = S8) {
                    if (super(), Object.defineProperties(this, {
                            _intern: {
                                value: new Map
                            },
                            _key: {
                                value: e
                            }
                        }), null != n)
                        for (const [i, r] of n) this.set(i, r)
                }
                get(n) {
                    return super.get(ID(this, n))
                }
                has(n) {
                    return super.has(ID(this, n))
                }
                set(n, e) {
                    return super.set(function C8({
                        _intern: t,
                        _key: n
                    }, e) {
                        const i = n(e);
                        return t.has(i) ? t.get(i) : (t.set(i, e), e)
                    }(this, n), e)
                }
                delete(n) {
                    return super.delete(function T8({
                        _intern: t,
                        _key: n
                    }, e) {
                        const i = n(e);
                        return t.has(i) && (e = t.get(i), t.delete(i)), e
                    }(this, n))
                }
            }

            function ID({
                _intern: t,
                _key: n
            }, e) {
                const i = n(e);
                return t.has(i) ? t.get(i) : e
            }

            function S8(t) {
                return null !== t && "object" == typeof t ? t.valueOf() : t
            }
            const E8 = Symbol("implicit");

            function PD() {
                var t = new x8,
                    n = [],
                    e = [],
                    i = E8;

                function r(s) {
                    let o = t.get(s);
                    if (void 0 === o) {
                        if (i !== E8) return i;
                        t.set(s, o = n.push(s) - 1)
                    }
                    return e[o % e.length]
                }
                return r.domain = function(s) {
                    if (!arguments.length) return n.slice();
                    n = [], t = new x8;
                    for (const o of s) t.has(o) || t.set(o, n.push(o) - 1);
                    return r
                }, r.range = function(s) {
                    return arguments.length ? (e = Array.from(s), r) : e.slice()
                }, r.unknown = function(s) {
                    return arguments.length ? (i = s, r) : i
                }, r.copy = function() {
                    return PD(n, e).unknown(i)
                }, B0.apply(r, arguments), r
            }

            function vx() {
                var s, o, t = PD().unknown(void 0),
                    n = t.domain,
                    e = t.range,
                    i = 0,
                    r = 1,
                    a = !1,
                    c = 0,
                    u = 0,
                    h = .5;

                function m() {
                    var x = n().length,
                        D = r < i,
                        V = D ? r : i,
                        te = D ? i : r;
                    s = (te - V) / Math.max(1, x - c + 2 * u), a && (s = Math.floor(s)), V += (te - V - s * (x - c)) * h, o = s * (1 - c), a && (V = Math.round(V), o = Math.round(o));
                    var ee = w8(x).map(function(_e) {
                        return V + s * _e
                    });
                    return e(D ? ee.reverse() : ee)
                }
                return delete t.unknown, t.domain = function(x) {
                    return arguments.length ? (n(x), m()) : n()
                }, t.range = function(x) {
                    return arguments.length ? ([i, r] = x, i = +i, r = +r, m()) : [i, r]
                }, t.rangeRound = function(x) {
                    return [i, r] = x, i = +i, r = +r, a = !0, m()
                }, t.bandwidth = function() {
                    return o
                }, t.step = function() {
                    return s
                }, t.round = function(x) {
                    return arguments.length ? (a = !!x, m()) : a
                }, t.padding = function(x) {
                    return arguments.length ? (c = Math.min(1, u = +x), m()) : c
                }, t.paddingInner = function(x) {
                    return arguments.length ? (c = Math.min(1, x), m()) : c
                }, t.paddingOuter = function(x) {
                    return arguments.length ? (u = +x, m()) : u
                }, t.align = function(x) {
                    return arguments.length ? (h = Math.max(0, Math.min(1, x)), m()) : h
                }, t.copy = function() {
                    return vx(n(), [i, r]).round(a).paddingInner(c).paddingOuter(u).align(h)
                }, B0.apply(m(), arguments)
            }

            function nue(t, n, e = o8) {
                if ((i = t.length) && !isNaN(n = +n)) {
                    if (n <= 0 || i < 2) return +e(t[0], 0, t);
                    if (n >= 1) return +e(t[i - 1], i - 1, t);
                    var i, r = (i - 1) * n,
                        s = Math.floor(r),
                        o = +e(t[s], s, t);
                    return o + (+e(t[s + 1], s + 1, t) - o) * (r - s)
                }
            }

            function A8() {
                var i, t = [],
                    n = [],
                    e = [];

                function r() {
                    var o = 0,
                        a = Math.max(1, n.length);
                    for (e = new Array(a - 1); ++o < a;) e[o - 1] = nue(t, o / a);
                    return s
                }

                function s(o) {
                    return null == o || isNaN(o = +o) ? i : n[c8(e, o)]
                }
                return s.invertExtent = function(o) {
                    var a = n.indexOf(o);
                    return a < 0 ? [NaN, NaN] : [a > 0 ? e[a - 1] : t[0], a < e.length ? e[a] : t[t.length - 1]]
                }, s.domain = function(o) {
                    if (!arguments.length) return t.slice();
                    t = [];
                    for (let a of o) null != a && !isNaN(a = +a) && t.push(a);
                    return t.sort(k0), r()
                }, s.range = function(o) {
                    return arguments.length ? (n = Array.from(o), r()) : n.slice()
                }, s.unknown = function(o) {
                    return arguments.length ? (i = o, s) : i
                }, s.quantiles = function() {
                    return e.slice()
                }, s.copy = function() {
                    return A8().domain(t).range(n).unknown(i)
                }, B0.apply(s, arguments)
            }
            var iue = T(52178);
            const rue = ["caretElm"];

            function sue(t, n) {}
            const oue = function(t) {
                return {
                    model: t
                }
            };

            function aue(t, n) {
                if (1 & t && (J(0, "span"), tt(1, sue, 0, 0, "ng-template", 5), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngTemplateOutlet", e.template)("ngTemplateOutletContext", fi(2, oue, e.context))
                }
            }

            function cue(t, n) {
                1 & t && gt(0, "span", 6), 2 & t && Re("innerHTML", Ke().title, iy)
            }

            function lue(t, n) {
                if (1 & t && (J(0, "header", 4)(1, "span", 5), Oe(2), ce()()), 2 & t) {
                    const e = Ke();
                    he(2), on(e.title)
                }
            }

            function uue(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 6)(1, "ngx-charts-legend-entry", 7), xt("select", function(r) {
                        return Nt(e), Ft(Ke().labelClick.emit(r))
                    })("activate", function(r) {
                        return Nt(e), Ft(Ke().activate(r))
                    })("deactivate", function(r) {
                        return Nt(e), Ft(Ke().deactivate(r))
                    }), ce()()
                }
                if (2 & t) {
                    const e = n.$implicit,
                        i = Ke();
                    he(1), Re("label", e.label)("formattedLabel", e.formattedLabel)("color", e.color)("isActive", i.isActive(e))
                }
            }

            function due(t, n) {
                if (1 & t && (Pn(), Fc(), gt(0, "ngx-charts-scale-legend", 4)), 2 & t) {
                    const e = Ke();
                    Re("horizontal", e.legendOptions && e.legendOptions.position === e.LegendPosition.Below)("valueRange", e.legendOptions.domain)("colors", e.legendOptions.colors)("height", e.view[1])("width", e.legendWidth)
                }
            }

            function hue(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), Fc(), J(0, "ngx-charts-legend", 5), xt("labelClick", function(r) {
                        return Nt(e), Ft(Ke().legendLabelClick.emit(r))
                    })("labelActivate", function(r) {
                        return Nt(e), Ft(Ke().legendLabelActivate.emit(r))
                    })("labelDeactivate", function(r) {
                        return Nt(e), Ft(Ke().legendLabelDeactivate.emit(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("horizontal", e.legendOptions && e.legendOptions.position === e.LegendPosition.Below)("data", e.legendOptions.domain)("title", e.legendOptions.title)("colors", e.legendOptions.colors)("height", e.view[1])("width", e.legendWidth)("activeEntries", e.activeEntries)
                }
            }
            const k8 = ["*"],
                fue = ["ngx-charts-axis-label", ""],
                M8 = ["ticksel"],
                pue = ["ngx-charts-x-axis-ticks", ""];

            function mue(t, n) {
                1 & t && (Pn(), tb(0))
            }

            function gue(t, n) {
                if (1 & t && (Pn(), J(0, "tspan", 10), Oe(1), ce()), 2 & t) {
                    const e = n.$implicit;
                    hi("y", 12 * n.index), he(1), Ln(" ", e, " ")
                }
            }

            function yue(t, n) {
                if (1 & t && (Pn(), Kl(0), tt(1, gue, 2, 2, "tspan", 9), ql()), 2 & t) {
                    const e = n.ngIf;
                    he(1), Re("ngForOf", e)
                }
            }

            function _ue(t, n) {
                if (1 & t && (Pn(), tt(0, yue, 2, 1, "ng-container", 4)), 2 & t) {
                    const e = Ke(2).$implicit;
                    Re("ngIf", Ke().tickChunks(e))
                }
            }

            function vue(t, n) {
                if (1 & t && (Pn(), Oe(0)), 2 & t) {
                    const e = Ke().ngIf;
                    Ln(" ", Ke(2).tickTrim(e), " ")
                }
            }

            function bue(t, n) {
                if (1 & t && (Pn(), Kl(0), J(1, "title"), Oe(2), ce(), J(3, "text", 5), tt(4, mue, 1, 0, "ng-container", 6), ce(), tt(5, _ue, 1, 1, "ng-template", null, 7, _l), tt(7, vue, 1, 1, "ng-template", null, 8, _l), ql()), 2 & t) {
                    const e = n.ngIf,
                        i = pl(6),
                        r = pl(8),
                        s = Ke(2);
                    he(2), on(e), he(1), hi("text-anchor", s.textAnchor)("transform", s.textTransform), he(1), Re("ngIf", s.isWrapTicksSupported)("ngIfThen", i)("ngIfElse", r)
                }
            }

            function wue(t, n) {
                if (1 & t && (Pn(), J(0, "g", 3), tt(1, bue, 9, 6, "ng-container", 4), ce()), 2 & t) {
                    const e = n.$implicit,
                        i = Ke();
                    hi("transform", i.tickTransform(e)), he(1), Re("ngIf", i.tickFormat(e))
                }
            }

            function xue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), gt(1, "line", 11), ce()), 2 & t) {
                    const e = Ke(2);
                    hi("transform", e.gridLineTransform()), he(1), hi("y1", -e.gridLineHeight)
                }
            }

            function Cue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, xue, 2, 2, "g", 4), ce()), 2 & t) {
                    const e = n.$implicit,
                        i = Ke();
                    hi("transform", i.tickTransform(e)), he(1), Re("ngIf", i.showGridLines)
                }
            }
            const Tue = ["ngx-charts-x-axis", ""];

            function Sue(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 2), xt("dimensionsChanged", function(r) {
                        return Nt(e), Ft(Ke().emitTicksHeight(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("trimTicks", e.trimTicks)("rotateTicks", e.rotateTicks)("maxTickLength", e.maxTickLength)("tickFormatting", e.tickFormatting)("tickArguments", e.tickArguments)("tickStroke", e.tickStroke)("scale", e.xScale)("orient", e.xOrient)("showGridLines", e.showGridLines)("gridLineHeight", e.dims.height)("width", e.dims.width)("tickValues", e.ticks)("wrapTicks", e.wrapTicks)
                }
            }

            function Eue(t, n) {
                if (1 & t && (Pn(), gt(0, "g", 3)), 2 & t) {
                    const e = Ke();
                    Re("label", e.labelText)("offset", e.labelOffset)("orient", e.orientation.Bottom)("height", e.dims.height)("width", e.dims.width)
                }
            }
            const Due = ["ngx-charts-y-axis-ticks", ""];

            function Aue(t, n) {
                1 & t && (Pn(), tb(0))
            }

            function kue(t, n) {
                if (1 & t && (Pn(), J(0, "tspan", 12), Oe(1), ce()), 2 & t) {
                    const e = n.$implicit;
                    hi("y", n.index * (8 + Ke(6).tickSpacing)), he(1), Ln(" ", e, " ")
                }
            }

            function Mue(t, n) {
                if (1 & t && (Pn(), Kl(0), tt(1, kue, 2, 2, "tspan", 11), ql()), 2 & t) {
                    const e = Ke().ngIf;
                    he(1), Re("ngForOf", e)
                }
            }

            function Iue(t, n) {
                if (1 & t && (Pn(), Kl(0), tt(1, Mue, 2, 1, "ng-container", 10), ql()), 2 & t) {
                    const e = n.ngIf;
                    Ke(2);
                    const i = pl(8);
                    he(1), Re("ngIf", e.length > 1)("ngIfElse", i)
                }
            }

            function Pue(t, n) {
                if (1 & t && (Pn(), tt(0, Iue, 2, 2, "ng-container", 5)), 2 & t) {
                    const e = Ke(2).$implicit;
                    Re("ngIf", Ke().tickChunks(e))
                }
            }

            function Oue(t, n) {
                if (1 & t && (Pn(), Oe(0)), 2 & t) {
                    const e = Ke().ngIf;
                    Ln(" ", Ke(2).tickTrim(e), " ")
                }
            }

            function Lue(t, n) {
                if (1 & t && (Pn(), Kl(0), J(1, "title"), Oe(2), ce(), J(3, "text", 6), tt(4, Aue, 1, 0, "ng-container", 7), ce(), tt(5, Pue, 1, 1, "ng-template", null, 8, _l), tt(7, Oue, 1, 1, "ng-template", null, 9, _l), ql()), 2 & t) {
                    const e = n.ngIf,
                        i = pl(6),
                        r = pl(8),
                        s = Ke(2);
                    he(2), on(e), he(1), jo("font-size", "12px"), hi("dy", s.dy)("x", s.x1)("y", s.y1)("text-anchor", s.textAnchor), he(1), Re("ngIf", s.wrapTicks)("ngIfThen", i)("ngIfElse", r)
                }
            }

            function Rue(t, n) {
                if (1 & t && (Pn(), J(0, "g", 4), tt(1, Lue, 9, 10, "ng-container", 5), ce()), 2 & t) {
                    const e = n.$implicit,
                        i = Ke();
                    hi("transform", i.transform(e)), he(1), Re("ngIf", i.tickFormat(e))
                }
            }

            function Bue(t, n) {
                if (1 & t && (Pn(), gt(0, "path", 13)), 2 & t) {
                    const e = Ke();
                    hi("d", e.referenceAreaPath)("transform", e.gridLineTransform())
                }
            }

            function Nue(t, n) {
                1 & t && (Pn(), gt(0, "line", 15)), 2 & t && hi("x2", Ke(3).gridLineWidth)
            }

            function Fue(t, n) {
                1 & t && (Pn(), gt(0, "line", 15)), 2 & t && hi("x2", -Ke(3).gridLineWidth)
            }

            function Vue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, Nue, 1, 1, "line", 14), tt(2, Fue, 1, 1, "line", 14), ce()), 2 & t) {
                    const e = Ke(2);
                    hi("transform", e.gridLineTransform()), he(1), Re("ngIf", e.orient === e.Orientation.Left), he(1), Re("ngIf", e.orient === e.Orientation.Right)
                }
            }

            function Uue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, Vue, 3, 3, "g", 5), ce()), 2 & t) {
                    const e = n.$implicit,
                        i = Ke();
                    hi("transform", i.transform(e)), he(1), Re("ngIf", i.showGridLines)
                }
            }

            function Hue(t, n) {
                if (1 & t && (Pn(), J(0, "g")(1, "title"), Oe(2), ce(), J(3, "text", 17), Oe(4), ce()()), 2 & t) {
                    const e = Ke(2).$implicit,
                        i = Ke();
                    he(2), on(i.tickTrim(i.tickFormat(e.value))), he(1), hi("dy", i.dy)("y", -6)("x", i.gridLineWidth)("text-anchor", i.textAnchor), he(1), Ln(" ", e.name, " ")
                }
            }

            function $ue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), gt(1, "line", 16), tt(2, Hue, 5, 6, "g", 5), ce()), 2 & t) {
                    const e = Ke().$implicit,
                        i = Ke();
                    hi("transform", i.transform(e.value)), he(1), hi("x2", i.gridLineWidth)("transform", i.gridLineTransform()), he(1), Re("ngIf", i.showRefLabels)
                }
            }

            function zue(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, $ue, 3, 4, "g", 5), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngIf", e.showRefLines)
                }
            }
            const jue = ["ngx-charts-y-axis", ""];

            function Wue(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 2), xt("dimensionsChanged", function(r) {
                        return Nt(e), Ft(Ke().emitTicksWidth(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("trimTicks", e.trimTicks)("maxTickLength", e.maxTickLength)("tickFormatting", e.tickFormatting)("tickArguments", e.tickArguments)("tickValues", e.ticks)("tickStroke", e.tickStroke)("scale", e.yScale)("orient", e.yOrient)("showGridLines", e.showGridLines)("gridLineWidth", e.dims.width)("referenceLines", e.referenceLines)("showRefLines", e.showRefLines)("showRefLabels", e.showRefLabels)("height", e.dims.height)("wrapTicks", e.wrapTicks)
                }
            }

            function Gue(t, n) {
                if (1 & t && (Pn(), gt(0, "g", 3)), 2 & t) {
                    const e = Ke();
                    Re("label", e.labelText)("offset", e.labelOffset)("orient", e.yOrient)("height", e.dims.height)("width", e.dims.width)
                }
            }
            const Kue = ["ngx-charts-svg-linear-gradient", ""];

            function que(t, n) {
                if (1 & t && (Pn(), gt(0, "stop")), 2 & t) {
                    const e = n.$implicit;
                    jo("stop-color", e.color)("stop-opacity", e.opacity), hi("offset", e.offset + "%")
                }
            }
            const wde = ["tooltipTemplate"],
                N0 = function(t, n) {
                    return [t, n]
                },
                kde = ["ngx-charts-bar", ""];

            function Mde(t, n) {
                if (1 & t && (Pn(), J(0, "defs"), gt(1, "g", 2), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("orientation", e.orientation)("name", e.gradientId)("stops", e.gradientStops)
                }
            }
            const Ide = ["ngx-charts-bar-label", ""],
                Vde = ["ngx-charts-series-vertical", ""];

            function Ude(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 2), xt("select", function(r) {
                        return Nt(e), Ft(Ke(2).onClick(r))
                    })("activate", function(r) {
                        return Nt(e), Ft(Ke(2).activate.emit(r))
                    })("deactivate", function(r) {
                        return Nt(e), Ft(Ke(2).deactivate.emit(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = n.$implicit,
                        i = Ke(2);
                    Re("@animationState", "active")("@.disabled", !i.animations)("width", e.width)("height", e.height)("x", e.x)("y", e.y)("fill", e.color)("stops", e.gradientStops)("data", e.data)("orientation", i.barOrientation.Vertical)("roundEdges", e.roundEdges)("gradient", i.gradient)("ariaLabel", e.ariaLabel)("isActive", i.isActive(e.data))("tooltipDisabled", i.tooltipDisabled)("tooltipPlacement", i.tooltipPlacement)("tooltipType", i.tooltipType)("tooltipTitle", i.tooltipTemplate ? void 0 : e.tooltipText)("tooltipTemplate", i.tooltipTemplate)("tooltipContext", e.data)("noBarWhenZero", i.noBarWhenZero)("animations", i.animations)
                }
            }

            function Hde(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, Ude, 1, 22, "g", 1), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngForOf", e.bars)("ngForTrackBy", e.trackBy)
                }
            }

            function $de(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 2), xt("select", function(r) {
                        return Nt(e), Ft(Ke(2).onClick(r))
                    })("activate", function(r) {
                        return Nt(e), Ft(Ke(2).activate.emit(r))
                    })("deactivate", function(r) {
                        return Nt(e), Ft(Ke(2).deactivate.emit(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = n.$implicit,
                        i = Ke(2);
                    Re("width", e.width)("height", e.height)("x", e.x)("y", e.y)("fill", e.color)("stops", e.gradientStops)("data", e.data)("orientation", i.barOrientation.Vertical)("roundEdges", e.roundEdges)("gradient", i.gradient)("ariaLabel", e.ariaLabel)("isActive", i.isActive(e.data))("tooltipDisabled", i.tooltipDisabled)("tooltipPlacement", i.tooltipPlacement)("tooltipType", i.tooltipType)("tooltipTitle", i.tooltipTemplate ? void 0 : e.tooltipText)("tooltipTemplate", i.tooltipTemplate)("tooltipContext", e.data)("noBarWhenZero", i.noBarWhenZero)("animations", i.animations)
                }
            }

            function zde(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, $de, 1, 20, "g", 1), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngForOf", e.bars)("ngForTrackBy", e.trackBy)
                }
            }

            function jde(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 4), xt("dimensionsChanged", function(r) {
                        const o = Nt(e).index;
                        return Ft(Ke(2).dataLabelHeightChanged.emit({
                            size: r,
                            index: o
                        }))
                    }), ce()
                }
                if (2 & t) {
                    const e = n.$implicit,
                        i = Ke(2);
                    Re("barX", e.x)("barY", e.y)("barWidth", e.width)("barHeight", e.height)("value", e.total)("valueFormatting", i.dataLabelFormatting)("orientation", i.barOrientation.Vertical)
                }
            }

            function Wde(t, n) {
                if (1 & t && (Pn(), J(0, "g"), tt(1, jde, 1, 7, "g", 3), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngForOf", e.barsForDataLabels)("ngForTrackBy", e.trackDataLabelBy)
                }
            }

            function Gde(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 5), xt("dimensionsChanged", function(r) {
                        return Nt(e), Ft(Ke().updateXAxisHeight(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("xScale", e.xScale)("dims", e.dims)("showGridLines", e.showGridLines)("showLabel", e.showXAxisLabel)("labelText", e.xAxisLabel)("trimTicks", e.trimXAxisTicks)("rotateTicks", e.rotateXAxisTicks)("maxTickLength", e.maxXAxisTickLength)("tickFormatting", e.xAxisTickFormatting)("ticks", e.xAxisTicks)("xAxisOffset", e.dataLabelMaxHeight.negative)("wrapTicks", e.wrapTicks)
                }
            }

            function Kde(t, n) {
                if (1 & t) {
                    const e = On();
                    Pn(), J(0, "g", 6), xt("dimensionsChanged", function(r) {
                        return Nt(e), Ft(Ke().updateYAxisWidth(r))
                    }), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("yScale", e.yScale)("dims", e.dims)("showGridLines", e.showGridLines)("showLabel", e.showYAxisLabel)("labelText", e.yAxisLabel)("trimTicks", e.trimYAxisTicks)("maxTickLength", e.maxYAxisTickLength)("tickFormatting", e.yAxisTickFormatting)("ticks", e.yAxisTicks)("wrapTicks", e.wrapTicks)
                }
            }

            function xhe(t, n, e) {
                e = e || {};
                let i, r, s, o = null,
                    a = 0;

                function c() {
                    a = !1 === e.leading ? 0 : +new Date, o = null, s = t.apply(i, r)
                }
                return function() {
                    const u = +new Date;
                    !a && !1 === e.leading && (a = u);
                    const h = n - (u - a);
                    return i = this, r = arguments, h <= 0 ? (clearTimeout(o), o = null, a = u, s = t.apply(i, r)) : !o && !1 !== e.trailing && (o = setTimeout(c, h)), s
                }
            }

            function Che(t, n) {
                return function(i, r, s) {
                    return {
                        configurable: !0,
                        enumerable: s.enumerable,
                        get: function() {
                            return Object.defineProperty(this, r, {
                                configurable: !0,
                                enumerable: s.enumerable,
                                value: xhe(s.value, t, n)
                            }), this[r]
                        }
                    }
                }
            }
            var rr = function(t) {
                return t.Top = "top", t.Bottom = "bottom", t.Left = "left", t.Right = "right", t.Center = "center", t
            }(rr || {});

            function I8(t, n, e) {
                return e === rr.Top ? t.top - 7 : e === rr.Bottom ? t.top + t.height - n.height + 7 : e === rr.Center ? t.top + t.height / 2 - n.height / 2 : void 0
            }

            function P8(t, n, e) {
                return e === rr.Left ? t.left - 7 : e === rr.Right ? t.left + t.width - n.width + 7 : e === rr.Center ? t.left + t.width / 2 - n.width / 2 : void 0
            }
            class xc {
                static calculateVerticalAlignment(n, e, i) {
                    let r = I8(n, e, i);
                    return r + e.height > window.innerHeight && (r = window.innerHeight - e.height), r
                }
                static calculateVerticalCaret(n, e, i, r) {
                    let s;
                    r === rr.Top && (s = n.height / 2 - i.height / 2 + 7), r === rr.Bottom && (s = e.height - n.height / 2 - i.height / 2 - 7), r === rr.Center && (s = e.height / 2 - i.height / 2);
                    const o = I8(n, e, r);
                    return o + e.height > window.innerHeight && (s += o + e.height - window.innerHeight), s
                }
                static calculateHorizontalAlignment(n, e, i) {
                    let r = P8(n, e, i);
                    return r + e.width > window.innerWidth && (r = window.innerWidth - e.width), r
                }
                static calculateHorizontalCaret(n, e, i, r) {
                    let s;
                    r === rr.Left && (s = n.width / 2 - i.width / 2 + 7), r === rr.Right && (s = e.width - n.width / 2 - i.width / 2 - 7), r === rr.Center && (s = e.width / 2 - i.width / 2);
                    const o = P8(n, e, r);
                    return o + e.width > window.innerWidth && (s += o + e.width - window.innerWidth), s
                }
                static shouldFlip(n, e, i, r) {
                    let s = !1;
                    return i === rr.Right && n.left + n.width + e.width + r > window.innerWidth && (s = !0), i === rr.Left && n.left - e.width - r < 0 && (s = !0), i === rr.Top && n.top - e.height - r < 0 && (s = !0), i === rr.Bottom && n.top + n.height + e.height + r > window.innerHeight && (s = !0), s
                }
                static positionCaret(n, e, i, r, s) {
                    let o = 0,
                        a = 0;
                    return n === rr.Right ? (a = -7, o = xc.calculateVerticalCaret(i, e, r, s)) : n === rr.Left ? (a = e.width, o = xc.calculateVerticalCaret(i, e, r, s)) : n === rr.Top ? (o = e.height, a = xc.calculateHorizontalCaret(i, e, r, s)) : n === rr.Bottom && (o = -7, a = xc.calculateHorizontalCaret(i, e, r, s)), {
                        top: o,
                        left: a
                    }
                }
                static positionContent(n, e, i, r, s) {
                    let o = 0,
                        a = 0;
                    return n === rr.Right ? (a = i.left + i.width + r, o = xc.calculateVerticalAlignment(i, e, s)) : n === rr.Left ? (a = i.left - e.width - r, o = xc.calculateVerticalAlignment(i, e, s)) : n === rr.Top ? (o = i.top - e.height - r, a = xc.calculateHorizontalAlignment(i, e, s)) : n === rr.Bottom && (o = i.top + i.height + r, a = xc.calculateHorizontalAlignment(i, e, s)), {
                        top: o,
                        left: a
                    }
                }
                static determinePlacement(n, e, i, r) {
                    if (xc.shouldFlip(i, e, n, r)) {
                        if (n === rr.Right) return rr.Left;
                        if (n === rr.Left) return rr.Right;
                        if (n === rr.Top) return rr.Bottom;
                        if (n === rr.Bottom) return rr.Top
                    }
                    return n
                }
            }
            let The = (() => {
                class t {
                    constructor(e, i, r) {
                        this.element = e, this.renderer = i, this.platformId = r
                    }
                    get cssClasses() {
                        let e = "ngx-charts-tooltip-content";
                        return e += ` position-${this.placement}`, e += ` type-${this.type}`, e += ` ${this.cssClass}`, e
                    }
                    ngAfterViewInit() {
                        setTimeout(this.position.bind(this))
                    }
                    position() {
                        if (!gc(this.platformId)) return;
                        const e = this.element.nativeElement,
                            i = this.host.nativeElement.getBoundingClientRect();
                        if (!i.height && !i.width) return;
                        const r = e.getBoundingClientRect();
                        this.checkFlip(i, r), this.positionContent(e, i, r), this.showCaret && this.positionCaret(i, r), setTimeout(() => this.renderer.addClass(e, "animate"), 1)
                    }
                    positionContent(e, i, r) {
                        const {
                            top: s,
                            left: o
                        } = xc.positionContent(this.placement, r, i, this.spacing, this.alignment);
                        this.renderer.setStyle(e, "top", `${s}px`), this.renderer.setStyle(e, "left", `${o}px`)
                    }
                    positionCaret(e, i) {
                        const r = this.caretElm.nativeElement,
                            s = r.getBoundingClientRect(),
                            {
                                top: o,
                                left: a
                            } = xc.positionCaret(this.placement, i, e, s, this.alignment);
                        this.renderer.setStyle(r, "top", `${o}px`), this.renderer.setStyle(r, "left", `${a}px`)
                    }
                    checkFlip(e, i) {
                        this.placement = xc.determinePlacement(this.placement, i, e, this.spacing)
                    }
                    onWindowResize() {
                        this.position()
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(We(ir), We(Ks), We(Bs))
                }, t.\u0275cmp = xn({
                    type: t,
                    selectors: [
                        ["ngx-tooltip-content"]
                    ],
                    viewQuery: function(e, i) {
                        if (1 & e && $c(rue, 5), 2 & e) {
                            let r;
                            wa(r = xa()) && (i.caretElm = r.first)
                        }
                    },
                    hostVars: 2,
                    hostBindings: function(e, i) {
                        1 & e && xt("resize", function() {
                            return i.onWindowResize()
                        }, 0, fl), 2 & e && AT(i.cssClasses)
                    },
                    inputs: {
                        host: "host",
                        showCaret: "showCaret",
                        type: "type",
                        placement: "placement",
                        alignment: "alignment",
                        spacing: "spacing",
                        cssClass: "cssClass",
                        title: "title",
                        template: "template",
                        context: "context"
                    },
                    decls: 6,
                    vars: 6,
                    consts: [
                        [3, "hidden"],
                        ["caretElm", ""],
                        [1, "tooltip-content"],
                        [4, "ngIf"],
                        [3, "innerHTML", 4, "ngIf"],
                        [3, "ngTemplateOutlet", "ngTemplateOutletContext"],
                        [3, "innerHTML"]
                    ],
                    template: function(e, i) {
                        1 & e && (J(0, "div"), gt(1, "span", 0, 1), J(3, "div", 2), tt(4, aue, 2, 4, "span", 3), tt(5, cue, 1, 1, "span", 4), ce()()), 2 & e && (he(1), MT("tooltip-caret position-", i.placement, ""), Re("hidden", !i.showCaret), he(3), Re("ngIf", !i.title), he(1), Re("ngIf", i.title))
                    },
                    dependencies: [ts, MS],
                    styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate(10px)}.ngx-charts-tooltip-content.position-left{transform:translate(-10px)}.ngx-charts-tooltip-content.position-top{transform:translateY(-10px)}.ngx-charts-tooltip-content.position-bottom{transform:translateY(10px)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"],
                    encapsulation: 2
                }), (0, Ge.__decorate)([Che(100)], t.prototype, "onWindowResize", null), t
            })();
            class She {
                constructor(n) {
                    this.injectionService = n, this.defaults = {}, this.components = new Map
                }
                getByType(n = this.type) {
                    return this.components.get(n)
                }
                create(n) {
                    return this.createByType(this.type, n)
                }
                createByType(n, e) {
                    e = this.assignDefaults(e);
                    const i = this.injectComponent(n, e);
                    return this.register(n, i), i
                }
                destroy(n) {
                    const e = this.components.get(n.componentType);
                    if (e && e.length) {
                        const i = e.indexOf(n);
                        i > -1 && (e[i].destroy(), e.splice(i, 1))
                    }
                }
                destroyAll() {
                    this.destroyByType(this.type)
                }
                destroyByType(n) {
                    const e = this.components.get(n);
                    if (e && e.length) {
                        let i = e.length - 1;
                        for (; i >= 0;) this.destroy(e[i--])
                    }
                }
                injectComponent(n, e) {
                    return this.injectionService.appendComponent(n, e)
                }
                assignDefaults(n) {
                    const e = { ...this.defaults.inputs
                        },
                        i = { ...this.defaults.outputs
                        };
                    return !n.inputs && !n.outputs && (n = {
                        inputs: n
                    }), e && (n.inputs = { ...e,
                        ...n.inputs
                    }), i && (n.outputs = { ...i,
                        ...n.outputs
                    }), n
                }
                register(n, e) {
                    this.components.has(n) || this.components.set(n, []), this.components.get(n).push(e)
                }
            }
            let O8 = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.applicationRef = e, this.componentFactoryResolver = i, this.injector = r
                        }
                        static setGlobalRootViewContainer(e) {
                            t.globalRootViewContainer = e
                        }
                        getRootViewContainer() {
                            if (this._container) return this._container;
                            if (t.globalRootViewContainer) return t.globalRootViewContainer;
                            if (this.applicationRef.components.length) return this.applicationRef.components[0];
                            throw new Error("View Container not found! ngUpgrade needs to manually set this via setRootViewContainer or setGlobalRootViewContainer.")
                        }
                        setRootViewContainer(e) {
                            this._container = e
                        }
                        getComponentRootNode(e) {
                            return function Ehe(t) {
                                return t.element
                            }(e) ? e.element.nativeElement : e.hostView && e.hostView.rootNodes.length > 0 ? e.hostView.rootNodes[0] : e.location.nativeElement
                        }
                        getRootViewContainerNode(e) {
                            return this.getComponentRootNode(e)
                        }
                        projectComponentBindings(e, i) {
                            if (i) {
                                if (void 0 !== i.inputs) {
                                    const r = Object.getOwnPropertyNames(i.inputs);
                                    for (const s of r) e.instance[s] = i.inputs[s]
                                }
                                if (void 0 !== i.outputs) {
                                    const r = Object.getOwnPropertyNames(i.outputs);
                                    for (const s of r) e.instance[s] = i.outputs[s]
                                }
                            }
                            return e
                        }
                        appendComponent(e, i = {}, r) {
                            r || (r = this.getRootViewContainer());
                            const s = this.getComponentRootNode(r),
                                o = new vre(s, this.componentFactoryResolver, this.applicationRef, this.injector),
                                a = new IF(e),
                                c = o.attach(a);
                            return this.projectComponentBindings(c, i), c
                        }
                    }
                    return t.globalRootViewContainer = null, t.\u0275fac = function(e) {
                        return new(e || t)(_t(Xl), _t(Xp), _t(Do))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                OD = (() => {
                    class t extends She {
                        constructor(e) {
                            super(e), this.type = The
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_t(O8))
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })();
            var Wf = function(t) {
                    return t.Right = "right", t.Below = "below", t
                }(Wf || {}),
                F0 = function(t) {
                    return t.ScaleLegend = "scaleLegend", t.Legend = "legend", t
                }(F0 || {}),
                gi = function(t) {
                    return t.Time = "time", t.Linear = "linear", t.Ordinal = "ordinal", t.Quantile = "quantile", t
                }(gi || {});
            let L8 = (() => {
                class t {
                    constructor() {
                        this.horizontal = !1
                    }
                    ngOnChanges(e) {
                        const i = this.gradientString(this.colors.range(), this.colors.domain());
                        this.gradient = `linear-gradient(to ${this.horizontal?"right":"bottom"}, ${i})`
                    }
                    gradientString(e, i) {
                        i.push(1);
                        const r = [];
                        return e.reverse().forEach((s, o) => {
                            r.push(`${s} ${Math.round(100*i[o])}%`)
                        }), r.join(", ")
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = xn({
                    type: t,
                    selectors: [
                        ["ngx-charts-scale-legend"]
                    ],
                    inputs: {
                        valueRange: "valueRange",
                        colors: "colors",
                        height: "height",
                        width: "width",
                        horizontal: "horizontal"
                    },
                    features: [Xi],
                    decls: 8,
                    vars: 10,
                    consts: [
                        [1, "scale-legend"],
                        [1, "scale-legend-label"],
                        [1, "scale-legend-wrap"]
                    ],
                    template: function(e, i) {
                        1 & e && (J(0, "div", 0)(1, "div", 1)(2, "span"), Oe(3), ce()(), gt(4, "div", 2), J(5, "div", 1)(6, "span"), Oe(7), ce()()()), 2 & e && (jo("height", i.horizontal ? void 0 : i.height, "px")("width", i.width, "px"), ja("horizontal-legend", i.horizontal), he(3), on(i.valueRange[1].toLocaleString()), he(1), jo("background", i.gradient), he(3), on(i.valueRange[0].toLocaleString()))
                    },
                    styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}\n"],
                    encapsulation: 2,
                    changeDetection: 0
                }), t
            })();

            function V0(t) {
                return t instanceof Date ? t.toLocaleDateString() : t.toLocaleString()
            }
            let R8 = (() => {
                    class t {
                        constructor() {
                            this.isActive = !1, this.select = new zt, this.activate = new zt, this.deactivate = new zt, this.toggle = new zt
                        }
                        get trimmedLabel() {
                            return this.formattedLabel || "(empty)"
                        }
                        onMouseEnter() {
                            this.activate.emit({
                                name: this.label
                            })
                        }
                        onMouseLeave() {
                            this.deactivate.emit({
                                name: this.label
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["ngx-charts-legend-entry"]
                        ],
                        hostBindings: function(e, i) {
                            1 & e && xt("mouseenter", function() {
                                return i.onMouseEnter()
                            })("mouseleave", function() {
                                return i.onMouseLeave()
                            })
                        },
                        inputs: {
                            color: "color",
                            label: "label",
                            formattedLabel: "formattedLabel",
                            isActive: "isActive"
                        },
                        outputs: {
                            select: "select",
                            activate: "activate",
                            deactivate: "deactivate",
                            toggle: "toggle"
                        },
                        decls: 4,
                        vars: 6,
                        consts: [
                            ["tabindex", "-1", 3, "title", "click"],
                            [1, "legend-label-color", 3, "click"],
                            [1, "legend-label-text"]
                        ],
                        template: function(e, i) {
                            1 & e && (J(0, "span", 0), xt("click", function() {
                                return i.select.emit(i.formattedLabel)
                            }), J(1, "span", 1), xt("click", function() {
                                return i.toggle.emit(i.formattedLabel)
                            }), ce(), J(2, "span", 2), Oe(3), ce()()), 2 & e && (ja("active", i.isActive), Re("title", i.formattedLabel), he(1), jo("background-color", i.color), he(2), Ln(" ", i.trimmedLabel, " "))
                        },
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                B8 = (() => {
                    class t {
                        constructor(e) {
                            this.cd = e, this.horizontal = !1, this.labelClick = new zt, this.labelActivate = new zt, this.labelDeactivate = new zt, this.legendEntries = []
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        update() {
                            this.cd.markForCheck(), this.legendEntries = this.getLegendEntries()
                        }
                        getLegendEntries() {
                            const e = [];
                            for (const i of this.data) {
                                const r = V0(i); - 1 === e.findIndex(o => o.label === r) && e.push({
                                    label: i,
                                    formattedLabel: r,
                                    color: this.colors.getColor(i)
                                })
                            }
                            return e
                        }
                        isActive(e) {
                            return !!this.activeEntries && void 0 !== this.activeEntries.find(r => e.label === r.name)
                        }
                        activate(e) {
                            this.labelActivate.emit(e)
                        }
                        deactivate(e) {
                            this.labelDeactivate.emit(e)
                        }
                        trackBy(e, i) {
                            return i.label
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(qa))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["ngx-charts-legend"]
                        ],
                        inputs: {
                            data: "data",
                            title: "title",
                            colors: "colors",
                            height: "height",
                            width: "width",
                            activeEntries: "activeEntries",
                            horizontal: "horizontal"
                        },
                        outputs: {
                            labelClick: "labelClick",
                            labelActivate: "labelActivate",
                            labelDeactivate: "labelDeactivate"
                        },
                        features: [Xi],
                        decls: 5,
                        vars: 9,
                        consts: [
                            ["class", "legend-title", 4, "ngIf"],
                            [1, "legend-wrap"],
                            [1, "legend-labels"],
                            ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"],
                            [1, "legend-title"],
                            [1, "legend-title-text"],
                            [1, "legend-label"],
                            [3, "label", "formattedLabel", "color", "isActive", "select", "activate", "deactivate"]
                        ],
                        template: function(e, i) {
                            1 & e && (J(0, "div"), tt(1, lue, 3, 1, "header", 0), J(2, "div", 1)(3, "ul", 2), tt(4, uue, 2, 4, "li", 3), ce()()()), 2 & e && (jo("width", i.width, "px"), he(1), Re("ngIf", (null == i.title ? null : i.title.length) > 0), he(2), jo("max-height", i.height - 45, "px"), ja("horizontal-legend", i.horizontal), he(1), Re("ngForOf", i.legendEntries)("ngForTrackBy", i.trackBy))
                        },
                        dependencies: [R8, ts, Ao],
                        styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                N8 = (() => {
                    class t {
                        constructor() {
                            this.showLegend = !1, this.animations = !0, this.legendLabelClick = new zt, this.legendLabelActivate = new zt, this.legendLabelDeactivate = new zt, this.LegendPosition = Wf, this.LegendType = F0
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        update() {
                            let e = 0;
                            this.showLegend && (this.legendType = this.getLegendType(), (!this.legendOptions || this.legendOptions.position === Wf.Right) && (e = this.legendType === F0.ScaleLegend ? 1 : 2)), this.chartWidth = Math.floor(this.view[0] * (12 - e) / 12), this.legendWidth = this.legendOptions && this.legendOptions.position !== Wf.Right ? this.chartWidth : Math.floor(this.view[0] * e / 12)
                        }
                        getLegendType() {
                            return this.legendOptions.scaleType === gi.Linear ? F0.ScaleLegend : F0.Legend
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["ngx-charts-chart"]
                        ],
                        inputs: {
                            view: "view",
                            showLegend: "showLegend",
                            legendOptions: "legendOptions",
                            legendType: "legendType",
                            activeEntries: "activeEntries",
                            animations: "animations"
                        },
                        outputs: {
                            legendLabelClick: "legendLabelClick",
                            legendLabelActivate: "legendLabelActivate",
                            legendLabelDeactivate: "legendLabelDeactivate"
                        },
                        features: [Jr([OD]), Xi],
                        ngContentSelectors: k8,
                        decls: 5,
                        vars: 8,
                        consts: [
                            [1, "ngx-charts-outer"],
                            [1, "ngx-charts"],
                            ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"],
                            ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"],
                            [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"],
                            [1, "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate"]
                        ],
                        template: function(e, i) {
                            1 & e && (Zd(), J(0, "div", 0), Pn(), J(1, "svg", 1), Ru(2), ce(), tt(3, due, 1, 5, "ngx-charts-scale-legend", 2), tt(4, hue, 1, 7, "ngx-charts-legend", 3), ce()), 2 & e && (jo("width", i.view[0], "px")("height", i.view[1], "px"), he(1), hi("width", i.chartWidth)("height", i.view[1]), he(2), Re("ngIf", i.showLegend && i.legendType === i.LegendType.ScaleLegend), he(1), Re("ngIf", i.showLegend && i.legendType === i.LegendType.Legend))
                        },
                        dependencies: [L8, B8, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                Dhe = (() => {
                    class t {
                        constructor(e, i) {
                            this.element = e, this.zone = i, this.visible = new zt, this.isVisible = !1, this.runCheck()
                        }
                        destroy() {
                            clearTimeout(this.timeout)
                        }
                        onVisibilityChange() {
                            this.zone.run(() => {
                                this.isVisible = !0, this.visible.emit(!0)
                            })
                        }
                        runCheck() {
                            const e = () => {
                                if (!this.element) return;
                                const {
                                    offsetHeight: i,
                                    offsetWidth: r
                                } = this.element.nativeElement;
                                i && r ? (clearTimeout(this.timeout), this.onVisibilityChange()) : (clearTimeout(this.timeout), this.zone.runOutsideAngular(() => {
                                    this.timeout = setTimeout(() => e(), 100)
                                }))
                            };
                            this.zone.runOutsideAngular(() => {
                                this.timeout = setTimeout(() => e())
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(cr))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["visibility-observer"]
                        ],
                        outputs: {
                            visible: "visible"
                        }
                    }), t
                })();

            function F8(t) {
                return "[object Date]" === toString.call(t)
            }
            let V8 = (() => {
                class t {
                    constructor(e, i, r, s) {
                        this.chartElement = e, this.zone = i, this.cd = r, this.platformId = s, this.scheme = "cool", this.schemeType = gi.Ordinal, this.animations = !0, this.select = new zt
                    }
                    ngOnInit() {
                        Oy(this.platformId) && (this.animations = !1)
                    }
                    ngAfterViewInit() {
                        this.bindWindowResizeEvent(), this.visibilityObserver = new Dhe(this.chartElement, this.zone), this.visibilityObserver.visible.subscribe(this.update.bind(this))
                    }
                    ngOnDestroy() {
                        this.unbindEvents(), this.visibilityObserver && (this.visibilityObserver.visible.unsubscribe(), this.visibilityObserver.destroy())
                    }
                    ngOnChanges(e) {
                        this.update()
                    }
                    update() {
                        if (this.results = this.results ? this.cloneData(this.results) : [], this.view) this.width = this.view[0], this.height = this.view[1];
                        else {
                            const e = this.getContainerDims();
                            e && (this.width = e.width, this.height = e.height)
                        }
                        this.width || (this.width = 600), this.height || (this.height = 400), this.width = Math.floor(this.width), this.height = Math.floor(this.height), this.cd && this.cd.markForCheck()
                    }
                    getContainerDims() {
                        let e, i;
                        const r = this.chartElement.nativeElement;
                        if (gc(this.platformId) && null !== r.parentNode) {
                            const s = r.parentNode.getBoundingClientRect();
                            e = s.width, i = s.height
                        }
                        return e && i ? {
                            width: e,
                            height: i
                        } : null
                    }
                    formatDates() {
                        for (let e = 0; e < this.results.length; e++) {
                            const i = this.results[e];
                            if (i.label = i.name, F8(i.label) && (i.label = i.label.toLocaleDateString()), i.series)
                                for (let r = 0; r < i.series.length; r++) {
                                    const s = i.series[r];
                                    s.label = s.name, F8(s.label) && (s.label = s.label.toLocaleDateString())
                                }
                        }
                    }
                    unbindEvents() {
                        this.resizeSubscription && this.resizeSubscription.unsubscribe()
                    }
                    bindWindowResizeEvent() {
                        if (!gc(this.platformId)) return;
                        const i = Sm(window, "resize").pipe(FE(200)).subscribe(r => {
                            this.update(), this.cd && this.cd.markForCheck()
                        });
                        this.resizeSubscription = i
                    }
                    cloneData(e) {
                        const i = [];
                        for (const r of e) {
                            const s = {};
                            if (void 0 !== r.name && (s.name = r.name), void 0 !== r.value && (s.value = r.value), void 0 !== r.series) {
                                s.series = [];
                                for (const o of r.series) {
                                    const a = Object.assign({}, o);
                                    s.series.push(a)
                                }
                            }
                            void 0 !== r.extra && (s.extra = JSON.parse(JSON.stringify(r.extra))), void 0 !== r.source && (s.source = r.source), void 0 !== r.target && (s.target = r.target), i.push(s)
                        }
                        return i
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(We(ir), We(cr), We(qa), We(Bs))
                }, t.\u0275cmp = xn({
                    type: t,
                    selectors: [
                        ["base-chart"]
                    ],
                    inputs: {
                        results: "results",
                        view: "view",
                        scheme: "scheme",
                        schemeType: "schemeType",
                        customColors: "customColors",
                        animations: "animations"
                    },
                    outputs: {
                        select: "select"
                    },
                    features: [Xi],
                    decls: 1,
                    vars: 0,
                    template: function(e, i) {
                        1 & e && gt(0, "div")
                    },
                    encapsulation: 2
                }), t
            })();
            var Wo = function(t) {
                return t.Top = "top", t.Bottom = "bottom", t.Left = "left", t.Right = "right", t
            }(Wo || {});
            let U8 = (() => {
                class t {
                    constructor(e) {
                        this.textHeight = 25, this.margin = 5, this.element = e.nativeElement
                    }
                    ngOnChanges(e) {
                        this.update()
                    }
                    update() {
                        switch (this.strokeWidth = "0.01", this.textAnchor = "middle", this.transform = "", this.orient) {
                            case Wo.Top:
                            case Wo.Bottom:
                                this.y = this.offset, this.x = this.width / 2;
                                break;
                            case Wo.Left:
                                this.y = -(this.offset + this.textHeight + this.margin), this.x = -this.height / 2, this.transform = "rotate(270)";
                                break;
                            case Wo.Right:
                                this.y = this.offset + this.margin, this.x = -this.height / 2, this.transform = "rotate(270)"
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(We(ir))
                }, t.\u0275cmp = xn({
                    type: t,
                    selectors: [
                        ["g", "ngx-charts-axis-label", ""]
                    ],
                    inputs: {
                        orient: "orient",
                        label: "label",
                        offset: "offset",
                        width: "width",
                        height: "height"
                    },
                    features: [Xi],
                    attrs: fue,
                    decls: 2,
                    vars: 6,
                    template: function(e, i) {
                        1 & e && (Pn(), J(0, "text"), Oe(1), ce()), 2 & e && (hi("stroke-width", i.strokeWidth)("x", i.x)("y", i.y)("text-anchor", i.textAnchor)("transform", i.transform), he(1), Ln(" ", i.label, " "))
                    },
                    encapsulation: 2,
                    changeDetection: 0
                }), t
            })();

            function RD(t, n = 16) {
                return "string" != typeof t ? "number" == typeof t ? t + "" : "" : (t = t.trim()).length <= n ? t : `${t.slice(0,n)}...`
            }

            function H8(t, n) {
                if (t.length > n) {
                    const e = [],
                        i = Math.floor(t.length / n);
                    for (let r = 0; r < t.length; r++) r % i == 0 && e.push(t[r]);
                    t = e
                }
                return t
            }

            function $8(t, n, e) {
                const i = (t || "").toString();
                let r = [];
                if (/\s/.test(i)) r = i.split(/\s+/).reduce((s, o) => {
                    const a = (s.pop() || "") + " ";
                    return a.length + o.length > n ? [...s, a.trim(), o.trim()] : [...s, a + o]
                }, []);
                else {
                    let s = 0;
                    for (; s < i.length;) r.push(i.substring(s, s + n)), s += n
                }
                return r.length > e && (r = r.splice(0, e), r[r.length - 1] += "..."), r
            }
            var nd = function(t) {
                return t.Start = "start", t.Middle = "middle", t.End = "end", t
            }(nd || {});
            let z8 = (() => {
                    class t {
                        constructor(e) {
                            this.platformId = e, this.tickArguments = [5], this.tickStroke = "#ccc", this.trimTicks = !0, this.maxTickLength = 16, this.showGridLines = !1, this.rotateTicks = !0, this.wrapTicks = !1, this.dimensionsChanged = new zt, this.verticalSpacing = 20, this.rotateLabels = !1, this.innerTickSize = 6, this.outerTickSize = 6, this.tickPadding = 3, this.textAnchor = nd.Middle, this.maxTicksLength = 0, this.maxAllowedLength = 16, this.height = 0, this.approxHeight = 10, this.maxPossibleLengthForTickIfWrapped = 16
                        }
                        get isWrapTicksSupported() {
                            return this.wrapTicks && this.scale.step
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        ngAfterViewInit() {
                            setTimeout(() => this.updateDims())
                        }
                        updateDims() {
                            if (!gc(this.platformId)) return void this.dimensionsChanged.emit({
                                height: this.approxHeight
                            });
                            const e = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
                            e !== this.height && (this.height = e, this.dimensionsChanged.emit({
                                height: this.height
                            }), setTimeout(() => this.updateDims()))
                        }
                        update() {
                            const e = this.scale;
                            this.ticks = this.getTicks(), this.tickFormat = this.tickFormatting ? this.tickFormatting : e.tickFormat ? e.tickFormat.apply(e, this.tickArguments) : function(r) {
                                return "Date" === r.constructor.name ? r.toLocaleDateString() : r.toLocaleString()
                            };
                            const i = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
                            this.adjustedScale = this.scale.bandwidth ? function(r) {
                                return this.scale(r) + .5 * this.scale.bandwidth()
                            } : this.scale, this.textTransform = "", i && 0 !== i ? (this.textTransform = `rotate(${i})`, this.textAnchor = nd.End, this.verticalSpacing = 10) : this.textAnchor = nd.Middle, setTimeout(() => this.updateDims())
                        }
                        getRotationAngle(e) {
                            let i = 0;
                            this.maxTicksLength = 0;
                            for (let m = 0; m < e.length; m++) {
                                const x = this.tickFormat(e[m]).toString();
                                let D = x.length;
                                this.trimTicks && (D = this.tickTrim(x).length), D > this.maxTicksLength && (this.maxTicksLength = D)
                            }
                            const o = 7 * Math.min(this.maxTicksLength, this.maxAllowedLength);
                            let a = o;
                            const c = Math.floor(this.width / e.length);
                            for (; a > c && i > -90;) i -= 30, a = Math.cos(i * (Math.PI / 180)) * o;
                            let u = 14;
                            if (this.isWrapTicksSupported) {
                                const m = this.ticks.reduce((D, V) => V.length > D.length ? V : D, "");
                                u = 14 * (this.tickChunks(m).length || 1), this.maxPossibleLengthForTickIfWrapped = this.getMaxPossibleLengthForTick(m)
                            }
                            const h = 0 !== i ? Math.max(Math.abs(Math.sin(i * Math.PI / 180)) * this.maxTickLength * 7, 10) : u;
                            return this.approxHeight = Math.min(h, 200), i
                        }
                        getTicks() {
                            let e;
                            const i = this.getMaxTicks(20),
                                r = this.getMaxTicks(100);
                            return this.tickValues ? e = this.tickValues : this.scale.ticks ? e = this.scale.ticks.apply(this.scale, [r]) : (e = this.scale.domain(), e = H8(e, i)), e
                        }
                        getMaxTicks(e) {
                            return Math.floor(this.width / e)
                        }
                        tickTransform(e) {
                            return "translate(" + this.adjustedScale(e) + "," + this.verticalSpacing + ")"
                        }
                        gridLineTransform() {
                            return `translate(0,${-this.verticalSpacing-5})`
                        }
                        tickTrim(e) {
                            return this.trimTicks ? RD(e, this.maxTickLength) : e
                        }
                        getMaxPossibleLengthForTick(e) {
                            if (this.scale.bandwidth) {
                                const r = Math.floor(this.scale.bandwidth() / 7),
                                    s = e.slice(0, r);
                                return Math.max(s.length, this.maxTickLength)
                            }
                            return this.maxTickLength
                        }
                        tickChunks(e) {
                            if (e.toString().length > this.maxTickLength && this.scale.bandwidth) {
                                let r = this.rotateTicks ? Math.floor(this.scale.step() / 14) : 5;
                                if (r <= 1) return [this.tickTrim(e)];
                                let s = Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength);
                                return gc(this.platformId) || (s = Math.floor(Math.min(this.approxHeight / 5, Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength)))), r = Math.min(r, 5), $8(e, s, r < 1 ? 1 : r)
                            }
                            return [this.tickTrim(e)]
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(Bs))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-x-axis-ticks", ""]
                        ],
                        viewQuery: function(e, i) {
                            if (1 & e && $c(M8, 5), 2 & e) {
                                let r;
                                wa(r = xa()) && (i.ticksElement = r.first)
                            }
                        },
                        inputs: {
                            scale: "scale",
                            orient: "orient",
                            tickArguments: "tickArguments",
                            tickValues: "tickValues",
                            tickStroke: "tickStroke",
                            trimTicks: "trimTicks",
                            maxTickLength: "maxTickLength",
                            tickFormatting: "tickFormatting",
                            showGridLines: "showGridLines",
                            gridLineHeight: "gridLineHeight",
                            width: "width",
                            rotateTicks: "rotateTicks",
                            wrapTicks: "wrapTicks"
                        },
                        outputs: {
                            dimensionsChanged: "dimensionsChanged"
                        },
                        features: [Xi],
                        attrs: pue,
                        decls: 4,
                        vars: 2,
                        consts: [
                            ["ticksel", ""],
                            ["class", "tick", 4, "ngFor", "ngForOf"],
                            [4, "ngFor", "ngForOf"],
                            [1, "tick"],
                            [4, "ngIf"],
                            ["stroke-width", "0.01", "font-size", "12px"],
                            [4, "ngIf", "ngIfThen", "ngIfElse"],
                            ["tmplMultilineTick", ""],
                            ["tmplSinglelineTick", ""],
                            ["x", "0", 4, "ngFor", "ngForOf"],
                            ["x", "0"],
                            ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]
                        ],
                        template: function(e, i) {
                            1 & e && (Pn(), J(0, "g", null, 0), tt(2, wue, 2, 2, "g", 1), ce(), tt(3, Cue, 2, 2, "g", 2)), 2 & e && (he(2), Re("ngForOf", i.ticks), he(1), Re("ngForOf", i.ticks))
                        },
                        dependencies: [Ao, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                Ahe = (() => {
                    class t {
                        constructor() {
                            this.rotateTicks = !0, this.showGridLines = !1, this.xOrient = Wo.Bottom, this.xAxisOffset = 0, this.wrapTicks = !1, this.dimensionsChanged = new zt, this.xAxisClassName = "x axis", this.labelOffset = 0, this.fill = "none", this.stroke = "stroke", this.tickStroke = "#ccc", this.strokeWidth = "none", this.padding = 5, this.orientation = Wo
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        update() {
                            this.transform = `translate(0,${this.xAxisOffset+this.padding+this.dims.height})`, typeof this.xAxisTickCount < "u" && (this.tickArguments = [this.xAxisTickCount])
                        }
                        emitTicksHeight({
                            height: e
                        }) {
                            const i = e + 25 + 5;
                            i !== this.labelOffset && (this.labelOffset = i, setTimeout(() => {
                                this.dimensionsChanged.emit({
                                    height: e
                                })
                            }, 0))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-x-axis", ""]
                        ],
                        viewQuery: function(e, i) {
                            if (1 & e && $c(z8, 5), 2 & e) {
                                let r;
                                wa(r = xa()) && (i.ticksComponent = r.first)
                            }
                        },
                        inputs: {
                            xScale: "xScale",
                            dims: "dims",
                            trimTicks: "trimTicks",
                            rotateTicks: "rotateTicks",
                            maxTickLength: "maxTickLength",
                            tickFormatting: "tickFormatting",
                            showGridLines: "showGridLines",
                            showLabel: "showLabel",
                            labelText: "labelText",
                            ticks: "ticks",
                            xAxisTickCount: "xAxisTickCount",
                            xOrient: "xOrient",
                            xAxisOffset: "xAxisOffset",
                            wrapTicks: "wrapTicks"
                        },
                        outputs: {
                            dimensionsChanged: "dimensionsChanged"
                        },
                        features: [Xi],
                        attrs: Tue,
                        decls: 3,
                        vars: 4,
                        consts: [
                            ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks", "dimensionsChanged", 4, "ngIf"],
                            ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"],
                            ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks", "dimensionsChanged"],
                            ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]
                        ],
                        template: function(e, i) {
                            1 & e && (Pn(), J(0, "g"), tt(1, Sue, 1, 13, "g", 0), tt(2, Eue, 1, 5, "g", 1), ce()), 2 & e && (hi("class", i.xAxisClassName)("transform", i.transform), he(1), Re("ngIf", i.xScale), he(1), Re("ngIf", i.showLabel))
                        },
                        dependencies: [z8, U8, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })();

            function ph(t, n, e, i, r, [s, o, a, c]) {
                let u = "";
                return u = `M${[t+r,n]}`, u += "h" + ((e = 0 === (e = Math.floor(e)) ? 1 : e) - 2 * r), u += o ? `a${[r,r]} 0 0 1 ${[r,r]}` : `h${r}v${r}`, u += "v" + ((i = 0 === (i = Math.floor(i)) ? 1 : i) - 2 * r), u += c ? `a${[r,r]} 0 0 1 ${[-r,r]}` : `v${r}h${-r}`, u += "h" + (2 * r - e), u += a ? `a${[r,r]} 0 0 1 ${[-r,-r]}` : `h${-r}v${-r}`, u += "v" + (2 * r - i), u += s ? `a${[r,r]} 0 0 1 ${[r,-r]}` : `v${-r}h${r}`, u += "z", u
            }
            let j8 = (() => {
                    class t {
                        constructor(e) {
                            this.platformId = e, this.tickArguments = [5], this.tickStroke = "#ccc", this.trimTicks = !0, this.maxTickLength = 16, this.showGridLines = !1, this.showRefLabels = !1, this.showRefLines = !1, this.wrapTicks = !1, this.dimensionsChanged = new zt, this.innerTickSize = 6, this.tickPadding = 3, this.verticalSpacing = 20, this.textAnchor = nd.Middle, this.width = 0, this.outerTickSize = 6, this.rotateLabels = !1, this.referenceLineLength = 0, this.Orientation = Wo
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        ngAfterViewInit() {
                            setTimeout(() => this.updateDims())
                        }
                        updateDims() {
                            if (!gc(this.platformId)) return this.width = this.getApproximateAxisWidth(), void this.dimensionsChanged.emit({
                                width: this.width
                            });
                            const e = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
                            e !== this.width && (this.width = e, this.dimensionsChanged.emit({
                                width: e
                            }), setTimeout(() => this.updateDims()))
                        }
                        update() {
                            const e = this.scale,
                                i = this.orient === Wo.Top || this.orient === Wo.Right ? -1 : 1;
                            switch (this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding, this.ticks = this.getTicks(), this.tickFormat = this.tickFormatting ? this.tickFormatting : e.tickFormat ? e.tickFormat.apply(e, this.tickArguments) : function(r) {
                                return "Date" === r.constructor.name ? r.toLocaleDateString() : r.toLocaleString()
                            }, this.adjustedScale = e.bandwidth ? r => {
                                const s = e(r) + .5 * e.bandwidth();
                                if (this.wrapTicks && r.toString().length > this.maxTickLength) {
                                    const o = this.tickChunks(r).length;
                                    if (1 === o) return s;
                                    const u = .5 * e.bandwidth() - 8 * o * .5;
                                    return e(r) + u
                                }
                                return s
                            } : e, this.showRefLines && this.referenceLines && this.setReferencelines(), this.orient) {
                                case Wo.Top:
                                case Wo.Bottom:
                                    this.transform = function(r) {
                                        return "translate(" + this.adjustedScale(r) + ",0)"
                                    }, this.textAnchor = nd.Middle, this.y2 = this.innerTickSize * i, this.y1 = this.tickSpacing * i, this.dy = i < 0 ? "0em" : ".71em";
                                    break;
                                case Wo.Left:
                                    this.transform = function(r) {
                                        return "translate(0," + this.adjustedScale(r) + ")"
                                    }, this.textAnchor = nd.End, this.x2 = this.innerTickSize * -i, this.x1 = this.tickSpacing * -i, this.dy = ".32em";
                                    break;
                                case Wo.Right:
                                    this.transform = function(r) {
                                        return "translate(0," + this.adjustedScale(r) + ")"
                                    }, this.textAnchor = nd.Start, this.x2 = this.innerTickSize * -i, this.x1 = this.tickSpacing * -i, this.dy = ".32em"
                            }
                            setTimeout(() => this.updateDims())
                        }
                        setReferencelines() {
                            this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map(e => e.value))), this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map(e => e.value))), this.referenceLineLength = this.referenceLines.length, this.referenceAreaPath = ph(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [!1, !1, !1, !1])
                        }
                        getTicks() {
                            let e;
                            const i = this.getMaxTicks(20),
                                r = this.getMaxTicks(50);
                            return this.tickValues ? e = this.tickValues : this.scale.ticks ? e = this.scale.ticks.apply(this.scale, [r]) : (e = this.scale.domain(), e = H8(e, i)), e
                        }
                        getMaxTicks(e) {
                            return Math.floor(this.height / e)
                        }
                        tickTransform(e) {
                            return `translate(${this.adjustedScale(e)},${this.verticalSpacing})`
                        }
                        gridLineTransform() {
                            return "translate(5,0)"
                        }
                        tickTrim(e) {
                            return this.trimTicks ? RD(e, this.maxTickLength) : e
                        }
                        getApproximateAxisWidth() {
                            return 7 * Math.max(...this.ticks.map(r => this.tickTrim(this.tickFormat(r)).length))
                        }
                        tickChunks(e) {
                            if (e.toString().length > this.maxTickLength && this.scale.bandwidth) {
                                const i = this.maxTickLength,
                                    r = Math.floor(this.scale.bandwidth() / 15);
                                return r <= 1 ? [this.tickTrim(e)] : $8(e, i, Math.min(r, 5))
                            }
                            return [this.tickFormat(e)]
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(Bs))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-y-axis-ticks", ""]
                        ],
                        viewQuery: function(e, i) {
                            if (1 & e && $c(M8, 5), 2 & e) {
                                let r;
                                wa(r = xa()) && (i.ticksElement = r.first)
                            }
                        },
                        inputs: {
                            scale: "scale",
                            orient: "orient",
                            tickArguments: "tickArguments",
                            tickValues: "tickValues",
                            tickStroke: "tickStroke",
                            trimTicks: "trimTicks",
                            maxTickLength: "maxTickLength",
                            tickFormatting: "tickFormatting",
                            showGridLines: "showGridLines",
                            gridLineWidth: "gridLineWidth",
                            height: "height",
                            referenceLines: "referenceLines",
                            showRefLabels: "showRefLabels",
                            showRefLines: "showRefLines",
                            wrapTicks: "wrapTicks"
                        },
                        outputs: {
                            dimensionsChanged: "dimensionsChanged"
                        },
                        features: [Xi],
                        attrs: Due,
                        decls: 6,
                        vars: 4,
                        consts: [
                            ["ticksel", ""],
                            ["class", "tick", 4, "ngFor", "ngForOf"],
                            ["class", "reference-area", 4, "ngIf"],
                            [4, "ngFor", "ngForOf"],
                            [1, "tick"],
                            [4, "ngIf"],
                            ["stroke-width", "0.01"],
                            [4, "ngIf", "ngIfThen", "ngIfElse"],
                            ["tmplMultilineTick", ""],
                            ["tmplSinglelineTick", ""],
                            [4, "ngIf", "ngIfElse"],
                            ["x", "0", 4, "ngFor", "ngForOf"],
                            ["x", "0"],
                            [1, "reference-area"],
                            ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"],
                            ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"],
                            ["x1", "0", 1, "refline-path", "gridline-path-horizontal"],
                            [1, "refline-label"]
                        ],
                        template: function(e, i) {
                            1 & e && (Pn(), J(0, "g", null, 0), tt(2, Rue, 2, 2, "g", 1), ce(), tt(3, Bue, 1, 2, "path", 2), tt(4, Uue, 2, 2, "g", 3), tt(5, zue, 2, 1, "g", 3)), 2 & e && (he(2), Re("ngForOf", i.ticks), he(1), Re("ngIf", i.referenceLineLength > 1 && i.refMax && i.refMin && i.showRefLines), he(1), Re("ngForOf", i.ticks), he(1), Re("ngForOf", i.referenceLines))
                        },
                        dependencies: [Ao, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                khe = (() => {
                    class t {
                        constructor() {
                            this.showGridLines = !1, this.yOrient = Wo.Left, this.yAxisOffset = 0, this.wrapTicks = !1, this.dimensionsChanged = new zt, this.yAxisClassName = "y axis", this.labelOffset = 15, this.fill = "none", this.stroke = "#CCC", this.tickStroke = "#CCC", this.strokeWidth = 1, this.padding = 5
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        update() {
                            this.offset = -(this.yAxisOffset + this.padding), this.yOrient === Wo.Right ? (this.labelOffset = 65, this.transform = `translate(${this.offset+this.dims.width} , 0)`) : this.transform = `translate(${this.offset} , 0)`, void 0 !== this.yAxisTickCount && (this.tickArguments = [this.yAxisTickCount])
                        }
                        emitTicksWidth({
                            width: e
                        }) {
                            e !== this.labelOffset && this.yOrient === Wo.Right ? (this.labelOffset = e + this.labelOffset, setTimeout(() => {
                                this.dimensionsChanged.emit({
                                    width: e
                                })
                            }, 0)) : e !== this.labelOffset && (this.labelOffset = e, setTimeout(() => {
                                this.dimensionsChanged.emit({
                                    width: e
                                })
                            }, 0))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-y-axis", ""]
                        ],
                        viewQuery: function(e, i) {
                            if (1 & e && $c(j8, 5), 2 & e) {
                                let r;
                                wa(r = xa()) && (i.ticksComponent = r.first)
                            }
                        },
                        inputs: {
                            yScale: "yScale",
                            dims: "dims",
                            trimTicks: "trimTicks",
                            maxTickLength: "maxTickLength",
                            tickFormatting: "tickFormatting",
                            ticks: "ticks",
                            showGridLines: "showGridLines",
                            showLabel: "showLabel",
                            labelText: "labelText",
                            yAxisTickCount: "yAxisTickCount",
                            yOrient: "yOrient",
                            referenceLines: "referenceLines",
                            showRefLines: "showRefLines",
                            showRefLabels: "showRefLabels",
                            yAxisOffset: "yAxisOffset",
                            wrapTicks: "wrapTicks"
                        },
                        outputs: {
                            dimensionsChanged: "dimensionsChanged"
                        },
                        features: [Xi],
                        attrs: jue,
                        decls: 3,
                        vars: 4,
                        consts: [
                            ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks", "dimensionsChanged", 4, "ngIf"],
                            ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"],
                            ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks", "dimensionsChanged"],
                            ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]
                        ],
                        template: function(e, i) {
                            1 & e && (Pn(), J(0, "g"), tt(1, Wue, 1, 15, "g", 0), tt(2, Gue, 1, 5, "g", 1), ce()), 2 & e && (hi("class", i.yAxisClassName)("transform", i.transform), he(1), Re("ngIf", i.yScale), he(1), Re("ngIf", i.showLabel))
                        },
                        dependencies: [j8, U8, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                W8 = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [mc]
                        ]
                    }), t
                })();
            var U0 = function(t) {
                    return t.popover = "popover", t.tooltip = "tooltip", t
                }(U0 || {}),
                Zm = function(t) {
                    return t[t.all = "all"] = "all", t[t.focus = "focus"] = "focus", t[t.mouseover = "mouseover"] = "mouseover", t
                }(Zm || {});
            let BD = (() => {
                    class t {
                        constructor(e, i, r) {
                            this.tooltipService = e, this.viewContainerRef = i, this.renderer = r, this.tooltipCssClass = "", this.tooltipAppendToBody = !0, this.tooltipSpacing = 10, this.tooltipDisabled = !1, this.tooltipShowCaret = !0, this.tooltipPlacement = rr.Top, this.tooltipAlignment = rr.Center, this.tooltipType = U0.popover, this.tooltipCloseOnClickOutside = !0, this.tooltipCloseOnMouseLeave = !0, this.tooltipHideTimeout = 300, this.tooltipShowTimeout = 100, this.tooltipShowEvent = Zm.all, this.tooltipImmediateExit = !1, this.show = new zt, this.hide = new zt
                        }
                        get listensForFocus() {
                            return this.tooltipShowEvent === Zm.all || this.tooltipShowEvent === Zm.focus
                        }
                        get listensForHover() {
                            return this.tooltipShowEvent === Zm.all || this.tooltipShowEvent === Zm.mouseover
                        }
                        ngOnDestroy() {
                            this.hideTooltip(!0)
                        }
                        onFocus() {
                            this.listensForFocus && this.showTooltip()
                        }
                        onBlur() {
                            this.listensForFocus && this.hideTooltip(!0)
                        }
                        onMouseEnter() {
                            this.listensForHover && this.showTooltip()
                        }
                        onMouseLeave(e) {
                            if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
                                if (clearTimeout(this.timeout), this.component && this.component.instance.element.nativeElement.contains(e)) return;
                                this.hideTooltip(this.tooltipImmediateExit)
                            }
                        }
                        onMouseClick() {
                            this.listensForHover && this.hideTooltip(!0)
                        }
                        showTooltip(e) {
                            if (this.component || this.tooltipDisabled) return;
                            const i = e ? 0 : this.tooltipShowTimeout + (navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) ? 400 : 0);
                            clearTimeout(this.timeout), this.timeout = setTimeout(() => {
                                this.tooltipService.destroyAll();
                                const r = this.createBoundOptions();
                                this.component = this.tooltipService.create(r), setTimeout(() => {
                                    this.component && this.addHideListeners(this.component.instance.element.nativeElement)
                                }, 10), this.show.emit(!0)
                            }, i)
                        }
                        addHideListeners(e) {
                            this.mouseEnterContentEvent = this.renderer.listen(e, "mouseenter", () => {
                                clearTimeout(this.timeout)
                            }), this.tooltipCloseOnMouseLeave && (this.mouseLeaveContentEvent = this.renderer.listen(e, "mouseleave", () => {
                                this.hideTooltip(this.tooltipImmediateExit)
                            })), this.tooltipCloseOnClickOutside && (this.documentClickEvent = this.renderer.listen("window", "click", i => {
                                e.contains(i.target) || this.hideTooltip()
                            }))
                        }
                        hideTooltip(e = !1) {
                            if (!this.component) return;
                            const i = () => {
                                this.mouseLeaveContentEvent && this.mouseLeaveContentEvent(), this.mouseEnterContentEvent && this.mouseEnterContentEvent(), this.documentClickEvent && this.documentClickEvent(), this.hide.emit(!0), this.tooltipService.destroy(this.component), this.component = void 0
                            };
                            clearTimeout(this.timeout), e ? i() : this.timeout = setTimeout(i, this.tooltipHideTimeout)
                        }
                        createBoundOptions() {
                            return {
                                title: this.tooltipTitle,
                                template: this.tooltipTemplate,
                                host: this.viewContainerRef.element,
                                placement: this.tooltipPlacement,
                                alignment: this.tooltipAlignment,
                                type: this.tooltipType,
                                showCaret: this.tooltipShowCaret,
                                cssClass: this.tooltipCssClass,
                                spacing: this.tooltipSpacing,
                                context: this.tooltipContext
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(OD), We(Ga), We(Ks))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "ngx-tooltip", ""]
                        ],
                        hostBindings: function(e, i) {
                            1 & e && xt("focusin", function() {
                                return i.onFocus()
                            })("blur", function() {
                                return i.onBlur()
                            })("mouseenter", function() {
                                return i.onMouseEnter()
                            })("mouseleave", function(s) {
                                return i.onMouseLeave(s.target)
                            })("click", function() {
                                return i.onMouseClick()
                            })
                        },
                        inputs: {
                            tooltipCssClass: "tooltipCssClass",
                            tooltipTitle: "tooltipTitle",
                            tooltipAppendToBody: "tooltipAppendToBody",
                            tooltipSpacing: "tooltipSpacing",
                            tooltipDisabled: "tooltipDisabled",
                            tooltipShowCaret: "tooltipShowCaret",
                            tooltipPlacement: "tooltipPlacement",
                            tooltipAlignment: "tooltipAlignment",
                            tooltipType: "tooltipType",
                            tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside",
                            tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave",
                            tooltipHideTimeout: "tooltipHideTimeout",
                            tooltipShowTimeout: "tooltipShowTimeout",
                            tooltipTemplate: "tooltipTemplate",
                            tooltipShowEvent: "tooltipShowEvent",
                            tooltipContext: "tooltipContext",
                            tooltipImmediateExit: "tooltipImmediateExit"
                        },
                        outputs: {
                            show: "show",
                            hide: "hide"
                        }
                    }), t
                })(),
                G8 = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        providers: [O8, OD],
                        imports: [
                            [mc]
                        ]
                    }), t
                })();
            const K8 = {};

            function H0() {
                let t = ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
                return t = `a${t}`, K8[t] ? H0() : (K8[t] = !0, t)
            }
            var _o = function(t) {
                return t.Vertical = "vertical", t.Horizontal = "horizontal", t
            }(_o || {});
            let ND, bx = (() => {
                class t {
                    constructor() {
                        this.orientation = _o.Vertical
                    }
                    ngOnChanges(e) {
                        this.x1 = "0%", this.x2 = "0%", this.y1 = "0%", this.y2 = "0%", this.orientation === _o.Horizontal ? this.x2 = "100%" : this.orientation === _o.Vertical && (this.y1 = "100%")
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = xn({
                    type: t,
                    selectors: [
                        ["g", "ngx-charts-svg-linear-gradient", ""]
                    ],
                    inputs: {
                        orientation: "orientation",
                        name: "name",
                        stops: "stops"
                    },
                    features: [Xi],
                    attrs: Kue,
                    decls: 2,
                    vars: 6,
                    consts: [
                        [3, "id"],
                        [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]
                    ],
                    template: function(e, i) {
                        1 & e && (Pn(), J(0, "linearGradient", 0), tt(1, que, 1, 5, "stop", 1), ce()), 2 & e && (Re("id", i.name), hi("x1", i.x1)("y1", i.y1)("x2", i.x2)("y2", i.y2), he(1), Re("ngForOf", i.stops))
                    },
                    dependencies: [Ao],
                    encapsulation: 2,
                    changeDetection: 0
                }), t
            })();
            typeof window < "u" ? ND = window : typeof global < "u" && (ND = global);
            let Cc = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = _i({
                    type: t
                }), t.\u0275inj = wi({
                    imports: [
                        [mc, W8, G8], mc, W8, G8
                    ]
                }), t
            })();
            const J8 = [{
                name: "vivid",
                selectable: !0,
                group: gi.Ordinal,
                domain: ["#647c8a", "#3f51b5", "#2196f3", "#00b862", "#afdf0a", "#a7b61a", "#f3e562", "#ff9800", "#ff5722", "#ff4514"]
            }, {
                name: "natural",
                selectable: !0,
                group: gi.Ordinal,
                domain: ["#bf9d76", "#e99450", "#d89f59", "#f2dfa7", "#a5d7c6", "#7794b1", "#afafaf", "#707160", "#ba9383", "#d9d5c3"]
            }, {
                name: "cool",
                selectable: !0,
                group: gi.Ordinal,
                domain: ["#a8385d", "#7aa3e5", "#a27ea8", "#aae3f5", "#adcded", "#a95963", "#8796c0", "#7ed3ed", "#50abcc", "#ad6886"]
            }, {
                name: "fire",
                selectable: !0,
                group: gi.Ordinal,
                domain: ["#ff3d00", "#bf360c", "#ff8f00", "#ff6f00", "#ff5722", "#e65100", "#ffca28", "#ffab00"]
            }, {
                name: "solar",
                selectable: !0,
                group: gi.Linear,
                domain: ["#fff8e1", "#ffecb3", "#ffe082", "#ffd54f", "#ffca28", "#ffc107", "#ffb300", "#ffa000", "#ff8f00", "#ff6f00"]
            }, {
                name: "air",
                selectable: !0,
                group: gi.Linear,
                domain: ["#e1f5fe", "#b3e5fc", "#81d4fa", "#4fc3f7", "#29b6f6", "#03a9f4", "#039be5", "#0288d1", "#0277bd", "#01579b"]
            }, {
                name: "aqua",
                selectable: !0,
                group: gi.Linear,
                domain: ["#e0f7fa", "#b2ebf2", "#80deea", "#4dd0e1", "#26c6da", "#00bcd4", "#00acc1", "#0097a7", "#00838f", "#006064"]
            }, {
                name: "flame",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#A10A28", "#D3342D", "#EF6D49", "#FAAD67", "#FDDE90", "#DBED91", "#A9D770", "#6CBA67", "#2C9653", "#146738"]
            }, {
                name: "ocean",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#1D68FB", "#33C0FC", "#4AFFFE", "#AFFFFF", "#FFFC63", "#FDBD2D", "#FC8A25", "#FA4F1E", "#FA141B", "#BA38D1"]
            }, {
                name: "forest",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#55C22D", "#C1F33D", "#3CC099", "#AFFFFF", "#8CFC9D", "#76CFFA", "#BA60FB", "#EE6490", "#C42A1C", "#FC9F32"]
            }, {
                name: "horizon",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#2597FB", "#65EBFD", "#99FDD0", "#FCEE4B", "#FEFCFA", "#FDD6E3", "#FCB1A8", "#EF6F7B", "#CB96E8", "#EFDEE0"]
            }, {
                name: "neons",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#FF3333", "#FF33FF", "#CC33FF", "#0000FF", "#33CCFF", "#33FFFF", "#33FF66", "#CCFF33", "#FFCC00", "#FF6600"]
            }, {
                name: "picnic",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#FAC51D", "#66BD6D", "#FAA026", "#29BB9C", "#E96B56", "#55ACD2", "#B7332F", "#2C83C9", "#9166B8", "#92E7E8"]
            }, {
                name: "night",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#2B1B5A", "#501356", "#183356", "#28203F", "#391B3C", "#1E2B3C", "#120634", "#2D0432", "#051932", "#453080", "#75267D", "#2C507D", "#4B3880", "#752F7D", "#35547D"]
            }, {
                name: "nightLights",
                selectable: !1,
                group: gi.Ordinal,
                domain: ["#4e31a5", "#9c25a7", "#3065ab", "#57468b", "#904497", "#46648b", "#32118d", "#a00fb3", "#1052a2", "#6e51bd", "#b63cc3", "#6c97cb", "#8671c1", "#b455be", "#7496c3"]
            }];
            class Nhe {
                constructor(n, e, i, r) {
                    "string" == typeof n && (n = J8.find(s => s.name === n)), this.colorDomain = n.domain, this.scaleType = e, this.domain = i, this.customColors = r, this.scale = this.generateColorScheme(n, e, this.domain)
                }
                generateColorScheme(n, e, i) {
                    let r;
                    switch ("string" == typeof n && (n = J8.find(s => s.name === n)), e) {
                        case gi.Quantile:
                            r = A8().range(n.domain).domain(i);
                            break;
                        case gi.Ordinal:
                            r = PD().range(n.domain).domain(i);
                            break;
                        case gi.Linear:
                            {
                                const s = [...n.domain];1 === s.length && (s.push(s[0]), this.colorDomain = s);
                                const o = w8(0, 1, 1 / s.length);r = qm().range(s).domain(o)
                            }
                    }
                    return r
                }
                getColor(n) {
                    if (null == n) throw new Error("Value can not be null");
                    if (this.scaleType === gi.Linear) {
                        const e = qm().domain(this.domain).range([0, 1]);
                        return this.scale(e(n))
                    } {
                        if ("function" == typeof this.customColors) return this.customColors(n);
                        const e = n.toString();
                        let i;
                        return this.customColors && this.customColors.length > 0 && (i = this.customColors.find(r => r.name.toLowerCase() === e.toLowerCase())), i ? i.value : this.scale(n)
                    }
                }
                getLinearGradientStops(n, e) {
                    void 0 === e && (e = this.domain[0]);
                    const i = qm().domain(this.domain).range([0, 1]),
                        r = vx().domain(this.colorDomain).range([0, 1]),
                        s = this.getColor(n),
                        o = i(e),
                        a = this.getColor(e),
                        c = i(n);
                    let u = 1,
                        h = o;
                    const m = [];
                    for (m.push({
                            color: a,
                            offset: o,
                            originalOffset: o,
                            opacity: 1
                        }); h < c && u < this.colorDomain.length;) {
                        const x = this.colorDomain[u],
                            D = r(x);
                        if (D <= o) u++;
                        else {
                            if (D.toFixed(4) >= (c - r.bandwidth()).toFixed(4)) break;
                            m.push({
                                color: x,
                                offset: D,
                                opacity: 1
                            }), h = D, u++
                        }
                    }
                    if (m[m.length - 1].offset < 100 && m.push({
                            color: s,
                            offset: c,
                            opacity: 1
                        }), c === o) m[0].offset = 0, m[1].offset = 100;
                    else if (100 !== m[m.length - 1].offset)
                        for (const x of m) x.offset = (x.offset - o) / (c - o) * 100;
                    return m
                }
            }
            let Vhe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                Uhe = (() => {
                    class t {
                        constructor(e) {
                            this.roundEdges = !0, this.gradient = !1, this.offset = 0, this.isActive = !1, this.animations = !0, this.noBarWhenZero = !0, this.select = new zt, this.activate = new zt, this.deactivate = new zt, this.hasGradient = !1, this.hideBar = !1, this.element = e.nativeElement
                        }
                        ngOnChanges(e) {
                            e.roundEdges && this.loadAnimation(), this.update()
                        }
                        update() {
                            this.gradientId = "grad" + H0().toString(), this.gradientFill = `url(#${this.gradientId})`, this.gradient || this.stops ? (this.gradientStops = this.getGradient(), this.hasGradient = !0) : this.hasGradient = !1, this.updatePathEl(), this.checkToHideBar()
                        }
                        loadAnimation() {
                            this.path = this.getStartingPath(), setTimeout(this.update.bind(this), 100)
                        }
                        updatePathEl() {
                            const e = function Gc(t) {
                                    return "string" == typeof t ? new wc([
                                        [document.querySelector(t)]
                                    ], [document.documentElement]) : new wc([
                                        [t]
                                    ], jF)
                                }(this.element).select(".bar"),
                                i = this.getPath();
                            this.animations ? e.transition().duration(500).attr("d", i) : e.attr("d", i)
                        }
                        getGradient() {
                            return this.stops ? this.stops : [{
                                offset: 0,
                                color: this.fill,
                                opacity: this.getStartOpacity()
                            }, {
                                offset: 100,
                                color: this.fill,
                                opacity: 1
                            }]
                        }
                        getStartingPath() {
                            if (!this.animations) return this.getPath();
                            let i, e = this.getRadius();
                            return this.roundEdges ? this.orientation === _o.Vertical ? (e = Math.min(this.height, e), i = ph(this.x, this.y + this.height, this.width, 1, 0, this.edges)) : this.orientation === _o.Horizontal && (e = Math.min(this.width, e), i = ph(this.x, this.y, 1, this.height, 0, this.edges)) : this.orientation === _o.Vertical ? i = ph(this.x, this.y + this.height, this.width, 1, 0, this.edges) : this.orientation === _o.Horizontal && (i = ph(this.x, this.y, 1, this.height, 0, this.edges)), i
                        }
                        getPath() {
                            let i, e = this.getRadius();
                            return this.roundEdges ? this.orientation === _o.Vertical ? (e = Math.min(this.height, e), i = ph(this.x, this.y, this.width, this.height, e, this.edges)) : this.orientation === _o.Horizontal && (e = Math.min(this.width, e), i = ph(this.x, this.y, this.width, this.height, e, this.edges)) : i = ph(this.x, this.y, this.width, this.height, e, this.edges), i
                        }
                        getRadius() {
                            let e = 0;
                            return this.roundEdges && this.height > 5 && this.width > 5 && (e = Math.floor(Math.min(5, this.height / 2, this.width / 2))), e
                        }
                        getStartOpacity() {
                            return this.roundEdges ? .2 : .5
                        }
                        get edges() {
                            let e = [!1, !1, !1, !1];
                            return this.roundEdges && (this.orientation === _o.Vertical ? e = this.data.value > 0 ? [!0, !0, !1, !1] : [!1, !1, !0, !0] : this.orientation === _o.Horizontal && (e = this.data.value > 0 ? [!1, !0, !1, !0] : [!0, !1, !0, !1])), e
                        }
                        onMouseEnter() {
                            this.activate.emit(this.data)
                        }
                        onMouseLeave() {
                            this.deactivate.emit(this.data)
                        }
                        checkToHideBar() {
                            this.hideBar = this.noBarWhenZero && (this.orientation === _o.Vertical && 0 === this.height || this.orientation === _o.Horizontal && 0 === this.width)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-bar", ""]
                        ],
                        hostBindings: function(e, i) {
                            1 & e && xt("mouseenter", function() {
                                return i.onMouseEnter()
                            })("mouseleave", function() {
                                return i.onMouseLeave()
                            })
                        },
                        inputs: {
                            fill: "fill",
                            data: "data",
                            width: "width",
                            height: "height",
                            x: "x",
                            y: "y",
                            orientation: "orientation",
                            roundEdges: "roundEdges",
                            gradient: "gradient",
                            offset: "offset",
                            isActive: "isActive",
                            stops: "stops",
                            animations: "animations",
                            ariaLabel: "ariaLabel",
                            noBarWhenZero: "noBarWhenZero"
                        },
                        outputs: {
                            select: "select",
                            activate: "activate",
                            deactivate: "deactivate"
                        },
                        features: [Xi],
                        attrs: kde,
                        decls: 2,
                        vars: 8,
                        consts: [
                            [4, "ngIf"],
                            ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"],
                            ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]
                        ],
                        template: function(e, i) {
                            1 & e && (tt(0, Mde, 2, 3, "defs", 0), Pn(), J(1, "path", 1), xt("click", function() {
                                return i.select.emit(i.data)
                            }), ce()), 2 & e && (Re("ngIf", i.hasGradient), he(1), ja("active", i.isActive)("hidden", i.hideBar), hi("d", i.path)("aria-label", i.ariaLabel)("fill", i.hasGradient ? i.gradientFill : i.fill))
                        },
                        dependencies: [bx, ts],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })();
            var mh = function(t) {
                    return t.Standard = "standard", t.Normalized = "normalized", t.Stacked = "stacked", t
                }(mh || {}),
                Ym = function(t) {
                    return t.positive = "positive", t.negative = "negative", t
                }(Ym || {});
            let Hhe = (() => {
                    class t {
                        constructor(e) {
                            this.dimensionsChanged = new zt, this.horizontalPadding = 2, this.verticalPadding = 5, this.element = e.nativeElement
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        getSize() {
                            return {
                                height: this.element.getBoundingClientRect().height,
                                width: this.element.getBoundingClientRect().width,
                                negative: this.value < 0
                            }
                        }
                        ngAfterViewInit() {
                            this.dimensionsChanged.emit(this.getSize())
                        }
                        update() {
                            this.formatedValue = this.valueFormatting ? this.valueFormatting(this.value) : V0(this.value), "horizontal" === this.orientation ? (this.x = this.barX + this.barWidth, this.value < 0 ? (this.x = this.x - this.horizontalPadding, this.textAnchor = "end") : (this.x = this.x + this.horizontalPadding, this.textAnchor = "start"), this.y = this.barY + this.barHeight / 2) : (this.x = this.barX + this.barWidth / 2, this.y = this.barY + this.barHeight, this.value < 0 ? (this.y = this.y + this.verticalPadding, this.textAnchor = "end") : (this.y = this.y - this.verticalPadding, this.textAnchor = "start"), this.transform = `rotate(-45, ${this.x} , ${this.y})`)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-bar-label", ""]
                        ],
                        inputs: {
                            value: "value",
                            valueFormatting: "valueFormatting",
                            barX: "barX",
                            barY: "barY",
                            barWidth: "barWidth",
                            barHeight: "barHeight",
                            orientation: "orientation"
                        },
                        outputs: {
                            dimensionsChanged: "dimensionsChanged"
                        },
                        features: [Xi],
                        attrs: Ide,
                        decls: 2,
                        vars: 5,
                        consts: [
                            ["alignment-baseline", "middle", 1, "textDataLabel"]
                        ],
                        template: function(e, i) {
                            1 & e && (Pn(), J(0, "text", 0), Oe(1), ce()), 2 & e && (hi("text-anchor", i.textAnchor)("transform", i.transform)("x", i.x)("y", i.y), he(1), Ln(" ", i.formatedValue, " "))
                        },
                        styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"],
                        changeDetection: 0
                    }), t
                })(),
                $he = (() => {
                    class t {
                        constructor(e) {
                            this.platformId = e, this.type = mh.Standard, this.tooltipDisabled = !1, this.animations = !0, this.showDataLabel = !1, this.noBarWhenZero = !0, this.select = new zt, this.activate = new zt, this.deactivate = new zt, this.dataLabelHeightChanged = new zt, this.barsForDataLabels = [], this.barOrientation = _o, this.isSSR = !1
                        }
                        ngOnInit() {
                            Oy(this.platformId) && (this.isSSR = !0)
                        }
                        ngOnChanges(e) {
                            this.update()
                        }
                        update() {
                            let e;
                            this.updateTooltipSettings(), this.series.length && (e = this.xScale.bandwidth()), e = Math.round(e);
                            const i = Math.max(this.yScale.domain()[0], 0),
                                r = {
                                    [Ym.positive]: 0,
                                    [Ym.negative]: 0
                                };
                            let o, s = Ym.positive;
                            this.type === mh.Normalized && (o = this.series.map(a => a.value).reduce((a, c) => a + c, 0)), this.bars = this.series.map((a, c) => {
                                let u = a.value;
                                const h = this.getLabel(a),
                                    m = V0(h);
                                s = u > 0 ? Ym.positive : Ym.negative;
                                const D = {
                                    value: u,
                                    label: h,
                                    roundEdges: this.roundEdges,
                                    data: a,
                                    width: e,
                                    formattedLabel: m,
                                    height: 0,
                                    x: 0,
                                    y: 0
                                };
                                if (this.type === mh.Standard) D.height = Math.abs(this.yScale(u) - this.yScale(i)), D.x = this.xScale(h), D.y = this.yScale(u < 0 ? 0 : u);
                                else if (this.type === mh.Stacked) {
                                    const te = r[s],
                                        ee = te + u;
                                    r[s] += u, D.height = this.yScale(te) - this.yScale(ee), D.x = 0, D.y = this.yScale(ee), D.offset0 = te, D.offset1 = ee
                                } else if (this.type === mh.Normalized) {
                                    let te = r[s],
                                        ee = te + u;
                                    r[s] += u, o > 0 ? (te = 100 * te / o, ee = 100 * ee / o) : (te = 0, ee = 0), D.height = this.yScale(te) - this.yScale(ee), D.x = 0, D.y = this.yScale(ee), D.offset0 = te, D.offset1 = ee, u = (ee - te).toFixed(2) + "%"
                                }
                                this.colors.scaleType === gi.Ordinal ? D.color = this.colors.getColor(h) : this.type === mh.Standard ? (D.color = this.colors.getColor(u), D.gradientStops = this.colors.getLinearGradientStops(u)) : (D.color = this.colors.getColor(D.offset1), D.gradientStops = this.colors.getLinearGradientStops(D.offset1, D.offset0));
                                let V = m;
                                return D.ariaLabel = m + " " + u.toLocaleString(), null != this.seriesName && (V = `${this.seriesName} \u2022 ${m}`, D.data.series = this.seriesName, D.ariaLabel = this.seriesName + " " + D.ariaLabel), D.tooltipText = this.tooltipDisabled ? void 0 : `\n        <span class="tooltip-label">${function LD(t){return t.toLocaleString().replace(/[&'`"<>]/g,n=>({"&":"&amp;","'":"&#x27;","`":"&#x60;",'"':"&quot;","<":"&lt;",">":"&gt;"}[n]))}(V)}</span>\n        <span class="tooltip-val">${this.dataLabelFormatting?this.dataLabelFormatting(u):u.toLocaleString()}</span>\n      `, D
                            }), this.updateDataLabels()
                        }
                        updateDataLabels() {
                            if (this.type === mh.Stacked) {
                                this.barsForDataLabels = [];
                                const e = {};
                                e.series = this.seriesName;
                                const i = this.series.map(s => s.value).reduce((s, o) => o > 0 ? s + o : s, 0),
                                    r = this.series.map(s => s.value).reduce((s, o) => o < 0 ? s + o : s, 0);
                                e.total = i + r, e.x = 0, e.y = 0, e.height = this.yScale(e.total > 0 ? i : r), e.width = this.xScale.bandwidth(), this.barsForDataLabels.push(e)
                            } else this.barsForDataLabels = this.series.map(e => {
                                const i = {};
                                return i.series = this.seriesName ? ? e.label, i.total = e.value, i.x = this.xScale(e.label), i.y = this.yScale(0), i.height = this.yScale(i.total) - this.yScale(0), i.width = this.xScale.bandwidth(), i
                            })
                        }
                        updateTooltipSettings() {
                            this.tooltipPlacement = this.tooltipDisabled ? void 0 : rr.Top, this.tooltipType = this.tooltipDisabled ? void 0 : U0.tooltip
                        }
                        isActive(e) {
                            return !!this.activeEntries && void 0 !== this.activeEntries.find(r => e.name === r.name && e.value === r.value)
                        }
                        onClick(e) {
                            this.select.emit(e)
                        }
                        getLabel(e) {
                            return e.label ? e.label : e.name
                        }
                        trackBy(e, i) {
                            return i.label
                        }
                        trackDataLabelBy(e, i) {
                            return e + "#" + i.series + "#" + i.total
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(Bs))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["g", "ngx-charts-series-vertical", ""]
                        ],
                        inputs: {
                            dims: "dims",
                            type: "type",
                            series: "series",
                            xScale: "xScale",
                            yScale: "yScale",
                            colors: "colors",
                            gradient: "gradient",
                            activeEntries: "activeEntries",
                            seriesName: "seriesName",
                            tooltipDisabled: "tooltipDisabled",
                            tooltipTemplate: "tooltipTemplate",
                            roundEdges: "roundEdges",
                            animations: "animations",
                            showDataLabel: "showDataLabel",
                            dataLabelFormatting: "dataLabelFormatting",
                            noBarWhenZero: "noBarWhenZero"
                        },
                        outputs: {
                            select: "select",
                            activate: "activate",
                            deactivate: "deactivate",
                            dataLabelHeightChanged: "dataLabelHeightChanged"
                        },
                        features: [Xi],
                        attrs: Vde,
                        decls: 3,
                        vars: 3,
                        consts: [
                            [4, "ngIf"],
                            ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"],
                            ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate"],
                            ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"],
                            ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]
                        ],
                        template: function(e, i) {
                            1 & e && (tt(0, Hde, 2, 2, "g", 0), tt(1, zde, 2, 2, "g", 0), tt(2, Wde, 2, 2, "g", 0)), 2 & e && (Re("ngIf", !i.isSSR), he(1), Re("ngIf", i.isSSR), he(1), Re("ngIf", i.showDataLabel))
                        },
                        dependencies: [Uhe, Hhe, ts, Ao, BD],
                        encapsulation: 2,
                        data: {
                            animation: [Lb("animationState", [vm(":leave", [ko({
                                opacity: 1
                            }), $u(500, ko({
                                opacity: 0
                            }))])])]
                        },
                        changeDetection: 0
                    }), t
                })(),
                zhe = (() => {
                    class t extends V8 {
                        constructor() {
                            super(...arguments), this.legend = !1, this.legendTitle = "Legend", this.legendPosition = Wf.Right, this.tooltipDisabled = !1, this.showGridLines = !0, this.activeEntries = [], this.trimXAxisTicks = !0, this.trimYAxisTicks = !0, this.rotateXAxisTicks = !0, this.maxXAxisTickLength = 16, this.maxYAxisTickLength = 16, this.barPadding = 8, this.roundDomains = !1, this.roundEdges = !0, this.showDataLabel = !1, this.noBarWhenZero = !0, this.wrapTicks = !1, this.activate = new zt, this.deactivate = new zt, this.margin = [10, 20, 10, 20], this.xAxisHeight = 0, this.yAxisWidth = 0, this.dataLabelMaxHeight = {
                                negative: 0,
                                positive: 0
                            }
                        }
                        update() {
                            super.update(), this.showDataLabel || (this.dataLabelMaxHeight = {
                                negative: 0,
                                positive: 0
                            }), this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20], this.dims = function Bhe({
                                width: t,
                                height: n,
                                margins: e,
                                showXAxis: i = !1,
                                showYAxis: r = !1,
                                xAxisHeight: s = 0,
                                yAxisWidth: o = 0,
                                showXLabel: a = !1,
                                showYLabel: c = !1,
                                showLegend: u = !1,
                                legendType: h = gi.Ordinal,
                                legendPosition: m = Wf.Right,
                                columns: x = 12
                            }) {
                                let D = e[3],
                                    V = t,
                                    te = n - e[0] - e[2];
                                return u && m === Wf.Right && (x -= h === gi.Ordinal ? 2 : 1), V = V * x / 12, V = V - e[1] - e[3], i && (te -= 5, te -= s, a && (te -= 30)), r && (V -= 5, V -= o, D += o, D += 10, c && (V -= 30, D += 30)), V = Math.max(0, V), te = Math.max(0, te), {
                                    width: Math.floor(V),
                                    height: Math.floor(te),
                                    xOffset: Math.floor(D)
                                }
                            }({
                                width: this.width,
                                height: this.height,
                                margins: this.margin,
                                showXAxis: this.xAxis,
                                showYAxis: this.yAxis,
                                xAxisHeight: this.xAxisHeight,
                                yAxisWidth: this.yAxisWidth,
                                showXLabel: this.showXAxisLabel,
                                showYLabel: this.showYAxisLabel,
                                showLegend: this.legend,
                                legendType: this.schemeType,
                                legendPosition: this.legendPosition
                            }), this.formatDates(), this.showDataLabel && (this.dims.height -= this.dataLabelMaxHeight.negative), this.xScale = this.getXScale(), this.yScale = this.getYScale(), this.setColors(), this.legendOptions = this.getLegendOptions(), this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]+this.dataLabelMaxHeight.negative})`
                        }
                        getXScale() {
                            this.xDomain = this.getXDomain();
                            const e = this.xDomain.length / (this.dims.width / this.barPadding + 1);
                            return vx().range([0, this.dims.width]).paddingInner(e).domain(this.xDomain)
                        }
                        getYScale() {
                            this.yDomain = this.getYDomain();
                            const e = qm().range([this.dims.height, 0]).domain(this.yDomain);
                            return this.roundDomains ? e.nice() : e
                        }
                        getXDomain() {
                            return this.results.map(e => e.label)
                        }
                        getYDomain() {
                            const e = this.results.map(s => s.value);
                            let i = this.yScaleMin ? Math.min(this.yScaleMin, ...e) : Math.min(0, ...e);
                            this.yAxisTicks && !this.yAxisTicks.some(isNaN) && (i = Math.min(i, ...this.yAxisTicks));
                            let r = this.yScaleMax ? Math.max(this.yScaleMax, ...e) : Math.max(0, ...e);
                            return this.yAxisTicks && !this.yAxisTicks.some(isNaN) && (r = Math.max(r, ...this.yAxisTicks)), [i, r]
                        }
                        onClick(e) {
                            this.select.emit(e)
                        }
                        setColors() {
                            let e;
                            e = this.schemeType === gi.Ordinal ? this.xDomain : this.yDomain, this.colors = new Nhe(this.scheme, this.schemeType, e, this.customColors)
                        }
                        getLegendOptions() {
                            const e = {
                                scaleType: this.schemeType,
                                colors: void 0,
                                domain: [],
                                title: void 0,
                                position: this.legendPosition
                            };
                            return e.scaleType === gi.Ordinal ? (e.domain = this.xDomain, e.colors = this.colors, e.title = this.legendTitle) : (e.domain = this.yDomain, e.colors = this.colors.scale), e
                        }
                        updateYAxisWidth({
                            width: e
                        }) {
                            this.yAxisWidth = e, this.update()
                        }
                        updateXAxisHeight({
                            height: e
                        }) {
                            this.xAxisHeight = e, this.update()
                        }
                        onDataLabelMaxHeightChanged(e) {
                            e.size.negative ? this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, e.size.height) : this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, e.size.height), e.index === this.results.length - 1 && setTimeout(() => this.update())
                        }
                        onActivate(e, i = !1) {
                            e = this.results.find(s => i ? s.label === e.name : s.name === e.name), !(this.activeEntries.findIndex(s => s.name === e.name && s.value === e.value && s.series === e.series) > -1) && (this.activeEntries = [e, ...this.activeEntries], this.activate.emit({
                                value: e,
                                entries: this.activeEntries
                            }))
                        }
                        onDeactivate(e, i = !1) {
                            e = this.results.find(s => i ? s.label === e.name : s.name === e.name);
                            const r = this.activeEntries.findIndex(s => s.name === e.name && s.value === e.value && s.series === e.series);
                            this.activeEntries.splice(r, 1), this.activeEntries = [...this.activeEntries], this.deactivate.emit({
                                value: e,
                                entries: this.activeEntries
                            })
                        }
                    }
                    return t.\u0275fac = function() {
                        let n;
                        return function(i) {
                            return (n || (n = ys(t)))(i || t)
                        }
                    }(), t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["ngx-charts-bar-vertical"]
                        ],
                        contentQueries: function(e, i, r) {
                            if (1 & e && ub(r, wde, 5), 2 & e) {
                                let s;
                                wa(s = xa()) && (i.tooltipTemplate = s.first)
                            }
                        },
                        inputs: {
                            legend: "legend",
                            legendTitle: "legendTitle",
                            legendPosition: "legendPosition",
                            xAxis: "xAxis",
                            yAxis: "yAxis",
                            showXAxisLabel: "showXAxisLabel",
                            showYAxisLabel: "showYAxisLabel",
                            xAxisLabel: "xAxisLabel",
                            yAxisLabel: "yAxisLabel",
                            tooltipDisabled: "tooltipDisabled",
                            gradient: "gradient",
                            showGridLines: "showGridLines",
                            activeEntries: "activeEntries",
                            schemeType: "schemeType",
                            trimXAxisTicks: "trimXAxisTicks",
                            trimYAxisTicks: "trimYAxisTicks",
                            rotateXAxisTicks: "rotateXAxisTicks",
                            maxXAxisTickLength: "maxXAxisTickLength",
                            maxYAxisTickLength: "maxYAxisTickLength",
                            xAxisTickFormatting: "xAxisTickFormatting",
                            yAxisTickFormatting: "yAxisTickFormatting",
                            xAxisTicks: "xAxisTicks",
                            yAxisTicks: "yAxisTicks",
                            barPadding: "barPadding",
                            roundDomains: "roundDomains",
                            roundEdges: "roundEdges",
                            yScaleMax: "yScaleMax",
                            yScaleMin: "yScaleMin",
                            showDataLabel: "showDataLabel",
                            dataLabelFormatting: "dataLabelFormatting",
                            noBarWhenZero: "noBarWhenZero",
                            wrapTicks: "wrapTicks"
                        },
                        outputs: {
                            activate: "activate",
                            deactivate: "deactivate"
                        },
                        features: [Vr],
                        decls: 5,
                        vars: 25,
                        consts: [
                            [3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"],
                            [1, "bar-chart", "chart"],
                            ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"],
                            ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"],
                            ["ngx-charts-series-vertical", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero", "activate", "deactivate", "select", "dataLabelHeightChanged"],
                            ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged"],
                            ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged"]
                        ],
                        template: function(e, i) {
                            1 & e && (J(0, "ngx-charts-chart", 0), xt("legendLabelClick", function(s) {
                                return i.onClick(s)
                            })("legendLabelActivate", function(s) {
                                return i.onActivate(s, !0)
                            })("legendLabelDeactivate", function(s) {
                                return i.onDeactivate(s, !0)
                            }), Pn(), J(1, "g", 1), tt(2, Gde, 1, 12, "g", 2), tt(3, Kde, 1, 10, "g", 3), J(4, "g", 4), xt("activate", function(s) {
                                return i.onActivate(s)
                            })("deactivate", function(s) {
                                return i.onDeactivate(s)
                            })("select", function(s) {
                                return i.onClick(s)
                            })("dataLabelHeightChanged", function(s) {
                                return i.onDataLabelMaxHeightChanged(s)
                            }), ce()()()), 2 & e && (Re("view", yl(22, N0, i.width, i.height))("showLegend", i.legend)("legendOptions", i.legendOptions)("activeEntries", i.activeEntries)("animations", i.animations), he(1), hi("transform", i.transform), he(1), Re("ngIf", i.xAxis), he(1), Re("ngIf", i.yAxis), he(1), Re("xScale", i.xScale)("yScale", i.yScale)("colors", i.colors)("series", i.results)("dims", i.dims)("gradient", i.gradient)("tooltipDisabled", i.tooltipDisabled)("tooltipTemplate", i.tooltipTemplate)("showDataLabel", i.showDataLabel)("dataLabelFormatting", i.dataLabelFormatting)("activeEntries", i.activeEntries)("roundEdges", i.roundEdges)("animations", i.animations)("noBarWhenZero", i.noBarWhenZero))
                        },
                        dependencies: [N8, Ahe, khe, $he, ts],
                        styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                eV = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })();
            iue();
            let jhe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                Whe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                Ghe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                tV = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })();
            Math;
            let VD = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                Zhe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc, VD, tV]
                        ]
                    }), t
                })(),
                Xhe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                Qhe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                efe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc, VD, eV]
                        ]
                    }), t
                })(),
                nfe = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [
                            [Cc]
                        ]
                    }), t
                })(),
                ife = (() => {
                    class t {
                        constructor() {
                            ! function tfe() {
                                typeof SVGElement < "u" && typeof SVGElement.prototype.contains > "u" && (SVGElement.prototype.contains = HTMLDivElement.prototype.contains)
                            }()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [Cc, Vhe, eV, jhe, Whe, Ghe, nfe, tV, Zhe, Xhe, VD, Qhe, efe]
                    }), t
                })();
            const nV = "400ms cubic-bezier(0.4,0.0,0.2,1)",
                rfe = [ko({
                    height: 0,
                    visibility: "hidden"
                }), $u(nV, ko({
                    height: "*",
                    visibility: "visible"
                }))],
                sfe = [ko({
                    height: "*",
                    visibility: "visible"
                }), $u(nV, ko({
                    height: 0,
                    visibility: "hidden"
                }))];
            let ofe = (() => {
                    class t {
                        constructor(e, i, r) {
                            this._el = e, this._renderer = i, this.collapsed = new zt, this.collapses = new zt, this.expanded = new zt, this.expands = new zt, this.isExpanded = !0, this.collapseNewValue = !0, this.isCollapsed = !1, this.isCollapse = !0, this.isCollapsing = !1, this.isAnimated = !1, this._display = "block", this._stylesLoaded = !1, this._COLLAPSE_ACTION_NAME = "collapse", this._EXPAND_ACTION_NAME = "expand", this._factoryCollapseAnimation = r.build(sfe), this._factoryExpandAnimation = r.build(rfe)
                        }
                        set display(e) {
                            this._display = e, "none" !== e ? this.isAnimated ? this.toggle() : this.show() : this.hide()
                        }
                        set collapse(e) {
                            this.collapseNewValue = e, (!this._player || this._isAnimationDone) && (this.isExpanded = e, this.toggle())
                        }
                        get collapse() {
                            return this.isExpanded
                        }
                        ngAfterViewChecked() {
                            this._stylesLoaded = !0, this._player && this._isAnimationDone && (this._player.reset(), this._renderer.setStyle(this._el.nativeElement, "height", "*"))
                        }
                        toggle() {
                            this.isExpanded ? this.hide() : this.show()
                        }
                        hide() {
                            this.isCollapsing = !0, this.isExpanded = !1, this.isCollapsed = !0, this.isCollapsing = !1, this.collapses.emit(this), this._isAnimationDone = !1, this.animationRun(this.isAnimated, this._COLLAPSE_ACTION_NAME)(() => {
                                this._isAnimationDone = !0, this.collapseNewValue !== this.isCollapsed && this.isAnimated ? this.show() : (this.collapsed.emit(this), this._renderer.setStyle(this._el.nativeElement, "display", "none"))
                            })
                        }
                        show() {
                            this._renderer.setStyle(this._el.nativeElement, "display", this._display), this.isCollapsing = !0, this.isExpanded = !0, this.isCollapsed = !1, this.isCollapsing = !1, this.expands.emit(this), this._isAnimationDone = !1, this.animationRun(this.isAnimated, this._EXPAND_ACTION_NAME)(() => {
                                this._isAnimationDone = !0, this.collapseNewValue !== this.isCollapsed && this.isAnimated ? this.hide() : (this.expanded.emit(this), this._renderer.removeStyle(this._el.nativeElement, "overflow"))
                            })
                        }
                        animationRun(e, i) {
                            if (!e || !this._stylesLoaded) return s => s();
                            this._renderer.setStyle(this._el.nativeElement, "overflow", "hidden"), this._renderer.addClass(this._el.nativeElement, "collapse");
                            const r = i === this._EXPAND_ACTION_NAME ? this._factoryExpandAnimation : this._factoryCollapseAnimation;
                            return this._player && this._player.reset(), this._player = r.create(this._el.nativeElement), this._player.play(), s => this._player ? .onDone(s)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ir), We(Ks), We(By))
                    }, t.\u0275dir = Un({
                        type: t,
                        selectors: [
                            ["", "collapse", ""]
                        ],
                        hostVars: 9,
                        hostBindings: function(e, i) {
                            2 & e && (hi("aria-hidden", i.isCollapsed), ja("collapse", i.isCollapse)("in", i.isExpanded)("show", i.isExpanded)("collapsing", i.isCollapsing))
                        },
                        inputs: {
                            display: "display",
                            isAnimated: "isAnimated",
                            collapse: "collapse"
                        },
                        outputs: {
                            collapsed: "collapsed",
                            collapses: "collapses",
                            expanded: "expanded",
                            expands: "expands"
                        },
                        exportAs: ["bs-collapse"]
                    }), t
                })(),
                afe = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: []
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({}), t
                })();
            const cfe = ["*"],
                lfe = function(t) {
                    return {
                        "text-muted": t
                    }
                };

            function ufe(t, n) {
                if (1 & t && (J(0, "button", 7), Oe(1), ce()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(2, lfe, e.isDisabled)), he(1), Ln(" ", e.heading, " ")
                }
            }
            const dfe = [
                    [
                        ["", "accordion-heading", ""]
                    ], "*"
                ],
                hfe = ["[accordion-heading]", "*"];
            let ffe = (() => {
                    class t {
                        constructor() {
                            this.closeOthers = !1, this.isAnimated = !1
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                iV = (() => {
                    class t {
                        constructor(e) {
                            this.isAnimated = !1, this.closeOthers = !1, this.groups = [], Object.assign(this, e)
                        }
                        closeOtherPanels(e) {
                            this.closeOthers && this.groups.forEach(i => {
                                i !== e && (i.isOpen = !1)
                            })
                        }
                        addGroup(e) {
                            e.isAnimated = this.isAnimated, this.groups.push(e)
                        }
                        removeGroup(e) {
                            const i = this.groups.indexOf(e); - 1 !== i && this.groups.splice(i, 1)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(ffe))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["accordion"]
                        ],
                        hostAttrs: ["role", "tablist", 1, "panel-group", 2, "display", "block"],
                        hostVars: 1,
                        hostBindings: function(e, i) {
                            2 & e && hi("aria-multiselectable", i.closeOthers)
                        },
                        inputs: {
                            isAnimated: "isAnimated",
                            closeOthers: "closeOthers"
                        },
                        ngContentSelectors: cfe,
                        decls: 1,
                        vars: 0,
                        template: function(e, i) {
                            1 & e && (Zd(), Ru(0))
                        },
                        encapsulation: 2
                    }), t
                })(),
                pfe = (() => {
                    class t {
                        constructor(e) {
                            this.isAnimated = !1, this.panelClass = "panel-default", this.isDisabled = !1, this.isOpenChange = new zt, this._isOpen = !1, this.accordion = e
                        }
                        get isOpen() {
                            return this._isOpen
                        }
                        set isOpen(e) {
                            e !== this.isOpen && (e && this.accordion.closeOtherPanels(this), this._isOpen = e, Promise.resolve(null).then(() => {
                                this.isOpenChange.emit(e)
                            }))
                        }
                        ngOnInit() {
                            this.accordion.addGroup(this)
                        }
                        ngOnDestroy() {
                            this.accordion.removeGroup(this)
                        }
                        toggleOpen() {
                            this.isDisabled || (this.isOpen = !this.isOpen)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(We(iV))
                    }, t.\u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["accordion-group"],
                            ["accordion-panel"]
                        ],
                        hostAttrs: [1, "panel", 2, "display", "block"],
                        hostVars: 2,
                        hostBindings: function(e, i) {
                            2 & e && ja("panel-open", i.isOpen)
                        },
                        inputs: {
                            heading: "heading",
                            panelClass: "panelClass",
                            isDisabled: "isDisabled",
                            isOpen: "isOpen"
                        },
                        outputs: {
                            isOpenChange: "isOpenChange"
                        },
                        ngContentSelectors: hfe,
                        decls: 9,
                        vars: 6,
                        consts: [
                            [1, "panel", "card", 3, "ngClass"],
                            ["role", "tab", 1, "panel-heading", "card-header", 3, "ngClass", "click"],
                            [1, "panel-title"],
                            ["role", "button", 1, "accordion-toggle"],
                            ["class", "btn btn-link", "type", "button", 3, "ngClass", 4, "ngIf"],
                            ["role", "tabpanel", 1, "panel-collapse", "collapse", 3, "collapse", "isAnimated"],
                            [1, "panel-body", "card-block", "card-body"],
                            ["type", "button", 1, "btn", "btn-link", 3, "ngClass"]
                        ],
                        template: function(e, i) {
                            1 & e && (Zd(dfe), J(0, "div", 0)(1, "div", 1), xt("click", function() {
                                return i.toggleOpen()
                            }), J(2, "div", 2)(3, "div", 3), tt(4, ufe, 2, 4, "button", 4), Ru(5), ce()()(), J(6, "div", 5)(7, "div", 6), Ru(8, 1), ce()()()), 2 & e && (Re("ngClass", i.panelClass), he(1), Re("ngClass", i.isDisabled ? "panel-disabled" : "panel-enabled"), he(2), hi("aria-expanded", i.isOpen), he(1), Re("ngIf", i.heading), he(2), Re("collapse", !i.isOpen)("isAnimated", i.isAnimated))
                        },
                        dependencies: [Jd, ts, ofe],
                        styles: ["[_nghost-%COMP%]   .card-header.panel-enabled[_ngcontent-%COMP%]{cursor:pointer}[_nghost-%COMP%]   .card-header.panel-disabled[_ngcontent-%COMP%]   .btn.btn-link[_ngcontent-%COMP%]{cursor:default;text-decoration:none}"]
                    }), t
                })(),
                mfe = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: []
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [mc, afe]
                    }), t
                })(),
                gfe = (() => {
                    class t {
                        static forRoot() {
                            return {
                                ngModule: t,
                                providers: [Em, Yy]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = _i({
                        type: t
                    }), t.\u0275inj = wi({
                        imports: [mc]
                    }), t
                })(),
                yfe = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275mod = _i({
                            type: t
                        });
                        static\ u0275inj = wi({
                            imports: [mc]
                        })
                    }
                    return t
                })();
            var Ki = function(t) {
                return t[t.not_started = 0] = "not_started", t[t.in_progess = 1] = "in_progess", t[t.complete = 2] = "complete", t[t.failed = 3] = "failed", t[t.rejected = 4] = "rejected", t[t.approval_pending = 5] = "approval_pending", t[t.confirm_pending = 6] = "confirm_pending", t
            }(Ki || {});
            const UD = [{
                name: "Arabic",
                value: "ar",
                country: "AR",
                flag: "ar"
            }, {
                name: "Bulgarian",
                value: "bg",
                country: "BGR",
                flag: "bg"
            }, {
                name: "English",
                value: "en",
                country: "US",
                flag: "en"
            }, {
                name: "Chinese (simplified)",
                value: "zh-hans",
                country: "CHN",
                flag: "cn"
            }, {
                name: "Chinese (traditional) ",
                value: "zh-hant",
                country: "CHN",
                flag: "cn"
            }, {
                name: "Czech",
                value: "cz",
                country: "CZE",
                flag: "cz"
            }, {
                name: "Dutch",
                value: "nl",
                country: "DT",
                flag: "nl"
            }, {
                name: "French",
                value: "fr",
                country: "FR",
                flag: "fr"
            }, {
                name: "German",
                value: "de",
                country: "DEU",
                flag: "de"
            }, {
                name: "Greek",
                value: "el",
                country: "GRC",
                flag: "el"
            }, {
                name: "Hungarian",
                value: "hu",
                country: "HUN",
                flag: "hu"
            }, {
                name: "Indonesian",
                value: "id",
                country: "IND",
                flag: "id"
            }, {
                name: "Italian",
                value: "it",
                country: "ITA",
                flag: "it"
            }, {
                name: "Japanese",
                value: "jp",
                country: "JPN",
                flag: "jp"
            }, {
                name: "Korean",
                value: "kr",
                country: "KOR",
                flag: "kr"
            }, {
                name: "Polish",
                value: "pl",
                country: "POL",
                flag: "pl"
            }, {
                name: "Portuguese",
                value: "pt",
                country: "PRT",
                flag: "pt"
            }, {
                name: "Romanian",
                value: "ro",
                country: "ROU",
                flag: "ro"
            }, {
                name: "Russian",
                value: "ru",
                country: "RUS",
                flag: "ru"
            }, {
                name: "Slovak",
                value: "sk",
                country: "SVK",
                flag: "sk"
            }, {
                name: "Spanish",
                value: "es",
                country: "ESP",
                flag: "es"
            }, {
                name: "Thai",
                value: "th",
                country: "THA",
                flag: "th"
            }, {
                name: "Turkish",
                value: "tr",
                country: "TUR",
                flag: "tr"
            }, {
                name: "Vietnamese",
                value: "vn",
                country: "VNM",
                flag: "vn"
            }];

            function au(t) {
                let e = new URLSearchParams(document.location.search),
                    i = (r => {
                        let s = document.cookie.match(new RegExp("(?:^|; )" + r.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
                        return s ? decodeURIComponent(s[1]) : void 0
                    })(t);
                return e.get(t) && (i = e.get(t), document.cookie = t + "=" + i + ";max-age=15778462"), i || ""
            }

            function HD(t) {
                let e, n = new URLSearchParams(document.location.search);
                return n.get(t) && (e = n.get(t)), e || ""
            }

            function $D(t) {
                return UD.filter(e => e.value === t).length > 0
            }

            function zD(t, n = 2) {
                const e = Math.floor(t * Math.pow(10, n)) / Math.pow(10, n);
                let i = new Intl.NumberFormat("en-US");
                return i.format(e), i.format(e)
            }
            let jD;
            try {
                jD = typeof Intl < "u" && Intl.v8BreakIterator
            } catch {
                jD = !1
            }
            let xfe = (() => {
                class t {
                    constructor(e) {
                        this._platformId = e, this.isBrowser = this._platformId ? gc(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !jD) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT
                    }
                    static# e = this.\u0275fac = function(i) {
                        return new(i || t)(_t(Bs))
                    };
                    static# t = this.\u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            var Ze = T(15861);

            function El(t, n = {}) {
                const {
                    fees: e = t.fees,
                    formatters: i = t.formatters,
                    serializers: r = t.serializers
                } = n;
                return { ...t,
                    fees: e,
                    formatters: i,
                    serializers: r
                }
            }
            const GD = El({
                id: 1,
                network: "homestead",
                name: "Ethereum",
                nativeCurrency: {
                    name: "Ether",
                    symbol: "ETH",
                    decimals: 18
                },
                rpcUrls: {
                    alchemy: {
                        http: ["https://eth-mainnet.g.alchemy.com/v2"],
                        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
                    },
                    infura: {
                        http: ["https://mainnet.infura.io/v3"],
                        webSocket: ["wss://mainnet.infura.io/ws/v3"]
                    },
                    default: {
                        http: ["https://cloudflare-eth.com"]
                    },
                    public: {
                        http: ["https://cloudflare-eth.com"]
                    }
                },
                blockExplorers: {
                    etherscan: {
                        name: "Etherscan",
                        url: "https://etherscan.io"
                    },
                    default: {
                        name: "Etherscan",
                        url: "https://etherscan.io"
                    }
                },
                contracts: {
                    ensRegistry: {
                        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
                    },
                    ensUniversalResolver: {
                        address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
                        blockCreated: 16966585
                    },
                    multicall3: {
                        address: "0xca11bde05977b3631167028862be2a173976ca11",
                        blockCreated: 14353601
                    }
                }
            });
            var sV = class extends Error {
                    constructor({
                        chainId: t,
                        connectorId: n
                    }) {
                        super(`Chain "${t}" not configured for connector "${n}".`), this.name = "ChainNotConfiguredForConnectorError"
                    }
                },
                cu = class extends Error {
                    constructor() {
                        super(...arguments), this.name = "ConnectorNotFoundError", this.message = "Connector not found"
                    }
                };

            function Tx(t) {
                return "string" == typeof t ? Number.parseInt(t, "0x" === t.trim().substring(0, 2) ? 16 : 10) : "bigint" == typeof t ? Number(t) : t
            }
            var oV = T(81472),
                Sfe = T.n(oV);
            const Efe = El({
                id: 5,
                network: "goerli",
                name: "Goerli",
                nativeCurrency: {
                    name: "Goerli Ether",
                    symbol: "ETH",
                    decimals: 18
                },
                rpcUrls: {
                    alchemy: {
                        http: ["https://eth-goerli.g.alchemy.com/v2"],
                        webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
                    },
                    infura: {
                        http: ["https://goerli.infura.io/v3"],
                        webSocket: ["wss://goerli.infura.io/ws/v3"]
                    },
                    default: {
                        http: ["https://rpc.ankr.com/eth_goerli"]
                    },
                    public: {
                        http: ["https://rpc.ankr.com/eth_goerli"]
                    }
                },
                blockExplorers: {
                    etherscan: {
                        name: "Etherscan",
                        url: "https://goerli.etherscan.io"
                    },
                    default: {
                        name: "Etherscan",
                        url: "https://goerli.etherscan.io"
                    }
                },
                contracts: {
                    ensRegistry: {
                        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
                    },
                    ensUniversalResolver: {
                        address: "0x56522D00C410a43BFfDF00a9A569489297385790",
                        blockCreated: 8765204
                    },
                    multicall3: {
                        address: "0xca11bde05977b3631167028862be2a173976ca11",
                        blockCreated: 6507670
                    }
                },
                testnet: !0
            });
            var KD = (t, n, e) => {
                    if (!n.has(t)) throw TypeError("Cannot " + e)
                },
                zr = (t, n, e) => (KD(t, n, "read from private field"), e ? e.call(t) : n.get(t)),
                Da = (t, n, e) => {
                    if (n.has(t)) throw TypeError("Cannot add the same private member more than once");
                    n instanceof WeakSet ? n.add(t) : n.set(t, e)
                },
                Qm = (t, n, e, i) => (KD(t, n, "write to private field"), i ? i.call(t, e) : n.set(t, e), e),
                Io = (t, n, e) => (KD(t, n, "access private method"), e),
                qD = class extends oV {
                    constructor({
                        chains: t = [GD, Efe],
                        options: n
                    }) {
                        super(), this.chains = t, this.options = n
                    }
                    getBlockExplorerUrls(t) {
                        const {
                            default: n,
                            ...e
                        } = t.blockExplorers ? ? {};
                        if (n) return [n.url, ...Object.values(e).map(i => i.url)]
                    }
                    isChainUnsupported(t) {
                        return !this.chains.some(n => n.id === t)
                    }
                    setStorage(t) {
                        this.storage = t
                    }
                },
                qc = T(46284),
                oi = T(59450),
                id = T(30277);
            const ZD = 256;
            let Ex, Sx = ZD;

            function Dfe(t = 11) {
                if (!Ex || Sx + t > 2 * ZD) {
                    Ex = "", Sx = 0;
                    for (let n = 0; n < ZD; n++) Ex += (256 + 256 * Math.random() | 0).toString(16).substring(1)
                }
                return Ex.substring(Sx, Sx++ + t)
            }

            function aV(t) {
                const {
                    batch: n,
                    cacheTime: e = t.pollingInterval ? ? 4e3,
                    key: i = "base",
                    name: r = "Base Client",
                    pollingInterval: s = 4e3,
                    type: o = "base"
                } = t, a = t.chain, c = t.account ? (0, id.T)(t.account) : void 0, {
                    config: u,
                    request: h,
                    value: m
                } = t.transport({
                    chain: a,
                    pollingInterval: s
                }), D = {
                    account: c,
                    batch: n,
                    cacheTime: e,
                    chain: a,
                    key: i,
                    name: r,
                    pollingInterval: s,
                    request: h,
                    transport: { ...u,
                        ...m
                    },
                    type: o,
                    uid: Dfe()
                };
                return Object.assign(D, {
                    extend: function V(te) {
                        return ee => {
                            const _e = ee(te);
                            for (const Be in D) delete _e[Be];
                            const ye = { ...te,
                                ..._e
                            };
                            return Object.assign(ye, {
                                extend: V(ye)
                            })
                        }
                    }(D)
                })
            }
            var aa = T(29415);

            function j0(t) {
                return YD.apply(this, arguments)
            }

            function YD() {
                return (YD = (0, Ze.Z)(function*(t) {
                    const n = yield t.request({
                        method: "eth_chainId"
                    });
                    return (0, aa.ly)(n)
                })).apply(this, arguments)
            }
            var kr = T(74439);

            function XD() {
                return (XD = (0, Ze.Z)(function*(t, {
                    chain: n
                }) {
                    const {
                        id: e,
                        name: i,
                        nativeCurrency: r,
                        rpcUrls: s,
                        blockExplorers: o
                    } = n;
                    yield t.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: (0, kr.eC)(e),
                            chainName: i,
                            nativeCurrency: r,
                            rpcUrls: s.default.http,
                            blockExplorerUrls: o ? Object.values(o).map(({
                                url: a
                            }) => a) : void 0
                        }]
                    })
                })).apply(this, arguments)
            }
            var Es = T(76577),
                QD = T(80770),
                Dx = T(62910);
            const JD = "/docs/contract/encodeDeployData";

            function cV({
                abi: t,
                args: n,
                bytecode: e
            }) {
                if (!n || 0 === n.length) return e;
                const i = t.find(s => "type" in s && "constructor" === s.type);
                if (!i) throw new Es.fM({
                    docsPath: JD
                });
                if (!("inputs" in i)) throw new Es.cO({
                    docsPath: JD
                });
                if (!i.inputs || 0 === i.inputs.length) throw new Es.cO({
                    docsPath: JD
                });
                const r = (0, Dx.E)(i.inputs, n);
                return (0, QD.SM)([e, r])
            }
            var lu = T(32618);
            class Jm extends lu.G {
                constructor({
                    docsPath: n
                } = {}) {
                    super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join("\n"), {
                        docsPath: n,
                        docsSlug: "account"
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AccountNotFoundError"
                    })
                }
            }
            var lV = T(8722);

            function uV({
                chain: t,
                currentChainId: n
            }) {
                if (!t) throw new lV.Bk;
                if (n !== t.id) throw new lV.Yl({
                    chain: t,
                    currentChainId: n
                })
            }
            var dV = T(17354),
                gh = T(98284),
                hV = T(92917),
                fV = T(77603),
                eA = T(67369),
                $i = T(14637),
                Ax = T(9056),
                kx = T(79077);
            class Mfe extends lu.G {
                constructor() {
                    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "BaseFeeScalarError"
                    })
                }
            }
            class tA extends lu.G {
                constructor() {
                    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "Eip1559FeesNotSupportedError"
                    })
                }
            }
            class Ife extends lu.G {
                constructor({
                    maxPriorityFeePerGas: n
                }) {
                    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0,kx.o)(n)} gwei).`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "MaxFeePerGasTooLowError"
                    })
                }
            }
            class pV extends lu.G {
                constructor({
                    blockHash: n,
                    blockNumber: e
                }) {
                    let i = "Block";
                    n && (i = `Block at hash "${n}"`), e && (i = `Block at number "${e}"`), super(`${i} could not be found.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "BlockNotFoundError"
                    })
                }
            }

            function nA(t, n) {
                return ({
                    exclude: e,
                    format: i
                }) => ({
                    exclude: e,
                    format: r => {
                        const s = n(r);
                        if (e)
                            for (const o of e) delete s[o];
                        return { ...s,
                            ...i(r)
                        }
                    },
                    type: t
                })
            }
            const mV = {
                "0x0": "legacy",
                "0x1": "eip2930",
                "0x2": "eip1559"
            };

            function Mx(t) {
                const n = { ...t,
                    blockHash: t.blockHash ? t.blockHash : null,
                    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
                    chainId: t.chainId ? (0, aa.ly)(t.chainId) : void 0,
                    gas: t.gas ? BigInt(t.gas) : void 0,
                    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
                    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
                    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
                    nonce: t.nonce ? (0, aa.ly)(t.nonce) : void 0,
                    to: t.to ? t.to : null,
                    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
                    type: t.type ? mV[t.type] : void 0,
                    typeHex: t.type ? t.type : void 0,
                    value: t.value ? BigInt(t.value) : void 0,
                    v: t.v ? BigInt(t.v) : void 0
                };
                return n.yParity = (() => {
                    if (t.yParity) return Number(t.yParity);
                    if ("bigint" == typeof n.v) {
                        if (0 n === n.v || 27 n === n.v) return 0;
                        if (1 n === n.v || 28 n === n.v) return 1;
                        if (n.v >= 35 n) return n.v % 2 n === 0 n ? 1 : 0
                    }
                })(), "legacy" === n.type && (delete n.accessList, delete n.maxFeePerGas, delete n.maxPriorityFeePerGas, delete n.yParity), "eip2930" === n.type && (delete n.maxFeePerGas, delete n.maxPriorityFeePerGas), n
            }
            const Pfe = nA("transaction", Mx);

            function iA(t) {
                const n = t.transactions ? .map(e => "string" == typeof e ? e : Mx(e));
                return { ...t,
                    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
                    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
                    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
                    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
                    hash: t.hash ? t.hash : null,
                    logsBloom: t.logsBloom ? t.logsBloom : null,
                    nonce: t.nonce ? t.nonce : null,
                    number: t.number ? BigInt(t.number) : null,
                    size: t.size ? BigInt(t.size) : void 0,
                    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
                    transactions: n,
                    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
                }
            }
            const Ofe = nA("block", iA);

            function yh(t) {
                return rA.apply(this, arguments)
            }

            function rA() {
                return (rA = (0, Ze.Z)(function*(t, {
                    blockHash: n,
                    blockNumber: e,
                    blockTag: i,
                    includeTransactions: r
                } = {}) {
                    const s = i ? ? "latest",
                        o = r ? ? !1,
                        a = void 0 !== e ? (0, kr.eC)(e) : void 0;
                    let c = null;
                    if (c = n ? yield t.request({
                            method: "eth_getBlockByHash",
                            params: [n, o]
                        }): yield t.request({
                            method: "eth_getBlockByNumber",
                            params: [a || s, o]
                        }), !c) throw new pV({
                        blockHash: n,
                        blockNumber: e
                    });
                    return (t.chain ? .formatters ? .block ? .format || iA)(c)
                })).apply(this, arguments)
            }

            function sA(t) {
                return oA.apply(this, arguments)
            }

            function oA() {
                return (oA = (0, Ze.Z)(function*(t) {
                    const n = yield t.request({
                        method: "eth_gasPrice"
                    });
                    return BigInt(n)
                })).apply(this, arguments)
            }

            function aA() {
                return (aA = (0, Ze.Z)(function*(t, n) {
                    return gV(t, n)
                })).apply(this, arguments)
            }

            function gV(t, n) {
                return cA.apply(this, arguments)
            }

            function cA() {
                return (cA = (0, Ze.Z)(function*(t, n) {
                    const {
                        block: e,
                        chain: i = t.chain,
                        request: r
                    } = n || {};
                    if ("function" == typeof i ? .fees ? .defaultPriorityFee) {
                        const s = e || (yield(0, $i.s)(t, yh, "getBlock")({}));
                        return i.fees.defaultPriorityFee({
                            block: s,
                            client: t,
                            request: r
                        })
                    }
                    if (typeof i ? .fees ? .defaultPriorityFee < "u") return i ? .fees ? .defaultPriorityFee;
                    try {
                        const s = yield t.request({
                            method: "eth_maxPriorityFeePerGas"
                        });
                        return (0, aa.y_)(s)
                    } catch {
                        const [s, o] = yield Promise.all([e ? Promise.resolve(e) : (0, $i.s)(t, yh, "getBlock")({}), (0, $i.s)(t, sA, "getGasPrice")({})]);
                        if ("bigint" != typeof s.baseFeePerGas) throw new tA;
                        const a = o - s.baseFeePerGas;
                        return a < 0 n ? 0 n : a
                    }
                })).apply(this, arguments)
            }

            function lA() {
                return (lA = (0, Ze.Z)(function*(t, n) {
                    return uA(t, n)
                })).apply(this, arguments)
            }

            function uA(t, n) {
                return dA.apply(this, arguments)
            }

            function dA() {
                return (dA = (0, Ze.Z)(function*(t, n) {
                    const {
                        block: e,
                        chain: i = t.chain,
                        request: r,
                        type: s = "eip1559"
                    } = n || {}, o = yield(0, Ze.Z)(function*() {
                        return "function" == typeof i ? .fees ? .baseFeeMultiplier ? i.fees.baseFeeMultiplier({
                            block: e,
                            client: t,
                            request: r
                        }) : i ? .fees ? .baseFeeMultiplier ? ? 1.2
                    })();
                    if (o < 1) throw new Mfe;
                    const c = 10 ** (o.toString().split(".")[1] ? .length ? ? 0),
                        u = x => x * BigInt(Math.ceil(o * c)) / BigInt(c),
                        h = e || (yield(0, $i.s)(t, yh, "getBlock")({}));
                    if ("function" == typeof i ? .fees ? .estimateFeesPerGas) return i.fees.estimateFeesPerGas({
                        block: e,
                        client: t,
                        multiply: u,
                        request: r,
                        type: s
                    });
                    if ("eip1559" === s) {
                        if ("bigint" != typeof h.baseFeePerGas) throw new tA;
                        const x = r ? .maxPriorityFeePerGas ? r.maxPriorityFeePerGas : yield gV(t, {
                            block: h,
                            chain: i,
                            request: r
                        }), D = u(h.baseFeePerGas);
                        return {
                            maxFeePerGas: r ? .maxFeePerGas ? ? D + x,
                            maxPriorityFeePerGas: x
                        }
                    }
                    return {
                        gasPrice: r ? .gasPrice ? ? u(yield(0, $i.s)(t, sA, "getGasPrice")({}))
                    }
                })).apply(this, arguments)
            }
            var Vs = T(78004);
            class Bfe extends lu.G {
                constructor(n, {
                    account: e,
                    docsPath: i,
                    chain: r,
                    data: s,
                    gas: o,
                    gasPrice: a,
                    maxFeePerGas: c,
                    maxPriorityFeePerGas: u,
                    nonce: h,
                    to: m,
                    value: x
                }) {
                    const D = (0, gh.xr)({
                        from: e ? .address,
                        to: m,
                        value: typeof x < "u" && `${(0,Vs.d)(x)} ${r?.nativeCurrency?.symbol||"ETH"}`,
                        data: s,
                        gas: o,
                        gasPrice: typeof a < "u" && `${(0,kx.o)(a)} gwei`,
                        maxFeePerGas: typeof c < "u" && `${(0,kx.o)(c)} gwei`,
                        maxPriorityFeePerGas: typeof u < "u" && `${(0,kx.o)(u)} gwei`,
                        nonce: h
                    });
                    super(n.shortMessage, {
                        cause: n,
                        docsPath: i,
                        metaMessages: [...n.metaMessages ? [...n.metaMessages, " "] : [], "Estimate Gas Arguments:", D].filter(Boolean)
                    }), Object.defineProperty(this, "cause", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "EstimateGasExecutionError"
                    }), this.cause = n
                }
            }

            function hA(t, n) {
                return fA.apply(this, arguments)
            }

            function fA() {
                return (fA = (0, Ze.Z)(function*(t, n) {
                    const e = n.account ? ? t.account;
                    if (!e) throw new Jm({
                        docsPath: "/docs/actions/public/estimateGas"
                    });
                    const i = (0, id.T)(e);
                    try {
                        const {
                            accessList: r,
                            blockNumber: s,
                            blockTag: o,
                            data: a,
                            gas: c,
                            gasPrice: u,
                            maxFeePerGas: h,
                            maxPriorityFeePerGas: m,
                            nonce: x,
                            to: D,
                            value: V,
                            ...te
                        } = "local" === i.type ? yield Ix(t, n): n, _e = (s ? (0, kr.eC)(s) : void 0) || o;
                        (0, Ax.F)(n);
                        const ye = t.chain ? .formatters ? .transactionRequest ? .format,
                            ze = (ye || eA.tG)({ ...(0, fV.K)(te, {
                                    format: ye
                                }),
                                from: i.address,
                                accessList: r,
                                data: a,
                                gas: c,
                                gasPrice: u,
                                maxFeePerGas: h,
                                maxPriorityFeePerGas: m,
                                nonce: x,
                                to: D,
                                value: V
                            }),
                            Xe = yield t.request({
                                method: "eth_estimateGas",
                                params: _e ? [ze, _e] : [ze]
                            });
                        return BigInt(Xe)
                    } catch (r) {
                        throw function Nfe(t, {
                            docsPath: n,
                            ...e
                        }) {
                            const i = (() => {
                                const r = (0, hV.k)(t, e);
                                return r instanceof dV.cj ? t : r
                            })();
                            return new Bfe(i, {
                                docsPath: n,
                                ...e
                            })
                        }(r, { ...n,
                            account: i,
                            chain: t.chain
                        })
                    }
                })).apply(this, arguments)
            }

            function yV(t, n) {
                return pA.apply(this, arguments)
            }

            function pA() {
                return (pA = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockTag: e = "latest",
                    blockNumber: i
                }) {
                    const r = yield t.request({
                        method: "eth_getTransactionCount",
                        params: [n, i ? (0, kr.eC)(i) : e]
                    });
                    return (0, aa.ly)(r)
                })).apply(this, arguments)
            }

            function Ix(t, n) {
                return mA.apply(this, arguments)
            }

            function mA() {
                return (mA = (0, Ze.Z)(function*(t, n) {
                    const {
                        account: e = t.account,
                        chain: i,
                        gas: r,
                        nonce: s,
                        type: o
                    } = n;
                    if (!e) throw new Jm;
                    const a = (0, id.T)(e),
                        c = yield(0, $i.s)(t, yh, "getBlock")({
                            blockTag: "latest"
                        }), u = { ...n,
                            from: a.address
                        };
                    if (typeof s > "u" && (u.nonce = yield(0, $i.s)(t, yV, "getTransactionCount")({
                            address: a.address,
                            blockTag: "pending"
                        })), typeof o > "u") try {
                        u.type = function Ffe(t) {
                            if (t.type) return t.type;
                            if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u") return "eip1559";
                            if (typeof t.gasPrice < "u") return typeof t.accessList < "u" ? "eip2930" : "legacy";
                            throw new gh.j3({
                                transaction: t
                            })
                        }(u)
                    } catch {
                        u.type = "bigint" == typeof c.baseFeePerGas ? "eip1559" : "legacy"
                    }
                    if ("eip1559" === u.type) {
                        const {
                            maxFeePerGas: h,
                            maxPriorityFeePerGas: m
                        } = yield uA(t, {
                            block: c,
                            chain: i,
                            request: u
                        });
                        if (typeof n.maxPriorityFeePerGas > "u" && n.maxFeePerGas && n.maxFeePerGas < m) throw new Ife({
                            maxPriorityFeePerGas: m
                        });
                        u.maxPriorityFeePerGas = m, u.maxFeePerGas = h
                    } else {
                        if (typeof n.maxFeePerGas < "u" || typeof n.maxPriorityFeePerGas < "u") throw new tA;
                        const {
                            gasPrice: h
                        } = yield uA(t, {
                            block: c,
                            chain: i,
                            request: u,
                            type: "legacy"
                        });
                        u.gasPrice = h
                    }
                    return typeof r > "u" && (u.gas = yield(0, $i.s)(t, hA, "estimateGas")({ ...u,
                        account: {
                            address: a.address,
                            type: "json-rpc"
                        }
                    })), (0, Ax.F)(u), u
                })).apply(this, arguments)
            }

            function gA(t, n) {
                return yA.apply(this, arguments)
            }

            function yA() {
                return (yA = (0, Ze.Z)(function*(t, {
                    serializedTransaction: n
                }) {
                    return t.request({
                        method: "eth_sendRawTransaction",
                        params: [n]
                    })
                })).apply(this, arguments)
            }

            function _A(t, n) {
                return vA.apply(this, arguments)
            }

            function vA() {
                return (vA = (0, Ze.Z)(function*(t, n) {
                    const {
                        account: e = t.account,
                        chain: i = t.chain,
                        accessList: r,
                        data: s,
                        gas: o,
                        gasPrice: a,
                        maxFeePerGas: c,
                        maxPriorityFeePerGas: u,
                        nonce: h,
                        to: m,
                        value: x,
                        ...D
                    } = n;
                    if (!e) throw new Jm({
                        docsPath: "/docs/actions/wallet/sendTransaction"
                    });
                    const V = (0, id.T)(e);
                    try {
                        let te;
                        if ((0, Ax.F)(n), null !== i && (te = yield(0, $i.s)(t, j0, "getChainId")({}), uV({
                                currentChainId: te,
                                chain: i
                            })), "local" === V.type) {
                            const Be = yield(0, $i.s)(t, Ix, "prepareTransactionRequest")({
                                account: V,
                                accessList: r,
                                chain: i,
                                data: s,
                                gas: o,
                                gasPrice: a,
                                maxFeePerGas: c,
                                maxPriorityFeePerGas: u,
                                nonce: h,
                                to: m,
                                value: x,
                                ...D
                            });
                            te || (te = yield(0, $i.s)(t, j0, "getChainId")({}));
                            const ze = i ? .serializers ? .transaction,
                                Xe = yield V.signTransaction({ ...Be,
                                    chainId: te
                                }, {
                                    serializer: ze
                                });
                            return yield(0, $i.s)(t, gA, "sendRawTransaction")({
                                serializedTransaction: Xe
                            })
                        }
                        const ee = t.chain ? .formatters ? .transactionRequest ? .format,
                            ye = (ee || eA.tG)({ ...(0, fV.K)(D, {
                                    format: ee
                                }),
                                accessList: r,
                                data: s,
                                from: V.address,
                                gas: o,
                                gasPrice: a,
                                maxFeePerGas: c,
                                maxPriorityFeePerGas: u,
                                nonce: h,
                                to: m,
                                value: x
                            });
                        return yield t.request({
                            method: "eth_sendTransaction",
                            params: [ye]
                        })
                    } catch (te) {
                        throw function kfe(t, {
                            docsPath: n,
                            ...e
                        }) {
                            const i = (() => {
                                const r = (0, hV.k)(t, e);
                                return r instanceof dV.cj ? t : r
                            })();
                            return new gh.mk(i, {
                                docsPath: n,
                                ...e
                            })
                        }(te, { ...n,
                            account: V,
                            chain: n.chain || void 0
                        })
                    }
                })).apply(this, arguments)
            }

            function bA() {
                return (bA = (0, Ze.Z)(function*(t) {
                    return "local" === t.account ? .type ? [t.account.address] : (yield t.request({
                        method: "eth_accounts"
                    })).map(e => (0, qc.x)(e))
                })).apply(this, arguments)
            }

            function wA() {
                return (wA = (0, Ze.Z)(function*(t) {
                    return yield t.request({
                        method: "wallet_getPermissions"
                    })
                })).apply(this, arguments)
            }

            function xA() {
                return (xA = (0, Ze.Z)(function*(t) {
                    return (yield t.request({
                        method: "eth_requestAccounts"
                    })).map(e => (0, qc.K)(e))
                })).apply(this, arguments)
            }

            function CA() {
                return (CA = (0, Ze.Z)(function*(t, n) {
                    return t.request({
                        method: "wallet_requestPermissions",
                        params: [n]
                    })
                })).apply(this, arguments)
            }

            function TA() {
                return (TA = (0, Ze.Z)(function*(t, {
                    account: n = t.account,
                    message: e
                }) {
                    if (!n) throw new Jm({
                        docsPath: "/docs/actions/wallet/signMessage"
                    });
                    const i = (0, id.T)(n);
                    if ("local" === i.type) return i.signMessage({
                        message: e
                    });
                    const r = "string" == typeof e ? (0, kr.$G)(e) : e.raw instanceof Uint8Array ? (0, kr.NC)(e.raw) : e.raw;
                    return t.request({
                        method: "personal_sign",
                        params: [r, i.address]
                    })
                })).apply(this, arguments)
            }

            function SA() {
                return (SA = (0, Ze.Z)(function*(t, n) {
                    const {
                        account: e = t.account,
                        chain: i = t.chain,
                        ...r
                    } = n;
                    if (!e) throw new Jm({
                        docsPath: "/docs/actions/wallet/signTransaction"
                    });
                    const s = (0, id.T)(e);
                    (0, Ax.F)({
                        account: s,
                        ...n
                    });
                    const o = yield(0, $i.s)(t, j0, "getChainId")({});
                    null !== i && uV({
                        currentChainId: o,
                        chain: i
                    });
                    const c = (i ? .formatters || t.chain ? .formatters) ? .transactionRequest ? .format || eA.tG;
                    return "local" === s.type ? s.signTransaction({ ...r,
                        chainId: o
                    }, {
                        serializer: t.chain ? .serializers ? .transaction
                    }) : yield t.request({
                        method: "eth_signTransaction",
                        params: [{ ...c(r),
                            chainId: (0, kr.eC)(o),
                            from: s.address
                        }]
                    })
                })).apply(this, arguments)
            }
            var Px = T(37812),
                uu = T(30038),
                Gfe = T(78355),
                Kfe = T(32099),
                _V = T(84018);
            const qfe = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
                Zfe = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

            function vV({
                domain: t,
                message: n,
                primaryType: e,
                types: i
            }) {
                const r = i,
                    s = (o, a) => {
                        for (const c of o) {
                            const {
                                name: u,
                                type: h
                            } = c, m = h, x = a[u], D = m.match(Zfe);
                            if (D && ("number" == typeof x || "bigint" == typeof x)) {
                                const [ee, _e, ye] = D;
                                (0, kr.eC)(x, {
                                    signed: "int" === _e,
                                    size: parseInt(ye) / 8
                                })
                            }
                            if ("address" === m && "string" == typeof x && !(0, Kfe.U)(x)) throw new Gfe.b({
                                address: x
                            });
                            const V = m.match(qfe);
                            if (V) {
                                const [ee, _e] = V;
                                if (_e && (0, _V.d)(x) !== parseInt(_e)) throw new Es.KY({
                                    expectedSize: parseInt(_e),
                                    givenSize: (0, _V.d)(x)
                                })
                            }
                            const te = r[m];
                            te && s(te, x)
                        }
                    };
                r.EIP712Domain && t && s(r.EIP712Domain, t), "EIP712Domain" !== e && s(r[e], n)
            }

            function EA({
                domain: t
            }) {
                return ["string" == typeof t ? .name && {
                    name: "name",
                    type: "string"
                }, t ? .version && {
                    name: "version",
                    type: "string"
                }, "number" == typeof t ? .chainId && {
                    name: "chainId",
                    type: "uint256"
                }, t ? .verifyingContract && {
                    name: "verifyingContract",
                    type: "address"
                }, t ? .salt && {
                    name: "salt",
                    type: "bytes32"
                }].filter(Boolean)
            }

            function DA() {
                return (DA = (0, Ze.Z)(function*(t, {
                    account: n = t.account,
                    domain: e,
                    message: i,
                    primaryType: r,
                    types: s
                }) {
                    if (!n) throw new Jm({
                        docsPath: "/docs/actions/wallet/signTypedData"
                    });
                    const o = (0, id.T)(n),
                        a = {
                            EIP712Domain: EA({
                                domain: e
                            }),
                            ...s
                        };
                    if (vV({
                            domain: e,
                            message: i,
                            primaryType: r,
                            types: a
                        }), "local" === o.type) return o.signTypedData({
                        domain: e,
                        primaryType: r,
                        types: a,
                        message: i
                    });
                    const c = (0, uu.P)({
                        domain: e ? ? {},
                        primaryType: r,
                        types: a,
                        message: i
                    }, (u, h) => (0, Px.v)(h) ? h.toLowerCase() : h);
                    return t.request({
                        method: "eth_signTypedData_v4",
                        params: [o.address, c]
                    })
                })).apply(this, arguments)
            }

            function AA() {
                return (AA = (0, Ze.Z)(function*(t, {
                    id: n
                }) {
                    yield t.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: (0, kr.eC)(n)
                        }]
                    })
                })).apply(this, arguments)
            }

            function kA() {
                return (kA = (0, Ze.Z)(function*(t, n) {
                    return yield t.request({
                        method: "wallet_watchAsset",
                        params: n
                    })
                })).apply(this, arguments)
            }
            var W0 = T(32490);

            function MA() {
                return (MA = (0, Ze.Z)(function*(t, {
                    abi: n,
                    address: e,
                    args: i,
                    dataSuffix: r,
                    functionName: s,
                    ...o
                }) {
                    const a = (0, W0.R)({
                        abi: n,
                        args: i,
                        functionName: s
                    });
                    return yield(0, $i.s)(t, _A, "sendTransaction")({
                        data: `${a}${r?r.replace("0x",""):""}`,
                        to: e,
                        ...o
                    })
                })).apply(this, arguments)
            }

            function epe(t) {
                return {
                    addChain: n => function Afe(t, n) {
                        return XD.apply(this, arguments)
                    }(t, n),
                    deployContract: n => function Vfe(t, {
                        abi: n,
                        args: e,
                        bytecode: i,
                        ...r
                    }) {
                        return _A(t, { ...r,
                            data: cV({
                                abi: n,
                                args: e,
                                bytecode: i
                            })
                        })
                    }(t, n),
                    getAddresses: () => function Ufe(t) {
                        return bA.apply(this, arguments)
                    }(t),
                    getChainId: () => j0(t),
                    getPermissions: () => function Hfe(t) {
                        return wA.apply(this, arguments)
                    }(t),
                    prepareTransactionRequest: n => Ix(t, n),
                    requestAddresses: () => function $fe(t) {
                        return xA.apply(this, arguments)
                    }(t),
                    requestPermissions: n => function zfe(t, n) {
                        return CA.apply(this, arguments)
                    }(t, n),
                    sendRawTransaction: n => gA(t, n),
                    sendTransaction: n => _A(t, n),
                    signMessage: n => function jfe(t, n) {
                        return TA.apply(this, arguments)
                    }(t, n),
                    signTransaction: n => function Wfe(t, n) {
                        return SA.apply(this, arguments)
                    }(t, n),
                    signTypedData: n => function Yfe(t, n) {
                        return DA.apply(this, arguments)
                    }(t, n),
                    switchChain: n => function Xfe(t, n) {
                        return AA.apply(this, arguments)
                    }(t, n),
                    watchAsset: n => function Qfe(t, n) {
                        return kA.apply(this, arguments)
                    }(t, n),
                    writeContract: n => function Jfe(t, n) {
                        return MA.apply(this, arguments)
                    }(t, n)
                }
            }

            function IA(t) {
                const {
                    key: n = "wallet",
                    name: e = "Wallet Client",
                    transport: i
                } = t;
                return aV({ ...t,
                    key: n,
                    name: e,
                    transport: s => i({ ...s,
                        retryCount: 0
                    }),
                    type: "walletClient"
                }).extend(epe)
            }
            var Dl = T(23979);

            function Ox(t) {
                return PA.apply(this, arguments)
            }

            function PA() {
                return (PA = (0, Ze.Z)(function*(t) {
                    return new Promise(n => setTimeout(n, t))
                })).apply(this, arguments)
            }

            function OA(t, {
                delay: n = 100,
                retryCount: e = 2,
                shouldRetry: i = (() => !0)
            } = {}) {
                return new Promise((r, s) => {
                    const o = function() {
                        var a = (0, Ze.Z)(function*({
                            count: c = 0
                        } = {}) {
                            const u = function() {
                                var h = (0, Ze.Z)(function*({
                                    error: m
                                }) {
                                    const x = "function" == typeof n ? n({
                                        count: c,
                                        error: m
                                    }) : n;
                                    x && (yield Ox(x)), o({
                                        count: c + 1
                                    })
                                });
                                return function(x) {
                                    return h.apply(this, arguments)
                                }
                            }();
                            try {
                                const h = yield t();
                                r(h)
                            } catch (h) {
                                if (c < e && (yield i({
                                        count: c,
                                        error: h
                                    }))) return u({
                                    error: h
                                });
                                s(h)
                            }
                        });
                        return function() {
                            return a.apply(this, arguments)
                        }
                    }();
                    o()
                })
            }
            const bV = t => "code" in t ? -1 !== t.code && -32004 !== t.code && -32005 !== t.code && -32042 !== t.code && -32603 !== t.code : !!(t instanceof Dl.Gg && t.status) && 403 !== t.status && 408 !== t.status && 413 !== t.status && 429 !== t.status && 500 !== t.status && 502 !== t.status && 503 !== t.status && 504 !== t.status;

            function tpe(t, {
                retryDelay: n = 150,
                retryCount: e = 3
            } = {}) {
                return function() {
                    var i = (0, Ze.Z)(function*(r) {
                        return OA((0, Ze.Z)(function*() {
                            try {
                                return yield t(r)
                            } catch (s) {
                                const o = s;
                                switch (o.code) {
                                    case oi.s7.code:
                                        throw new oi.s7(o);
                                    case oi.B.code:
                                        throw new oi.B(o);
                                    case oi.LX.code:
                                        throw new oi.LX(o);
                                    case oi.nY.code:
                                        throw new oi.nY(o);
                                    case oi.XS.code:
                                        throw new oi.XS(o);
                                    case oi.yR.code:
                                        throw new oi.yR(o);
                                    case oi.Og.code:
                                        throw new oi.Og(o);
                                    case oi.pT.code:
                                        throw new oi.pT(o);
                                    case oi.KB.code:
                                        throw new oi.KB(o);
                                    case oi.gS.code:
                                        throw new oi.gS(o);
                                    case oi.Pv.code:
                                        throw new oi.Pv(o);
                                    case oi.GD.code:
                                        throw new oi.GD(o);
                                    case oi.ab.code:
                                        throw new oi.ab(o);
                                    case oi.PE.code:
                                        throw new oi.PE(o);
                                    case oi.Ts.code:
                                        throw new oi.Ts(o);
                                    case oi.u5.code:
                                        throw new oi.u5(o);
                                    case oi.I0.code:
                                        throw new oi.I0(o);
                                    case oi.x3.code:
                                        throw new oi.x3(o);
                                    case 5e3:
                                        throw new oi.ab(o);
                                    default:
                                        throw s instanceof lu.G ? s : new oi.ir(o)
                                }
                            }
                        }), {
                            delay: ({
                                count: s,
                                error: o
                            }) => {
                                if (o && o instanceof Dl.Gg) {
                                    const a = o ? .headers ? .get("Retry-After");
                                    if (a ? .match(/\d/)) return 1e3 * parseInt(a)
                                }
                                return ~~(1 << s) * n
                            },
                            retryCount: e,
                            shouldRetry: ({
                                error: s
                            }) => !bV(s)
                        })
                    });
                    return function(r) {
                        return i.apply(this, arguments)
                    }
                }()
            }

            function Lx({
                key: t,
                name: n,
                request: e,
                retryCount: i = 3,
                retryDelay: r = 150,
                timeout: s,
                type: o
            }, a) {
                return {
                    config: {
                        key: t,
                        name: n,
                        request: e,
                        retryCount: i,
                        retryDelay: r,
                        timeout: s,
                        type: o
                    },
                    request: tpe(e, {
                        retryCount: i,
                        retryDelay: r
                    }),
                    value: a
                }
            }

            function LA(t, n = {}) {
                const {
                    key: e = "custom",
                    name: i = "Custom Provider",
                    retryDelay: r
                } = n;
                return ({
                    retryCount: s
                }) => Lx({
                    key: e,
                    name: i,
                    request: t.request.bind(t),
                    retryCount: n.retryCount ? ? s,
                    retryDelay: r,
                    type: "custom"
                })
            }
            var Rx, wV = class extends qD {
                constructor({
                    chains: t,
                    options: n
                } = {}) {
                    var e;
                    const i = {
                        shimDisconnect: !0,
                        getProvider() {
                            if (typeof window > "u") return;
                            const s = window.ethereum;
                            return s ? .providers && s.providers.length > 0 ? s.providers[0] : s
                        },
                        ...n
                    };
                    super({
                        chains: t,
                        options: i
                    }), e = this, this.id = "injected", Da(this, Rx, void 0), this.shimDisconnectKey = `${this.id}.shimDisconnect`, this.onAccountsChanged = s => {
                        0 === s.length ? this.emit("disconnect") : this.emit("change", {
                            account: (0, qc.K)(s[0])
                        })
                    }, this.onChainChanged = s => {
                        const o = Tx(s),
                            a = this.isChainUnsupported(o);
                        this.emit("change", {
                            chain: {
                                id: o,
                                unsupported: a
                            }
                        })
                    }, this.onDisconnect = function() {
                        var s = (0, Ze.Z)(function*(o) {
                            1013 === o.code && (yield e.getProvider()) && (yield e.getAccount()) || (e.emit("disconnect"), e.options.shimDisconnect && e.storage ? .removeItem(e.shimDisconnectKey))
                        });
                        return function(o) {
                            return s.apply(this, arguments)
                        }
                    }();
                    const r = i.getProvider();
                    if ("string" == typeof i.name) this.name = i.name;
                    else if (r) {
                        const s = function npe(t) {
                            if (!t) return "Injected";
                            const n = e => e.isApexWallet ? "Apex Wallet" : e.isAvalanche ? "Core Wallet" : e.isBackpack ? "Backpack" : e.isBifrost ? "Bifrost Wallet" : e.isBitKeep ? "BitKeep" : e.isBitski ? "Bitski" : e.isBlockWallet ? "BlockWallet" : e.isBraveWallet ? "Brave Wallet" : e.isCoin98 ? "Coin98 Wallet" : e.isCoinbaseWallet ? "Coinbase Wallet" : e.isDawn ? "Dawn Wallet" : e.isDefiant ? "Defiant" : e.isDesig ? "Desig Wallet" : e.isEnkrypt ? "Enkrypt" : e.isExodus ? "Exodus" : e.isFordefi ? "Fordefi" : e.isFrame ? "Frame" : e.isFrontier ? "Frontier Wallet" : e.isGamestop ? "GameStop Wallet" : e.isHaqqWallet ? "HAQQ Wallet" : e.isHyperPay ? "HyperPay Wallet" : e.isImToken ? "ImToken" : e.isHaloWallet ? "Halo Wallet" : e.isKuCoinWallet ? "KuCoin Wallet" : e.isMathWallet ? "MathWallet" : e.isNovaWallet ? "Nova Wallet" : e.isOkxWallet || e.isOKExWallet ? "OKX Wallet" : e.isOktoWallet ? "Okto Wallet" : e.isOneInchIOSWallet || e.isOneInchAndroidWallet ? "1inch Wallet" : e.isOneKey ? "OneKey Wallet" : e.isOpera ? "Opera" : e.isPhantom ? "Phantom" : e.isPortal ? "Ripio Portal" : e.isRabby ? "Rabby Wallet" : e.isRainbow ? "Rainbow" : e.isSafePal ? "SafePal Wallet" : e.isStatus ? "Status" : e.isSubWallet ? "SubWallet" : e.isTalisman ? "Talisman" : e.isTally ? "Taho" : e.isTokenPocket ? "TokenPocket" : e.isTokenary ? "Tokenary" : e.isTrust || e.isTrustWallet ? "Trust Wallet" : e.isTTWallet ? "TTWallet" : e.isXDEFI ? "XDEFI Wallet" : e.isZeal ? "Zeal" : e.isZerion ? "Zerion" : e.isMetaMask ? "MetaMask" : void 0;
                            if (t.providers ? .length) {
                                const e = new Set;
                                let i = 1;
                                for (const s of t.providers) {
                                    let o = n(s);
                                    o || (o = `Unknown Wallet #${i}`, i += 1), e.add(o)
                                }
                                const r = [...e];
                                return r.length ? r : r[0] ? ? "Injected"
                            }
                            return n(t) ? ? "Injected"
                        }(r);
                        this.name = i.name ? i.name(s) : "string" == typeof s ? s : s[0]
                    } else this.name = "Injected";
                    this.ready = !!r
                }
                connect({
                    chainId: t
                } = {}) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        try {
                            const e = yield n.getProvider();
                            if (!e) throw new cu;
                            e.on && (e.on("accountsChanged", n.onAccountsChanged), e.on("chainChanged", n.onChainChanged), e.on("disconnect", n.onDisconnect)), n.emit("message", {
                                type: "connecting"
                            });
                            const i = yield e.request({
                                method: "eth_requestAccounts"
                            }), r = (0, qc.K)(i[0]);
                            let s = yield n.getChainId(), o = n.isChainUnsupported(s);
                            return t && s !== t && (s = (yield n.switchChain(t)).id, o = n.isChainUnsupported(s)), n.options.shimDisconnect && n.storage ? .setItem(n.shimDisconnectKey, !0), {
                                account: r,
                                chain: {
                                    id: s,
                                    unsupported: o
                                }
                            }
                        } catch (e) {
                            throw n.isUserRejectedRequestError(e) ? new oi.ab(e) : -32002 === e.code ? new oi.pT(e) : e
                        }
                    })()
                }
                disconnect() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        const n = yield t.getProvider();
                        n ? .removeListener && (n.removeListener("accountsChanged", t.onAccountsChanged), n.removeListener("chainChanged", t.onChainChanged), n.removeListener("disconnect", t.onDisconnect), t.options.shimDisconnect && t.storage ? .removeItem(t.shimDisconnectKey))
                    })()
                }
                getAccount() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        const n = yield t.getProvider();
                        if (!n) throw new cu;
                        const e = yield n.request({
                            method: "eth_accounts"
                        });
                        return (0, qc.K)(e[0])
                    })()
                }
                getChainId() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        const n = yield t.getProvider();
                        if (!n) throw new cu;
                        return n.request({
                            method: "eth_chainId"
                        }).then(Tx)
                    })()
                }
                getProvider() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        const n = t.options.getProvider();
                        return n && Qm(t, Rx, n), zr(t, Rx)
                    })()
                }
                getWalletClient({
                    chainId: t
                } = {}) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        const [e, i] = yield Promise.all([n.getProvider(), n.getAccount()]), r = n.chains.find(s => s.id === t);
                        if (!e) throw new Error("provider is required.");
                        return IA({
                            account: i,
                            chain: r,
                            transport: LA(e)
                        })
                    })()
                }
                isAuthorized() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        try {
                            if (t.options.shimDisconnect && !t.storage ? .getItem(t.shimDisconnectKey)) return !1;
                            if (!(yield t.getProvider())) throw new cu;
                            return !!(yield t.getAccount())
                        } catch {
                            return !1
                        }
                    })()
                }
                switchChain(t) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        const e = yield n.getProvider();
                        if (!e) throw new cu;
                        const i = (0, kr.eC)(t);
                        try {
                            return yield Promise.all([e.request({
                                method: "wallet_switchEthereumChain",
                                params: [{
                                    chainId: i
                                }]
                            }), new Promise(r => n.on("change", ({
                                chain: s
                            }) => {
                                s ? .id === t && r()
                            }))]), n.chains.find(r => r.id === t) ? ? {
                                id: t,
                                name: `Chain ${i}`,
                                network: `${i}`,
                                nativeCurrency: {
                                    name: "Ether",
                                    decimals: 18,
                                    symbol: "ETH"
                                },
                                rpcUrls: {
                                    default: {
                                        http: [""]
                                    },
                                    public: {
                                        http: [""]
                                    }
                                }
                            }
                        } catch (r) {
                            const s = n.chains.find(o => o.id === t);
                            if (!s) throw new sV({
                                chainId: t,
                                connectorId: n.id
                            });
                            if (4902 === r.code || 4902 === r ? .data ? .originalError ? .code) try {
                                if (yield e.request({
                                        method: "wallet_addEthereumChain",
                                        params: [{
                                            chainId: i,
                                            chainName: s.name,
                                            nativeCurrency: s.nativeCurrency,
                                            rpcUrls: [s.rpcUrls.public ? .http[0] ? ? ""],
                                            blockExplorerUrls: n.getBlockExplorerUrls(s)
                                        }]
                                    }), (yield n.getChainId()) !== t) throw new oi.ab(new Error("User rejected switch after adding network."));
                                return s
                            } catch (o) {
                                throw new oi.ab(o)
                            }
                            throw n.isUserRejectedRequestError(r) ? new oi.ab(r) : new oi.x3(r)
                        }
                    })()
                }
                watchAsset({
                    address: t,
                    decimals: n = 18,
                    image: e,
                    symbol: i
                }) {
                    var r = this;
                    return (0, Ze.Z)(function*() {
                        const s = yield r.getProvider();
                        if (!s) throw new cu;
                        return s.request({
                            method: "wallet_watchAsset",
                            params: {
                                type: "ERC20",
                                options: {
                                    address: t,
                                    decimals: n,
                                    image: e,
                                    symbol: i
                                }
                            }
                        })
                    })()
                }
                isUserRejectedRequestError(t) {
                    return 4001 === t.code
                }
            };
            Rx = new WeakMap;
            var RA = (t, n, e) => {
                    if (!n.has(t)) throw TypeError("Cannot " + e)
                },
                BA = (t, n, e) => (RA(t, n, "read from private field"), e ? e.call(t) : n.get(t)),
                NA = (t, n, e) => {
                    if (n.has(t)) throw TypeError("Cannot add the same private member more than once");
                    n instanceof WeakSet ? n.add(t) : n.set(t, e)
                },
                Bx = (t, n, e, i) => (RA(t, n, "write to private field"), i ? i.call(t, e) : n.set(t, e), e),
                rpe = T(4257),
                spe = T(69632),
                ope = T(28971),
                ape = T(33069),
                cpe = T(51180),
                FA = T(19934);

            function Nx(t, {
                method: n
            }) {
                const e = {};
                return "fallback" === t.transport.type && t.transport.onResponse ? .(({
                    method: i,
                    response: r,
                    status: s,
                    transport: o
                }) => {
                    "success" === s && n === i && (e[r] = o.request)
                }), i => e[i] || t.request
            }

            function VA() {
                return (VA = (0, Ze.Z)(function*(t) {
                    const n = Nx(t, {
                            method: "eth_newBlockFilter"
                        }),
                        e = yield t.request({
                            method: "eth_newBlockFilter"
                        });
                    return {
                        id: e,
                        request: n(e),
                        type: "block"
                    }
                })).apply(this, arguments)
            }
            class upe extends lu.G {
                constructor(n) {
                    super(`Filter type "${n}" is not supported.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "FilterTypeNotSupportedError"
                    })
                }
            }
            var eg = T(9427),
                xV = T(77467),
                rd = T(71201),
                CV = T(16537),
                TV = T(30930);

            function G0({
                abi: t,
                eventName: n,
                args: e
            }) {
                let i = t[0];
                if (n && (i = (0, TV.mE)({
                        abi: t,
                        args: e,
                        name: n
                    }), !i)) throw new Es.mv(n, {
                    docsPath: "/docs/contract/encodeEventTopics"
                });
                if ("event" !== i.type) throw new Es.mv(void 0, {
                    docsPath: "/docs/contract/encodeEventTopics"
                });
                const r = (0, CV.t)(i),
                    s = (0, xV.e)(r);
                let o = [];
                if (e && "inputs" in i) {
                    const a = i.inputs ? .filter(u => "indexed" in u && u.indexed),
                        c = Array.isArray(e) ? e : Object.values(e).length > 0 ? a ? .map(u => e[u.name]) ? ? [] : [];
                    c.length > 0 && (o = a ? .map((u, h) => Array.isArray(c[h]) ? c[h].map((m, x) => SV({
                        param: u,
                        value: c[h][x]
                    })) : c[h] ? SV({
                        param: u,
                        value: c[h]
                    }) : null) ? ? [])
                }
                return [s, ...o]
            }

            function SV({
                param: t,
                value: n
            }) {
                if ("string" === t.type || "bytes" === t.type) return (0, rd.w)((0, eg.O0)(n));
                if ("tuple" === t.type || t.type.match(/^(.*)\[(\d+)?\]$/)) throw new upe(t.type);
                return (0, Dx.E)([t], [n])
            }

            function EV(t, n) {
                return UA.apply(this, arguments)
            }

            function UA() {
                return (UA = (0, Ze.Z)(function*(t, {
                    address: n,
                    abi: e,
                    args: i,
                    eventName: r,
                    fromBlock: s,
                    strict: o,
                    toBlock: a
                }) {
                    const c = Nx(t, {
                            method: "eth_newFilter"
                        }),
                        u = r ? G0({
                            abi: e,
                            args: i,
                            eventName: r
                        }) : void 0,
                        h = yield t.request({
                            method: "eth_newFilter",
                            params: [{
                                address: n,
                                fromBlock: "bigint" == typeof s ? (0, kr.eC)(s) : s,
                                toBlock: "bigint" == typeof a ? (0, kr.eC)(a) : a,
                                topics: u
                            }]
                        });
                    return {
                        abi: e,
                        args: i,
                        eventName: r,
                        id: h,
                        request: c(h),
                        strict: o,
                        type: "event"
                    }
                })).apply(this, arguments)
            }

            function DV(t) {
                return HA.apply(this, arguments)
            }

            function HA() {
                return (HA = (0, Ze.Z)(function*(t, {
                    address: n,
                    args: e,
                    event: i,
                    events: r,
                    fromBlock: s,
                    strict: o,
                    toBlock: a
                } = {}) {
                    const c = r ? ? (i ? [i] : void 0),
                        u = Nx(t, {
                            method: "eth_newFilter"
                        });
                    let h = [];
                    c && (h = [c.flatMap(x => G0({
                        abi: [x],
                        eventName: x.name,
                        args: e
                    }))], i && (h = h[0]));
                    const m = yield t.request({
                        method: "eth_newFilter",
                        params: [{
                            address: n,
                            fromBlock: "bigint" == typeof s ? (0, kr.eC)(s) : s,
                            toBlock: "bigint" == typeof a ? (0, kr.eC)(a) : a,
                            ...h.length ? {
                                topics: h
                            } : {}
                        }]
                    });
                    return {
                        abi: c,
                        args: e,
                        eventName: i ? i.name : void 0,
                        fromBlock: s,
                        id: m,
                        request: u(m),
                        strict: o,
                        toBlock: a,
                        type: "event"
                    }
                })).apply(this, arguments)
            }

            function AV(t) {
                return $A.apply(this, arguments)
            }

            function $A() {
                return ($A = (0, Ze.Z)(function*(t) {
                    const n = Nx(t, {
                            method: "eth_newPendingTransactionFilter"
                        }),
                        e = yield t.request({
                            method: "eth_newPendingTransactionFilter"
                        });
                    return {
                        id: e,
                        request: n(e),
                        type: "transaction"
                    }
                })).apply(this, arguments)
            }
            var Fx = T(50660);

            function zA() {
                return (zA = (0, Ze.Z)(function*(t, {
                    abi: n,
                    address: e,
                    args: i,
                    functionName: r,
                    ...s
                }) {
                    const o = (0, W0.R)({
                        abi: n,
                        args: i,
                        functionName: r
                    });
                    try {
                        return yield(0, $i.s)(t, hA, "estimateGas")({
                            data: o,
                            to: e,
                            ...s
                        })
                    } catch (a) {
                        const c = s.account ? (0, id.T)(s.account) : void 0;
                        throw (0, Fx.S)(a, {
                            abi: n,
                            address: e,
                            args: i,
                            docsPath: "/docs/contract/estimateContractGas",
                            functionName: r,
                            sender: c ? .address
                        })
                    }
                })).apply(this, arguments)
            }

            function jA() {
                return (jA = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockNumber: e,
                    blockTag: i = "latest"
                }) {
                    const r = e ? (0, kr.eC)(e) : void 0,
                        s = yield t.request({
                            method: "eth_getBalance",
                            params: [n, r || i]
                        });
                    return BigInt(s)
                })).apply(this, arguments)
            }
            const fpe = new Map,
                ppe = new Map;

            function WA() {
                return (WA = (0, Ze.Z)(function*(t, {
                    cacheKey: n,
                    cacheTime: e = 1 / 0
                }) {
                    const i = function mpe(t) {
                            const n = (r, s) => ({
                                    clear: () => s.delete(r),
                                    get: () => s.get(r),
                                    set: o => s.set(r, o)
                                }),
                                e = n(t, fpe),
                                i = n(t, ppe);
                            return {
                                clear: () => {
                                    e.clear(), i.clear()
                                },
                                promise: e,
                                response: i
                            }
                        }(n),
                        r = i.response.get();
                    if (r && e > 0 && (new Date).getTime() - r.created.getTime() < e) return r.data;
                    let s = i.promise.get();
                    s || (s = t(), i.promise.set(s));
                    try {
                        const o = yield s;
                        return i.response.set({
                            created: new Date,
                            data: o
                        }), o
                    } finally {
                        i.promise.clear()
                    }
                })).apply(this, arguments)
            }
            const kV = t => `blockNumber.${t}`;

            function K0(t) {
                return GA.apply(this, arguments)
            }

            function GA() {
                return GA = (0, Ze.Z)(function*(t, {
                    cacheTime: n = t.cacheTime,
                    maxAge: e
                } = {}) {
                    const i = yield function gpe(t, n) {
                        return WA.apply(this, arguments)
                    }(() => t.request({
                        method: "eth_blockNumber"
                    }), {
                        cacheKey: kV(t.uid),
                        cacheTime: e ? ? n
                    });
                    return BigInt(i)
                }), GA.apply(this, arguments)
            }

            function KA() {
                return (KA = (0, Ze.Z)(function*(t, {
                    blockHash: n,
                    blockNumber: e,
                    blockTag: i = "latest"
                } = {}) {
                    const r = void 0 !== e ? (0, kr.eC)(e) : void 0;
                    let s;
                    return s = n ? yield t.request({
                        method: "eth_getBlockTransactionCountByHash",
                        params: [n]
                    }): yield t.request({
                        method: "eth_getBlockTransactionCountByNumber",
                        params: [r || i]
                    }), (0, aa.ly)(s)
                })).apply(this, arguments)
            }

            function qA() {
                return (qA = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockNumber: e,
                    blockTag: i = "latest"
                }) {
                    const r = void 0 !== e ? (0, kr.eC)(e) : void 0,
                        s = yield t.request({
                            method: "eth_getCode",
                            params: [n, r || i]
                        });
                    if ("0x" !== s) return s
                })).apply(this, arguments)
            }
            var MV = T(75777);
            const IV = "/docs/contract/decodeEventLog";

            function q0({
                abi: t,
                data: n,
                strict: e,
                topics: i
            }) {
                const r = e ? ? !0,
                    [s, ...o] = i;
                if (!s) throw new Es.FM({
                    docsPath: IV
                });
                const a = t.find(V => "event" === V.type && s === (0, xV.e)((0, CV.t)(V)));
                if (!a || !("name" in a) || "event" !== a.type) throw new Es.lC(s, {
                    docsPath: IV
                });
                const {
                    name: c,
                    inputs: u
                } = a, h = u ? .some(V => !("name" in V && V.name));
                let m = h ? [] : {};
                const x = u.filter(V => "indexed" in V && V.indexed);
                for (let V = 0; V < x.length; V++) {
                    const te = x[V],
                        ee = o[V];
                    if (!ee) throw new Es.Gy({
                        abiItem: a,
                        param: te
                    });
                    m[te.name || V] = vpe({
                        param: te,
                        value: ee
                    })
                }
                const D = u.filter(V => !("indexed" in V && V.indexed));
                if (D.length > 0)
                    if (n && "0x" !== n) try {
                        const V = (0, MV.r)(D, n);
                        if (V)
                            if (h) m = [...m, ...V];
                            else
                                for (let te = 0; te < D.length; te++) m[D[te].name] = V[te]
                    } catch (V) {
                        if (r) throw V instanceof Es.xB ? new Es.SM({
                            abiItem: a,
                            data: V.data,
                            params: V.params,
                            size: V.size
                        }) : V
                    } else if (r) throw new Es.SM({
                        abiItem: a,
                        data: "0x",
                        params: D,
                        size: 0
                    });
                return {
                    eventName: c,
                    args: Object.values(m).length > 0 ? m : void 0
                }
            }

            function vpe({
                param: t,
                value: n
            }) {
                return "string" === t.type || "bytes" === t.type || "tuple" === t.type || t.type.match(/^(.*)\[(\d+)?\]$/) ? n : ((0, MV.r)([t], n) || [])[0]
            }

            function Al(t, {
                args: n,
                eventName: e
            } = {}) {
                return { ...t,
                    blockHash: t.blockHash ? t.blockHash : null,
                    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
                    logIndex: t.logIndex ? Number(t.logIndex) : null,
                    transactionHash: t.transactionHash ? t.transactionHash : null,
                    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
                    ...e ? {
                        args: n,
                        eventName: e
                    } : {}
                }
            }

            function ZA(t) {
                return YA.apply(this, arguments)
            }

            function YA() {
                return (YA = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockHash: e,
                    fromBlock: i,
                    toBlock: r,
                    event: s,
                    events: o,
                    args: a,
                    strict: c
                } = {}) {
                    const u = c ? ? !1,
                        h = o ? ? (s ? [s] : void 0);
                    let x, m = [];
                    return h && (m = [h.flatMap(D => G0({
                        abi: [D],
                        eventName: D.name,
                        args: a
                    }))], s && (m = m[0])), x = e ? yield t.request({
                        method: "eth_getLogs",
                        params: [{
                            address: n,
                            topics: m,
                            blockHash: e
                        }]
                    }): yield t.request({
                        method: "eth_getLogs",
                        params: [{
                            address: n,
                            topics: m,
                            fromBlock: "bigint" == typeof i ? (0, kr.eC)(i) : i,
                            toBlock: "bigint" == typeof r ? (0, kr.eC)(r) : r
                        }]
                    }), x.map(D => {
                        try {
                            const {
                                eventName: V,
                                args: te
                            } = h ? q0({
                                abi: h,
                                data: D.data,
                                topics: D.topics,
                                strict: u
                            }) : {
                                eventName: void 0,
                                args: void 0
                            };
                            return Al(D, {
                                args: te,
                                eventName: V
                            })
                        } catch (V) {
                            let te, ee;
                            if (V instanceof Es.SM || V instanceof Es.Gy) {
                                if (u) return;
                                te = V.abiItem.name, ee = V.abiItem.inputs ? .some(_e => !("name" in _e && _e.name))
                            }
                            return Al(D, {
                                args: ee ? [] : {},
                                eventName: te
                            })
                        }
                    }).filter(Boolean)
                })).apply(this, arguments)
            }

            function PV(t, n) {
                return XA.apply(this, arguments)
            }

            function XA() {
                return (XA = (0, Ze.Z)(function*(t, {
                    abi: n,
                    address: e,
                    args: i,
                    blockHash: r,
                    eventName: s,
                    fromBlock: o,
                    toBlock: a,
                    strict: c
                }) {
                    const u = s ? (0, TV.mE)({
                            abi: n,
                            name: s
                        }) : void 0,
                        h = u ? void 0 : n.filter(m => "event" === m.type);
                    return (0, $i.s)(t, ZA, "getLogs")({
                        address: e,
                        args: i,
                        blockHash: r,
                        event: u,
                        events: h,
                        fromBlock: o,
                        toBlock: a,
                        strict: c
                    })
                })).apply(this, arguments)
            }

            function QA() {
                return (QA = (0, Ze.Z)(function*(t, {
                    blockCount: n,
                    blockNumber: e,
                    blockTag: i = "latest",
                    rewardPercentiles: r
                }) {
                    const s = e ? (0, kr.eC)(e) : void 0;
                    return function bpe(t) {
                        return {
                            baseFeePerGas: t.baseFeePerGas.map(n => BigInt(n)),
                            gasUsedRatio: t.gasUsedRatio,
                            oldestBlock: BigInt(t.oldestBlock),
                            reward: t.reward ? .map(n => n.map(e => BigInt(e)))
                        }
                    }(yield t.request({
                        method: "eth_feeHistory",
                        params: [(0, kr.eC)(n), s || i, r]
                    }))
                })).apply(this, arguments)
            }

            function Vx(t, n) {
                return JA.apply(this, arguments)
            }

            function JA() {
                return (JA = (0, Ze.Z)(function*(t, {
                    filter: n
                }) {
                    const e = "strict" in n && n.strict;
                    return (yield n.request({
                        method: "eth_getFilterChanges",
                        params: [n.id]
                    })).map(r => {
                        if ("string" == typeof r) return r;
                        try {
                            const {
                                eventName: s,
                                args: o
                            } = "abi" in n && n.abi ? q0({
                                abi: n.abi,
                                data: r.data,
                                topics: r.topics,
                                strict: e
                            }) : {
                                eventName: void 0,
                                args: void 0
                            };
                            return Al(r, {
                                args: o,
                                eventName: s
                            })
                        } catch (s) {
                            let o, a;
                            if (s instanceof Es.SM || s instanceof Es.Gy) {
                                if ("strict" in n && n.strict) return;
                                o = s.abiItem.name, a = s.abiItem.inputs ? .some(c => !("name" in c && c.name))
                            }
                            return Al(r, {
                                args: a ? [] : {},
                                eventName: o
                            })
                        }
                    }).filter(Boolean)
                })).apply(this, arguments)
            }

            function ek() {
                return (ek = (0, Ze.Z)(function*(t, {
                    filter: n
                }) {
                    const e = n.strict ? ? !1;
                    return (yield n.request({
                        method: "eth_getFilterLogs",
                        params: [n.id]
                    })).map(r => {
                        try {
                            const {
                                eventName: s,
                                args: o
                            } = "abi" in n && n.abi ? q0({
                                abi: n.abi,
                                data: r.data,
                                topics: r.topics,
                                strict: e
                            }) : {
                                eventName: void 0,
                                args: void 0
                            };
                            return Al(r, {
                                args: o,
                                eventName: s
                            })
                        } catch (s) {
                            let o, a;
                            if (s instanceof Es.SM || s instanceof Es.Gy) {
                                if ("strict" in n && n.strict) return;
                                o = s.abiItem.name, a = s.abiItem.inputs ? .some(c => !("name" in c && c.name))
                            }
                            return Al(r, {
                                args: a ? [] : {},
                                eventName: o
                            })
                        }
                    }).filter(Boolean)
                })).apply(this, arguments)
            }

            function Cpe(t) {
                return t.map(n => ({ ...n,
                    value: BigInt(n.value)
                }))
            }

            function tk() {
                return (tk = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockNumber: e,
                    blockTag: i,
                    storageKeys: r
                }) {
                    const s = i ? ? "latest",
                        o = void 0 !== e ? (0, kr.eC)(e) : void 0;
                    return function Tpe(t) {
                        return { ...t,
                            balance: t.balance ? BigInt(t.balance) : void 0,
                            nonce: t.nonce ? (0, aa.ly)(t.nonce) : void 0,
                            storageProof: t.storageProof ? Cpe(t.storageProof) : void 0
                        }
                    }(yield t.request({
                        method: "eth_getProof",
                        params: [n, r, o || s]
                    }))
                })).apply(this, arguments)
            }

            function nk() {
                return (nk = (0, Ze.Z)(function*(t, {
                    address: n,
                    blockNumber: e,
                    blockTag: i = "latest",
                    slot: r
                }) {
                    const s = void 0 !== e ? (0, kr.eC)(e) : void 0;
                    return yield t.request({
                        method: "eth_getStorageAt",
                        params: [n, r, s || i]
                    })
                })).apply(this, arguments)
            }

            function ik(t, n) {
                return rk.apply(this, arguments)
            }

            function rk() {
                return (rk = (0, Ze.Z)(function*(t, {
                    blockHash: n,
                    blockNumber: e,
                    blockTag: i,
                    hash: r,
                    index: s
                }) {
                    const o = i || "latest",
                        a = void 0 !== e ? (0, kr.eC)(e) : void 0;
                    let c = null;
                    if (r ? c = yield t.request({
                            method: "eth_getTransactionByHash",
                            params: [r]
                        }): n ? c = yield t.request({
                            method: "eth_getTransactionByBlockHashAndIndex",
                            params: [n, (0, kr.eC)(s)]
                        }): (a || o) && (c = yield t.request({
                            method: "eth_getTransactionByBlockNumberAndIndex",
                            params: [a || o, (0, kr.eC)(s)]
                        })), !c) throw new gh.Bh({
                        blockHash: n,
                        blockNumber: e,
                        blockTag: o,
                        hash: r,
                        index: s
                    });
                    return (t.chain ? .formatters ? .transaction ? .format || Mx)(c)
                })).apply(this, arguments)
            }

            function sk() {
                return (sk = (0, Ze.Z)(function*(t, {
                    hash: n,
                    transactionReceipt: e
                }) {
                    const [i, r] = yield Promise.all([(0, $i.s)(t, K0, "getBlockNumber")({}), n ? (0, $i.s)(t, ik, "getBlockNumber")({
                        hash: n
                    }) : void 0]), s = e ? .blockNumber || r ? .blockNumber;
                    return s ? i - s + 1 n : 0 n
                })).apply(this, arguments)
            }
            const Ape = {
                "0x0": "reverted",
                "0x1": "success"
            };

            function OV(t) {
                return { ...t,
                    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
                    contractAddress: t.contractAddress ? t.contractAddress : null,
                    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
                    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
                    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
                    logs: t.logs ? t.logs.map(n => Al(n)) : null,
                    to: t.to ? t.to : null,
                    transactionIndex: t.transactionIndex ? (0, aa.ly)(t.transactionIndex) : null,
                    status: t.status ? Ape[t.status] : null,
                    type: t.type ? mV[t.type] || t.type : null
                }
            }
            const kpe = nA("transactionReceipt", OV);

            function ok(t, n) {
                return ak.apply(this, arguments)
            }

            function ak() {
                return (ak = (0, Ze.Z)(function*(t, {
                    hash: n
                }) {
                    const e = yield t.request({
                        method: "eth_getTransactionReceipt",
                        params: [n]
                    });
                    if (!e) throw new gh.Yb({
                        hash: n
                    });
                    return (t.chain ? .formatters ? .transactionReceipt ? .format || OV)(e)
                })).apply(this, arguments)
            }
            var LV = T(17627),
                Ux = T(28169),
                RV = T(54963),
                Mpe = T(91849),
                BV = T(68347);

            function ck() {
                return (ck = (0, Ze.Z)(function*(t, n) {
                    const {
                        allowFailure: e = !0,
                        batchSize: i,
                        blockNumber: r,
                        blockTag: s,
                        contracts: o,
                        multicallAddress: a
                    } = n, c = i ? ? ("object" == typeof t.batch ? .multicall && t.batch.multicall.batchSize || 1024);
                    let u = a;
                    if (!u) {
                        if (!t.chain) throw new Error("client chain not configured. multicallAddress is required.");
                        u = (0, Mpe.L)({
                            blockNumber: r,
                            chain: t.chain,
                            contract: "multicall3"
                        })
                    }
                    const h = [
                        []
                    ];
                    let m = 0,
                        x = 0;
                    for (let te = 0; te < o.length; te++) {
                        const {
                            abi: ee,
                            address: _e,
                            args: ye,
                            functionName: Be
                        } = o[te];
                        try {
                            const ze = (0, W0.R)({
                                abi: ee,
                                args: ye,
                                functionName: Be
                            });
                            x += (ze.length - 2) / 2, c > 0 && x > c && h[m].length > 0 && (m++, x = (ze.length - 2) / 2, h[m] = []), h[m] = [...h[m], {
                                allowFailure: !0,
                                callData: ze,
                                target: _e
                            }]
                        } catch (ze) {
                            const Xe = (0, Fx.S)(ze, {
                                abi: ee,
                                address: _e,
                                args: ye,
                                docsPath: "/docs/contract/multicall",
                                functionName: Be
                            });
                            if (!e) throw Xe;
                            h[m] = [...h[m], {
                                allowFailure: !0,
                                callData: "0x",
                                target: _e
                            }]
                        }
                    }
                    const D = yield Promise.allSettled(h.map(te => (0, $i.s)(t, BV.L, "readContract")({
                        abi: LV.F8,
                        address: u,
                        args: [te],
                        blockNumber: r,
                        blockTag: s,
                        functionName: "aggregate3"
                    }))), V = [];
                    for (let te = 0; te < D.length; te++) {
                        const ee = D[te];
                        if ("rejected" === ee.status) {
                            if (!e) throw ee.reason;
                            for (let ye = 0; ye < h[te].length; ye++) V.push({
                                status: "failure",
                                error: ee.reason,
                                result: void 0
                            });
                            continue
                        }
                        const _e = ee.value;
                        for (let ye = 0; ye < _e.length; ye++) {
                            const {
                                returnData: Be,
                                success: ze
                            } = _e[ye], {
                                callData: Xe
                            } = h[te][ye], {
                                abi: ht,
                                address: vt,
                                functionName: jt,
                                args: Cn
                            } = o[V.length];
                            try {
                                if ("0x" === Xe) throw new Es.wb;
                                if (!ze) throw new Ux.VQ({
                                    data: Be
                                });
                                const Xt = (0, RV.k)({
                                    abi: ht,
                                    args: Cn,
                                    data: Be,
                                    functionName: jt
                                });
                                V.push(e ? {
                                    result: Xt,
                                    status: "success"
                                } : Xt)
                            } catch (Xt) {
                                const Rt = (0, Fx.S)(Xt, {
                                    abi: ht,
                                    address: vt,
                                    args: Cn,
                                    docsPath: "/docs/contract/multicall",
                                    functionName: jt
                                });
                                if (!e) throw Rt;
                                V.push({
                                    error: Rt,
                                    result: void 0,
                                    status: "failure"
                                })
                            }
                        }
                    }
                    if (V.length !== o.length) throw new lu.G("multicall results mismatch");
                    return V
                })).apply(this, arguments)
            }

            function lk() {
                return (lk = (0, Ze.Z)(function*(t, {
                    abi: n,
                    address: e,
                    args: i,
                    dataSuffix: r,
                    functionName: s,
                    ...o
                }) {
                    const a = o.account ? (0, id.T)(o.account) : void 0,
                        c = (0, W0.R)({
                            abi: n,
                            args: i,
                            functionName: s
                        });
                    try {
                        const {
                            data: u
                        } = yield(0, $i.s)(t, FA.R, "call")({
                            batch: !1,
                            data: `${c}${r?r.replace("0x",""):""}`,
                            to: e,
                            ...o
                        });
                        return {
                            result: (0, RV.k)({
                                abi: n,
                                args: i,
                                functionName: s,
                                data: u || "0x"
                            }),
                            request: {
                                abi: n,
                                address: e,
                                args: i,
                                dataSuffix: r,
                                functionName: s,
                                ...o
                            }
                        }
                    } catch (u) {
                        throw (0, Fx.S)(u, {
                            abi: n,
                            address: e,
                            args: i,
                            docsPath: "/docs/contract/simulateContract",
                            functionName: s,
                            sender: a ? .address
                        })
                    }
                })).apply(this, arguments)
            }

            function Hx(t, n) {
                return uk.apply(this, arguments)
            }

            function uk() {
                return (uk = (0, Ze.Z)(function*(t, {
                    filter: n
                }) {
                    return n.request({
                        method: "eth_uninstallFilter",
                        params: [n.id]
                    })
                })).apply(this, arguments)
            }
            const Ope = "\x19Ethereum Signed Message:\n",
                Rpe = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

            function HV(t, n) {
                return fk.apply(this, arguments)
            }

            function fk() {
                return (fk = (0, Ze.Z)(function*(t, {
                    address: n,
                    hash: e,
                    signature: i,
                    ...r
                }) {
                    const s = (0, Px.v)(i) ? i : (0, kr.NC)(i);
                    try {
                        const {
                            data: o
                        } = yield(0, $i.s)(t, FA.R, "call")({
                            data: cV({
                                abi: LV.$o,
                                args: [n, e, s],
                                bytecode: Rpe
                            }),
                            ...r
                        });
                        return function zpe(t, n) {
                            return function Hpe(t, n) {
                                if (t.length !== n.length) return !1;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e] !== n[e]) return !1;
                                return !0
                            }((0, Px.v)(t) ? (0, eg.O0)(t) : t, (0, Px.v)(n) ? (0, eg.O0)(n) : n)
                        }(o ? ? "0x0", "0x1")
                    } catch (o) {
                        if (o instanceof Ux.cg) return !1;
                        throw o
                    }
                })).apply(this, arguments)
            }

            function pk() {
                return (pk = (0, Ze.Z)(function*(t, {
                    address: n,
                    message: e,
                    signature: i,
                    ...r
                }) {
                    const s = function Lpe(t, n) {
                        const e = "string" == typeof t ? (0, eg.qX)(t) : t.raw instanceof Uint8Array ? t.raw : (0, eg.O0)(t.raw),
                            i = (0, eg.qX)(`${Ope}${e.length}`);
                        return (0, rd.w)((0, QD.zo)([i, e]), n)
                    }(e);
                    return HV(t, {
                        address: n,
                        hash: s,
                        signature: i,
                        ...r
                    })
                })).apply(this, arguments)
            }

            function Wpe({
                domain: t,
                message: n,
                primaryType: e,
                types: i
            }) {
                const r = typeof t > "u" ? {} : t,
                    s = {
                        EIP712Domain: EA({
                            domain: r
                        }),
                        ...i
                    };
                vV({
                    domain: r,
                    message: n,
                    primaryType: e,
                    types: s
                });
                const o = ["0x1901"];
                return r && o.push(function Gpe({
                    domain: t,
                    types: n
                }) {
                    return $V({
                        data: t,
                        primaryType: "EIP712Domain",
                        types: n
                    })
                }({
                    domain: r,
                    types: s
                })), "EIP712Domain" !== e && o.push($V({
                    data: n,
                    primaryType: e,
                    types: s
                })), (0, rd.w)((0, QD.zo)(o))
            }

            function $V({
                data: t,
                primaryType: n,
                types: e
            }) {
                const i = zV({
                    data: t,
                    primaryType: n,
                    types: e
                });
                return (0, rd.w)(i)
            }

            function zV({
                data: t,
                primaryType: n,
                types: e
            }) {
                const i = [{
                        type: "bytes32"
                    }],
                    r = [Kpe({
                        primaryType: n,
                        types: e
                    })];
                for (const s of e[n]) {
                    const [o, a] = WV({
                        types: e,
                        name: s.name,
                        type: s.type,
                        value: t[s.name]
                    });
                    i.push(o), r.push(a)
                }
                return (0, Dx.E)(i, r)
            }

            function Kpe({
                primaryType: t,
                types: n
            }) {
                const e = (0, kr.NC)(function qpe({
                    primaryType: t,
                    types: n
                }) {
                    let e = "";
                    const i = jV({
                        primaryType: t,
                        types: n
                    });
                    i.delete(t);
                    const r = [t, ...Array.from(i).sort()];
                    for (const s of r) e += `${s}(${n[s].map(({name:o,type:a})=>`
                    $ {
                        a
                    }
                    $ {
                        o
                    }
                    `).join(",")})`;
                    return e
                }({
                    primaryType: t,
                    types: n
                }));
                return (0, rd.w)(e)
            }

            function jV({
                primaryType: t,
                types: n
            }, e = new Set) {
                const r = t.match(/^\w*/u) ? .[0];
                if (e.has(r) || void 0 === n[r]) return e;
                e.add(r);
                for (const s of n[r]) jV({
                    primaryType: s.type,
                    types: n
                }, e);
                return e
            }

            function WV({
                types: t,
                name: n,
                type: e,
                value: i
            }) {
                if (void 0 !== t[e]) return [{
                    type: "bytes32"
                }, (0, rd.w)(zV({
                    data: i,
                    primaryType: e,
                    types: t
                }))];
                if ("bytes" === e) return i = "0x" + (i.length % 2 ? "0" : "") + i.slice(2), [{
                    type: "bytes32"
                }, (0, rd.w)(i)];
                if ("string" === e) return [{
                    type: "bytes32"
                }, (0, rd.w)((0, kr.NC)(i))];
                if (e.lastIndexOf("]") === e.length - 1) {
                    const r = e.slice(0, e.lastIndexOf("[")),
                        s = i.map(o => WV({
                            name: n,
                            type: r,
                            types: t,
                            value: o
                        }));
                    return [{
                        type: "bytes32"
                    }, (0, rd.w)((0, Dx.E)(s.map(([o]) => o), s.map(([, o]) => o)))]
                }
                return [{
                    type: e
                }, i]
            }

            function mk() {
                return (mk = (0, Ze.Z)(function*(t, {
                    address: n,
                    signature: e,
                    message: i,
                    primaryType: r,
                    types: s,
                    domain: o,
                    ...a
                }) {
                    return HV(t, {
                        address: n,
                        hash: Wpe({
                            message: i,
                            primaryType: r,
                            types: s,
                            domain: o
                        }),
                        signature: e,
                        ...a
                    })
                })).apply(this, arguments)
            }
            BigInt(0), BigInt(1), BigInt(2);
            const gk = new Map,
                GV = new Map;
            let Ype = 0;

            function tg(t, n, e) {
                const i = ++Ype,
                    r = () => gk.get(t) || [],
                    o = () => {
                        const h = GV.get(t);
                        1 === r().length && h && h(), (() => {
                            const h = r();
                            gk.set(t, h.filter(m => m.id !== i))
                        })()
                    },
                    a = r();
                if (gk.set(t, [...a, {
                        id: i,
                        fns: n
                    }]), a && a.length > 0) return o;
                const c = {};
                for (const h in n) c[h] = (...m) => {
                    const x = r();
                    if (0 !== x.length)
                        for (const D of x) D.fns[h] ? .(...m)
                };
                const u = e(c);
                return "function" == typeof u && GV.set(t, u), o
            }

            function Z0(t, {
                emitOnBegin: n,
                initialWaitTime: e,
                interval: i
            }) {
                let r = !0;
                const s = () => r = !1;
                return function() {
                    var a = (0, Ze.Z)(function*() {
                        let c;
                        n && (c = yield t({
                            unpoll: s
                        }));
                        const u = (yield e ? .(c)) ? ? i;
                        yield Ox(u);
                        const h = function() {
                            var m = (0, Ze.Z)(function*() {
                                r && (yield t({
                                    unpoll: s
                                }), yield Ox(i), h())
                            });
                            return function() {
                                return m.apply(this, arguments)
                            }
                        }();
                        h()
                    });
                    return function() {
                        return a.apply(this, arguments)
                    }
                }()(), s
            }

            function KV(t, {
                emitOnBegin: n = !1,
                emitMissed: e = !1,
                onBlockNumber: i,
                onError: r,
                poll: s,
                pollingInterval: o = t.pollingInterval
            }) {
                let c;
                return (typeof s < "u" ? s : "webSocket" !== t.transport.type) ? tg((0, uu.P)(["watchBlockNumber", t.uid, n, e, o]), {
                    onBlockNumber: i,
                    onError: r
                }, x => Z0((0, Ze.Z)(function*() {
                    try {
                        const D = yield(0, $i.s)(t, K0, "getBlockNumber")({
                            cacheTime: 0
                        });
                        if (c) {
                            if (D === c) return;
                            if (D - c > 1 && e)
                                for (let V = c + 1 n; V < D; V++) x.onBlockNumber(V, c), c = V
                        }(!c || D > c) && (x.onBlockNumber(D, c), c = D)
                    } catch (D) {
                        x.onError ? .(D)
                    }
                }), {
                    emitOnBegin: n,
                    interval: o
                })) : (() => {
                    let m = !0,
                        x = () => m = !1;
                    return (0, Ze.Z)(function*() {
                        try {
                            const {
                                unsubscribe: D
                            } = yield t.transport.subscribe({
                                params: ["newHeads"],
                                onData(V) {
                                    if (!m) return;
                                    const te = (0, aa.y_)(V.result ? .number);
                                    i(te, c), c = te
                                },
                                onError(V) {
                                    r ? .(V)
                                }
                            });
                            x = D, m || x()
                        } catch (D) {
                            r ? .(D)
                        }
                    })(), x
                })()
            }

            function yk() {
                return (yk = (0, Ze.Z)(function*(t, {
                    confirmations: n = 1,
                    hash: e,
                    onReplaced: i,
                    pollingInterval: r = t.pollingInterval,
                    timeout: s
                }) {
                    const o = (0, uu.P)(["waitForTransactionReceipt", t.uid, e]);
                    let a, c, u, h = !1;
                    return new Promise((m, x) => {
                        s && setTimeout(() => x(new gh.mc({
                            hash: e
                        })), s);
                        const D = tg(o, {
                            onReplaced: i,
                            resolve: m,
                            reject: x
                        }, V => {
                            const te = (0, $i.s)(t, KV, "watchBlockNumber")({
                                emitMissed: !0,
                                emitOnBegin: !0,
                                poll: !0,
                                pollingInterval: r,
                                onBlockNumber: ee => (0, Ze.Z)(function*() {
                                    if (h) return;
                                    let _e = ee;
                                    const ye = Be => {
                                        te(), Be(), D()
                                    };
                                    try {
                                        if (u) {
                                            if (n > 1 && (!u.blockNumber || _e - u.blockNumber + 1 n < n)) return;
                                            return void ye(() => V.resolve(u))
                                        }
                                        if (a || (h = !0, yield OA((0, Ze.Z)(function*() {
                                                a = yield(0, $i.s)(t, ik, "getTransaction")({
                                                    hash: e
                                                }), a.blockNumber && (_e = a.blockNumber)
                                            }), {
                                                delay: ({
                                                    count: Be
                                                }) => 200 * ~~(1 << Be),
                                                retryCount: 6
                                            }), h = !1), u = yield(0, $i.s)(t, ok, "getTransactionReceipt")({
                                                hash: e
                                            }), n > 1 && (!u.blockNumber || _e - u.blockNumber + 1 n < n)) return;
                                        ye(() => V.resolve(u))
                                    } catch (Be) {
                                        if (a && (Be instanceof gh.Bh || Be instanceof gh.Yb)) try {
                                            c = a, h = !0;
                                            const ze = yield OA(() => (0, $i.s)(t, yh, "getBlock")({
                                                blockNumber: _e,
                                                includeTransactions: !0
                                            }), {
                                                delay: ({
                                                    count: vt
                                                }) => 200 * ~~(1 << vt),
                                                retryCount: 6,
                                                shouldRetry: ({
                                                    error: vt
                                                }) => vt instanceof pV
                                            });
                                            h = !1;
                                            const Xe = ze.transactions.find(({
                                                from: vt,
                                                nonce: jt
                                            }) => vt === c.from && jt === c.nonce);
                                            if (!Xe || (u = yield(0, $i.s)(t, ok, "getTransactionReceipt")({
                                                    hash: Xe.hash
                                                }), n > 1 && (!u.blockNumber || _e - u.blockNumber + 1 n < n))) return;
                                            let ht = "replaced";
                                            Xe.to === c.to && Xe.value === c.value ? ht = "repriced" : Xe.from === Xe.to && 0 n === Xe.value && (ht = "cancelled"), ye(() => {
                                                V.onReplaced ? .({
                                                    reason: ht,
                                                    replacedTransaction: c,
                                                    transaction: Xe,
                                                    transactionReceipt: u
                                                }), V.resolve(u)
                                            })
                                        } catch (ze) {
                                            ye(() => V.reject(ze))
                                        } else ye(() => V.reject(Be))
                                    }
                                })()
                            })
                        })
                    })
                })).apply(this, arguments)
            }

            function nme(t) {
                return {
                    call: n => (0, FA.R)(t, n),
                    createBlockFilter: () => function lpe(t) {
                        return VA.apply(this, arguments)
                    }(t),
                    createContractEventFilter: n => EV(t, n),
                    createEventFilter: n => DV(t, n),
                    createPendingTransactionFilter: () => AV(t),
                    estimateContractGas: n => function dpe(t, n) {
                        return zA.apply(this, arguments)
                    }(t, n),
                    estimateGas: n => hA(t, n),
                    getBalance: n => function hpe(t, n) {
                        return jA.apply(this, arguments)
                    }(t, n),
                    getBlock: n => yh(t, n),
                    getBlockNumber: n => K0(t, n),
                    getBlockTransactionCount: n => function ype(t) {
                        return KA.apply(this, arguments)
                    }(t, n),
                    getBytecode: n => function _pe(t, n) {
                        return qA.apply(this, arguments)
                    }(t, n),
                    getChainId: () => j0(t),
                    getContractEvents: n => PV(t, n),
                    getEnsAddress: n => (0, rpe.O)(t, n),
                    getEnsAvatar: n => (0, spe.r)(t, n),
                    getEnsName: n => (0, ope.w)(t, n),
                    getEnsResolver: n => (0, ape.S)(t, n),
                    getEnsText: n => (0, cpe.g)(t, n),
                    getFeeHistory: n => function wpe(t, n) {
                        return QA.apply(this, arguments)
                    }(t, n),
                    estimateFeesPerGas: n => function Rfe(t, n) {
                        return lA.apply(this, arguments)
                    }(t, n),
                    getFilterChanges: n => Vx(t, n),
                    getFilterLogs: n => function xpe(t, n) {
                        return ek.apply(this, arguments)
                    }(t, n),
                    getGasPrice: () => sA(t),
                    getLogs: n => ZA(t, n),
                    getProof: n => function Spe(t, n) {
                        return tk.apply(this, arguments)
                    }(t, n),
                    estimateMaxPriorityFeePerGas: n => function Lfe(t, n) {
                        return aA.apply(this, arguments)
                    }(t, n),
                    getStorageAt: n => function Epe(t, n) {
                        return nk.apply(this, arguments)
                    }(t, n),
                    getTransaction: n => ik(t, n),
                    getTransactionConfirmations: n => function Dpe(t, n) {
                        return sk.apply(this, arguments)
                    }(t, n),
                    getTransactionCount: n => yV(t, n),
                    getTransactionReceipt: n => ok(t, n),
                    multicall: n => function Ipe(t, n) {
                        return ck.apply(this, arguments)
                    }(t, n),
                    prepareTransactionRequest: n => Ix(t, n),
                    readContract: n => (0, BV.L)(t, n),
                    sendRawTransaction: n => gA(t, n),
                    simulateContract: n => function Ppe(t, n) {
                        return lk.apply(this, arguments)
                    }(t, n),
                    verifyMessage: n => function jpe(t, n) {
                        return pk.apply(this, arguments)
                    }(t, n),
                    verifyTypedData: n => function Zpe(t, n) {
                        return mk.apply(this, arguments)
                    }(t, n),
                    uninstallFilter: n => Hx(t, n),
                    waitForTransactionReceipt: n => function Xpe(t, n) {
                        return yk.apply(this, arguments)
                    }(t, n),
                    watchBlocks: n => function Qpe(t, {
                        blockTag: n = "latest",
                        emitMissed: e = !1,
                        emitOnBegin: i = !1,
                        onBlock: r,
                        onError: s,
                        includeTransactions: o,
                        poll: a,
                        pollingInterval: c = t.pollingInterval
                    }) {
                        const h = o ? ? !1;
                        let m;
                        return (typeof a < "u" ? a : "webSocket" !== t.transport.type) ? tg((0, uu.P)(["watchBlocks", t.uid, e, i, h, c]), {
                            onBlock: r,
                            onError: s
                        }, te => Z0((0, Ze.Z)(function*() {
                            try {
                                const ee = yield(0, $i.s)(t, yh, "getBlock")({
                                    blockTag: n,
                                    includeTransactions: h
                                });
                                if (ee.number && m ? .number) {
                                    if (ee.number === m.number) return;
                                    if (ee.number - m.number > 1 && e)
                                        for (let _e = m ? .number + 1 n; _e < ee.number; _e++) {
                                            const ye = yield(0, $i.s)(t, yh, "getBlock")({
                                                blockNumber: _e,
                                                includeTransactions: h
                                            });
                                            te.onBlock(ye, m), m = ye
                                        }
                                }(!m ? .number || "pending" === n && !ee ? .number || ee.number && ee.number > m.number) && (te.onBlock(ee, m), m = ee)
                            } catch (ee) {
                                te.onError ? .(ee)
                            }
                        }), {
                            emitOnBegin: i,
                            interval: c
                        })) : (() => {
                            let V = !0,
                                te = () => V = !1;
                            return (0, Ze.Z)(function*() {
                                try {
                                    const {
                                        unsubscribe: ee
                                    } = yield t.transport.subscribe({
                                        params: ["newHeads"],
                                        onData(_e) {
                                            if (!V) return;
                                            const Be = (t.chain ? .formatters ? .block ? .format || iA)(_e.result);
                                            r(Be, m), m = Be
                                        },
                                        onError(_e) {
                                            s ? .(_e)
                                        }
                                    });
                                    te = ee, V || te()
                                } catch (ee) {
                                    s ? .(ee)
                                }
                            })(), te
                        })()
                    }(t, n),
                    watchBlockNumber: n => KV(t, n),
                    watchContractEvent: n => function Jpe(t, {
                        abi: n,
                        address: e,
                        args: i,
                        batch: r = !0,
                        eventName: s,
                        onError: o,
                        onLogs: a,
                        poll: c,
                        pollingInterval: u = t.pollingInterval,
                        strict: h
                    }) {
                        return (typeof c < "u" ? c : "webSocket" !== t.transport.type) ? (() => {
                            const V = (0, uu.P)(["watchContractEvent", e, i, r, t.uid, s, u]),
                                te = h ? ? !1;
                            return tg(V, {
                                onLogs: a,
                                onError: o
                            }, ee => {
                                let _e, ye, Be = !1;
                                const ze = Z0((0, Ze.Z)(function*() {
                                    if (Be) try {
                                        let Xe;
                                        if (ye) Xe = yield(0, $i.s)(t, Vx, "getFilterChanges")({
                                            filter: ye
                                        });
                                        else {
                                            const ht = yield(0, $i.s)(t, K0, "getBlockNumber")({});
                                            Xe = _e && _e !== ht ? yield(0, $i.s)(t, PV, "getContractEvents")({
                                                abi: n,
                                                address: e,
                                                args: i,
                                                eventName: s,
                                                fromBlock: _e + 1 n,
                                                toBlock: ht,
                                                strict: te
                                            }): [], _e = ht
                                        }
                                        if (0 === Xe.length) return;
                                        if (r) ee.onLogs(Xe);
                                        else
                                            for (const ht of Xe) ee.onLogs([ht])
                                    } catch (Xe) {
                                        ye && Xe instanceof oi.yR && (Be = !1), ee.onError ? .(Xe)
                                    } else {
                                        try {
                                            ye = yield(0, $i.s)(t, EV, "createContractEventFilter")({
                                                abi: n,
                                                address: e,
                                                args: i,
                                                eventName: s,
                                                strict: te
                                            })
                                        } catch {}
                                        Be = !0
                                    }
                                }), {
                                    emitOnBegin: !0,
                                    interval: u
                                });
                                return (0, Ze.Z)(function*() {
                                    ye && (yield(0, $i.s)(t, Hx, "uninstallFilter")({
                                        filter: ye
                                    })), ze()
                                })
                            })
                        })() : (() => {
                            let V = !0,
                                te = () => V = !1;
                            return (0, Ze.Z)(function*() {
                                try {
                                    const ee = s ? G0({
                                            abi: n,
                                            eventName: s,
                                            args: i
                                        }) : [],
                                        {
                                            unsubscribe: _e
                                        } = yield t.transport.subscribe({
                                            params: ["logs", {
                                                address: e,
                                                topics: ee
                                            }],
                                            onData(ye) {
                                                if (!V) return;
                                                const Be = ye.result;
                                                try {
                                                    const {
                                                        eventName: ze,
                                                        args: Xe
                                                    } = q0({
                                                        abi: n,
                                                        data: Be.data,
                                                        topics: Be.topics,
                                                        strict: h
                                                    }), ht = Al(Be, {
                                                        args: Xe,
                                                        eventName: ze
                                                    });
                                                    a([ht])
                                                } catch (ze) {
                                                    let Xe, ht;
                                                    if (ze instanceof Es.SM || ze instanceof Es.Gy) {
                                                        if (h) return;
                                                        Xe = ze.abiItem.name, ht = ze.abiItem.inputs ? .some(jt => !("name" in jt && jt.name))
                                                    }
                                                    const vt = Al(Be, {
                                                        args: ht ? [] : {},
                                                        eventName: Xe
                                                    });
                                                    a([vt])
                                                }
                                            },
                                            onError(ye) {
                                                o ? .(ye)
                                            }
                                        });
                                    te = _e, V || te()
                                } catch (ee) {
                                    o ? .(ee)
                                }
                            })(), te
                        })()
                    }(t, n),
                    watchEvent: n => function eme(t, {
                        address: n,
                        args: e,
                        batch: i = !0,
                        event: r,
                        events: s,
                        onError: o,
                        onLogs: a,
                        poll: c,
                        pollingInterval: u = t.pollingInterval,
                        strict: h
                    }) {
                        const x = h ? ? !1;
                        return (typeof c < "u" ? c : "webSocket" !== t.transport.type) ? tg((0, uu.P)(["watchEvent", n, e, i, t.uid, r, u]), {
                            onLogs: a,
                            onError: o
                        }, ee => {
                            let _e, ye, Be = !1;
                            const ze = Z0((0, Ze.Z)(function*() {
                                if (Be) try {
                                    let Xe;
                                    if (ye) Xe = yield(0, $i.s)(t, Vx, "getFilterChanges")({
                                        filter: ye
                                    });
                                    else {
                                        const ht = yield(0, $i.s)(t, K0, "getBlockNumber")({});
                                        Xe = _e && _e !== ht ? yield(0, $i.s)(t, ZA, "getLogs")({
                                            address: n,
                                            args: e,
                                            event: r,
                                            events: s,
                                            fromBlock: _e + 1 n,
                                            toBlock: ht
                                        }): [], _e = ht
                                    }
                                    if (0 === Xe.length) return;
                                    if (i) ee.onLogs(Xe);
                                    else
                                        for (const ht of Xe) ee.onLogs([ht])
                                } catch (Xe) {
                                    ye && Xe instanceof oi.yR && (Be = !1), ee.onError ? .(Xe)
                                } else {
                                    try {
                                        ye = yield(0, $i.s)(t, DV, "createEventFilter")({
                                            address: n,
                                            args: e,
                                            event: r,
                                            events: s,
                                            strict: x
                                        })
                                    } catch {}
                                    Be = !0
                                }
                            }), {
                                emitOnBegin: !0,
                                interval: u
                            });
                            return (0, Ze.Z)(function*() {
                                ye && (yield(0, $i.s)(t, Hx, "uninstallFilter")({
                                    filter: ye
                                })), ze()
                            })
                        }) : (() => {
                            let te = !0,
                                ee = () => te = !1;
                            return (0, Ze.Z)(function*() {
                                try {
                                    const _e = s ? ? (r ? [r] : void 0);
                                    let ye = [];
                                    _e && (ye = [_e.flatMap(ze => G0({
                                        abi: [ze],
                                        eventName: ze.name,
                                        args: e
                                    }))], r && (ye = ye[0]));
                                    const {
                                        unsubscribe: Be
                                    } = yield t.transport.subscribe({
                                        params: ["logs", {
                                            address: n,
                                            topics: ye
                                        }],
                                        onData(ze) {
                                            if (!te) return;
                                            const Xe = ze.result;
                                            try {
                                                const {
                                                    eventName: ht,
                                                    args: vt
                                                } = q0({
                                                    abi: _e,
                                                    data: Xe.data,
                                                    topics: Xe.topics,
                                                    strict: x
                                                }), jt = Al(Xe, {
                                                    args: vt,
                                                    eventName: ht
                                                });
                                                a([jt])
                                            } catch (ht) {
                                                let vt, jt;
                                                if (ht instanceof Es.SM || ht instanceof Es.Gy) {
                                                    if (h) return;
                                                    vt = ht.abiItem.name, jt = ht.abiItem.inputs ? .some(Xt => !("name" in Xt && Xt.name))
                                                }
                                                const Cn = Al(Xe, {
                                                    args: jt ? [] : {},
                                                    eventName: vt
                                                });
                                                a([Cn])
                                            }
                                        },
                                        onError(ze) {
                                            o ? .(ze)
                                        }
                                    });
                                    ee = Be, te || ee()
                                } catch (_e) {
                                    o ? .(_e)
                                }
                            })(), ee
                        })()
                    }(t, n),
                    watchPendingTransactions: n => function tme(t, {
                        batch: n = !0,
                        onError: e,
                        onTransactions: i,
                        poll: r,
                        pollingInterval: s = t.pollingInterval
                    }) {
                        return (typeof r < "u" ? r : "webSocket" !== t.transport.type) ? tg((0, uu.P)(["watchPendingTransactions", t.uid, n, s]), {
                            onTransactions: i,
                            onError: e
                        }, h => {
                            let m;
                            const x = Z0((0, Ze.Z)(function*() {
                                try {
                                    if (!m) try {
                                        return void(m = yield(0, $i.s)(t, AV, "createPendingTransactionFilter")({}))
                                    } catch (V) {
                                        throw x(), V
                                    }
                                    const D = yield(0, $i.s)(t, Vx, "getFilterChanges")({
                                        filter: m
                                    });
                                    if (0 === D.length) return;
                                    if (n) h.onTransactions(D);
                                    else
                                        for (const V of D) h.onTransactions([V])
                                } catch (D) {
                                    h.onError ? .(D)
                                }
                            }), {
                                emitOnBegin: !0,
                                interval: s
                            });
                            return (0, Ze.Z)(function*() {
                                m && (yield(0, $i.s)(t, Hx, "uninstallFilter")({
                                    filter: m
                                })), x()
                            })
                        }) : (() => {
                            let u = !0,
                                h = () => u = !1;
                            return (0, Ze.Z)(function*() {
                                try {
                                    const {
                                        unsubscribe: m
                                    } = yield t.transport.subscribe({
                                        params: ["newPendingTransactions"],
                                        onData(x) {
                                            u && i([x.result])
                                        },
                                        onError(x) {
                                            e ? .(x)
                                        }
                                    });
                                    h = m, u || h()
                                } catch (m) {
                                    e ? .(m)
                                }
                            })(), h
                        })()
                    }(t, n)
                }
            }

            function _k(t) {
                const {
                    key: n = "public",
                    name: e = "Public Client"
                } = t;
                return aV({ ...t,
                    key: n,
                    name: e,
                    type: "publicClient"
                }).extend(nme)
            }

            function qV(t, n = {}) {
                const {
                    key: e = "fallback",
                    name: i = "Fallback",
                    rank: r = !1,
                    retryCount: s,
                    retryDelay: o
                } = n;
                return ({
                    chain: a,
                    pollingInterval: c = 4e3,
                    timeout: u
                }) => {
                    let h = t,
                        m = () => {};
                    const x = Lx({
                        key: e,
                        name: i,
                        request: ({
                            method: D,
                            params: V
                        }) => (0, Ze.Z)(function*() {
                            const te = function() {
                                var ee = (0, Ze.Z)(function*(_e = 0) {
                                    const ye = h[_e]({
                                        chain: a,
                                        retryCount: 0,
                                        timeout: u
                                    });
                                    try {
                                        const Be = yield ye.request({
                                            method: D,
                                            params: V
                                        });
                                        return m({
                                            method: D,
                                            params: V,
                                            response: Be,
                                            transport: ye,
                                            status: "success"
                                        }), Be
                                    } catch (Be) {
                                        if (m({
                                                error: Be,
                                                method: D,
                                                params: V,
                                                transport: ye,
                                                status: "error"
                                            }), bV(Be) || _e === h.length - 1) throw Be;
                                        return te(_e + 1)
                                    }
                                });
                                return function() {
                                    return ee.apply(this, arguments)
                                }
                            }();
                            return te()
                        })(),
                        retryCount: s,
                        retryDelay: o,
                        type: "fallback"
                    }, {
                        onResponse: D => m = D,
                        transports: h.map(D => D({
                            chain: a,
                            retryCount: 0
                        }))
                    });
                    if (r) {
                        const D = "object" == typeof r ? r : {};
                        ! function ime({
                            chain: t,
                            interval: n = 4e3,
                            onTransports: e,
                            sampleCount: i = 10,
                            timeout: r = 1e3,
                            transports: s,
                            weights: o = {}
                        }) {
                            const {
                                stability: a = .7,
                                latency: c = .3
                            } = o, u = [], h = function() {
                                var m = (0, Ze.Z)(function*() {
                                    const x = yield Promise.all(s.map(function() {
                                        var te = (0, Ze.Z)(function*(ee) {
                                            const _e = ee({
                                                    chain: t,
                                                    retryCount: 0,
                                                    timeout: r
                                                }),
                                                ye = Date.now();
                                            let Be, ze;
                                            try {
                                                yield _e.request({
                                                    method: "net_listening"
                                                }), ze = 1
                                            } catch {
                                                ze = 0
                                            } finally {
                                                Be = Date.now()
                                            }
                                            return {
                                                latency: Be - ye,
                                                success: ze
                                            }
                                        });
                                        return function(ee) {
                                            return te.apply(this, arguments)
                                        }
                                    }()));
                                    u.push(x), u.length > i && u.shift();
                                    const D = Math.max(...u.map(te => Math.max(...te.map(({
                                            latency: ee
                                        }) => ee)))),
                                        V = s.map((te, ee) => {
                                            const _e = u.map(ht => ht[ee].latency),
                                                Be = 1 - _e.reduce((ht, vt) => ht + vt, 0) / _e.length / D,
                                                ze = u.map(ht => ht[ee].success),
                                                Xe = ze.reduce((ht, vt) => ht + vt, 0) / ze.length;
                                            return 0 === Xe ? [0, ee] : [c * Be + a * Xe, ee]
                                        }).sort((te, ee) => ee[0] - te[0]);
                                    e(V.map(([, te]) => s[te])), yield Ox(n), h()
                                });
                                return function() {
                                    return m.apply(this, arguments)
                                }
                            }();
                            h()
                        }({
                            chain: a,
                            interval: D.interval ? ? c,
                            onTransports: V => h = V,
                            sampleCount: D.sampleCount,
                            timeout: D.timeout,
                            transports: h,
                            weights: D.weights
                        })
                    }
                    return x
                }
            }
            class ZV extends lu.G {
                constructor() {
                    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
                        docsPath: "/docs/clients/intro"
                    })
                }
            }
            var YV = T(87447);
            const XV = function rme() {
                if (typeof WebSocket < "u") return WebSocket;
                if (typeof global.WebSocket < "u") return global.WebSocket;
                if (typeof window.WebSocket < "u") return window.WebSocket;
                if (typeof self.WebSocket < "u") return self.WebSocket;
                throw new Error("`WebSocket` is not supported in this environment")
            }();

            function QV(t, {
                errorInstance: n = new Error("timed out"),
                timeout: e,
                signal: i
            }) {
                return new Promise((r, s) => {
                    (0, Ze.Z)(function*() {
                        let o;
                        try {
                            const a = new AbortController;
                            e > 0 && (o = setTimeout(() => {
                                i ? a.abort() : s(n)
                            }, e)), r(yield t({
                                signal: a ? .signal
                            }))
                        } catch (a) {
                            "AbortError" === a.name && s(n), s(a)
                        } finally {
                            clearTimeout(o)
                        }
                    })()
                })
            }
            let vk = 0;

            function bk() {
                return bk = (0, Ze.Z)(function*(t, {
                    body: n,
                    fetchOptions: e = {},
                    timeout: i = 1e4
                }) {
                    const {
                        headers: r,
                        method: s,
                        signal: o
                    } = e;
                    try {
                        const a = yield QV(function() {
                            var u = (0, Ze.Z)(function*({
                                signal: h
                            }) {
                                return yield fetch(t, { ...e,
                                    body: Array.isArray(n) ? (0, uu.P)(n.map(x => ({
                                        jsonrpc: "2.0",
                                        id: x.id ? ? vk++,
                                        ...x
                                    }))) : (0, uu.P)({
                                        jsonrpc: "2.0",
                                        id: n.id ? ? vk++,
                                        ...n
                                    }),
                                    headers: { ...r,
                                        "Content-Type": "application/json"
                                    },
                                    method: s || "POST",
                                    signal: o || (i > 0 ? h : void 0)
                                })
                            });
                            return function(h) {
                                return u.apply(this, arguments)
                            }
                        }(), {
                            errorInstance: new Dl.W5({
                                body: n,
                                url: t
                            }),
                            timeout: i,
                            signal: !0
                        });
                        let c;
                        if (c = a.headers.get("Content-Type") ? .startsWith("application/json") ? yield a.json(): yield a.text(), !a.ok) throw new Dl.Gg({
                            body: n,
                            details: (0, uu.P)(c.error) || a.statusText,
                            headers: a.headers,
                            status: a.status,
                            url: t
                        });
                        return c
                    } catch (a) {
                        throw a instanceof Dl.Gg || a instanceof Dl.W5 ? a : new Dl.Gg({
                            body: n,
                            details: a.message,
                            url: t
                        })
                    }
                }), bk.apply(this, arguments)
            }
            const wk = new Map;

            function xk(t) {
                return Ck.apply(this, arguments)
            }

            function Ck() {
                return Ck = (0, Ze.Z)(function*(t) {
                    let n = wk.get(t);
                    if (n) return n;
                    const {
                        schedule: e
                    } = (0, YV.S)({
                        id: t,
                        fn: (s = (0, Ze.Z)(function*() {
                            const o = new XV(t),
                                a = new Map,
                                c = new Map,
                                u = ({
                                    data: m
                                }) => {
                                    const x = JSON.parse(m),
                                        D = "eth_subscription" === x.method,
                                        V = D ? x.params.subscription : x.id,
                                        te = D ? c : a,
                                        ee = te.get(V);
                                    ee && ee({
                                        data: m
                                    }), D || te.delete(V)
                                },
                                h = () => {
                                    wk.delete(t), o.removeEventListener("close", h), o.removeEventListener("message", u)
                                };
                            return o.addEventListener("close", h), o.addEventListener("message", u), o.readyState === XV.CONNECTING && (yield new Promise((m, x) => {
                                o && (o.onopen = m, o.onerror = x)
                            })), n = Object.assign(o, {
                                requests: a,
                                subscriptions: c
                            }), wk.set(t, n), [n]
                        }), function() {
                            return s.apply(this, arguments)
                        })
                    }), [i, [r]] = yield e();
                    var s;
                    return r
                }), Ck.apply(this, arguments)
            }

            function Tk() {
                return (Tk = (0, Ze.Z)(function*(t, {
                    body: n,
                    timeout: e = 1e4
                }) {
                    return QV(() => new Promise(i => ng.webSocket(t, {
                        body: n,
                        onResponse: i
                    })), {
                        errorInstance: new Dl.W5({
                            body: n,
                            url: t.url
                        }),
                        timeout: e
                    })
                })).apply(this, arguments)
            }
            const ng = {
                http: function sme(t, n) {
                    return bk.apply(this, arguments)
                },
                webSocket: function ome(t, {
                    body: n,
                    onResponse: e
                }) {
                    if (t.readyState === t.CLOSED || t.readyState === t.CLOSING) throw new Dl.c9({
                        body: n,
                        url: t.url,
                        details: "Socket is closed."
                    });
                    const i = vk++,
                        r = ({
                            data: s
                        }) => {
                            const o = JSON.parse(s);
                            "number" == typeof o.id && i !== o.id || (e ? .(o), "eth_subscribe" === n.method && "string" == typeof o.result && t.subscriptions.set(o.result, r), "eth_unsubscribe" === n.method && t.subscriptions.delete(n.params ? .[0]))
                        };
                    return t.requests.set(i, r), t.send(JSON.stringify({
                        jsonrpc: "2.0",
                        ...n,
                        id: i
                    })), t
                },
                webSocketAsync: function ame(t, n) {
                    return Tk.apply(this, arguments)
                }
            };

            function JV(t, n = {}) {
                const {
                    batch: e,
                    fetchOptions: i,
                    key: r = "http",
                    name: s = "HTTP JSON-RPC",
                    retryDelay: o
                } = n;
                return ({
                    chain: a,
                    retryCount: c,
                    timeout: u
                }) => {
                    const {
                        batchSize: h = 1e3,
                        wait: m = 0
                    } = "object" == typeof e ? e : {}, x = n.retryCount ? ? c, D = u ? ? n.timeout ? ? 1e4, V = t || a ? .rpcUrls.default.http[0];
                    if (!V) throw new ZV;
                    return Lx({
                        key: r,
                        name: s,
                        request: ({
                            method: te,
                            params: ee
                        }) => (0, Ze.Z)(function*() {
                            const _e = {
                                    method: te,
                                    params: ee
                                },
                                {
                                    schedule: ye
                                } = (0, YV.S)({
                                    id: `${t}`,
                                    wait: m,
                                    shouldSplitBatch: ht => ht.length > h,
                                    fn: ht => ng.http(V, {
                                        body: ht,
                                        fetchOptions: i,
                                        timeout: D
                                    }),
                                    sort: (ht, vt) => ht.id - vt.id
                                }),
                                Be = function() {
                                    var ht = (0, Ze.Z)(function*(vt) {
                                        return e ? ye(vt) : [yield ng.http(V, {
                                            body: vt,
                                            fetchOptions: i,
                                            timeout: D
                                        })]
                                    });
                                    return function(jt) {
                                        return ht.apply(this, arguments)
                                    }
                                }(),
                                [{
                                    error: ze,
                                    result: Xe
                                }] = yield Be(_e);
                            if (ze) throw new Dl.bs({
                                body: _e,
                                error: ze,
                                url: V
                            });
                            return Xe
                        })(),
                        retryCount: x,
                        retryDelay: o,
                        timeout: D,
                        type: "http"
                    }, {
                        fetchOptions: i,
                        url: t
                    })
                }
            }
            var eU = T(99744);

            function dme(t, n) {
                let e;
                try {
                    e = t()
                } catch {
                    return
                }
                return {
                    getItem: r => {
                        var s;
                        const o = c => null === c ? null : JSON.parse(c, n ? .reviver),
                            a = null != (s = e.getItem(r)) ? s : null;
                        return a instanceof Promise ? a.then(o) : o(a)
                    },
                    setItem: (r, s) => e.setItem(r, JSON.stringify(s, n ? .replacer)),
                    removeItem: r => e.removeItem(r)
                }
            }
            const Y0 = t => n => {
                    try {
                        const e = t(n);
                        return e instanceof Promise ? e : {
                            then: i => Y0(i)(e),
                            catch (i) {
                                return this
                            }
                        }
                    } catch (e) {
                        return {
                            then(i) {
                                return this
                            },
                            catch: i => Y0(i)(e)
                        }
                    }
                },
                tU = t => {
                    let n;
                    const e = new Set,
                        i = (h, m) => {
                            const x = "function" == typeof h ? h(n) : h;
                            if (!Object.is(x, n)) {
                                const D = n;
                                n = m ? ? ("object" != typeof x || null === x) ? x : Object.assign({}, n, x), e.forEach(V => V(n, D))
                            }
                        },
                        r = () => n,
                        c = {
                            setState: i,
                            getState: r,
                            getInitialState: () => u,
                            subscribe: h => (e.add(h), () => e.delete(h)),
                            destroy: () => {
                                console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), e.clear()
                            }
                        },
                        u = n = t(i, r, c);
                    return c
                };
            var iU = T(24102),
                mme = T(70783);

            function Dk(t, n) {
                if (Object.is(t, n)) return !0;
                if ("object" != typeof t || null === t || "object" != typeof n || null === n) return !1;
                if (t instanceof Map && n instanceof Map) {
                    if (t.size !== n.size) return !1;
                    for (const [i, r] of t)
                        if (!Object.is(r, n.get(i))) return !1;
                    return !0
                }
                if (t instanceof Set && n instanceof Set) {
                    if (t.size !== n.size) return !1;
                    for (const i of t)
                        if (!n.has(i)) return !1;
                    return !0
                }
                const e = Object.keys(t);
                if (e.length !== Object.keys(n).length) return !1;
                for (const i of e)
                    if (!Object.prototype.hasOwnProperty.call(n, i) || !Object.is(t[i], n[i])) return !1;
                return !0
            }
            var yme = class extends Error {
                    constructor({
                        activeChain: t,
                        targetChain: n
                    }) {
                        super(`Chain mismatch: Expected "${n}", received "${t}".`), this.name = "ChainMismatchError"
                    }
                },
                _me = class extends Error {
                    constructor({
                        chainId: t,
                        connectorId: n
                    }) {
                        super(`Chain "${t}" not configured${n?` for connector "${n}"`:""}.`), this.name = "ChainNotConfigured"
                    }
                },
                vme = class extends Error {
                    constructor() {
                        super(...arguments), this.name = "ConnectorAlreadyConnectedError", this.message = "Connector already connected"
                    }
                },
                bme = class extends Error {
                    constructor() {
                        super(...arguments), this.name = "ConfigChainsNotFound", this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work."
                    }
                },
                wme = class extends Error {
                    constructor({
                        connector: t
                    }) {
                        super(`"${t.name}" does not support programmatic chain switching.`), this.name = "SwitchChainNotSupportedError"
                    }
                },
                Ak = (t, {
                    find: n,
                    replace: e
                }) => t && n(t) ? e(t) : "object" != typeof t ? t : Array.isArray(t) ? t.map(i => Ak(i, {
                    find: n,
                    replace: e
                })) : t instanceof Object ? Object.entries(t).reduce((i, [r, s]) => ({ ...i,
                    [r]: Ak(s, {
                        find: n,
                        replace: e
                    })
                }), {}) : t;

            function xme(t) {
                const n = JSON.parse(t);
                return Ak(n, {
                    find: i => "string" == typeof i && i.startsWith("#bigint."),
                    replace: i => BigInt(i.replace("#bigint.", ""))
                })
            }

            function Wx(t) {
                return "number" == typeof t ? t : "wei" === t ? 0 : Math.abs(eU.Bd[t])
            }

            function sU(t, n) {
                return t.slice(0, n).join(".") || "."
            }

            function oU(t, n) {
                const {
                    length: e
                } = t;
                for (let i = 0; i < e; ++i)
                    if (t[i] === n) return i + 1;
                return 0
            }

            function Sme(t, n, e, i) {
                return JSON.stringify(t, function Tme(t, n) {
                    const e = "function" == typeof t,
                        i = "function" == typeof n,
                        r = [],
                        s = [];
                    return function(a, c) {
                        if ("object" == typeof c)
                            if (r.length) {
                                const u = oU(r, this);
                                0 === u ? r[r.length] = this : (r.splice(u), s.splice(u)), s[s.length] = a;
                                const h = oU(r, c);
                                if (0 !== h) return i ? n.call(this, a, c, sU(s, h)) : `[ref=${sU(s,h)}]`
                            } else r[0] = c, s[0] = a;
                        return e ? t.call(this, a, c) : c
                    }
                }((r, s) => {
                    const o = "bigint" == typeof s ? `#bigint.${s.toString()}` : s;
                    return n ? .(r, o) || o
                }, i), e ? ? void 0)
            }
            var ig, X0, kk, cU, Mk, Eme = {
                getItem: t => "",
                setItem: (t, n) => null,
                removeItem: t => null
            };

            function Dme({
                deserialize: t = xme,
                key: n = "wagmi",
                serialize: e = Sme,
                storage: i
            }) {
                return { ...i,
                    getItem: (r, s = null) => {
                        const o = i.getItem(`${n}.${r}`);
                        try {
                            return o ? t(o) : s
                        } catch (a) {
                            return console.warn(a), s
                        }
                    },
                    setItem: (r, s) => {
                        if (null === s) i.removeItem(`${n}.${r}`);
                        else try {
                            i.setItem(`${n}.${r}`, e(s))
                        } catch (o) {
                            console.error(o)
                        }
                    },
                    removeItem: r => i.removeItem(`${n}.${r}`)
                }
            }

            function kme(t) {
                const n = new class {
                    constructor({
                        autoConnect: t = !1,
                        connectors: n = [new wV],
                        publicClient: e,
                        storage: i = Dme({
                            storage: typeof window < "u" ? window.localStorage : Eme
                        }),
                        logger: r = {
                            warn: console.warn
                        },
                        webSocketPublicClient: s
                    }) {
                        var o = this;
                        NA(this, kk), this.publicClients = new Map, this.webSocketPublicClients = new Map, NA(this, ig, void 0), NA(this, X0, void 0), this.args = {
                            autoConnect: t,
                            connectors: n,
                            logger: r,
                            publicClient: e,
                            storage: i,
                            webSocketPublicClient: s
                        };
                        let c, a = "disconnected";
                        if (t) try {
                            const m = i.getItem("store") ? .state ? .data;
                            a = m ? .account ? "reconnecting" : "connecting", c = m ? .chain ? .id
                        } catch {}
                        const u = "function" == typeof n ? n() : n;
                        u.forEach(h => h.setStorage(i)), this.store = (t => t ? tU(t) : tU)((t => (n, e, i) => {
                            const r = i.subscribe;
                            return i.subscribe = (o, a, c) => {
                                let u = o;
                                if (a) {
                                    const h = c ? .equalityFn || Object.is;
                                    let m = o(i.getState());
                                    u = x => {
                                        const D = o(x);
                                        if (!h(m, D)) {
                                            const V = m;
                                            a(m = D, V)
                                        }
                                    }, c ? .fireImmediately && a(m, m)
                                }
                                return r(u)
                            }, t(n, e, i)
                        })(((t, n) => "getStorage" in n || "serialize" in n || "deserialize" in n ? (console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."), ((t, n) => (e, i, r) => {
                            let s = {
                                    getStorage: () => localStorage,
                                    serialize: JSON.stringify,
                                    deserialize: JSON.parse,
                                    partialize: ee => ee,
                                    version: 0,
                                    merge: (ee, _e) => ({ ..._e,
                                        ...ee
                                    }),
                                    ...n
                                },
                                o = !1;
                            const a = new Set,
                                c = new Set;
                            let u;
                            try {
                                u = s.getStorage()
                            } catch {}
                            if (!u) return t((...ee) => {
                                console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`), e(...ee)
                            }, i, r);
                            const h = Y0(s.serialize),
                                m = () => {
                                    const ee = s.partialize({ ...i()
                                    });
                                    let _e;
                                    const ye = h({
                                        state: ee,
                                        version: s.version
                                    }).then(Be => u.setItem(s.name, Be)).catch(Be => {
                                        _e = Be
                                    });
                                    if (_e) throw _e;
                                    return ye
                                },
                                x = r.setState;
                            r.setState = (ee, _e) => {
                                x(ee, _e), m()
                            };
                            const D = t((...ee) => {
                                e(...ee), m()
                            }, i, r);
                            let V;
                            const te = () => {
                                var ee;
                                if (!u) return;
                                o = !1, a.forEach(ye => ye(i()));
                                const _e = (null == (ee = s.onRehydrateStorage) ? void 0 : ee.call(s, i())) || void 0;
                                return Y0(u.getItem.bind(u))(s.name).then(ye => {
                                    if (ye) return s.deserialize(ye)
                                }).then(ye => {
                                    if (ye) {
                                        if ("number" != typeof ye.version || ye.version === s.version) return ye.state;
                                        if (s.migrate) return s.migrate(ye.state, ye.version);
                                        console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                                    }
                                }).then(ye => {
                                    var Be;
                                    return V = s.merge(ye, null != (Be = i()) ? Be : D), e(V, !0), m()
                                }).then(() => {
                                    _e ? .(V, void 0), o = !0, c.forEach(ye => ye(V))
                                }).catch(ye => {
                                    _e ? .(void 0, ye)
                                })
                            };
                            return r.persist = {
                                setOptions: ee => {
                                    s = { ...s,
                                        ...ee
                                    }, ee.getStorage && (u = ee.getStorage())
                                },
                                clearStorage: () => {
                                    u ? .removeItem(s.name)
                                },
                                getOptions: () => s,
                                rehydrate: () => te(),
                                hasHydrated: () => o,
                                onHydrate: ee => (a.add(ee), () => {
                                    a.delete(ee)
                                }),
                                onFinishHydration: ee => (c.add(ee), () => {
                                    c.delete(ee)
                                })
                            }, te(), V || D
                        })(t, n)) : ((t, n) => (e, i, r) => {
                            let s = {
                                    storage: dme(() => localStorage),
                                    partialize: te => te,
                                    version: 0,
                                    merge: (te, ee) => ({ ...ee,
                                        ...te
                                    }),
                                    ...n
                                },
                                o = !1;
                            const a = new Set,
                                c = new Set;
                            let u = s.storage;
                            if (!u) return t((...te) => {
                                console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`), e(...te)
                            }, i, r);
                            const h = () => {
                                    const te = s.partialize({ ...i()
                                    });
                                    return u.setItem(s.name, {
                                        state: te,
                                        version: s.version
                                    })
                                },
                                m = r.setState;
                            r.setState = (te, ee) => {
                                m(te, ee), h()
                            };
                            const x = t((...te) => {
                                e(...te), h()
                            }, i, r);
                            let D;
                            r.getInitialState = () => x;
                            const V = () => {
                                var te, ee;
                                if (!u) return;
                                o = !1, a.forEach(ye => {
                                    var Be;
                                    return ye(null != (Be = i()) ? Be : x)
                                });
                                const _e = (null == (ee = s.onRehydrateStorage) ? void 0 : ee.call(s, null != (te = i()) ? te : x)) || void 0;
                                return Y0(u.getItem.bind(u))(s.name).then(ye => {
                                    if (ye) {
                                        if ("number" != typeof ye.version || ye.version === s.version) return ye.state;
                                        if (s.migrate) return s.migrate(ye.state, ye.version);
                                        console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                                    }
                                }).then(ye => {
                                    var Be;
                                    return D = s.merge(ye, null != (Be = i()) ? Be : x), e(D, !0), h()
                                }).then(() => {
                                    _e ? .(D, void 0), D = i(), o = !0, c.forEach(ye => ye(D))
                                }).catch(ye => {
                                    _e ? .(void 0, ye)
                                })
                            };
                            return r.persist = {
                                setOptions: te => {
                                    s = { ...s,
                                        ...te
                                    }, te.storage && (u = te.storage)
                                },
                                clearStorage: () => {
                                    u ? .removeItem(s.name)
                                },
                                getOptions: () => s,
                                rehydrate: () => V(),
                                hasHydrated: () => o,
                                onHydrate: te => (a.add(te), () => {
                                    a.delete(te)
                                }),
                                onFinishHydration: te => (c.add(te), () => {
                                    c.delete(te)
                                })
                            }, s.skipHydration || V(), D || x
                        })(t, n))(() => ({
                            connectors: u,
                            publicClient: this.getPublicClient({
                                chainId: c
                            }),
                            status: a,
                            webSocketPublicClient: this.getWebSocketPublicClient({
                                chainId: c
                            })
                        }), {
                            name: "store",
                            storage: i,
                            partialize: h => ({ ...t && {
                                    data: {
                                        account: h ? .data ? .account,
                                        chain: h ? .data ? .chain
                                    }
                                },
                                chains: h ? .chains
                            }),
                            version: 2
                        }))), this.storage = i, Bx(this, X0, i ? .getItem("wallet")), ((t, n, e) => (RA(this, n, "access private method"), e))(0, kk, cU).call(this), t && typeof window < "u" && setTimeout((0, Ze.Z)(function*() {
                            return yield o.autoConnect()
                        }), 0)
                    }
                    get chains() {
                        return this.store.getState().chains
                    }
                    get connectors() {
                        return this.store.getState().connectors
                    }
                    get connector() {
                        return this.store.getState().connector
                    }
                    get data() {
                        return this.store.getState().data
                    }
                    get error() {
                        return this.store.getState().error
                    }
                    get lastUsedChainId() {
                        return this.data ? .chain ? .id
                    }
                    get publicClient() {
                        return this.store.getState().publicClient
                    }
                    get status() {
                        return this.store.getState().status
                    }
                    get subscribe() {
                        return this.store.subscribe
                    }
                    get webSocketPublicClient() {
                        return this.store.getState().webSocketPublicClient
                    }
                    setState(t) {
                        const n = "function" == typeof t ? t(this.store.getState()) : t;
                        this.store.setState(n, !0)
                    }
                    clearState() {
                        this.setState(t => ({ ...t,
                            chains: void 0,
                            connector: void 0,
                            data: void 0,
                            error: void 0,
                            status: "disconnected"
                        }))
                    }
                    destroy() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            t.connector && (yield t.connector.disconnect ? .()), Bx(t, ig, !1), t.clearState(), t.store.destroy()
                        })()
                    }
                    autoConnect() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            if (BA(t, ig)) return;
                            Bx(t, ig, !0), t.setState(i => ({ ...i,
                                status: i.data ? .account ? "reconnecting" : "connecting"
                            }));
                            const n = BA(t, X0) ? [...t.connectors].sort(i => i.id === BA(t, X0) ? -1 : 1) : t.connectors;
                            let e = !1;
                            for (const i of n) {
                                if (!i.ready || !i.isAuthorized || !(yield i.isAuthorized())) continue;
                                const s = yield i.connect();
                                t.setState(o => ({ ...o,
                                    connector: i,
                                    chains: i ? .chains,
                                    data: s,
                                    status: "connected"
                                })), e = !0;
                                break
                            }
                            return e || t.setState(i => ({ ...i,
                                data: void 0,
                                status: "disconnected"
                            })), Bx(t, ig, !1), t.data
                        })()
                    }
                    setConnectors(t) {
                        this.args = { ...this.args,
                            connectors: t
                        };
                        const n = "function" == typeof t ? t() : t;
                        n.forEach(e => e.setStorage(this.args.storage)), this.setState(e => ({ ...e,
                            connectors: n
                        }))
                    }
                    getPublicClient({
                        chainId: t
                    } = {}) {
                        let n = this.publicClients.get(-1);
                        if (n && n ? .chain.id === t || (n = this.publicClients.get(t ? ? -1), n)) return n;
                        const {
                            publicClient: e
                        } = this.args;
                        return n = "function" == typeof e ? e({
                            chainId: t
                        }) : e, this.publicClients.set(t ? ? -1, n), n
                    }
                    setPublicClient(t) {
                        const n = this.data ? .chain ? .id;
                        this.args = { ...this.args,
                            publicClient: t
                        }, this.publicClients.clear(), this.setState(e => ({ ...e,
                            publicClient: this.getPublicClient({
                                chainId: n
                            })
                        }))
                    }
                    getWebSocketPublicClient({
                        chainId: t
                    } = {}) {
                        let n = this.webSocketPublicClients.get(-1);
                        if (n && n ? .chain.id === t || (n = this.webSocketPublicClients.get(t ? ? -1), n)) return n;
                        const {
                            webSocketPublicClient: e
                        } = this.args;
                        return n = "function" == typeof e ? e({
                            chainId: t
                        }) : e, n && this.webSocketPublicClients.set(t ? ? -1, n), n
                    }
                    setWebSocketPublicClient(t) {
                        const n = this.data ? .chain ? .id;
                        this.args = { ...this.args,
                            webSocketPublicClient: t
                        }, this.webSocketPublicClients.clear(), this.setState(e => ({ ...e,
                            webSocketPublicClient: this.getWebSocketPublicClient({
                                chainId: n
                            })
                        }))
                    }
                    setLastUsedConnector(t = null) {
                        this.storage ? .setItem("wallet", t)
                    }
                }(t);
                return Mk = n, n
            }

            function Ys() {
                if (!Mk) throw new Error("No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config");
                return Mk
            }

            function Ik() {
                return (Ik = (0, Ze.Z)(function*({
                    chainId: t,
                    connector: n
                }) {
                    const e = Ys(),
                        i = e.connector;
                    if (i && n.id === i.id) throw new vme;
                    try {
                        e.setState(s => ({ ...s,
                            status: "connecting"
                        }));
                        const r = yield n.connect({
                            chainId: t
                        });
                        return e.setLastUsedConnector(n.id), e.setState(s => ({ ...s,
                            connector: n,
                            chains: n ? .chains,
                            data: r,
                            status: "connected"
                        })), e.storage.setItem("connected", !0), { ...r,
                            connector: n
                        }
                    } catch (r) {
                        throw e.setState(s => ({ ...s,
                            status: s.connector ? "connected" : "disconnected"
                        })), r
                    }
                })).apply(this, arguments)
            }

            function Pk() {
                return (Pk = (0, Ze.Z)(function*() {
                    const t = Ys();
                    t.connector && (yield t.connector.disconnect()), t.clearState(), t.storage.removeItem("connected")
                })).apply(this, arguments)
            }
            ig = new WeakMap, X0 = new WeakMap, kk = new WeakSet, cU = function() {
                const t = a => {
                        this.setState(c => ({ ...c,
                            data: { ...c.data,
                                ...a
                            }
                        }))
                    },
                    n = () => {
                        this.clearState()
                    },
                    e = a => {
                        this.setState(c => ({ ...c,
                            error: a
                        }))
                    };
                this.store.subscribe(({
                    connector: a
                }) => a, (a, c) => {
                    c ? .off ? .("change", t), c ? .off ? .("disconnect", n), c ? .off ? .("error", e), a && (a.on ? .("change", t), a.on ? .("disconnect", n), a.on ? .("error", e))
                });
                const {
                    publicClient: i,
                    webSocketPublicClient: r
                } = this.args;
                ("function" == typeof i || "function" == typeof r) && this.store.subscribe(({
                    data: a
                }) => a ? .chain ? .id, a => {
                    this.setState(c => ({ ...c,
                        publicClient: this.getPublicClient({
                            chainId: a
                        }),
                        webSocketPublicClient: this.getWebSocketPublicClient({
                            chainId: a
                        })
                    }))
                })
            };
            var lU = [{
                    type: "event",
                    name: "Approval",
                    inputs: [{
                        indexed: !0,
                        name: "owner",
                        type: "address"
                    }, {
                        indexed: !0,
                        name: "spender",
                        type: "address"
                    }, {
                        indexed: !1,
                        name: "value",
                        type: "uint256"
                    }]
                }, {
                    type: "event",
                    name: "Transfer",
                    inputs: [{
                        indexed: !0,
                        name: "from",
                        type: "address"
                    }, {
                        indexed: !0,
                        name: "to",
                        type: "address"
                    }, {
                        indexed: !1,
                        name: "value",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "allowance",
                    stateMutability: "view",
                    inputs: [{
                        name: "owner",
                        type: "address"
                    }, {
                        name: "spender",
                        type: "address"
                    }],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "approve",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "spender",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }, {
                    type: "function",
                    name: "balanceOf",
                    stateMutability: "view",
                    inputs: [{
                        name: "account",
                        type: "address"
                    }],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "decimals",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "uint8"
                    }]
                }, {
                    type: "function",
                    name: "name",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "string"
                    }]
                }, {
                    type: "function",
                    name: "symbol",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "string"
                    }]
                }, {
                    type: "function",
                    name: "totalSupply",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "transfer",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "recipient",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }, {
                    type: "function",
                    name: "transferFrom",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "sender",
                        type: "address"
                    }, {
                        name: "recipient",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }],
                uU = [{
                    type: "event",
                    name: "Approval",
                    inputs: [{
                        indexed: !0,
                        name: "owner",
                        type: "address"
                    }, {
                        indexed: !0,
                        name: "spender",
                        type: "address"
                    }, {
                        indexed: !1,
                        name: "value",
                        type: "uint256"
                    }]
                }, {
                    type: "event",
                    name: "Transfer",
                    inputs: [{
                        indexed: !0,
                        name: "from",
                        type: "address"
                    }, {
                        indexed: !0,
                        name: "to",
                        type: "address"
                    }, {
                        indexed: !1,
                        name: "value",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "allowance",
                    stateMutability: "view",
                    inputs: [{
                        name: "owner",
                        type: "address"
                    }, {
                        name: "spender",
                        type: "address"
                    }],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "approve",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "spender",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }, {
                    type: "function",
                    name: "balanceOf",
                    stateMutability: "view",
                    inputs: [{
                        name: "account",
                        type: "address"
                    }],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "decimals",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "uint8"
                    }]
                }, {
                    type: "function",
                    name: "name",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "bytes32"
                    }]
                }, {
                    type: "function",
                    name: "symbol",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "bytes32"
                    }]
                }, {
                    type: "function",
                    name: "totalSupply",
                    stateMutability: "view",
                    inputs: [],
                    outputs: [{
                        name: "",
                        type: "uint256"
                    }]
                }, {
                    type: "function",
                    name: "transfer",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "recipient",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }, {
                    type: "function",
                    name: "transferFrom",
                    stateMutability: "nonpayable",
                    inputs: [{
                        name: "sender",
                        type: "address"
                    }, {
                        name: "recipient",
                        type: "address"
                    }, {
                        name: "amount",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bool"
                    }]
                }];

            function vo({
                chainId: t
            } = {}) {
                const n = Ys();
                return t && n.getPublicClient({
                    chainId: t
                }) || n.publicClient
            }

            function Kf() {
                return Lk.apply(this, arguments)
            }

            function Lk() {
                return (Lk = (0, Ze.Z)(function*({
                    chainId: t
                } = {}) {
                    return (yield Ys().connector ? .getWalletClient ? .({
                        chainId: t
                    })) || null
                })).apply(this, arguments)
            }

            function sd(t) {
                return Rk.apply(this, arguments)
            }

            function Rk() {
                return (Rk = (0, Ze.Z)(function*({
                    abi: t,
                    address: n,
                    args: e,
                    chainId: i,
                    dataSuffix: r,
                    functionName: s,
                    walletClient: o,
                    ...a
                }) {
                    const c = vo({
                            chainId: i
                        }),
                        u = o ? ? (yield Kf({
                            chainId: i
                        }));
                    if (!u) throw new cu;
                    i && Q0({
                        chainId: i
                    });
                    const {
                        account: h,
                        accessList: m,
                        blockNumber: x,
                        blockTag: D,
                        gas: V,
                        gasPrice: te,
                        maxFeePerGas: ee,
                        maxPriorityFeePerGas: _e,
                        nonce: ye,
                        value: Be
                    } = function Cme(t) {
                        return {
                            accessList: t.accessList,
                            account: t.account,
                            blockNumber: t.blockNumber,
                            blockTag: t.blockTag,
                            data: t.data,
                            gas: t.gas,
                            gasPrice: t.gasPrice,
                            maxFeePerGas: t.maxFeePerGas,
                            maxPriorityFeePerGas: t.maxPriorityFeePerGas,
                            nonce: t.nonce,
                            to: t.to,
                            value: t.value
                        }
                    }(a), {
                        result: ze,
                        request: Xe
                    } = yield c.simulateContract({
                        abi: t,
                        address: n,
                        functionName: s,
                        args: e,
                        account: h || u.account,
                        accessList: m,
                        blockNumber: x,
                        blockTag: D,
                        dataSuffix: r,
                        gas: V,
                        gasPrice: te,
                        maxFeePerGas: ee,
                        maxPriorityFeePerGas: _e,
                        nonce: ye,
                        value: Be
                    });
                    return {
                        mode: "prepared",
                        request: { ...Xe,
                            abi: t.filter(vt => "name" in vt && vt.name === s),
                            chainId: i
                        },
                        result: ze
                    }
                })).apply(this, arguments)
            }

            function Bk() {
                return (Bk = (0, Ze.Z)(function*({
                    chainId: t,
                    contracts: n,
                    blockNumber: e,
                    blockTag: i,
                    ...r
                }) {
                    const s = vo({
                        chainId: t
                    });
                    if (!s.chains) throw new bme;
                    if (t && s.chain.id !== t) throw new _me({
                        chainId: t
                    });
                    return s.multicall({
                        allowFailure: r.allowFailure ? ? !0,
                        blockNumber: e,
                        blockTag: i,
                        contracts: n
                    })
                })).apply(this, arguments)
            }

            function Nk() {
                return (Nk = (0, Ze.Z)(function*({
                    address: t,
                    account: n,
                    chainId: e,
                    abi: i,
                    args: r,
                    functionName: s,
                    blockNumber: o,
                    blockTag: a
                }) {
                    return vo({
                        chainId: e
                    }).readContract({
                        abi: i,
                        address: t,
                        account: n,
                        functionName: s,
                        args: r,
                        blockNumber: o,
                        blockTag: a
                    })
                })).apply(this, arguments)
            }

            function qf(t) {
                return Fk.apply(this, arguments)
            }

            function Fk() {
                return (Fk = (0, Ze.Z)(function*({
                    contracts: t,
                    blockNumber: n,
                    blockTag: e,
                    ...i
                }) {
                    const {
                        allowFailure: r = !0
                    } = i;
                    try {
                        const s = vo(),
                            o = t.reduce((h, m, x) => {
                                const D = m.chainId ? ? s.chain.id;
                                return { ...h,
                                    [D]: [...h[D] || [], {
                                        contract: m,
                                        index: x
                                    }]
                                }
                            }, {}),
                            a = () => Object.entries(o).map(([h, m]) => function dU(t) {
                                return Bk.apply(this, arguments)
                            }({
                                allowFailure: r,
                                chainId: parseInt(h),
                                contracts: m.map(({
                                    contract: x
                                }) => x),
                                blockNumber: n,
                                blockTag: e
                            })),
                            c = (yield Promise.all(a())).flat(),
                            u = Object.values(o).flatMap(h => h.map(({
                                index: m
                            }) => m));
                        return c.reduce((h, m, x) => (h && (h[u[x]] = m), h), [])
                    } catch (s) {
                        if (s instanceof Ux.uq) throw s;
                        const o = () => t.map(a => function hU(t) {
                            return Nk.apply(this, arguments)
                        }({ ...a,
                            blockNumber: n,
                            blockTag: e
                        }));
                        return r ? (yield Promise.allSettled(o())).map(a => "fulfilled" === a.status ? {
                            result: a.value,
                            status: "success"
                        } : {
                            error: a.reason,
                            result: void 0,
                            status: "failure"
                        }) : yield Promise.all(o())
                    }
                })).apply(this, arguments)
            }

            function _h(t) {
                return Uk.apply(this, arguments)
            }

            function Uk() {
                return (Uk = (0, Ze.Z)(function*(t) {
                    const n = yield Kf({
                        chainId: t.chainId
                    });
                    if (!n) throw new cu;
                    let e;
                    if (t.chainId && Q0({
                            chainId: t.chainId
                        }), "prepared" === t.mode) e = t.request;
                    else {
                        const {
                            chainId: r,
                            mode: s,
                            ...o
                        } = t;
                        e = (yield sd(o)).request
                    }
                    return {
                        hash: yield n.writeContract({ ...e,
                            chain: t.chainId ? {
                                id: t.chainId
                            } : null
                        })
                    }
                })).apply(this, arguments)
            }

            function fU(t) {
                return Hk.apply(this, arguments)
            }

            function Hk() {
                return Hk = (0, Ze.Z)(function*({
                    address: t,
                    chainId: n,
                    formatUnits: e,
                    token: i
                }) {
                    const r = Ys(),
                        s = vo({
                            chainId: n
                        });
                    if (i) {
                        const u = function() {
                            var h = (0, Ze.Z)(function*({
                                abi: m
                            }) {
                                const x = {
                                        abi: m,
                                        address: i,
                                        chainId: n
                                    },
                                    [D, V, te] = yield qf({
                                        allowFailure: !1,
                                        contracts: [{ ...x,
                                            functionName: "balanceOf",
                                            args: [t]
                                        }, { ...x,
                                            functionName: "decimals"
                                        }, { ...x,
                                            functionName: "symbol"
                                        }]
                                    });
                                return {
                                    decimals: V,
                                    formatted: (0, iU.b)(D ? ? "0", Wx(e ? ? V)),
                                    symbol: te,
                                    value: D
                                }
                            });
                            return function(x) {
                                return h.apply(this, arguments)
                            }
                        }();
                        try {
                            return yield u({
                                abi: lU
                            })
                        } catch (h) {
                            if (h instanceof Ux.uq) {
                                const {
                                    symbol: m,
                                    ...x
                                } = yield u({
                                    abi: uU
                                });
                                return {
                                    symbol: (0, aa.rR)((0, mme.f)(m, {
                                        dir: "right"
                                    })),
                                    ...x
                                }
                            }
                            throw h
                        }
                    }
                    const o = [...r.publicClient.chains || [], ...r.chains ? ? []],
                        a = yield s.getBalance({
                            address: t
                        }), c = o.find(u => u.id === s.chain.id);
                    return {
                        decimals: c ? .nativeCurrency.decimals ? ? 18,
                        formatted: (0, iU.b)(a ? ? "0", Wx(e ? ? 18)),
                        symbol: c ? .nativeCurrency.symbol ? ? "ETH",
                        value: a
                    }
                }), Hk.apply(this, arguments)
            }

            function pU() {
                const t = Ys(),
                    n = t.data ? .chain ? .id,
                    e = t.chains ? ? [],
                    i = [...t.publicClient ? .chains || [], ...e].find(r => r.id === n) ? ? {
                        id: n,
                        name: `Chain ${n}`,
                        network: `${n}`,
                        nativeCurrency: {
                            name: "Ether",
                            decimals: 18,
                            symbol: "ETH"
                        },
                        rpcUrls: {
                            default: {
                                http: [""]
                            },
                            public: {
                                http: [""]
                            }
                        }
                    };
                return {
                    chain: n ? { ...i,
                        ...t.data ? .chain,
                        id : n
                    } : void 0,
                    chains: e
                }
            }

            function jk() {
                return (jk = (0, Ze.Z)(function*({
                    chainId: t
                }) {
                    const {
                        connector: n
                    } = Ys();
                    if (!n) throw new cu;
                    if (!n.switchChain) throw new wme({
                        connector: n
                    });
                    return n.switchChain(t)
                })).apply(this, arguments)
            }

            function eM(t) {
                return tM.apply(this, arguments)
            }

            function tM() {
                return (tM = (0, Ze.Z)(function*({
                    chainId: t,
                    confirmations: n = 1,
                    hash: e,
                    onReplaced: i,
                    timeout: r = 0
                }) {
                    const s = vo({
                            chainId: t
                        }),
                        o = yield s.waitForTransactionReceipt({
                            hash: e,
                            confirmations: n,
                            onReplaced: i,
                            timeout: r
                        });
                    if ("reverted" === o.status) {
                        const a = yield s.getTransaction({
                            hash: o.transactionHash
                        }), c = yield s.call({ ...a,
                            gasPrice: "eip1559" !== a.type ? a.gasPrice : void 0,
                            maxFeePerGas: "eip1559" === a.type ? a.maxFeePerGas : void 0,
                            maxPriorityFeePerGas: "eip1559" === a.type ? a.maxPriorityFeePerGas : void 0
                        }), u = (0, aa.rR)(`0x${c.substring(138)}`);
                        throw new Error(u)
                    }
                    return o
                })).apply(this, arguments)
            }

            function Q0({
                chainId: t
            }) {
                const {
                    chain: n,
                    chains: e
                } = pU(), i = n ? .id;
                if (i && t !== i) throw new yme({
                    activeChain: e.find(r => r.id === i) ? .name ? ? `Chain ${i}`,
                    targetChain: e.find(r => r.id === t) ? .name ? ? `Chain ${t}`
                })
            }

            function nM({
                rpc: t
            }) {
                return function(n) {
                    const e = t(n);
                    return e && "" !== e.http ? {
                        chain: { ...n,
                            rpcUrls: { ...n.rpcUrls,
                                default: {
                                    http: [e.http]
                                }
                            }
                        },
                        rpcUrls: {
                            http: [e.http],
                            webSocket: e.webSocket ? [e.webSocket] : void 0
                        }
                    } : null
                }
            }
            var Kx, Fme = class extends wV {
                constructor({
                    chains: t,
                    options: n
                } = {}) {
                    const e = {
                        name: "MetaMask",
                        shimDisconnect: !0,
                        getProvider() {
                            function i(s) {
                                if (s ? .isMetaMask && (!s.isBraveWallet || s._events || s._state) && !s.isApexWallet && !s.isAvalanche && !s.isBitKeep && !s.isBlockWallet && !s.isCoin98 && !s.isFordefi && !s.isMathWallet && !s.isOkxWallet && !s.isOKExWallet && !s.isOneInchIOSWallet && !s.isOneInchAndroidWallet && !s.isOpera && !s.isPortal && !s.isRabby && !s.isDefiant && !s.isTokenPocket && !s.isTokenary && !s.isZeal && !s.isZerion) return s
                            }
                            if (typeof window > "u") return;
                            const r = window.ethereum;
                            return r ? .providers ? r.providers.find(i) : i(r)
                        },
                        ...n
                    };
                    super({
                        chains: t,
                        options: e
                    }), this.id = "metaMask", this.shimDisconnectKey = `${this.id}.shimDisconnect`, Da(this, Kx, void 0), Qm(this, Kx, e.UNSTABLE_shimOnConnectSelectAccount)
                }
                connect({
                    chainId: t
                } = {}) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        try {
                            const e = yield n.getProvider();
                            if (!e) throw new cu;
                            e.on && (e.on("accountsChanged", n.onAccountsChanged), e.on("chainChanged", n.onChainChanged), e.on("disconnect", n.onDisconnect)), n.emit("message", {
                                type: "connecting"
                            });
                            let i = null;
                            if (zr(n, Kx) && n.options ? .shimDisconnect && !n.storage ? .getItem(n.shimDisconnectKey) && (i = yield n.getAccount().catch(() => null), i)) try {
                                yield e.request({
                                    method: "wallet_requestPermissions",
                                    params: [{
                                        eth_accounts: {}
                                    }]
                                }), i = yield n.getAccount()
                            } catch (a) {
                                if (n.isUserRejectedRequestError(a)) throw new oi.ab(a);
                                if (a.code === new oi.pT(a).code) throw a
                            }
                            if (!i) {
                                const o = yield e.request({
                                    method: "eth_requestAccounts"
                                });
                                i = (0, qc.K)(o[0])
                            }
                            let r = yield n.getChainId(), s = n.isChainUnsupported(r);
                            return t && r !== t && (r = (yield n.switchChain(t)).id, s = n.isChainUnsupported(r)), n.options ? .shimDisconnect && n.storage ? .setItem(n.shimDisconnectKey, !0), {
                                account: i,
                                chain: {
                                    id: r,
                                    unsupported: s
                                },
                                provider: e
                            }
                        } catch (e) {
                            throw n.isUserRejectedRequestError(e) ? new oi.ab(e) : -32002 === e.code ? new oi.pT(e) : e
                        }
                    })()
                }
            };
            Kx = new WeakMap;
            var Ds, J0, qx, rM, sM, _U, Zx, oM, aM, vU, Yx, cM, rg, e_, Xx, lM, Qx, uM, Jx, dM, mU = T(13304),
                yU = "requestedChains",
                iM = "wallet_addEthereumChain",
                hM = class extends qD {
                    constructor(t) {
                        super({ ...t,
                            options: {
                                isNewChainsStale: !0,
                                ...t.options
                            }
                        }), Da(this, qx), Da(this, sM), Da(this, Zx), Da(this, aM), Da(this, Yx), Da(this, rg), Da(this, Xx), Da(this, Qx), Da(this, Jx), this.id = "walletConnect", this.name = "WalletConnect", this.ready = !0, Da(this, Ds, void 0), Da(this, J0, void 0), this.onAccountsChanged = n => {
                            0 === n.length ? this.emit("disconnect") : this.emit("change", {
                                account: (0, qc.K)(n[0])
                            })
                        }, this.onChainChanged = n => {
                            const e = Number(n),
                                i = this.isChainUnsupported(e);
                            this.emit("change", {
                                chain: {
                                    id: e,
                                    unsupported: i
                                }
                            })
                        }, this.onDisconnect = () => {
                            Io(this, rg, e_).call(this, []), this.emit("disconnect")
                        }, this.onDisplayUri = n => {
                            this.emit("message", {
                                type: "display_uri",
                                data: n
                            })
                        }, this.onConnect = () => {
                            this.emit("connect", {})
                        }, Io(this, qx, rM).call(this)
                    }
                    connect({
                        chainId: t,
                        pairingTopic: n
                    } = {}) {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            try {
                                let i = t;
                                if (!i) {
                                    const m = e.storage ? .getItem("store") ? .state ? .data ? .chain ? .id;
                                    i = m && !e.isChainUnsupported(m) ? m : e.chains[0] ? .id
                                }
                                if (!i) throw new Error("No chains found on connector.");
                                const r = yield e.getProvider();
                                Io(e, aM, vU).call(e);
                                const s = Io(e, Zx, oM).call(e);
                                if (r.session && s && (yield r.disconnect()), !r.session || s) {
                                    const h = e.chains.filter(m => m.id !== i).map(m => m.id);
                                    e.emit("message", {
                                        type: "connecting"
                                    }), yield r.connect({
                                        pairingTopic: n,
                                        optionalChains: [i, ...h]
                                    }), Io(e, rg, e_).call(e, e.chains.map(({
                                        id: m
                                    }) => m))
                                }
                                const o = yield r.enable(), a = (0, qc.K)(o[0]), c = yield e.getChainId();
                                return {
                                    account: a,
                                    chain: {
                                        id: c,
                                        unsupported: e.isChainUnsupported(c)
                                    }
                                }
                            } catch (i) {
                                throw /user rejected/i.test(i ? .message) ? new oi.ab(i) : i
                            }
                        })()
                    }
                    disconnect() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            const n = yield t.getProvider();
                            try {
                                yield n.disconnect()
                            } catch (e) {
                                if (!/No matching key/i.test(e.message)) throw e
                            } finally {
                                Io(t, Yx, cM).call(t), Io(t, rg, e_).call(t, [])
                            }
                        })()
                    }
                    getAccount() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            const {
                                accounts: n
                            } = yield t.getProvider();
                            return (0, qc.K)(n[0])
                        })()
                    }
                    getChainId() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            const {
                                chainId: n
                            } = yield t.getProvider();
                            return n
                        })()
                    }
                    getProvider({
                        chainId: t
                    } = {}) {
                        var n = this;
                        return (0, Ze.Z)(function*() {
                            return zr(n, Ds) || (yield Io(n, qx, rM).call(n)), t && (yield n.switchChain(t)), zr(n, Ds)
                        })()
                    }
                    getWalletClient({
                        chainId: t
                    } = {}) {
                        var n = this;
                        return (0, Ze.Z)(function*() {
                            const [e, i] = yield Promise.all([n.getProvider({
                                chainId: t
                            }), n.getAccount()]), r = n.chains.find(s => s.id === t);
                            if (!e) throw new Error("provider is required.");
                            return IA({
                                account: i,
                                chain: r,
                                transport: LA(e)
                            })
                        })()
                    }
                    isAuthorized() {
                        var t = this;
                        return (0, Ze.Z)(function*() {
                            try {
                                const [n, e] = yield Promise.all([t.getAccount(), t.getProvider()]), i = Io(t, Zx, oM).call(t);
                                if (!n) return !1;
                                if (i && e.session) {
                                    try {
                                        yield e.disconnect()
                                    } catch {}
                                    return !1
                                }
                                return !0
                            } catch {
                                return !1
                            }
                        })()
                    }
                    switchChain(t) {
                        var n = this;
                        return (0, Ze.Z)(function*() {
                            const e = n.chains.find(i => i.id === t);
                            if (!e) throw new oi.x3(new Error("chain not found on connector."));
                            try {
                                const i = yield n.getProvider(), r = Io(n, Qx, uM).call(n), s = Io(n, Jx, dM).call(n);
                                if (!r.includes(t) && s.includes(iM)) {
                                    yield i.request({
                                        method: iM,
                                        params: [{
                                            chainId: (0, kr.eC)(e.id),
                                            blockExplorerUrls: [e.blockExplorers ? .default ? .url],
                                            chainName: e.name,
                                            nativeCurrency: e.nativeCurrency,
                                            rpcUrls: [...e.rpcUrls.default.http]
                                        }]
                                    });
                                    const a = Io(n, Xx, lM).call(n);
                                    a.push(t), Io(n, rg, e_).call(n, a)
                                }
                                return yield i.request({
                                    method: "wallet_switchEthereumChain",
                                    params: [{
                                        chainId: (0, kr.eC)(t)
                                    }]
                                }), e
                            } catch (i) {
                                throw /user rejected request/i.test("string" == typeof i ? i : i ? .message) ? new oi.ab(i) : new oi.x3(i)
                            }
                        })()
                    }
                };
            Ds = new WeakMap, J0 = new WeakMap, qx = new WeakSet, rM = function() {
                var t = (0, Ze.Z)(function*() {
                    return !zr(this, J0) && typeof window < "u" && Qm(this, J0, Io(this, sM, _U).call(this)), zr(this, J0)
                });
                return function() {
                    return t.apply(this, arguments)
                }
            }(), sM = new WeakSet, _U = function() {
                var t = (0, Ze.Z)(function*() {
                    const {
                        EthereumProvider: n
                    } = yield Promise.all([T.e(592), T.e(794)]).then(T.bind(T, 70794)), e = this.chains.map(({
                        id: i
                    }) => i);
                    if (e.length) {
                        const {
                            projectId: i,
                            showQrModal: r = !0,
                            qrModalOptions: s,
                            metadata: o,
                            relayUrl: a
                        } = this.options;
                        Qm(this, Ds, yield n.init({
                            showQrModal: r,
                            qrModalOptions: s,
                            projectId: i,
                            optionalChains: e,
                            rpcMap: Object.fromEntries(this.chains.map(c => [c.id, c.rpcUrls.default.http[0]])),
                            metadata: o,
                            relayUrl: a
                        }))
                    }
                });
                return function() {
                    return t.apply(this, arguments)
                }
            }(), Zx = new WeakSet, oM = function() {
                if (Io(this, Jx, dM).call(this).includes(iM) || !this.options.isNewChainsStale) return !1;
                const n = Io(this, Xx, lM).call(this),
                    e = this.chains.map(({
                        id: r
                    }) => r),
                    i = Io(this, Qx, uM).call(this);
                return !(i.length && !i.some(r => e.includes(r)) || e.every(r => n.includes(r)))
            }, aM = new WeakSet, vU = function() {
                zr(this, Ds) && (Io(this, Yx, cM).call(this), zr(this, Ds).on("accountsChanged", this.onAccountsChanged), zr(this, Ds).on("chainChanged", this.onChainChanged), zr(this, Ds).on("disconnect", this.onDisconnect), zr(this, Ds).on("session_delete", this.onDisconnect), zr(this, Ds).on("display_uri", this.onDisplayUri), zr(this, Ds).on("connect", this.onConnect))
            }, Yx = new WeakSet, cM = function() {
                zr(this, Ds) && (zr(this, Ds).removeListener("accountsChanged", this.onAccountsChanged), zr(this, Ds).removeListener("chainChanged", this.onChainChanged), zr(this, Ds).removeListener("disconnect", this.onDisconnect), zr(this, Ds).removeListener("session_delete", this.onDisconnect), zr(this, Ds).removeListener("display_uri", this.onDisplayUri), zr(this, Ds).removeListener("connect", this.onConnect))
            }, rg = new WeakSet, e_ = function(t) {
                this.storage ? .setItem(yU, t)
            }, Xx = new WeakSet, lM = function() {
                return this.storage ? .getItem(yU) ? ? []
            }, Qx = new WeakSet, uM = function() {
                if (!zr(this, Ds)) return [];
                const t = zr(this, Ds).session ? .namespaces;
                return t ? (0, mU.fK)(t).eip155 ? .chains ? .map(i => parseInt(i.split(":")[1] || "")) ? ? [] : []
            }, Jx = new WeakSet, dM = function() {
                if (!zr(this, Ds)) return [];
                const t = zr(this, Ds).session ? .namespaces;
                return t ? (0, mU.fK)(t).eip155 ? .methods ? ? [] : []
            };
            var t_, sg, Ume = class extends qD {
                constructor({
                    chains: t,
                    options: n
                }) {
                    super({
                        chains: t,
                        options: {
                            reloadOnDisconnect: !1,
                            ...n
                        }
                    }), this.id = "coinbaseWallet", this.name = "Coinbase Wallet", this.ready = !0, Da(this, t_, void 0), Da(this, sg, void 0), this.onAccountsChanged = e => {
                        0 === e.length ? this.emit("disconnect") : this.emit("change", {
                            account: (0, qc.K)(e[0])
                        })
                    }, this.onChainChanged = e => {
                        const i = Tx(e),
                            r = this.isChainUnsupported(i);
                        this.emit("change", {
                            chain: {
                                id: i,
                                unsupported: r
                            }
                        })
                    }, this.onDisconnect = () => {
                        this.emit("disconnect")
                    }
                }
                connect({
                    chainId: t
                } = {}) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        try {
                            const e = yield n.getProvider();
                            e.on("accountsChanged", n.onAccountsChanged), e.on("chainChanged", n.onChainChanged), e.on("disconnect", n.onDisconnect), n.emit("message", {
                                type: "connecting"
                            });
                            const i = yield e.enable(), r = (0, qc.K)(i[0]);
                            let s = yield n.getChainId(), o = n.isChainUnsupported(s);
                            return t && s !== t && (s = (yield n.switchChain(t)).id, o = n.isChainUnsupported(s)), {
                                account: r,
                                chain: {
                                    id: s,
                                    unsupported: o
                                }
                            }
                        } catch (e) {
                            throw /(user closed modal|accounts received is empty)/i.test(e.message) ? new oi.ab(e) : e
                        }
                    })()
                }
                disconnect() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        if (!zr(t, sg)) return;
                        const n = yield t.getProvider();
                        n.removeListener("accountsChanged", t.onAccountsChanged), n.removeListener("chainChanged", t.onChainChanged), n.removeListener("disconnect", t.onDisconnect), n.disconnect(), n.close()
                    })()
                }
                getAccount() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        const e = yield(yield t.getProvider()).request({
                            method: "eth_accounts"
                        });
                        return (0, qc.K)(e[0])
                    })()
                }
                getChainId() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        return Tx((yield t.getProvider()).chainId)
                    })()
                }
                getProvider() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        if (!zr(t, sg)) {
                            let n = (yield Promise.all([T.e(592), T.e(404)]).then(T.t.bind(T, 29404, 19))).default;
                            "function" != typeof n && "function" == typeof n.default && (n = n.default), Qm(t, t_, new n(t.options));
                            const r = zr(t, t_).walletExtension ? .getChainId(),
                                s = t.chains.find(c => t.options.chainId ? c.id === t.options.chainId : c.id === r) || t.chains[0],
                                o = t.options.chainId || s ? .id,
                                a = t.options.jsonRpcUrl || s ? .rpcUrls.default.http[0];
                            Qm(t, sg, zr(t, t_).makeWeb3Provider(a, o))
                        }
                        return zr(t, sg)
                    })()
                }
                getWalletClient({
                    chainId: t
                } = {}) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        const [e, i] = yield Promise.all([n.getProvider(), n.getAccount()]), r = n.chains.find(s => s.id === t);
                        if (!e) throw new Error("provider is required.");
                        return IA({
                            account: i,
                            chain: r,
                            transport: LA(e)
                        })
                    })()
                }
                isAuthorized() {
                    var t = this;
                    return (0, Ze.Z)(function*() {
                        try {
                            return !!(yield t.getAccount())
                        } catch {
                            return !1
                        }
                    })()
                }
                switchChain(t) {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        const e = yield n.getProvider(), i = (0, kr.eC)(t);
                        try {
                            return yield e.request({
                                method: "wallet_switchEthereumChain",
                                params: [{
                                    chainId: i
                                }]
                            }), n.chains.find(r => r.id === t) ? ? {
                                id: t,
                                name: `Chain ${i}`,
                                network: `${i}`,
                                nativeCurrency: {
                                    name: "Ether",
                                    decimals: 18,
                                    symbol: "ETH"
                                },
                                rpcUrls: {
                                    default: {
                                        http: [""]
                                    },
                                    public: {
                                        http: [""]
                                    }
                                }
                            }
                        } catch (r) {
                            const s = n.chains.find(o => o.id === t);
                            if (!s) throw new sV({
                                chainId: t,
                                connectorId: n.id
                            });
                            if (4902 === r.code) try {
                                return yield e.request({
                                    method: "wallet_addEthereumChain",
                                    params: [{
                                        chainId: i,
                                        chainName: s.name,
                                        nativeCurrency: s.nativeCurrency,
                                        rpcUrls: [s.rpcUrls.public ? .http[0] ? ? ""],
                                        blockExplorerUrls: n.getBlockExplorerUrls(s)
                                    }]
                                }), s
                            } catch (o) {
                                throw new oi.ab(o)
                            }
                            throw new oi.x3(r)
                        }
                    })()
                }
                watchAsset({
                    address: t,
                    decimals: n = 18,
                    image: e,
                    symbol: i
                }) {
                    var r = this;
                    return (0, Ze.Z)(function*() {
                        return (yield r.getProvider()).request({
                            method: "wallet_watchAsset",
                            params: {
                                type: "ERC20",
                                options: {
                                    address: t,
                                    decimals: n,
                                    image: e,
                                    symbol: i
                                }
                            }
                        })
                    })()
                }
            };

            function bU(t, n = "wei") {
                return function Hme(t, n) {
                    let [e, i = "0"] = t.split(".");
                    const r = e.startsWith("-");
                    if (r && (e = e.slice(1)), i = i.replace(/(0+)$/, ""), 0 === n) 1 === Math.round(+`.${i}`) && (e = `${BigInt(e)+1n}`), i = "";
                    else if (i.length > n) {
                        const [s, o, a] = [i.slice(0, n - 1), i.slice(n - 1, n), i.slice(n)], c = Math.round(+`${o}.${a}`);
                        i = c > 9 ? `${BigInt(s)+BigInt(1)}0`.padStart(s.length + 1, "0") : `${s}${c}`, i.length > n && (i = i.slice(1), e = `${BigInt(e)+1n}`), i = i.slice(0, n)
                    } else i = i.padEnd(n, "0");
                    return BigInt(`${r?"-":""}${e}${i}`)
                }(t, eU.ez[n])
            }
            t_ = new WeakMap, sg = new WeakMap;
            const $me = El({
                    id: 56,
                    name: "BNB Smart Chain",
                    network: "bsc",
                    nativeCurrency: {
                        decimals: 18,
                        name: "BNB",
                        symbol: "BNB"
                    },
                    rpcUrls: {
                        default: {
                            http: ["https://rpc.ankr.com/bsc"]
                        },
                        public: {
                            http: ["https://rpc.ankr.com/bsc"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "BscScan",
                            url: "https://bscscan.com"
                        },
                        default: {
                            name: "BscScan",
                            url: "https://bscscan.com"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 15921452
                        }
                    }
                }),
                zme = El({
                    id: 137,
                    name: "Polygon",
                    network: "matic",
                    nativeCurrency: {
                        name: "MATIC",
                        symbol: "MATIC",
                        decimals: 18
                    },
                    rpcUrls: {
                        alchemy: {
                            http: ["https://polygon-mainnet.g.alchemy.com/v2"],
                            webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
                        },
                        infura: {
                            http: ["https://polygon-mainnet.infura.io/v3"],
                            webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
                        },
                        default: {
                            http: ["https://polygon-rpc.com"]
                        },
                        public: {
                            http: ["https://polygon-rpc.com"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "PolygonScan",
                            url: "https://polygonscan.com"
                        },
                        default: {
                            name: "PolygonScan",
                            url: "https://polygonscan.com"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 25770160
                        }
                    }
                }),
                jme = El({
                    id: 43114,
                    name: "Avalanche",
                    network: "avalanche",
                    nativeCurrency: {
                        decimals: 18,
                        name: "Avalanche",
                        symbol: "AVAX"
                    },
                    rpcUrls: {
                        default: {
                            http: ["https://api.avax.network/ext/bc/C/rpc"]
                        },
                        public: {
                            http: ["https://api.avax.network/ext/bc/C/rpc"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "SnowTrace",
                            url: "https://snowtrace.io"
                        },
                        default: {
                            name: "SnowTrace",
                            url: "https://snowtrace.io"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 11907934
                        }
                    }
                }),
                wU = {
                    block: Ofe({
                        format: t => ({
                            transactions: t.transactions ? .map(e => {
                                if ("string" == typeof e) return e;
                                const i = Mx(e);
                                return "0x7e" === i.typeHex && (i.isSystemTx = e.isSystemTx, i.mint = e.mint ? (0, aa.y_)(e.mint) : void 0, i.sourceHash = e.sourceHash, i.type = "deposit"), i
                            }),
                            stateRoot: t.stateRoot
                        })
                    }),
                    transaction: Pfe({
                        format(t) {
                            const n = {};
                            return "0x7e" === t.type && (n.isSystemTx = t.isSystemTx, n.mint = t.mint ? (0, aa.y_)(t.mint) : void 0, n.sourceHash = t.sourceHash, n.type = "deposit"), n
                        }
                    }),
                    transactionReceipt: kpe({
                        format: t => ({
                            l1GasPrice: t.l1GasPrice ? (0, aa.y_)(t.l1GasPrice) : null,
                            l1GasUsed: t.l1GasUsed ? (0, aa.y_)(t.l1GasUsed) : null,
                            l1Fee: t.l1Fee ? (0, aa.y_)(t.l1Fee) : null,
                            l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null
                        })
                    })
                },
                Wme = El({
                    id: 8453,
                    network: "base",
                    name: "Base",
                    nativeCurrency: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18
                    },
                    rpcUrls: {
                        alchemy: {
                            http: ["https://base-mainnet.g.alchemy.com/v2"],
                            webSocket: ["wss://base-mainnet.g.alchemy.com/v2"]
                        },
                        infura: {
                            http: ["https://base-mainnet.infura.io/v3"],
                            webSocket: ["wss://base-mainnet.infura.io/ws/v3"]
                        },
                        default: {
                            http: ["https://mainnet.base.org"]
                        },
                        public: {
                            http: ["https://mainnet.base.org"]
                        }
                    },
                    blockExplorers: {
                        blockscout: {
                            name: "Basescout",
                            url: "https://base.blockscout.com"
                        },
                        default: {
                            name: "Basescan",
                            url: "https://basescan.org"
                        },
                        etherscan: {
                            name: "Basescan",
                            url: "https://basescan.org"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 5022
                        }
                    }
                }, {
                    formatters: wU
                }),
                Gme = El({
                    id: 11155111,
                    network: "sepolia",
                    name: "Sepolia",
                    nativeCurrency: {
                        name: "Sepolia Ether",
                        symbol: "SEP",
                        decimals: 18
                    },
                    rpcUrls: {
                        alchemy: {
                            http: ["https://eth-sepolia.g.alchemy.com/v2"],
                            webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
                        },
                        infura: {
                            http: ["https://sepolia.infura.io/v3"],
                            webSocket: ["wss://sepolia.infura.io/ws/v3"]
                        },
                        default: {
                            http: ["https://rpc.sepolia.org"]
                        },
                        public: {
                            http: ["https://rpc.sepolia.org"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "Etherscan",
                            url: "https://sepolia.etherscan.io"
                        },
                        default: {
                            name: "Etherscan",
                            url: "https://sepolia.etherscan.io"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 751532
                        },
                        ensRegistry: {
                            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
                        },
                        ensUniversalResolver: {
                            address: "0x21B000Fd62a880b2125A61e36a284BB757b76025",
                            blockCreated: 3914906
                        }
                    },
                    testnet: !0
                }),
                Kme = El({
                    id: 97,
                    name: "Binance Smart Chain Testnet",
                    network: "bsc-testnet",
                    nativeCurrency: {
                        decimals: 18,
                        name: "BNB",
                        symbol: "tBNB"
                    },
                    rpcUrls: {
                        default: {
                            http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"]
                        },
                        public: {
                            http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "BscScan",
                            url: "https://testnet.bscscan.com"
                        },
                        default: {
                            name: "BscScan",
                            url: "https://testnet.bscscan.com"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 17422483
                        }
                    },
                    testnet: !0
                }),
                qme = El({
                    id: 80001,
                    name: "Polygon Mumbai",
                    network: "maticmum",
                    nativeCurrency: {
                        name: "MATIC",
                        symbol: "MATIC",
                        decimals: 18
                    },
                    rpcUrls: {
                        alchemy: {
                            http: ["https://polygon-mumbai.g.alchemy.com/v2"],
                            webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
                        },
                        infura: {
                            http: ["https://polygon-mumbai.infura.io/v3"],
                            webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
                        },
                        default: {
                            http: ["https://rpc.ankr.com/polygon_mumbai"]
                        },
                        public: {
                            http: ["https://rpc.ankr.com/polygon_mumbai"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "PolygonScan",
                            url: "https://mumbai.polygonscan.com"
                        },
                        default: {
                            name: "PolygonScan",
                            url: "https://mumbai.polygonscan.com"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 25770160
                        }
                    },
                    testnet: !0
                }),
                Zme = El({
                    id: 43113,
                    name: "Avalanche Fuji",
                    network: "avalanche-fuji",
                    nativeCurrency: {
                        decimals: 18,
                        name: "Avalanche Fuji",
                        symbol: "AVAX"
                    },
                    rpcUrls: {
                        default: {
                            http: ["https://api.avax-test.network/ext/bc/C/rpc"]
                        },
                        public: {
                            http: ["https://api.avax-test.network/ext/bc/C/rpc"]
                        }
                    },
                    blockExplorers: {
                        etherscan: {
                            name: "SnowTrace",
                            url: "https://testnet.snowtrace.io"
                        },
                        default: {
                            name: "SnowTrace",
                            url: "https://testnet.snowtrace.io"
                        }
                    },
                    contracts: {
                        multicall3: {
                            address: "0xca11bde05977b3631167028862be2a173976ca11",
                            blockCreated: 7096959
                        }
                    },
                    testnet: !0
                }),
                Yme = El({
                    id: 84532,
                    network: "base-sepolia",
                    name: "Base Sepolia",
                    nativeCurrency: {
                        name: "Sepolia Ether",
                        symbol: "ETH",
                        decimals: 18
                    },
                    rpcUrls: {
                        alchemy: {
                            http: ["https://base-sepolia.g.alchemy.com/v2"],
                            webSocket: ["wss://base-sepolia.g.alchemy.com/v2"]
                        },
                        default: {
                            http: ["https://sepolia.base.org"]
                        },
                        public: {
                            http: ["https://sepolia.base.org"]
                        }
                    },
                    blockExplorers: {
                        blockscout: {
                            name: "Blockscout",
                            url: "https://base-sepolia.blockscout.com"
                        },
                        default: {
                            name: "Blockscout",
                            url: "https://base-sepolia.blockscout.com"
                        }
                    },
                    testnet: !0,
                    sourceId: 11155111
                }, {
                    formatters: wU
                }),
                nt = {
                    production: !0,
                    eth: {
                        chainId: "0x1",
                        chainIdInt: 1,
                        chainName: "Ethereum Mainnet",
                        gasFees: .015,
                        purchaseToken: "ETH",
                        hasStaking: !0,
                        nativeFunction: "buyWithEth",
                        presaleAddress: "0xab19D5d8590a7f337B7c2ecE83e0733F55fe2DBf",
                        usdTAddress: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
                        rpcURL: "https://wiser-boldest-frog.quiknode.pro/3cc8cdf89d7bf58f83a78ac27f5347e13bfeedfa/",
                        backupRPC: "https://wiser-boldest-frog.quiknode.pro/3cc8cdf89d7bf58f83a78ac27f5347e13bfeedfa/",
                        blockExplorerURL: "https://etherscan.io/tx/",
                        chainInfo: {
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0x1",
                                chainName: "Ethereum Mainnet",
                                nativeCurrency: {
                                    name: "ETH",
                                    symbol: "ETH",
                                    decimals: 18
                                },
                                rpcUrls: ["https://rpc.ankr.com/eth"],
                                blockExplorerUrls: ["https://etherscan.io/"]
                            }]
                        }
                    },
                    bsc: {
                        chainId: "0x38",
                        chainIdInt: 56,
                        chainName: "BSC Mainnet",
                        gasFees: .0025,
                        purchaseToken: "BNB",
                        hasStaking: !1,
                        nativeFunction: "buyWithBNB",
                        presaleAddress: "0x7d1859c61dB54940f28ca94B486ddE6bC6507Ba3",
                        usdTAddress: "0x55d398326f99059fF775485246999027B3197955",
                        rpcURL: "https://wispy-hidden-layer.bsc.quiknode.pro/c671fc9023a7d6bfe8de72362ee808e9cfedcb3b/",
                        backupRPC: "https://wispy-hidden-layer.bsc.quiknode.pro/c671fc9023a7d6bfe8de72362ee808e9cfedcb3b/",
                        blockExplorerURL: "https://bscscan.com/tx/",
                        chainInfo: {
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0x38",
                                chainName: "BSC Mainnet",
                                nativeCurrency: {
                                    name: "BNB",
                                    symbol: "BNB",
                                    decimals: 18
                                },
                                rpcUrls: ["https://bsc-dataseed2.ninicoin.io/"],
                                blockExplorerUrls: ["https://bscscan.com/"]
                            }]
                        }
                    },
                    poly: {
                        chainId: "0x89",
                        chainIdInt: 137,
                        hasStaking: !1,
                        chainName: "Polygon",
                        nativeFunction: "buyWithMATIC",
                        gasFees: .0025,
                        purchaseToken: "MATIC",
                        presaleAddress: "0x7d1859c61dB54940f28ca94B486ddE6bC6507Ba3",
                        usdTAddress: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
                        rpcURL: "https://smart-methodical-owl.matic.quiknode.pro/c849167558e4a989ada193eca05cf92149c72678/",
                        backupRPC: "https://smart-methodical-owl.matic.quiknode.pro/c849167558e4a989ada193eca05cf92149c72678/",
                        blockExplorerURL: "https://polygonscan.com/tx/",
                        chainInfo: {
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0x89",
                                chainName: "Polygon",
                                nativeCurrency: {
                                    name: "MATIC",
                                    symbol: "MATIC",
                                    decimals: 18
                                },
                                rpcUrls: ["polygon-rpc.com"],
                                blockExplorerUrls: ["https://polygonscan.com/"]
                            }]
                        }
                    },
                    avalanche: {
                        chainId: "0xa86a",
                        chainIdInt: 43114,
                        hasStaking: !1,
                        chainName: "Avalanche",
                        nativeFunction: "buyWithAVAX",
                        gasFees: .0025,
                        purchaseToken: "AVAX",
                        presaleAddress: "0x7d1859c61dB54940f28ca94B486ddE6bC6507Ba3",
                        usdTAddress: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",
                        rpcURL: "https://cosmopolitan-evocative-isle.avalanche-mainnet.quiknode.pro/70424d295daca922433cc6fecbeb611a33b57221/ext/bc/C/rpc/",
                        backupRPC: "https://cosmopolitan-evocative-isle.avalanche-mainnet.quiknode.pro/70424d295daca922433cc6fecbeb611a33b57221/ext/bc/C/rpc/",
                        blockExplorerURL: "https://snowtrace.io/tx/",
                        chainInfo: {
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0xa86a",
                                chainName: "Avalanche",
                                nativeCurrency: {
                                    name: "AVAX",
                                    symbol: "AVAX",
                                    decimals: 18
                                },
                                rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
                                blockExplorerUrls: ["https://snowtrace.io/"]
                            }]
                        }
                    },
                    base: {
                        chainId: "0x2105",
                        chainIdInt: 8453,
                        hasStaking: !1,
                        chainName: "Base",
                        nativeFunction: "buyWithETH",
                        gasFees: 1e-5,
                        purchaseToken: "BASE",
                        presaleAddress: "0x7d1859c61db54940f28ca94b486dde6bc6507ba3",
                        usdTAddress: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
                        rpcURL: "https://broken-powerful-model.base-mainnet.quiknode.pro/3d09ecd5318afa8267b26f631a320b2650d007b0/",
                        backupRPC: "https://broken-powerful-model.base-mainnet.quiknode.pro/3d09ecd5318afa8267b26f631a320b2650d007b0/",
                        blockExplorerURL: "https://basescan.org/tx/",
                        chainInfo: {
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0x2105",
                                chainName: "Base",
                                nativeCurrency: {
                                    name: "ETH",
                                    symbol: "ETH",
                                    decimals: 18
                                },
                                rpcUrls: ["https://mainnet.base.org"],
                                blockExplorerUrls: ["https://basescan.org/"]
                            }]
                        }
                    },
                    solana: {
                        rpcUrl: "https://damp-damp-rain.solana-mainnet.quiknode.pro/58d4cbc9456e60ae44a44c558534044293588a9c/",
                        blockExplorerURL: "https://solscan.io/tx/",
                        gasFees: .0015,
                        usdcTokenAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
                        presaleAddress: "7o6QTfR72APn9WY97jDEpQ6TZVuAVnbfXdpSuD6vVSWT",
                        otherAccountUsdc: "3jswKduJny9rTNB1sDZSuGRJNLijWRA6cGRAXYLhznyX",
                        otherAccountSol: "6XGpfyhvxn2rEm4YRf9CAj88hzZpToPga48itvHBYBim"
                    },
                    minToken: 10,
                    tokenAddress: "0x62F03b52c377FeA3EB71D451a95ad86C818755D1",
                    stakingAddress: "0x7935083BAdE77E77c6b56A1f758A07114bA4A308",
                    tokenName: "$DOGEVERSE",
                    apyCalcConst: "16000000000",
                    iidDashFx: 1614,
                    urlDashFx: "https://sg2sq75bq5ogpia7skmxkqjqmy0vbkvi.lambda-url.eu-west-2.on.aws/",
                    referUrl: "https://ebdqgfb4dgdnuz5mtwdbtufng40laqdt.lambda-url.eu-west-2.on.aws/",
                    wertOrigin: "https://widget.wert.io",
                    partnerId: "01HTYTTEZGXMQJCMGFY81EFY5T",
                    wertUrl: "https://vxzntbxdf5lbfovpndbosxqgjm0bthcj.lambda-url.eu-west-2.on.aws/",
                    walletConnectId: "3a886cf0d5a82188584e4641e98083fd",
                    bwUniversalLink: "https://best-wallet-prod.web.app",
                    bwDeepLink: "bw://app/connect?",
                    bwApiUrl: "https://api.bestwallet.com/presale-transactions",
                    showBestWallet: !0,
                    solDomain: "https://solana.dogeversetoken.com/",
                    usdRaisedApi: "https://d2jpne85jsgz7z.cloudfront.net/v1/blockchain/usd"
                };
            var Mr = T(45151),
                Aa = T(39007),
                Xme = T(62662),
                xU = T.n(Xme),
                Qme = T(71109),
                og = T.n(Qme),
                Jme = T(63241),
                bs = T.n(Jme),
                zi = T(56936),
                e1 = T(87501);

            function ag(t) {
                let n = t.length;
                for (; --n >= 0;) t[n] = 0
            }
            const yM = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
                t1 = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
                age = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
                MU = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                od = new Array(576);
            ag(od);
            const r_ = new Array(60);
            ag(r_);
            const s_ = new Array(512);
            ag(s_);
            const o_ = new Array(256);
            ag(o_);
            const _M = new Array(29);
            ag(_M);
            const n1 = new Array(30);

            function vM(t, n, e, i, r) {
                this.static_tree = t, this.extra_bits = n, this.extra_base = e, this.elems = i, this.max_length = r, this.has_stree = t && t.length
            }
            let IU, PU, OU;

            function bM(t, n) {
                this.dyn_tree = t, this.max_code = 0, this.stat_desc = n
            }
            ag(n1);
            const LU = t => t < 256 ? s_[t] : s_[256 + (t >>> 7)],
                a_ = (t, n) => {
                    t.pending_buf[t.pending++] = 255 & n, t.pending_buf[t.pending++] = n >>> 8 & 255
                },
                Xa = (t, n, e) => {
                    t.bi_valid > 16 - e ? (t.bi_buf |= n << t.bi_valid & 65535, a_(t, t.bi_buf), t.bi_buf = n >> 16 - t.bi_valid, t.bi_valid += e - 16) : (t.bi_buf |= n << t.bi_valid & 65535, t.bi_valid += e)
                },
                du = (t, n, e) => {
                    Xa(t, e[2 * n], e[2 * n + 1])
                },
                RU = (t, n) => {
                    let e = 0;
                    do {
                        e |= 1 & t, t >>>= 1, e <<= 1
                    } while (--n > 0);
                    return e >>> 1
                },
                BU = (t, n, e) => {
                    const i = new Array(16);
                    let s, o, r = 0;
                    for (s = 1; s <= 15; s++) r = r + e[s - 1] << 1, i[s] = r;
                    for (o = 0; o <= n; o++) {
                        let a = t[2 * o + 1];
                        0 !== a && (t[2 * o] = RU(i[a]++, a))
                    }
                },
                NU = t => {
                    let n;
                    for (n = 0; n < 286; n++) t.dyn_ltree[2 * n] = 0;
                    for (n = 0; n < 30; n++) t.dyn_dtree[2 * n] = 0;
                    for (n = 0; n < 19; n++) t.bl_tree[2 * n] = 0;
                    t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0
                },
                FU = t => {
                    t.bi_valid > 8 ? a_(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
                },
                VU = (t, n, e, i) => {
                    const r = 2 * n,
                        s = 2 * e;
                    return t[r] < t[s] || t[r] === t[s] && i[n] <= i[e]
                },
                wM = (t, n, e) => {
                    const i = t.heap[e];
                    let r = e << 1;
                    for (; r <= t.heap_len && (r < t.heap_len && VU(n, t.heap[r + 1], t.heap[r], t.depth) && r++, !VU(n, i, t.heap[r], t.depth));) t.heap[e] = t.heap[r], e = r, r <<= 1;
                    t.heap[e] = i
                },
                UU = (t, n, e) => {
                    let i, r, o, a, s = 0;
                    if (0 !== t.sym_next)
                        do {
                            i = 255 & t.pending_buf[t.sym_buf + s++], i += (255 & t.pending_buf[t.sym_buf + s++]) << 8, r = t.pending_buf[t.sym_buf + s++], 0 === i ? du(t, r, n) : (o = o_[r], du(t, o + 256 + 1, n), a = yM[o], 0 !== a && (r -= _M[o], Xa(t, r, a)), i--, o = LU(i), du(t, o, e), a = t1[o], 0 !== a && (i -= n1[o], Xa(t, i, a)))
                        } while (s < t.sym_next);
                    du(t, 256, n)
                },
                xM = (t, n) => {
                    const e = n.dyn_tree,
                        i = n.stat_desc.static_tree,
                        r = n.stat_desc.has_stree,
                        s = n.stat_desc.elems;
                    let o, a, u, c = -1;
                    for (t.heap_len = 0, t.heap_max = 573, o = 0; o < s; o++) 0 !== e[2 * o] ? (t.heap[++t.heap_len] = c = o, t.depth[o] = 0) : e[2 * o + 1] = 0;
                    for (; t.heap_len < 2;) u = t.heap[++t.heap_len] = c < 2 ? ++c : 0, e[2 * u] = 1, t.depth[u] = 0, t.opt_len--, r && (t.static_len -= i[2 * u + 1]);
                    for (n.max_code = c, o = t.heap_len >> 1; o >= 1; o--) wM(t, e, o);
                    u = s;
                    do {
                        o = t.heap[1], t.heap[1] = t.heap[t.heap_len--], wM(t, e, 1), a = t.heap[1], t.heap[--t.heap_max] = o, t.heap[--t.heap_max] = a, e[2 * u] = e[2 * o] + e[2 * a], t.depth[u] = (t.depth[o] >= t.depth[a] ? t.depth[o] : t.depth[a]) + 1, e[2 * o + 1] = e[2 * a + 1] = u, t.heap[1] = u++, wM(t, e, 1)
                    } while (t.heap_len >= 2);
                    t.heap[--t.heap_max] = t.heap[1], ((t, n) => {
                        const e = n.dyn_tree,
                            i = n.max_code,
                            r = n.stat_desc.static_tree,
                            s = n.stat_desc.has_stree,
                            o = n.stat_desc.extra_bits,
                            a = n.stat_desc.extra_base,
                            c = n.stat_desc.max_length;
                        let u, h, m, x, D, V, te = 0;
                        for (x = 0; x <= 15; x++) t.bl_count[x] = 0;
                        for (e[2 * t.heap[t.heap_max] + 1] = 0, u = t.heap_max + 1; u < 573; u++) h = t.heap[u], x = e[2 * e[2 * h + 1] + 1] + 1, x > c && (x = c, te++), e[2 * h + 1] = x, !(h > i) && (t.bl_count[x]++, D = 0, h >= a && (D = o[h - a]), V = e[2 * h], t.opt_len += V * (x + D), s && (t.static_len += V * (r[2 * h + 1] + D)));
                        if (0 !== te) {
                            do {
                                for (x = c - 1; 0 === t.bl_count[x];) x--;
                                t.bl_count[x]--, t.bl_count[x + 1] += 2, t.bl_count[c]--, te -= 2
                            } while (te > 0);
                            for (x = c; 0 !== x; x--)
                                for (h = t.bl_count[x]; 0 !== h;) m = t.heap[--u], !(m > i) && (e[2 * m + 1] !== x && (t.opt_len += (x - e[2 * m + 1]) * e[2 * m], e[2 * m + 1] = x), h--)
                        }
                    })(t, n), BU(e, c, t.bl_count)
                },
                HU = (t, n, e) => {
                    let i, s, r = -1,
                        o = n[1],
                        a = 0,
                        c = 7,
                        u = 4;
                    for (0 === o && (c = 138, u = 3), n[2 * (e + 1) + 1] = 65535, i = 0; i <= e; i++) s = o, o = n[2 * (i + 1) + 1], !(++a < c && s === o) && (a < u ? t.bl_tree[2 * s] += a : 0 !== s ? (s !== r && t.bl_tree[2 * s]++, t.bl_tree[32]++) : a <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, a = 0, r = s, 0 === o ? (c = 138, u = 3) : s === o ? (c = 6, u = 3) : (c = 7, u = 4))
                },
                $U = (t, n, e) => {
                    let i, s, r = -1,
                        o = n[1],
                        a = 0,
                        c = 7,
                        u = 4;
                    for (0 === o && (c = 138, u = 3), i = 0; i <= e; i++)
                        if (s = o, o = n[2 * (i + 1) + 1], !(++a < c && s === o)) {
                            if (a < u)
                                do {
                                    du(t, s, t.bl_tree)
                                } while (0 != --a);
                            else 0 !== s ? (s !== r && (du(t, s, t.bl_tree), a--), du(t, 16, t.bl_tree), Xa(t, a - 3, 2)) : a <= 10 ? (du(t, 17, t.bl_tree), Xa(t, a - 3, 3)) : (du(t, 18, t.bl_tree), Xa(t, a - 11, 7));
                            a = 0, r = s, 0 === o ? (c = 138, u = 3) : s === o ? (c = 6, u = 3) : (c = 7, u = 4)
                        }
                };
            let zU = !1;
            const jU = (t, n, e, i) => {
                Xa(t, 0 + (i ? 1 : 0), 3), FU(t), a_(t, e), a_(t, ~e), e && t.pending_buf.set(t.window.subarray(n, n + e), t.pending), t.pending += e
            };
            var Tge = {
                    _tr_init: t => {
                        zU || ((() => {
                            let t, n, e, i, r;
                            const s = new Array(16);
                            for (e = 0, i = 0; i < 28; i++)
                                for (_M[i] = e, t = 0; t < 1 << yM[i]; t++) o_[e++] = i;
                            for (o_[e - 1] = i, r = 0, i = 0; i < 16; i++)
                                for (n1[i] = r, t = 0; t < 1 << t1[i]; t++) s_[r++] = i;
                            for (r >>= 7; i < 30; i++)
                                for (n1[i] = r << 7, t = 0; t < 1 << t1[i] - 7; t++) s_[256 + r++] = i;
                            for (n = 0; n <= 15; n++) s[n] = 0;
                            for (t = 0; t <= 143;) od[2 * t + 1] = 8, t++, s[8]++;
                            for (; t <= 255;) od[2 * t + 1] = 9, t++, s[9]++;
                            for (; t <= 279;) od[2 * t + 1] = 7, t++, s[7]++;
                            for (; t <= 287;) od[2 * t + 1] = 8, t++, s[8]++;
                            for (BU(od, 287, s), t = 0; t < 30; t++) r_[2 * t + 1] = 5, r_[2 * t] = RU(t, 5);
                            IU = new vM(od, yM, 257, 286, 15), PU = new vM(r_, t1, 0, 30, 15), OU = new vM(new Array(0), age, 0, 19, 7)
                        })(), zU = !0), t.l_desc = new bM(t.dyn_ltree, IU), t.d_desc = new bM(t.dyn_dtree, PU), t.bl_desc = new bM(t.bl_tree, OU), t.bi_buf = 0, t.bi_valid = 0, NU(t)
                    },
                    _tr_stored_block: jU,
                    _tr_flush_block: (t, n, e, i) => {
                        let r, s, o = 0;
                        t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = (t => {
                            let e, n = 4093624447;
                            for (e = 0; e <= 31; e++, n >>>= 1)
                                if (1 & n && 0 !== t.dyn_ltree[2 * e]) return 0;
                            if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
                            for (e = 32; e < 256; e++)
                                if (0 !== t.dyn_ltree[2 * e]) return 1;
                            return 0
                        })(t)), xM(t, t.l_desc), xM(t, t.d_desc), o = (t => {
                            let n;
                            for (HU(t, t.dyn_ltree, t.l_desc.max_code), HU(t, t.dyn_dtree, t.d_desc.max_code), xM(t, t.bl_desc), n = 18; n >= 3 && 0 === t.bl_tree[2 * MU[n] + 1]; n--);
                            return t.opt_len += 3 * (n + 1) + 5 + 5 + 4, n
                        })(t), r = t.opt_len + 3 + 7 >>> 3, s = t.static_len + 3 + 7 >>> 3, s <= r && (r = s)) : r = s = e + 5, e + 4 <= r && -1 !== n ? jU(t, n, e, i) : 4 === t.strategy || s === r ? (Xa(t, 2 + (i ? 1 : 0), 3), UU(t, od, r_)) : (Xa(t, 4 + (i ? 1 : 0), 3), ((t, n, e, i) => {
                            let r;
                            for (Xa(t, n - 257, 5), Xa(t, e - 1, 5), Xa(t, i - 4, 4), r = 0; r < i; r++) Xa(t, t.bl_tree[2 * MU[r] + 1], 3);
                            $U(t, t.dyn_ltree, n - 1), $U(t, t.dyn_dtree, e - 1)
                        })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), UU(t, t.dyn_ltree, t.dyn_dtree)), NU(t), i && FU(t)
                    },
                    _tr_tally: (t, n, e) => (t.pending_buf[t.sym_buf + t.sym_next++] = n, t.pending_buf[t.sym_buf + t.sym_next++] = n >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = e, 0 === n ? t.dyn_ltree[2 * e]++ : (t.matches++, n--, t.dyn_ltree[2 * (o_[e] + 256 + 1)]++, t.dyn_dtree[2 * LU(n)]++), t.sym_next === t.sym_end),
                    _tr_align: t => {
                        Xa(t, 2, 3), du(t, 256, od), (t => {
                            16 === t.bi_valid ? (a_(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
                        })(t)
                    }
                },
                c_ = (t, n, e, i) => {
                    let r = 65535 & t | 0,
                        s = t >>> 16 & 65535 | 0,
                        o = 0;
                    for (; 0 !== e;) {
                        o = e > 2e3 ? 2e3 : e, e -= o;
                        do {
                            r = r + n[i++] | 0, s = s + r | 0
                        } while (--o);
                        r %= 65521, s %= 65521
                    }
                    return r | s << 16 | 0
                };
            const Ege = new Uint32Array((() => {
                let t, n = [];
                for (var e = 0; e < 256; e++) {
                    t = e;
                    for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                    n[e] = t
                }
                return n
            })());
            var Po = (t, n, e, i) => {
                    const r = Ege,
                        s = i + e;
                    t ^= -1;
                    for (let o = i; o < s; o++) t = t >>> 8 ^ r[255 & (t ^ n[o])];
                    return -1 ^ t
                },
                Yf = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                },
                Xf = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_MEM_ERROR: -4,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                };
            const {
                _tr_init: Dge,
                _tr_stored_block: CM,
                _tr_flush_block: Age,
                _tr_tally: vh,
                _tr_align: kge
            } = Tge, {
                Z_NO_FLUSH: bh,
                Z_PARTIAL_FLUSH: Mge,
                Z_FULL_FLUSH: Ige,
                Z_FINISH: Zc,
                Z_BLOCK: WU,
                Z_OK: Go,
                Z_STREAM_END: GU,
                Z_STREAM_ERROR: hu,
                Z_DATA_ERROR: Pge,
                Z_BUF_ERROR: TM,
                Z_DEFAULT_COMPRESSION: Oge,
                Z_FILTERED: Lge,
                Z_HUFFMAN_ONLY: r1,
                Z_RLE: Rge,
                Z_FIXED: Bge,
                Z_DEFAULT_STRATEGY: Nge,
                Z_UNKNOWN: Fge,
                Z_DEFLATED: s1
            } = Xf, fu = 262, ep = (t, n) => (t.msg = Yf[n], n), KU = t => 2 * t - (t > 4 ? 9 : 0), xh = t => {
                let n = t.length;
                for (; --n >= 0;) t[n] = 0
            }, Zge = t => {
                let n, e, i, r = t.w_size;
                n = t.hash_size, i = n;
                do {
                    e = t.head[--i], t.head[i] = e >= r ? e - r : 0
                } while (--n);
                n = r, i = n;
                do {
                    e = t.prev[--i], t.prev[i] = e >= r ? e - r : 0
                } while (--n)
            };
            let Ch = (t, n, e) => (n << t.hash_shift ^ e) & t.hash_mask;
            const Tc = t => {
                    const n = t.state;
                    let e = n.pending;
                    e > t.avail_out && (e = t.avail_out), 0 !== e && (t.output.set(n.pending_buf.subarray(n.pending_out, n.pending_out + e), t.next_out), t.next_out += e, n.pending_out += e, t.total_out += e, t.avail_out -= e, n.pending -= e, 0 === n.pending && (n.pending_out = 0))
                },
                Sc = (t, n) => {
                    Age(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, n), t.block_start = t.strstart, Tc(t.strm)
                },
                Br = (t, n) => {
                    t.pending_buf[t.pending++] = n
                },
                u_ = (t, n) => {
                    t.pending_buf[t.pending++] = n >>> 8 & 255, t.pending_buf[t.pending++] = 255 & n
                },
                IM = (t, n, e, i) => {
                    let r = t.avail_in;
                    return r > i && (r = i), 0 === r ? 0 : (t.avail_in -= r, n.set(t.input.subarray(t.next_in, t.next_in + r), e), 1 === t.state.wrap ? t.adler = c_(t.adler, n, r, e) : 2 === t.state.wrap && (t.adler = Po(t.adler, n, r, e)), t.next_in += r, t.total_in += r, r)
                },
                qU = (t, n) => {
                    let r, s, e = t.max_chain_length,
                        i = t.strstart,
                        o = t.prev_length,
                        a = t.nice_match;
                    const c = t.strstart > t.w_size - fu ? t.strstart - (t.w_size - fu) : 0,
                        u = t.window,
                        h = t.w_mask,
                        m = t.prev,
                        x = t.strstart + 258;
                    let D = u[i + o - 1],
                        V = u[i + o];
                    t.prev_length >= t.good_match && (e >>= 2), a > t.lookahead && (a = t.lookahead);
                    do {
                        if (r = n, u[r + o] === V && u[r + o - 1] === D && u[r] === u[i] && u[++r] === u[i + 1]) {
                            i += 2, r++;
                            do {} while (u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && i < x);
                            if (s = 258 - (x - i), i = x - 258, s > o) {
                                if (t.match_start = n, o = s, s >= a) break;
                                D = u[i + o - 1], V = u[i + o]
                            }
                        }
                    } while ((n = m[n & h]) > c && 0 != --e);
                    return o <= t.lookahead ? o : t.lookahead
                },
                hg = t => {
                    const n = t.w_size;
                    let e, i, r;
                    do {
                        if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= n + (n - fu) && (t.window.set(t.window.subarray(n, n + n - i), 0), t.match_start -= n, t.strstart -= n, t.block_start -= n, t.insert > t.strstart && (t.insert = t.strstart), Zge(t), i += n), 0 === t.strm.avail_in) break;
                        if (e = IM(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += e, t.lookahead + t.insert >= 3)
                            for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = Ch(t, t.ins_h, t.window[r + 1]); t.insert && (t.ins_h = Ch(t, t.ins_h, t.window[r + 3 - 1]), t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++, t.insert--, !(t.lookahead + t.insert < 3)););
                    } while (t.lookahead < fu && 0 !== t.strm.avail_in)
                },
                ZU = (t, n) => {
                    let i, r, s, e = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
                        o = 0,
                        a = t.strm.avail_in;
                    do {
                        if (i = 65535, s = t.bi_valid + 42 >> 3, t.strm.avail_out < s || (s = t.strm.avail_out - s, r = t.strstart - t.block_start, i > r + t.strm.avail_in && (i = r + t.strm.avail_in), i > s && (i = s), i < e && (0 === i && n !== Zc || n === bh || i !== r + t.strm.avail_in))) break;
                        o = n === Zc && i === r + t.strm.avail_in ? 1 : 0, CM(t, 0, 0, o), t.pending_buf[t.pending - 4] = i, t.pending_buf[t.pending - 3] = i >> 8, t.pending_buf[t.pending - 2] = ~i, t.pending_buf[t.pending - 1] = ~i >> 8, Tc(t.strm), r && (r > i && (r = i), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + r), t.strm.next_out), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r, t.block_start += r, i -= r), i && (IM(t.strm, t.strm.output, t.strm.next_out, i), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i)
                    } while (0 === o);
                    return a -= t.strm.avail_in, a && (a >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= a && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), o ? 4 : n !== bh && n !== Zc && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (s = t.window_size - t.strstart, t.strm.avail_in > s && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, s += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), s > t.strm.avail_in && (s = t.strm.avail_in), s && (IM(t.strm, t.window, t.strstart, s), t.strstart += s, t.insert += s > t.w_size - t.insert ? t.w_size - t.insert : s), t.high_water < t.strstart && (t.high_water = t.strstart), s = t.bi_valid + 42 >> 3, s = t.pending_buf_size - s > 65535 ? 65535 : t.pending_buf_size - s, e = s > t.w_size ? t.w_size : s, r = t.strstart - t.block_start, (r >= e || (r || n === Zc) && n !== bh && 0 === t.strm.avail_in && r <= s) && (i = r > s ? s : r, o = n === Zc && 0 === t.strm.avail_in && i === r ? 1 : 0, CM(t, t.block_start, i, o), t.block_start += i, Tc(t.strm)), o ? 3 : 1)
                },
                PM = (t, n) => {
                    let e, i;
                    for (;;) {
                        if (t.lookahead < fu) {
                            if (hg(t), t.lookahead < fu && n === bh) return 1;
                            if (0 === t.lookahead) break
                        }
                        if (e = 0, t.lookahead >= 3 && (t.ins_h = Ch(t, t.ins_h, t.window[t.strstart + 3 - 1]), e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== e && t.strstart - e <= t.w_size - fu && (t.match_length = qU(t, e)), t.match_length >= 3)
                            if (i = vh(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
                                t.match_length--;
                                do {
                                    t.strstart++, t.ins_h = Ch(t, t.ins_h, t.window[t.strstart + 3 - 1]), e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
                                } while (0 != --t.match_length);
                                t.strstart++
                            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Ch(t, t.ins_h, t.window[t.strstart + 1]);
                        else i = vh(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
                        if (i && (Sc(t, !1), 0 === t.strm.avail_out)) return 1
                    }
                    return t.insert = t.strstart < 2 ? t.strstart : 2, n === Zc ? (Sc(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Sc(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                },
                fg = (t, n) => {
                    let e, i, r;
                    for (;;) {
                        if (t.lookahead < fu) {
                            if (hg(t), t.lookahead < fu && n === bh) return 1;
                            if (0 === t.lookahead) break
                        }
                        if (e = 0, t.lookahead >= 3 && (t.ins_h = Ch(t, t.ins_h, t.window[t.strstart + 3 - 1]), e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== e && t.prev_length < t.max_lazy_match && t.strstart - e <= t.w_size - fu && (t.match_length = qU(t, e), t.match_length <= 5 && (t.strategy === Lge || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) {
                            r = t.strstart + t.lookahead - 3, i = vh(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                            do {
                                ++t.strstart <= r && (t.ins_h = Ch(t, t.ins_h, t.window[t.strstart + 3 - 1]), e = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
                            } while (0 != --t.prev_length);
                            if (t.match_available = 0, t.match_length = 2, t.strstart++, i && (Sc(t, !1), 0 === t.strm.avail_out)) return 1
                        } else if (t.match_available) {
                            if (i = vh(t, 0, t.window[t.strstart - 1]), i && Sc(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1
                        } else t.match_available = 1, t.strstart++, t.lookahead--
                    }
                    return t.match_available && (i = vh(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, n === Zc ? (Sc(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Sc(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                };

            function pu(t, n, e, i, r) {
                this.good_length = t, this.max_lazy = n, this.nice_length = e, this.max_chain = i, this.func = r
            }
            const d_ = [new pu(0, 0, 0, 0, ZU), new pu(4, 4, 8, 4, PM), new pu(4, 5, 16, 8, PM), new pu(4, 6, 32, 32, PM), new pu(4, 4, 16, 16, fg), new pu(8, 16, 32, 32, fg), new pu(8, 16, 128, 128, fg), new pu(8, 32, 128, 256, fg), new pu(32, 128, 258, 1024, fg), new pu(32, 258, 258, 4096, fg)];

            function Jge() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = s1, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), xh(this.dyn_ltree), xh(this.dyn_dtree), xh(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), xh(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), xh(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
            }
            const h_ = t => {
                    if (!t) return 1;
                    const n = t.state;
                    return !n || n.strm !== t || 42 !== n.status && 57 !== n.status && 69 !== n.status && 73 !== n.status && 91 !== n.status && 103 !== n.status && 113 !== n.status && 666 !== n.status ? 1 : 0
                },
                YU = t => {
                    if (h_(t)) return ep(t, hu);
                    t.total_in = t.total_out = 0, t.data_type = Fge;
                    const n = t.state;
                    return n.pending = 0, n.pending_out = 0, n.wrap < 0 && (n.wrap = -n.wrap), n.status = 2 === n.wrap ? 57 : n.wrap ? 42 : 113, t.adler = 2 === n.wrap ? 0 : 1, n.last_flush = -2, Dge(n), Go
                },
                XU = t => {
                    const n = YU(t);
                    return n === Go && (t => {
                        t.window_size = 2 * t.w_size, xh(t.head), t.max_lazy_match = d_[t.level].max_lazy, t.good_match = d_[t.level].good_length, t.nice_match = d_[t.level].nice_length, t.max_chain_length = d_[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = 2, t.match_available = 0, t.ins_h = 0
                    })(t.state), n
                },
                QU = (t, n, e, i, r, s) => {
                    if (!t) return hu;
                    let o = 1;
                    if (n === Oge && (n = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), r < 1 || r > 9 || e !== s1 || i < 8 || i > 15 || n < 0 || n > 9 || s < 0 || s > Bge || 8 === i && 1 !== o) return ep(t, hu);
                    8 === i && (i = 9);
                    const a = new Jge;
                    return t.state = a, a.strm = t, a.status = 42, a.wrap = o, a.gzhead = null, a.w_bits = i, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = n, a.strategy = s, a.method = e, XU(t)
                };
            var f_ = {
                deflateInit: (t, n) => QU(t, n, s1, 15, 8, Nge),
                deflateInit2: QU,
                deflateReset: XU,
                deflateResetKeep: YU,
                deflateSetHeader: (t, n) => h_(t) || 2 !== t.state.wrap ? hu : (t.state.gzhead = n, Go),
                deflate: (t, n) => {
                    if (h_(t) || n > WU || n < 0) return t ? ep(t, hu) : hu;
                    const e = t.state;
                    if (!t.output || 0 !== t.avail_in && !t.input || 666 === e.status && n !== Zc) return ep(t, 0 === t.avail_out ? TM : hu);
                    const i = e.last_flush;
                    if (e.last_flush = n, 0 !== e.pending) {
                        if (Tc(t), 0 === t.avail_out) return e.last_flush = -1, Go
                    } else if (0 === t.avail_in && KU(n) <= KU(i) && n !== Zc) return ep(t, TM);
                    if (666 === e.status && 0 !== t.avail_in) return ep(t, TM);
                    if (42 === e.status && 0 === e.wrap && (e.status = 113), 42 === e.status) {
                        let r = s1 + (e.w_bits - 8 << 4) << 8,
                            s = -1;
                        if (s = e.strategy >= r1 || e.level < 2 ? 0 : e.level < 6 ? 1 : 6 === e.level ? 2 : 3, r |= s << 6, 0 !== e.strstart && (r |= 32), r += 31 - r % 31, u_(e, r), 0 !== e.strstart && (u_(e, t.adler >>> 16), u_(e, 65535 & t.adler)), t.adler = 1, e.status = 113, Tc(t), 0 !== e.pending) return e.last_flush = -1, Go
                    }
                    if (57 === e.status)
                        if (t.adler = 0, Br(e, 31), Br(e, 139), Br(e, 8), e.gzhead) Br(e, (e.gzhead.text ? 1 : 0) + (e.gzhead.hcrc ? 2 : 0) + (e.gzhead.extra ? 4 : 0) + (e.gzhead.name ? 8 : 0) + (e.gzhead.comment ? 16 : 0)), Br(e, 255 & e.gzhead.time), Br(e, e.gzhead.time >> 8 & 255), Br(e, e.gzhead.time >> 16 & 255), Br(e, e.gzhead.time >> 24 & 255), Br(e, 9 === e.level ? 2 : e.strategy >= r1 || e.level < 2 ? 4 : 0), Br(e, 255 & e.gzhead.os), e.gzhead.extra && e.gzhead.extra.length && (Br(e, 255 & e.gzhead.extra.length), Br(e, e.gzhead.extra.length >> 8 & 255)), e.gzhead.hcrc && (t.adler = Po(t.adler, e.pending_buf, e.pending, 0)), e.gzindex = 0, e.status = 69;
                        else if (Br(e, 0), Br(e, 0), Br(e, 0), Br(e, 0), Br(e, 0), Br(e, 9 === e.level ? 2 : e.strategy >= r1 || e.level < 2 ? 4 : 0), Br(e, 3), e.status = 113, Tc(t), 0 !== e.pending) return e.last_flush = -1, Go;
                    if (69 === e.status) {
                        if (e.gzhead.extra) {
                            let r = e.pending,
                                s = (65535 & e.gzhead.extra.length) - e.gzindex;
                            for (; e.pending + s > e.pending_buf_size;) {
                                let a = e.pending_buf_size - e.pending;
                                if (e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex, e.gzindex + a), e.pending), e.pending = e.pending_buf_size, e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r)), e.gzindex += a, Tc(t), 0 !== e.pending) return e.last_flush = -1, Go;
                                r = 0, s -= a
                            }
                            let o = new Uint8Array(e.gzhead.extra);
                            e.pending_buf.set(o.subarray(e.gzindex, e.gzindex + s), e.pending), e.pending += s, e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0
                        }
                        e.status = 73
                    }
                    if (73 === e.status) {
                        if (e.gzhead.name) {
                            let s, r = e.pending;
                            do {
                                if (e.pending === e.pending_buf_size) {
                                    if (e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r)), Tc(t), 0 !== e.pending) return e.last_flush = -1, Go;
                                    r = 0
                                }
                                s = e.gzindex < e.gzhead.name.length ? 255 & e.gzhead.name.charCodeAt(e.gzindex++) : 0, Br(e, s)
                            } while (0 !== s);
                            e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0
                        }
                        e.status = 91
                    }
                    if (91 === e.status) {
                        if (e.gzhead.comment) {
                            let s, r = e.pending;
                            do {
                                if (e.pending === e.pending_buf_size) {
                                    if (e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r)), Tc(t), 0 !== e.pending) return e.last_flush = -1, Go;
                                    r = 0
                                }
                                s = e.gzindex < e.gzhead.comment.length ? 255 & e.gzhead.comment.charCodeAt(e.gzindex++) : 0, Br(e, s)
                            } while (0 !== s);
                            e.gzhead.hcrc && e.pending > r && (t.adler = Po(t.adler, e.pending_buf, e.pending - r, r))
                        }
                        e.status = 103
                    }
                    if (103 === e.status) {
                        if (e.gzhead.hcrc) {
                            if (e.pending + 2 > e.pending_buf_size && (Tc(t), 0 !== e.pending)) return e.last_flush = -1, Go;
                            Br(e, 255 & t.adler), Br(e, t.adler >> 8 & 255), t.adler = 0
                        }
                        if (e.status = 113, Tc(t), 0 !== e.pending) return e.last_flush = -1, Go
                    }
                    if (0 !== t.avail_in || 0 !== e.lookahead || n !== bh && 666 !== e.status) {
                        let r = 0 === e.level ? ZU(e, n) : e.strategy === r1 ? ((t, n) => {
                            let e;
                            for (;;) {
                                if (0 === t.lookahead && (hg(t), 0 === t.lookahead)) {
                                    if (n === bh) return 1;
                                    break
                                }
                                if (t.match_length = 0, e = vh(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, e && (Sc(t, !1), 0 === t.strm.avail_out)) return 1
                            }
                            return t.insert = 0, n === Zc ? (Sc(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Sc(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                        })(e, n) : e.strategy === Rge ? ((t, n) => {
                            let e, i, r, s;
                            const o = t.window;
                            for (;;) {
                                if (t.lookahead <= 258) {
                                    if (hg(t), t.lookahead <= 258 && n === bh) return 1;
                                    if (0 === t.lookahead) break
                                }
                                if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (r = t.strstart - 1, i = o[r], i === o[++r] && i === o[++r] && i === o[++r])) {
                                    s = t.strstart + 258;
                                    do {} while (i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && r < s);
                                    t.match_length = 258 - (s - r), t.match_length > t.lookahead && (t.match_length = t.lookahead)
                                }
                                if (t.match_length >= 3 ? (e = vh(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (e = vh(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), e && (Sc(t, !1), 0 === t.strm.avail_out)) return 1
                            }
                            return t.insert = 0, n === Zc ? (Sc(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Sc(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                        })(e, n) : d_[e.level].func(e, n);
                        if ((3 === r || 4 === r) && (e.status = 666), 1 === r || 3 === r) return 0 === t.avail_out && (e.last_flush = -1), Go;
                        if (2 === r && (n === Mge ? kge(e) : n !== WU && (CM(e, 0, 0, !1), n === Ige && (xh(e.head), 0 === e.lookahead && (e.strstart = 0, e.block_start = 0, e.insert = 0))), Tc(t), 0 === t.avail_out)) return e.last_flush = -1, Go
                    }
                    return n !== Zc ? Go : e.wrap <= 0 ? GU : (2 === e.wrap ? (Br(e, 255 & t.adler), Br(e, t.adler >> 8 & 255), Br(e, t.adler >> 16 & 255), Br(e, t.adler >> 24 & 255), Br(e, 255 & t.total_in), Br(e, t.total_in >> 8 & 255), Br(e, t.total_in >> 16 & 255), Br(e, t.total_in >> 24 & 255)) : (u_(e, t.adler >>> 16), u_(e, 65535 & t.adler)), Tc(t), e.wrap > 0 && (e.wrap = -e.wrap), 0 !== e.pending ? Go : GU)
                },
                deflateEnd: t => {
                    if (h_(t)) return hu;
                    const n = t.state.status;
                    return t.state = null, 113 === n ? ep(t, Pge) : Go
                },
                deflateSetDictionary: (t, n) => {
                    let e = n.length;
                    if (h_(t)) return hu;
                    const i = t.state,
                        r = i.wrap;
                    if (2 === r || 1 === r && 42 !== i.status || i.lookahead) return hu;
                    if (1 === r && (t.adler = c_(t.adler, n, e, 0)), i.wrap = 0, e >= i.w_size) {
                        0 === r && (xh(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
                        let c = new Uint8Array(i.w_size);
                        c.set(n.subarray(e - i.w_size, e), 0), n = c, e = i.w_size
                    }
                    const s = t.avail_in,
                        o = t.next_in,
                        a = t.input;
                    for (t.avail_in = e, t.next_in = 0, t.input = n, hg(i); i.lookahead >= 3;) {
                        let c = i.strstart,
                            u = i.lookahead - 2;
                        do {
                            i.ins_h = Ch(i, i.ins_h, i.window[c + 3 - 1]), i.prev[c & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = c, c++
                        } while (--u);
                        i.strstart = c, i.lookahead = 2, hg(i)
                    }
                    return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t.next_in = o, t.input = a, t.avail_in = s, i.wrap = r, Go
                },
                deflateInfo: "pako deflate (from Nodeca project)"
            };
            const pye = (t, n) => Object.prototype.hasOwnProperty.call(t, n);
            var o1 = {
                assign: function(t) {
                    const n = Array.prototype.slice.call(arguments, 1);
                    for (; n.length;) {
                        const e = n.shift();
                        if (e) {
                            if ("object" != typeof e) throw new TypeError(e + "must be non-object");
                            for (const i in e) pye(e, i) && (t[i] = e[i])
                        }
                    }
                    return t
                },
                flattenChunks: t => {
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) n += t[i].length;
                    const e = new Uint8Array(n);
                    for (let i = 0, r = 0, s = t.length; i < s; i++) {
                        let o = t[i];
                        e.set(o, r), r += o.length
                    }
                    return e
                }
            };
            let JU = !0;
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch {
                JU = !1
            }
            const p_ = new Uint8Array(256);
            for (let t = 0; t < 256; t++) p_[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
            p_[254] = p_[254] = 1;
            var m_ = {
                    string2buf: t => {
                        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(t);
                        let n, e, i, r, s, o = t.length,
                            a = 0;
                        for (r = 0; r < o; r++) e = t.charCodeAt(r), 55296 == (64512 & e) && r + 1 < o && (i = t.charCodeAt(r + 1), 56320 == (64512 & i) && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), a += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4;
                        for (n = new Uint8Array(a), s = 0, r = 0; s < a; r++) e = t.charCodeAt(r), 55296 == (64512 & e) && r + 1 < o && (i = t.charCodeAt(r + 1), 56320 == (64512 & i) && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), e < 128 ? n[s++] = e : e < 2048 ? (n[s++] = 192 | e >>> 6, n[s++] = 128 | 63 & e) : e < 65536 ? (n[s++] = 224 | e >>> 12, n[s++] = 128 | e >>> 6 & 63, n[s++] = 128 | 63 & e) : (n[s++] = 240 | e >>> 18, n[s++] = 128 | e >>> 12 & 63, n[s++] = 128 | e >>> 6 & 63, n[s++] = 128 | 63 & e);
                        return n
                    },
                    buf2string: (t, n) => {
                        const e = n || t.length;
                        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(t.subarray(0, n));
                        let i, r;
                        const s = new Array(2 * e);
                        for (r = 0, i = 0; i < e;) {
                            let o = t[i++];
                            if (o < 128) {
                                s[r++] = o;
                                continue
                            }
                            let a = p_[o];
                            if (a > 4) s[r++] = 65533, i += a - 1;
                            else {
                                for (o &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && i < e;) o = o << 6 | 63 & t[i++], a--;
                                a > 1 ? s[r++] = 65533 : o < 65536 ? s[r++] = o : (o -= 65536, s[r++] = 55296 | o >> 10 & 1023, s[r++] = 56320 | 1023 & o)
                            }
                        }
                        return ((t, n) => {
                            if (n < 65534 && t.subarray && JU) return String.fromCharCode.apply(null, t.length === n ? t : t.subarray(0, n));
                            let e = "";
                            for (let i = 0; i < n; i++) e += String.fromCharCode(t[i]);
                            return e
                        })(s, r)
                    },
                    utf8border: (t, n) => {
                        (n = n || t.length) > t.length && (n = t.length);
                        let e = n - 1;
                        for (; e >= 0 && 128 == (192 & t[e]);) e--;
                        return e < 0 || 0 === e ? n : e + p_[t[e]] > n ? e : n
                    }
                },
                eH = function wye() {
                    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
                };
            const tH = Object.prototype.toString,
                {
                    Z_NO_FLUSH: xye,
                    Z_SYNC_FLUSH: Cye,
                    Z_FULL_FLUSH: Tye,
                    Z_FINISH: Sye,
                    Z_OK: a1,
                    Z_STREAM_END: Eye,
                    Z_DEFAULT_COMPRESSION: Dye,
                    Z_DEFAULT_STRATEGY: Aye,
                    Z_DEFLATED: kye
                } = Xf;

            function g_(t) {
                this.options = o1.assign({
                    level: Dye,
                    method: kye,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: Aye
                }, t || {});
                let n = this.options;
                n.raw && n.windowBits > 0 ? n.windowBits = -n.windowBits : n.gzip && n.windowBits > 0 && n.windowBits < 16 && (n.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new eH, this.strm.avail_out = 0;
                let e = f_.deflateInit2(this.strm, n.level, n.method, n.windowBits, n.memLevel, n.strategy);
                if (e !== a1) throw new Error(Yf[e]);
                if (n.header && f_.deflateSetHeader(this.strm, n.header), n.dictionary) {
                    let i;
                    if (i = "string" == typeof n.dictionary ? m_.string2buf(n.dictionary) : "[object ArrayBuffer]" === tH.call(n.dictionary) ? new Uint8Array(n.dictionary) : n.dictionary, e = f_.deflateSetDictionary(this.strm, i), e !== a1) throw new Error(Yf[e]);
                    this._dict_set = !0
                }
            }

            function OM(t, n) {
                const e = new g_(n);
                if (e.push(t, !0), e.err) throw e.msg || Yf[e.err];
                return e.result
            }
            g_.prototype.push = function(t, n) {
                const e = this.strm,
                    i = this.options.chunkSize;
                let r, s;
                if (this.ended) return !1;
                for (s = n === ~~n ? n : !0 === n ? Sye : xye, e.input = "string" == typeof t ? m_.string2buf(t) : "[object ArrayBuffer]" === tH.call(t) ? new Uint8Array(t) : t, e.next_in = 0, e.avail_in = e.input.length;;)
                    if (0 === e.avail_out && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), (s === Cye || s === Tye) && e.avail_out <= 6) this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
                    else {
                        if (r = f_.deflate(e, s), r === Eye) return e.next_out > 0 && this.onData(e.output.subarray(0, e.next_out)), r = f_.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === a1;
                        if (0 !== e.avail_out) {
                            if (s > 0 && e.next_out > 0) this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
                            else if (0 === e.avail_in) break
                        } else this.onData(e.output)
                    }
                return !0
            }, g_.prototype.onData = function(t) {
                this.chunks.push(t)
            }, g_.prototype.onEnd = function(t) {
                t === a1 && (this.result = o1.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            };
            var Nye = {
                Deflate: g_,
                deflate: OM,
                deflateRaw: function Mye(t, n) {
                    return (n = n || {}).raw = !0, OM(t, n)
                },
                gzip: function Iye(t, n) {
                    return (n = n || {}).gzip = !0, OM(t, n)
                },
                constants: Xf
            };
            const c1 = 16209;
            var Vye = function(n, e) {
                let i, r, s, o, a, c, u, h, m, x, D, V, te, ee, _e, ye, Be, ze, Xe, ht, vt, jt, Cn, Xt;
                const Rt = n.state;
                i = n.next_in, Cn = n.input, r = i + (n.avail_in - 5), s = n.next_out, Xt = n.output, o = s - (e - n.avail_out), a = s + (n.avail_out - 257), c = Rt.dmax, u = Rt.wsize, h = Rt.whave, m = Rt.wnext, x = Rt.window, D = Rt.hold, V = Rt.bits, te = Rt.lencode, ee = Rt.distcode, _e = (1 << Rt.lenbits) - 1, ye = (1 << Rt.distbits) - 1;
                e: do {
                    V < 15 && (D += Cn[i++] << V, V += 8, D += Cn[i++] << V, V += 8), Be = te[D & _e];
                    t: for (;;) {
                        if (ze = Be >>> 24, D >>>= ze, V -= ze, ze = Be >>> 16 & 255, 0 === ze) Xt[s++] = 65535 & Be;
                        else {
                            if (!(16 & ze)) {
                                if (64 & ze) {
                                    if (32 & ze) {
                                        Rt.mode = 16191;
                                        break e
                                    }
                                    n.msg = "invalid literal/length code", Rt.mode = c1;
                                    break e
                                }
                                Be = te[(65535 & Be) + (D & (1 << ze) - 1)];
                                continue t
                            }
                            for (Xe = 65535 & Be, ze &= 15, ze && (V < ze && (D += Cn[i++] << V, V += 8), Xe += D & (1 << ze) - 1, D >>>= ze, V -= ze), V < 15 && (D += Cn[i++] << V, V += 8, D += Cn[i++] << V, V += 8), Be = ee[D & ye];;) {
                                if (ze = Be >>> 24, D >>>= ze, V -= ze, ze = Be >>> 16 & 255, 16 & ze) {
                                    if (ht = 65535 & Be, ze &= 15, V < ze && (D += Cn[i++] << V, V += 8, V < ze && (D += Cn[i++] << V, V += 8)), ht += D & (1 << ze) - 1, ht > c) {
                                        n.msg = "invalid distance too far back", Rt.mode = c1;
                                        break e
                                    }
                                    if (D >>>= ze, V -= ze, ze = s - o, ht > ze) {
                                        if (ze = ht - ze, ze > h && Rt.sane) {
                                            n.msg = "invalid distance too far back", Rt.mode = c1;
                                            break e
                                        }
                                        if (vt = 0, jt = x, 0 === m) {
                                            if (vt += u - ze, ze < Xe) {
                                                Xe -= ze;
                                                do {
                                                    Xt[s++] = x[vt++]
                                                } while (--ze);
                                                vt = s - ht, jt = Xt
                                            }
                                        } else if (m < ze) {
                                            if (vt += u + m - ze, ze -= m, ze < Xe) {
                                                Xe -= ze;
                                                do {
                                                    Xt[s++] = x[vt++]
                                                } while (--ze);
                                                if (vt = 0, m < Xe) {
                                                    ze = m, Xe -= ze;
                                                    do {
                                                        Xt[s++] = x[vt++]
                                                    } while (--ze);
                                                    vt = s - ht, jt = Xt
                                                }
                                            }
                                        } else if (vt += m - ze, ze < Xe) {
                                            Xe -= ze;
                                            do {
                                                Xt[s++] = x[vt++]
                                            } while (--ze);
                                            vt = s - ht, jt = Xt
                                        }
                                        for (; Xe > 2;) Xt[s++] = jt[vt++], Xt[s++] = jt[vt++], Xt[s++] = jt[vt++], Xe -= 3;
                                        Xe && (Xt[s++] = jt[vt++], Xe > 1 && (Xt[s++] = jt[vt++]))
                                    } else {
                                        vt = s - ht;
                                        do {
                                            Xt[s++] = Xt[vt++], Xt[s++] = Xt[vt++], Xt[s++] = Xt[vt++], Xe -= 3
                                        } while (Xe > 2);
                                        Xe && (Xt[s++] = Xt[vt++], Xe > 1 && (Xt[s++] = Xt[vt++]))
                                    }
                                    break
                                }
                                if (64 & ze) {
                                    n.msg = "invalid distance code", Rt.mode = c1;
                                    break e
                                }
                                Be = ee[(65535 & Be) + (D & (1 << ze) - 1)]
                            }
                        }
                        break
                    }
                } while (i < r && s < a);
                Xe = V >> 3, i -= Xe, V -= Xe << 3, D &= (1 << V) - 1, n.next_in = i, n.next_out = s, n.avail_in = i < r ? r - i + 5 : 5 - (i - r), n.avail_out = s < a ? a - s + 257 : 257 - (s - a), Rt.hold = D, Rt.bits = V
            };
            const Uye = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
                Hye = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
                $ye = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
                zye = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
            var y_ = (t, n, e, i, r, s, o, a) => {
                const c = a.bits;
                let Be, ze, Xe, ht, vt, Cn, u = 0,
                    h = 0,
                    m = 0,
                    x = 0,
                    D = 0,
                    V = 0,
                    te = 0,
                    ee = 0,
                    _e = 0,
                    ye = 0,
                    jt = null;
                const Xt = new Uint16Array(16),
                    Rt = new Uint16Array(16);
                let xi, ut, Ht, wr = null;
                for (u = 0; u <= 15; u++) Xt[u] = 0;
                for (h = 0; h < i; h++) Xt[n[e + h]]++;
                for (D = c, x = 15; x >= 1 && 0 === Xt[x]; x--);
                if (D > x && (D = x), 0 === x) return r[s++] = 20971520, r[s++] = 20971520, a.bits = 1, 0;
                for (m = 1; m < x && 0 === Xt[m]; m++);
                for (D < m && (D = m), ee = 1, u = 1; u <= 15; u++)
                    if (ee <<= 1, ee -= Xt[u], ee < 0) return -1;
                if (ee > 0 && (0 === t || 1 !== x)) return -1;
                for (Rt[1] = 0, u = 1; u < 15; u++) Rt[u + 1] = Rt[u] + Xt[u];
                for (h = 0; h < i; h++) 0 !== n[e + h] && (o[Rt[n[e + h]]++] = h);
                if (0 === t ? (jt = wr = o, Cn = 20) : 1 === t ? (jt = Uye, wr = Hye, Cn = 257) : (jt = $ye, wr = zye, Cn = 0), ye = 0, h = 0, u = m, vt = s, V = D, te = 0, Xe = -1, _e = 1 << D, ht = _e - 1, 1 === t && _e > 852 || 2 === t && _e > 592) return 1;
                for (;;) {
                    xi = u - te, o[h] + 1 < Cn ? (ut = 0, Ht = o[h]) : o[h] >= Cn ? (ut = wr[o[h] - Cn], Ht = jt[o[h] - Cn]) : (ut = 96, Ht = 0), Be = 1 << u - te, ze = 1 << V, m = ze;
                    do {
                        ze -= Be, r[vt + (ye >> te) + ze] = xi << 24 | ut << 16 | Ht | 0
                    } while (0 !== ze);
                    for (Be = 1 << u - 1; ye & Be;) Be >>= 1;
                    if (0 !== Be ? (ye &= Be - 1, ye += Be) : ye = 0, h++, 0 == --Xt[u]) {
                        if (u === x) break;
                        u = n[e + o[h]]
                    }
                    if (u > D && (ye & ht) !== Xe) {
                        for (0 === te && (te = D), vt += m, V = u - te, ee = 1 << V; V + te < x && (ee -= Xt[V + te], !(ee <= 0));) V++, ee <<= 1;
                        if (_e += 1 << V, 1 === t && _e > 852 || 2 === t && _e > 592) return 1;
                        Xe = ye & ht, r[Xe] = D << 24 | V << 16 | vt - s | 0
                    }
                }
                return 0 !== ye && (r[vt + ye] = u - te << 24 | 64 << 16 | 0), a.bits = D, 0
            };
            const {
                Z_FINISH: cH,
                Z_BLOCK: Wye,
                Z_TREES: l1,
                Z_OK: tp,
                Z_STREAM_END: Gye,
                Z_NEED_DICT: Kye,
                Z_STREAM_ERROR: Yc,
                Z_DATA_ERROR: lH,
                Z_MEM_ERROR: uH,
                Z_BUF_ERROR: qye,
                Z_DEFLATED: dH
            } = Xf, u1 = 16180, d1 = 16190, ad = 16191, h1 = 16199, f1 = 16200, ws = 16209, RH = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);

            function Qye() {
                this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }
            const np = t => {
                    if (!t) return 1;
                    const n = t.state;
                    return !n || n.strm !== t || n.mode < u1 || n.mode > 16211 ? 1 : 0
                },
                BH = t => {
                    if (np(t)) return Yc;
                    const n = t.state;
                    return t.total_in = t.total_out = n.total = 0, t.msg = "", n.wrap && (t.adler = 1 & n.wrap), n.mode = u1, n.last = 0, n.havedict = 0, n.flags = -1, n.dmax = 32768, n.head = null, n.hold = 0, n.bits = 0, n.lencode = n.lendyn = new Int32Array(852), n.distcode = n.distdyn = new Int32Array(592), n.sane = 1, n.back = -1, tp
                },
                NH = t => {
                    if (np(t)) return Yc;
                    const n = t.state;
                    return n.wsize = 0, n.whave = 0, n.wnext = 0, BH(t)
                },
                FH = (t, n) => {
                    let e;
                    if (np(t)) return Yc;
                    const i = t.state;
                    return n < 0 ? (e = 0, n = -n) : (e = 5 + (n >> 4), n < 48 && (n &= 15)), n && (n < 8 || n > 15) ? Yc : (null !== i.window && i.wbits !== n && (i.window = null), i.wrap = e, i.wbits = n, NH(t))
                },
                VH = (t, n) => {
                    if (!t) return Yc;
                    const e = new Qye;
                    t.state = e, e.strm = t, e.window = null, e.mode = u1;
                    const i = FH(t, n);
                    return i !== tp && (t.state = null), i
                };
            let FM, VM, UH = !0;
            const e0e = t => {
                    if (UH) {
                        FM = new Int32Array(512), VM = new Int32Array(32);
                        let n = 0;
                        for (; n < 144;) t.lens[n++] = 8;
                        for (; n < 256;) t.lens[n++] = 9;
                        for (; n < 280;) t.lens[n++] = 7;
                        for (; n < 288;) t.lens[n++] = 8;
                        for (y_(1, t.lens, 0, 288, FM, 0, t.work, {
                                bits: 9
                            }), n = 0; n < 32;) t.lens[n++] = 5;
                        y_(2, t.lens, 0, 32, VM, 0, t.work, {
                            bits: 5
                        }), UH = !1
                    }
                    t.lencode = FM, t.lenbits = 9, t.distcode = VM, t.distbits = 5
                },
                HH = (t, n, e, i) => {
                    let r;
                    const s = t.state;
                    return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), i >= s.wsize ? (s.window.set(n.subarray(e - s.wsize, e), 0), s.wnext = 0, s.whave = s.wsize) : (r = s.wsize - s.wnext, r > i && (r = i), s.window.set(n.subarray(e - i, e - i + r), s.wnext), (i -= r) ? (s.window.set(n.subarray(e - i, e), 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += r, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += r))), 0
                };
            var cd = {
                    inflateReset: NH,
                    inflateReset2: FH,
                    inflateResetKeep: BH,
                    inflateInit: t => VH(t, 15),
                    inflateInit2: VH,
                    inflate: (t, n) => {
                        let e, i, r, s, o, a, c, u, h, m, x, D, V, te, _e, ye, Be, ze, Xe, ht, vt, jt, ee = 0;
                        const Cn = new Uint8Array(4);
                        let Xt, Rt;
                        const wr = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                        if (np(t) || !t.output || !t.input && 0 !== t.avail_in) return Yc;
                        e = t.state, e.mode === ad && (e.mode = 16192), o = t.next_out, r = t.output, c = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, u = e.hold, h = e.bits, m = a, x = c, jt = tp;
                        e: for (;;) switch (e.mode) {
                            case u1:
                                if (0 === e.wrap) {
                                    e.mode = 16192;
                                    break
                                }
                                for (; h < 16;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if (2 & e.wrap && 35615 === u) {
                                    0 === e.wbits && (e.wbits = 15), e.check = 0, Cn[0] = 255 & u, Cn[1] = u >>> 8 & 255, e.check = Po(e.check, Cn, 2, 0), u = 0, h = 0, e.mode = 16181;
                                    break
                                }
                                if (e.head && (e.head.done = !1), !(1 & e.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) {
                                    t.msg = "incorrect header check", e.mode = ws;
                                    break
                                }
                                if ((15 & u) !== dH) {
                                    t.msg = "unknown compression method", e.mode = ws;
                                    break
                                }
                                if (u >>>= 4, h -= 4, vt = 8 + (15 & u), 0 === e.wbits && (e.wbits = vt), vt > 15 || vt > e.wbits) {
                                    t.msg = "invalid window size", e.mode = ws;
                                    break
                                }
                                e.dmax = 1 << e.wbits, e.flags = 0, t.adler = e.check = 1, e.mode = 512 & u ? 16189 : ad, u = 0, h = 0;
                                break;
                            case 16181:
                                for (; h < 16;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if (e.flags = u, (255 & e.flags) !== dH) {
                                    t.msg = "unknown compression method", e.mode = ws;
                                    break
                                }
                                if (57344 & e.flags) {
                                    t.msg = "unknown header flags set", e.mode = ws;
                                    break
                                }
                                e.head && (e.head.text = u >> 8 & 1), 512 & e.flags && 4 & e.wrap && (Cn[0] = 255 & u, Cn[1] = u >>> 8 & 255, e.check = Po(e.check, Cn, 2, 0)), u = 0, h = 0, e.mode = 16182;
                            case 16182:
                                for (; h < 32;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                e.head && (e.head.time = u), 512 & e.flags && 4 & e.wrap && (Cn[0] = 255 & u, Cn[1] = u >>> 8 & 255, Cn[2] = u >>> 16 & 255, Cn[3] = u >>> 24 & 255, e.check = Po(e.check, Cn, 4, 0)), u = 0, h = 0, e.mode = 16183;
                            case 16183:
                                for (; h < 16;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                e.head && (e.head.xflags = 255 & u, e.head.os = u >> 8), 512 & e.flags && 4 & e.wrap && (Cn[0] = 255 & u, Cn[1] = u >>> 8 & 255, e.check = Po(e.check, Cn, 2, 0)), u = 0, h = 0, e.mode = 16184;
                            case 16184:
                                if (1024 & e.flags) {
                                    for (; h < 16;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    e.length = u, e.head && (e.head.extra_len = u), 512 & e.flags && 4 & e.wrap && (Cn[0] = 255 & u, Cn[1] = u >>> 8 & 255, e.check = Po(e.check, Cn, 2, 0)), u = 0, h = 0
                                } else e.head && (e.head.extra = null);
                                e.mode = 16185;
                            case 16185:
                                if (1024 & e.flags && (D = e.length, D > a && (D = a), D && (e.head && (vt = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)), e.head.extra.set(i.subarray(s, s + D), vt)), 512 & e.flags && 4 & e.wrap && (e.check = Po(e.check, i, D, s)), a -= D, s += D, e.length -= D), e.length)) break e;
                                e.length = 0, e.mode = 16186;
                            case 16186:
                                if (2048 & e.flags) {
                                    if (0 === a) break e;
                                    D = 0;
                                    do {
                                        vt = i[s + D++], e.head && vt && e.length < 65536 && (e.head.name += String.fromCharCode(vt))
                                    } while (vt && D < a);
                                    if (512 & e.flags && 4 & e.wrap && (e.check = Po(e.check, i, D, s)), a -= D, s += D, vt) break e
                                } else e.head && (e.head.name = null);
                                e.length = 0, e.mode = 16187;
                            case 16187:
                                if (4096 & e.flags) {
                                    if (0 === a) break e;
                                    D = 0;
                                    do {
                                        vt = i[s + D++], e.head && vt && e.length < 65536 && (e.head.comment += String.fromCharCode(vt))
                                    } while (vt && D < a);
                                    if (512 & e.flags && 4 & e.wrap && (e.check = Po(e.check, i, D, s)), a -= D, s += D, vt) break e
                                } else e.head && (e.head.comment = null);
                                e.mode = 16188;
                            case 16188:
                                if (512 & e.flags) {
                                    for (; h < 16;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    if (4 & e.wrap && u !== (65535 & e.check)) {
                                        t.msg = "header crc mismatch", e.mode = ws;
                                        break
                                    }
                                    u = 0, h = 0
                                }
                                e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = !0), t.adler = e.check = 0, e.mode = ad;
                                break;
                            case 16189:
                                for (; h < 32;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                t.adler = e.check = RH(u), u = 0, h = 0, e.mode = d1;
                            case d1:
                                if (0 === e.havedict) return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, e.hold = u, e.bits = h, Kye;
                                t.adler = e.check = 1, e.mode = ad;
                            case ad:
                                if (n === Wye || n === l1) break e;
                            case 16192:
                                if (e.last) {
                                    u >>>= 7 & h, h -= 7 & h, e.mode = 16206;
                                    break
                                }
                                for (; h < 3;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                switch (e.last = 1 & u, u >>>= 1, h -= 1, 3 & u) {
                                    case 0:
                                        e.mode = 16193;
                                        break;
                                    case 1:
                                        if (e0e(e), e.mode = h1, n === l1) {
                                            u >>>= 2, h -= 2;
                                            break e
                                        }
                                        break;
                                    case 2:
                                        e.mode = 16196;
                                        break;
                                    case 3:
                                        t.msg = "invalid block type", e.mode = ws
                                }
                                u >>>= 2, h -= 2;
                                break;
                            case 16193:
                                for (u >>>= 7 & h, h -= 7 & h; h < 32;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if ((65535 & u) != (u >>> 16 ^ 65535)) {
                                    t.msg = "invalid stored block lengths", e.mode = ws;
                                    break
                                }
                                if (e.length = 65535 & u, u = 0, h = 0, e.mode = 16194, n === l1) break e;
                            case 16194:
                                e.mode = 16195;
                            case 16195:
                                if (D = e.length, D) {
                                    if (D > a && (D = a), D > c && (D = c), 0 === D) break e;
                                    r.set(i.subarray(s, s + D), o), a -= D, s += D, c -= D, o += D, e.length -= D;
                                    break
                                }
                                e.mode = ad;
                                break;
                            case 16196:
                                for (; h < 14;) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if (e.nlen = 257 + (31 & u), u >>>= 5, h -= 5, e.ndist = 1 + (31 & u), u >>>= 5, h -= 5, e.ncode = 4 + (15 & u), u >>>= 4, h -= 4, e.nlen > 286 || e.ndist > 30) {
                                    t.msg = "too many length or distance symbols", e.mode = ws;
                                    break
                                }
                                e.have = 0, e.mode = 16197;
                            case 16197:
                                for (; e.have < e.ncode;) {
                                    for (; h < 3;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    e.lens[wr[e.have++]] = 7 & u, u >>>= 3, h -= 3
                                }
                                for (; e.have < 19;) e.lens[wr[e.have++]] = 0;
                                if (e.lencode = e.lendyn, e.lenbits = 7, Xt = {
                                        bits: e.lenbits
                                    }, jt = y_(0, e.lens, 0, 19, e.lencode, 0, e.work, Xt), e.lenbits = Xt.bits, jt) {
                                    t.msg = "invalid code lengths set", e.mode = ws;
                                    break
                                }
                                e.have = 0, e.mode = 16198;
                            case 16198:
                                for (; e.have < e.nlen + e.ndist;) {
                                    for (; ee = e.lencode[u & (1 << e.lenbits) - 1], _e = ee >>> 24, ye = ee >>> 16 & 255, Be = 65535 & ee, !(_e <= h);) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    if (Be < 16) u >>>= _e, h -= _e, e.lens[e.have++] = Be;
                                    else {
                                        if (16 === Be) {
                                            for (Rt = _e + 2; h < Rt;) {
                                                if (0 === a) break e;
                                                a--, u += i[s++] << h, h += 8
                                            }
                                            if (u >>>= _e, h -= _e, 0 === e.have) {
                                                t.msg = "invalid bit length repeat", e.mode = ws;
                                                break
                                            }
                                            vt = e.lens[e.have - 1], D = 3 + (3 & u), u >>>= 2, h -= 2
                                        } else if (17 === Be) {
                                            for (Rt = _e + 3; h < Rt;) {
                                                if (0 === a) break e;
                                                a--, u += i[s++] << h, h += 8
                                            }
                                            u >>>= _e, h -= _e, vt = 0, D = 3 + (7 & u), u >>>= 3, h -= 3
                                        } else {
                                            for (Rt = _e + 7; h < Rt;) {
                                                if (0 === a) break e;
                                                a--, u += i[s++] << h, h += 8
                                            }
                                            u >>>= _e, h -= _e, vt = 0, D = 11 + (127 & u), u >>>= 7, h -= 7
                                        }
                                        if (e.have + D > e.nlen + e.ndist) {
                                            t.msg = "invalid bit length repeat", e.mode = ws;
                                            break
                                        }
                                        for (; D--;) e.lens[e.have++] = vt
                                    }
                                }
                                if (e.mode === ws) break;
                                if (0 === e.lens[256]) {
                                    t.msg = "invalid code -- missing end-of-block", e.mode = ws;
                                    break
                                }
                                if (e.lenbits = 9, Xt = {
                                        bits: e.lenbits
                                    }, jt = y_(1, e.lens, 0, e.nlen, e.lencode, 0, e.work, Xt), e.lenbits = Xt.bits, jt) {
                                    t.msg = "invalid literal/lengths set", e.mode = ws;
                                    break
                                }
                                if (e.distbits = 6, e.distcode = e.distdyn, Xt = {
                                        bits: e.distbits
                                    }, jt = y_(2, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, Xt), e.distbits = Xt.bits, jt) {
                                    t.msg = "invalid distances set", e.mode = ws;
                                    break
                                }
                                if (e.mode = h1, n === l1) break e;
                            case h1:
                                e.mode = f1;
                            case f1:
                                if (a >= 6 && c >= 258) {
                                    t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, e.hold = u, e.bits = h, Vye(t, x), o = t.next_out, r = t.output, c = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, u = e.hold, h = e.bits, e.mode === ad && (e.back = -1);
                                    break
                                }
                                for (e.back = 0; ee = e.lencode[u & (1 << e.lenbits) - 1], _e = ee >>> 24, ye = ee >>> 16 & 255, Be = 65535 & ee, !(_e <= h);) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if (ye && !(240 & ye)) {
                                    for (ze = _e, Xe = ye, ht = Be; ee = e.lencode[ht + ((u & (1 << ze + Xe) - 1) >> ze)], _e = ee >>> 24, ye = ee >>> 16 & 255, Be = 65535 & ee, !(ze + _e <= h);) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    u >>>= ze, h -= ze, e.back += ze
                                }
                                if (u >>>= _e, h -= _e, e.back += _e, e.length = Be, 0 === ye) {
                                    e.mode = 16205;
                                    break
                                }
                                if (32 & ye) {
                                    e.back = -1, e.mode = ad;
                                    break
                                }
                                if (64 & ye) {
                                    t.msg = "invalid literal/length code", e.mode = ws;
                                    break
                                }
                                e.extra = 15 & ye, e.mode = 16201;
                            case 16201:
                                if (e.extra) {
                                    for (Rt = e.extra; h < Rt;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    e.length += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra
                                }
                                e.was = e.length, e.mode = 16202;
                            case 16202:
                                for (; ee = e.distcode[u & (1 << e.distbits) - 1], _e = ee >>> 24, ye = ee >>> 16 & 255, Be = 65535 & ee, !(_e <= h);) {
                                    if (0 === a) break e;
                                    a--, u += i[s++] << h, h += 8
                                }
                                if (!(240 & ye)) {
                                    for (ze = _e, Xe = ye, ht = Be; ee = e.distcode[ht + ((u & (1 << ze + Xe) - 1) >> ze)], _e = ee >>> 24, ye = ee >>> 16 & 255, Be = 65535 & ee, !(ze + _e <= h);) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    u >>>= ze, h -= ze, e.back += ze
                                }
                                if (u >>>= _e, h -= _e, e.back += _e, 64 & ye) {
                                    t.msg = "invalid distance code", e.mode = ws;
                                    break
                                }
                                e.offset = Be, e.extra = 15 & ye, e.mode = 16203;
                            case 16203:
                                if (e.extra) {
                                    for (Rt = e.extra; h < Rt;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    e.offset += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra
                                }
                                if (e.offset > e.dmax) {
                                    t.msg = "invalid distance too far back", e.mode = ws;
                                    break
                                }
                                e.mode = 16204;
                            case 16204:
                                if (0 === c) break e;
                                if (D = x - c, e.offset > D) {
                                    if (D = e.offset - D, D > e.whave && e.sane) {
                                        t.msg = "invalid distance too far back", e.mode = ws;
                                        break
                                    }
                                    D > e.wnext ? (D -= e.wnext, V = e.wsize - D) : V = e.wnext - D, D > e.length && (D = e.length), te = e.window
                                } else te = r, V = o - e.offset, D = e.length;
                                D > c && (D = c), c -= D, e.length -= D;
                                do {
                                    r[o++] = te[V++]
                                } while (--D);
                                0 === e.length && (e.mode = f1);
                                break;
                            case 16205:
                                if (0 === c) break e;
                                r[o++] = e.length, c--, e.mode = f1;
                                break;
                            case 16206:
                                if (e.wrap) {
                                    for (; h < 32;) {
                                        if (0 === a) break e;
                                        a--, u |= i[s++] << h, h += 8
                                    }
                                    if (x -= c, t.total_out += x, e.total += x, 4 & e.wrap && x && (t.adler = e.check = e.flags ? Po(e.check, r, x, o - x) : c_(e.check, r, x, o - x)), x = c, 4 & e.wrap && (e.flags ? u : RH(u)) !== e.check) {
                                        t.msg = "incorrect data check", e.mode = ws;
                                        break
                                    }
                                    u = 0, h = 0
                                }
                                e.mode = 16207;
                            case 16207:
                                if (e.wrap && e.flags) {
                                    for (; h < 32;) {
                                        if (0 === a) break e;
                                        a--, u += i[s++] << h, h += 8
                                    }
                                    if (4 & e.wrap && u !== (4294967295 & e.total)) {
                                        t.msg = "incorrect length check", e.mode = ws;
                                        break
                                    }
                                    u = 0, h = 0
                                }
                                e.mode = 16208;
                            case 16208:
                                jt = Gye;
                                break e;
                            case ws:
                                jt = lH;
                                break e;
                            case 16210:
                                return uH;
                            default:
                                return Yc
                        }
                        return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, e.hold = u, e.bits = h, (e.wsize || x !== t.avail_out && e.mode < ws && (e.mode < 16206 || n !== cH)) && HH(t, t.output, t.next_out, x - t.avail_out), m -= t.avail_in, x -= t.avail_out, t.total_in += m, t.total_out += x, e.total += x, 4 & e.wrap && x && (t.adler = e.check = e.flags ? Po(e.check, r, x, t.next_out - x) : c_(e.check, r, x, t.next_out - x)), t.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === ad ? 128 : 0) + (e.mode === h1 || 16194 === e.mode ? 256 : 0), (0 === m && 0 === x || n === cH) && jt === tp && (jt = qye), jt
                    },
                    inflateEnd: t => {
                        if (np(t)) return Yc;
                        let n = t.state;
                        return n.window && (n.window = null), t.state = null, tp
                    },
                    inflateGetHeader: (t, n) => {
                        if (np(t)) return Yc;
                        const e = t.state;
                        return 2 & e.wrap ? (e.head = n, n.done = !1, tp) : Yc
                    },
                    inflateSetDictionary: (t, n) => {
                        const e = n.length;
                        let i, r, s;
                        return np(t) || (i = t.state, 0 !== i.wrap && i.mode !== d1) ? Yc : i.mode === d1 && (r = 1, r = c_(r, n, e, 0), r !== i.check) ? lH : (s = HH(t, n, e, e), s ? (i.mode = 16210, uH) : (i.havedict = 1, tp))
                    },
                    inflateInfo: "pako inflate (from Nodeca project)"
                },
                g0e = function m0e() {
                    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
                };
            const $H = Object.prototype.toString,
                {
                    Z_NO_FLUSH: y0e,
                    Z_FINISH: _0e,
                    Z_OK: __,
                    Z_STREAM_END: UM,
                    Z_NEED_DICT: HM,
                    Z_STREAM_ERROR: v0e,
                    Z_DATA_ERROR: zH,
                    Z_MEM_ERROR: b0e
                } = Xf;

            function v_(t) {
                this.options = o1.assign({
                    chunkSize: 65536,
                    windowBits: 15,
                    to: ""
                }, t || {});
                const n = this.options;
                n.raw && n.windowBits >= 0 && n.windowBits < 16 && (n.windowBits = -n.windowBits, 0 === n.windowBits && (n.windowBits = -15)), n.windowBits >= 0 && n.windowBits < 16 && !(t && t.windowBits) && (n.windowBits += 32), n.windowBits > 15 && n.windowBits < 48 && (15 & n.windowBits || (n.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new eH, this.strm.avail_out = 0;
                let e = cd.inflateInit2(this.strm, n.windowBits);
                if (e !== __) throw new Error(Yf[e]);
                if (this.header = new g0e, cd.inflateGetHeader(this.strm, this.header), n.dictionary && ("string" == typeof n.dictionary ? n.dictionary = m_.string2buf(n.dictionary) : "[object ArrayBuffer]" === $H.call(n.dictionary) && (n.dictionary = new Uint8Array(n.dictionary)), n.raw && (e = cd.inflateSetDictionary(this.strm, n.dictionary), e !== __))) throw new Error(Yf[e])
            }

            function $M(t, n) {
                const e = new v_(n);
                if (e.push(t), e.err) throw e.msg || Yf[e.err];
                return e.result
            }
            v_.prototype.push = function(t, n) {
                const e = this.strm,
                    i = this.options.chunkSize,
                    r = this.options.dictionary;
                let s, o, a;
                if (this.ended) return !1;
                for (o = n === ~~n ? n : !0 === n ? _0e : y0e, e.input = "[object ArrayBuffer]" === $H.call(t) ? new Uint8Array(t) : t, e.next_in = 0, e.avail_in = e.input.length;;) {
                    for (0 === e.avail_out && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), s = cd.inflate(e, o), s === HM && r && (s = cd.inflateSetDictionary(e, r), s === __ ? s = cd.inflate(e, o) : s === zH && (s = HM)); e.avail_in > 0 && s === UM && e.state.wrap > 0 && 0 !== t[e.next_in];) cd.inflateReset(e), s = cd.inflate(e, o);
                    switch (s) {
                        case v0e:
                        case zH:
                        case HM:
                        case b0e:
                            return this.onEnd(s), this.ended = !0, !1
                    }
                    if (a = e.avail_out, e.next_out && (0 === e.avail_out || s === UM))
                        if ("string" === this.options.to) {
                            let c = m_.utf8border(e.output, e.next_out),
                                u = e.next_out - c,
                                h = m_.buf2string(e.output, c);
                            e.next_out = u, e.avail_out = i - u, u && e.output.set(e.output.subarray(c, c + u), 0), this.onData(h)
                        } else this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out));
                    if (s !== __ || 0 !== a) {
                        if (s === UM) return s = cd.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
                        if (0 === e.avail_in) break
                    }
                }
                return !0
            }, v_.prototype.onData = function(t) {
                this.chunks.push(t)
            }, v_.prototype.onEnd = function(t) {
                t === __ && (this.result = "string" === this.options.to ? this.chunks.join("") : o1.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            };
            var D0e = {
                Inflate: v_,
                inflate: $M,
                inflateRaw: function w0e(t, n) {
                    return (n = n || {}).raw = !0, $M(t, n)
                },
                ungzip: $M,
                constants: Xf
            };
            const {
                inflate: O0e
            } = D0e;
            var jH = O0e;
            const b_ = t => "version" in t;

            function zM(t) {
                return og().encode(t)
            }

            function jM(t) {
                return t.toString("base64")
            }

            function WM(t) {
                return Aa.Buffer.from(t, "base64")
            }

            function e_e(t, ...n) {
                if (t.args.length != n.length) throw new Error("Invalid argument length");
                const e = {};
                let i = 0;
                return t.args.forEach(r => {
                    e[r.name] = n[i], i += 1
                }), e
            }

            function KH(t, n = {}) {
                t.forEach(e => {
                    if ("accounts" in e) KH(e.accounts, n[e.name]);
                    else if (void 0 === n[e.name]) throw new Error(`Invalid arguments: ${e.name} not provided.`)
                })
            }

            function Ec(t) {
                return t instanceof Mr.PublicKey ? t : new Mr.PublicKey(t)
            }
            class t_e extends TypeError {
                constructor(n, e) {
                    let i;
                    const {
                        message: r,
                        ...s
                    } = n, {
                        path: o
                    } = n;
                    super(0 === o.length ? r : "At path: " + o.join(".") + " -- " + r), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, s), this.name = this.constructor.name, this.failures = () => {
                        var c;
                        return null != (c = i) ? c : i = [n, ...e()]
                    }
                }
            }

            function mg(t) {
                return "object" == typeof t && null != t
            }

            function Th(t) {
                return "string" == typeof t ? JSON.stringify(t) : "" + t
            }

            function r_e(t, n, e, i) {
                if (!0 === t) return;
                !1 === t ? t = {} : "string" == typeof t && (t = {
                    message: t
                });
                const {
                    path: r,
                    branch: s
                } = n, {
                    type: o
                } = e, {
                    refinement: a,
                    message: c = "Expected a value of type `" + o + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + Th(i) + "`"
                } = t;
                return {
                    value: i,
                    type: o,
                    refinement: a,
                    key: r[r.length - 1],
                    path: r,
                    branch: s,
                    ...t,
                    message: c
                }
            }

            function* qH(t, n, e, i) {
                (function n_e(t) {
                    return mg(t) && "function" == typeof t[Symbol.iterator]
                })(t) || (t = [t]);
                for (const r of t) {
                    const s = r_e(r, n, e, i);
                    s && (yield s)
                }
            }

            function* GM(t, n, e) {
                void 0 === e && (e = {});
                const {
                    path: i = [],
                    branch: r = [t],
                    coerce: s = !1,
                    mask: o = !1
                } = e, a = {
                    path: i,
                    branch: r
                };
                if (s && (t = n.coercer(t, a), o && "type" !== n.type && mg(n.schema) && mg(t) && !Array.isArray(t)))
                    for (const u in t) void 0 === n.schema[u] && delete t[u];
                let c = !0;
                for (const u of n.validator(t, a)) c = !1, yield [u, void 0];
                for (let [u, h, m] of n.entries(t, a)) {
                    const x = GM(h, m, {
                        path: void 0 === u ? i : [...i, u],
                        branch: void 0 === u ? r : [...r, h],
                        coerce: s,
                        mask: o
                    });
                    for (const D of x) D[0] ? (c = !1, yield [D[0], void 0]) : s && (h = D[1], void 0 === u ? t = h : t instanceof Map ? t.set(u, h) : t instanceof Set ? t.add(h) : mg(t) && (t[u] = h))
                }
                if (c)
                    for (const u of n.refiner(t, a)) c = !1, yield [u, void 0];
                c && (yield [void 0, t])
            }
            class Sh {
                constructor(n) {
                    this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
                    const {
                        type: e,
                        schema: i,
                        validator: r,
                        refiner: s,
                        coercer: o = (c => c),
                        entries: a = function*() {}
                    } = n;
                    this.type = e, this.schema = i, this.entries = a, this.coercer = o, this.validator = r ? (c, u) => qH(r(c, u), u, this, c) : () => [], this.refiner = s ? (c, u) => qH(s(c, u), u, this, c) : () => []
                }
                assert(n) {
                    return function s_e(t, n) {
                        const e = w_(t, n);
                        if (e[0]) throw e[0]
                    }(n, this)
                }
                create(n) {
                    return KM(n, this)
                }
                is(n) {
                    return ZH(n, this)
                }
                mask(n) {
                    return function o_e(t, n) {
                        const e = w_(t, n, {
                            coerce: !0,
                            mask: !0
                        });
                        if (e[0]) throw e[0];
                        return e[1]
                    }(n, this)
                }
                validate(n, e) {
                    return void 0 === e && (e = {}), w_(n, this, e)
                }
            }

            function KM(t, n) {
                const e = w_(t, n, {
                    coerce: !0
                });
                if (e[0]) throw e[0];
                return e[1]
            }

            function ZH(t, n) {
                return !w_(t, n)[0]
            }

            function w_(t, n, e) {
                void 0 === e && (e = {});
                const i = GM(t, n, e),
                    r = function i_e(t) {
                        const {
                            done: n,
                            value: e
                        } = t.next();
                        return n ? void 0 : e
                    }(i);
                return r[0] ? [new t_e(r[0], function*() {
                    for (const o of i) o[0] && (yield o[0])
                }), void 0] : [void 0, r[1]]
            }

            function x_(t, n) {
                return new Sh({
                    type: t,
                    schema: null,
                    validator: n
                })
            }

            function qM(t) {
                return new Sh({
                    type: "array",
                    schema: t,
                    * entries(n) {
                        if (t && Array.isArray(n))
                            for (const [e, i] of n.entries()) yield [e, i, t]
                    },
                    coercer: n => Array.isArray(n) ? n.slice() : n,
                    validator: n => Array.isArray(n) || "Expected an array value, but received: " + Th(n)
                })
            }

            function YH(t) {
                const n = Th(t),
                    e = typeof t;
                return new Sh({
                    type: "literal",
                    schema: "string" === e || "number" === e || "boolean" === e ? t : null,
                    validator: i => i === t || "Expected the literal `" + n + "`, but received: " + Th(i)
                })
            }

            function p1(t) {
                return new Sh({ ...t,
                    validator: (n, e) => null === n || t.validator(n, e),
                    refiner: (n, e) => null === n || t.refiner(n, e)
                })
            }

            function m1() {
                return x_("number", t => "number" == typeof t && !isNaN(t) || "Expected a number, but received: " + Th(t))
            }

            function g1(t) {
                return new Sh({ ...t,
                    validator: (n, e) => void 0 === n || t.validator(n, e),
                    refiner: (n, e) => void 0 === n || t.refiner(n, e)
                })
            }

            function ip() {
                return x_("string", t => "string" == typeof t || "Expected a string, but received: " + Th(t))
            }

            function Eh(t) {
                const n = Object.keys(t);
                return new Sh({
                    type: "type",
                    schema: t,
                    * entries(e) {
                        if (mg(e))
                            for (const i of n) yield [i, e[i], t[i]]
                    },
                    validator: e => mg(e) || "Expected an object, but received: " + Th(e)
                })
            }

            function XH(t) {
                const n = t.map(e => e.type).join(" | ");
                return new Sh({
                    type: "union",
                    schema: null,
                    coercer: (e, i) => (t.find(s => {
                        const [o] = s.validate(e, {
                            coerce: !0
                        });
                        return !o
                    }) || ZM()).coercer(e, i),
                    validator(e, i) {
                        const r = [];
                        for (const s of t) {
                            const [...o] = GM(e, s, i), [a] = o;
                            if (!a[0]) return [];
                            for (const [c] of o) c && r.push(c)
                        }
                        return ["Expected the value to satisfy a union of `" + n + "`, but received: " + Th(e), ...r]
                    }
                })
            }

            function ZM() {
                return x_("unknown", () => !0)
            }
            const QH = 99;

            function QM(t, n, e) {
                return JM.apply(this, arguments)
            }

            function JM() {
                return (JM = (0, Ze.Z)(function*(t, n, e) {
                    if (n.length <= QH) return yield JH(t, n, e); {
                        const i = function j0e(t, n) {
                            return Array.apply(0, new Array(Math.ceil(t.length / n))).map((e, i) => t.slice(i * n, (i + 1) * n))
                        }(n, QH);
                        return (yield Promise.all(i.map(s => JH(t, s, e)))).flat()
                    }
                })).apply(this, arguments)
            }

            function JH(t, n, e) {
                return eI.apply(this, arguments)
            }

            function eI() {
                return (eI = (0, Ze.Z)(function*(t, n, e) {
                    const i = e ? ? t.commitment,
                        {
                            value: r,
                            context: s
                        } = yield t.getMultipleAccountsInfoAndContext(n, i);
                    return r.map((a, c) => null === a ? null : {
                        publicKey: n[c],
                        account: a,
                        context: s
                    })
                })).apply(this, arguments)
            }

            function e7(t, n, e, i, r) {
                return tI.apply(this, arguments)
            }

            function tI() {
                return (tI = (0, Ze.Z)(function*(t, n, e, i, r) {
                    var s;
                    e && e.length > 0 && n.sign(...e);
                    const o = n._compile(),
                        a = o.serialize(),
                        u = n._serialize(a).toString("base64"),
                        h = {
                            encoding: "base64",
                            commitment: i ? ? t.commitment
                        };
                    if (r) {
                        const V = (Array.isArray(r) ? r : o.nonProgramIds()).map(te => te.toBase58());
                        h.accounts = {
                            encoding: "base64",
                            addresses: V
                        }
                    }
                    e && (h.sigVerify = !0);
                    const m = [u, h],
                        D = KM(yield t._rpcRequest("simulateTransaction", m), m_e);
                    if ("error" in D) {
                        let V;
                        if ("data" in D.error && (V = null === (s = D.error.data) || void 0 === s ? void 0 : s.logs, V && Array.isArray(V))) {
                            const te = "\n    ",
                                ee = te + V.join(te);
                            console.error(D.error.message, ee)
                        }
                        throw new Mr.SendTransactionError("failed to simulate transaction: " + D.error.message, V)
                    }
                    return D.result
                })).apply(this, arguments)
            }
            const f_e = t7(ZM());

            function t7(t) {
                return XH([Eh({
                    jsonrpc: YH("2.0"),
                    id: ip(),
                    result: t
                }), Eh({
                    jsonrpc: YH("2.0"),
                    id: ip(),
                    error: Eh({
                        code: ZM(),
                        message: ip(),
                        data: g1(x_("any", () => !0))
                    })
                })])
            }
            const m_e = function p_e(t) {
                return function h_e(t) {
                    return function l_e(t, n, e) {
                        return new Sh({ ...t,
                            coercer: (i, r) => ZH(i, n) ? t.coercer(e(i, r), r) : t.coercer(i, r)
                        })
                    }(t7(t), f_e, n => "error" in n ? n : { ...n,
                        result: KM(n.result, t)
                    })
                }(Eh({
                    context: Eh({
                        slot: m1()
                    }),
                    value: t
                }))
            }(Eh({
                err: p1(XH([Eh({}), ip()])),
                logs: p1(qM(ip())),
                accounts: g1(p1(qM(p1(Eh({
                    executable: function c_e() {
                        return x_("boolean", t => "boolean" == typeof t)
                    }(),
                    owner: ip(),
                    lamports: m1(),
                    data: qM(ip()),
                    rentEpoch: g1(m1())
                }))))),
                unitsConsumed: g1(m1())
            }));
            class n7 {
                constructor(n, e, i) {
                    this.connection = n, this.wallet = e, this.opts = i, this.publicKey = e ? .publicKey
                }
                static defaultOptions() {
                    return {
                        preflightCommitment: "processed",
                        commitment: "processed"
                    }
                }
                static local(n, e) {
                    throw new Error("Provider local is not available on browser.")
                }
                static env() {
                    throw new Error("Provider env is not available on browser.")
                }
                sendAndConfirm(n, e, i) {
                    var r = this;
                    return (0, Ze.Z)(function*() {
                        var s, o, a, c;
                        if (void 0 === i && (i = r.opts), b_(n)) e && n.sign(e);
                        else if (n.feePayer = null !== (s = n.feePayer) && void 0 !== s ? s : r.wallet.publicKey, n.recentBlockhash = (yield r.connection.getLatestBlockhash(i.preflightCommitment)).blockhash, e)
                            for (const h of e) n.partialSign(h);
                        const u = (n = yield r.wallet.signTransaction(n)).serialize();
                        try {
                            return yield i7(r.connection, u, i)
                        } catch (h) {
                            if (h instanceof iI) {
                                const m = zM(b_(n) ? (null === (o = n.signatures) || void 0 === o ? void 0 : o[0]) || new Uint8Array : null !== (a = n.signature) && void 0 !== a ? a : new Uint8Array),
                                    x = yield r.connection.getTransaction(m, {
                                        commitment: "confirmed"
                                    });
                                if (x) {
                                    const D = null === (c = x.meta) || void 0 === c ? void 0 : c.logMessages;
                                    throw D ? new Mr.SendTransactionError(h.message, D) : h
                                }
                                throw h
                            }
                            throw h
                        }
                    })()
                }
                sendAll(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        var r, s, o;
                        void 0 === e && (e = i.opts);
                        const a = (yield i.connection.getLatestBlockhash(e.preflightCommitment)).blockhash;
                        let c = n.map(m => {
                            var x, D;
                            if (b_(m.tx)) {
                                let V = m.tx;
                                return m.signers && V.sign(m.signers), V
                            } {
                                let V = m.tx,
                                    te = null !== (x = m.signers) && void 0 !== x ? x : [];
                                return V.feePayer = null !== (D = V.feePayer) && void 0 !== D ? D : i.wallet.publicKey, V.recentBlockhash = a, te.forEach(ee => {
                                    V.partialSign(ee)
                                }), V
                            }
                        });
                        const u = yield i.wallet.signAllTransactions(c), h = [];
                        for (let m = 0; m < c.length; m += 1) {
                            const x = u[m],
                                D = x.serialize();
                            try {
                                h.push(yield i7(i.connection, D, e))
                            } catch (V) {
                                if (V instanceof iI) {
                                    const te = zM(b_(x) ? (null === (r = x.signatures) || void 0 === r ? void 0 : r[0]) || new Uint8Array : null !== (s = x.signature) && void 0 !== s ? s : new Uint8Array),
                                        ee = yield i.connection.getTransaction(te, {
                                            commitment: "confirmed"
                                        });
                                    if (ee) {
                                        const _e = null === (o = ee.meta) || void 0 === o ? void 0 : o.logMessages;
                                        throw _e ? new Mr.SendTransactionError(V.message, _e) : V
                                    }
                                    throw V
                                }
                                throw V
                            }
                        }
                        return h
                    })()
                }
                simulate(n, e, i, r) {
                    var s = this;
                    return (0, Ze.Z)(function*() {
                        let a, o = (yield s.connection.getLatestBlockhash(i ? ? s.connection.commitment)).blockhash;
                        if (b_(n) ? (e && (n.sign(e), n = yield s.wallet.signTransaction(n)), a = yield s.connection.simulateTransaction(n, {
                                commitment: i
                            })) : (n.feePayer = n.feePayer || s.wallet.publicKey, n.recentBlockhash = o, e && (n = yield s.wallet.signTransaction(n)), a = yield e7(s.connection, n, e, i, r)), a.value.err) throw new y_e(a.value);
                        return a.value
                    })()
                }
            }
            class y_e extends Error {
                constructor(n, e) {
                    super(e), this.simulationResponse = n
                }
            }

            function i7(t, n, e) {
                return nI.apply(this, arguments)
            }

            function nI() {
                return (nI = (0, Ze.Z)(function*(t, n, e) {
                    const i = e && {
                            skipPreflight: e.skipPreflight,
                            preflightCommitment: e.preflightCommitment || e.commitment
                        },
                        r = yield t.sendRawTransaction(n, i), s = (yield t.confirmTransaction(r, e && e.commitment)).value;
                    if (s.err) throw new iI(`Raw transaction ${r} failed (${JSON.stringify(s)})`);
                    return r
                })).apply(this, arguments)
            }
            class iI extends Error {
                constructor(n) {
                    super(n)
                }
            }

            function y1() {
                return null === rI ? n7.local() : rI
            }
            let rI = null;
            const r7 = new Map;

            function sI(t) {
                return void 0 !== r7.get(t)
            }
            class _1 extends Error {
                constructor(n) {
                    super(n), this.name = "IdlError"
                }
            }
            class C_ {
                constructor(n) {
                    this.stack = n
                }
                static parse(n) {
                    var e;
                    const i = /^Program (\w*) invoke/,
                        r = /^Program \w* success/,
                        s = [];
                    for (let o = 0; o < n.length; o++) {
                        if (r.exec(n[o])) {
                            s.pop();
                            continue
                        }
                        const a = null === (e = i.exec(n[o])) || void 0 === e ? void 0 : e[1];
                        a && s.push(new Mr.PublicKey(a))
                    }
                    return new C_(s)
                }
            }
            class T_ extends Error {
                constructor(n, e, i, r, s, o) {
                    super(i.join("\n").replace("Program log: ", "")), this.errorLogs = i, this.logs = r, this.error = {
                        errorCode: n,
                        errorMessage: e,
                        comparedValues: o,
                        origin: s
                    }, this._programErrorStack = C_.parse(r)
                }
                static parse(n) {
                    if (!n) return null;
                    const e = n.findIndex(x => x.startsWith("Program log: AnchorError"));
                    if (-1 === e) return null;
                    const i = n[e],
                        r = [i];
                    let s;
                    if (e + 1 < n.length)
                        if ("Program log: Left:" === n[e + 1]) {
                            const x = /^Program log: (.*)$/,
                                D = x.exec(n[e + 2])[1],
                                V = x.exec(n[e + 4])[1];
                            s = [new Mr.PublicKey(D), new Mr.PublicKey(V)], r.push(...n.slice(e + 1, e + 5))
                        } else if (n[e + 1].startsWith("Program log: Left:")) {
                        const x = /^Program log: (Left|Right): (.*)$/,
                            D = x.exec(n[e + 1])[2],
                            V = x.exec(n[e + 2])[2];
                        r.push(...n.slice(e + 1, e + 3)), s = [D, V]
                    }
                    const a = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(i),
                        u = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(i),
                        m = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(i);
                    if (a) {
                        const [x, D, V] = a.slice(1, 4), te = {
                            code: x,
                            number: parseInt(D)
                        };
                        return new T_(te, V, r, n, void 0, s)
                    }
                    if (u) {
                        const [x, D, V, te, ee] = u.slice(1, 6), _e = {
                            code: V,
                            number: parseInt(te)
                        }, ye = {
                            file: x,
                            line: parseInt(D)
                        };
                        return new T_(_e, ee, r, n, ye, s)
                    }
                    if (m) {
                        const [x, D, V, te] = m.slice(1, 5), ee = x, _e = {
                            code: D,
                            number: parseInt(V)
                        };
                        return new T_(_e, te, r, n, ee, s)
                    }
                    return null
                }
                get program() {
                    return this._programErrorStack.stack[this._programErrorStack.stack.length - 1]
                }
                get programErrorStack() {
                    return this._programErrorStack.stack
                }
                toString() {
                    return this.message
                }
            }
            class v1 extends Error {
                constructor(n, e, i) {
                    super(), this.code = n, this.msg = e, this.logs = i, i && (this._programErrorStack = C_.parse(i))
                }
                static parse(n, e) {
                    const i = n.toString();
                    let r, s;
                    if (i.includes("custom program error:")) {
                        let a = i.split("custom program error: ");
                        if (2 !== a.length) return null;
                        r = a[1]
                    } else {
                        const a = i.match(/"Custom":([0-9]+)}/g);
                        if (!a || a.length > 1) return null;
                        r = a[0].match(/([0-9]+)/g)[0]
                    }
                    try {
                        s = parseInt(r)
                    } catch {
                        return null
                    }
                    let o = e.get(s);
                    return void 0 !== o ? new v1(s, o, n.logs) : (o = w_e.get(s), void 0 !== o ? new v1(s, o, n.logs) : null)
                }
                get program() {
                    var n;
                    return null === (n = this._programErrorStack) || void 0 === n ? void 0 : n.stack[this._programErrorStack.stack.length - 1]
                }
                get programErrorStack() {
                    var n;
                    return null === (n = this._programErrorStack) || void 0 === n ? void 0 : n.stack
                }
                toString() {
                    return this.msg
                }
            }

            function s7(t, n) {
                sI("debug-logs") && console.log("Translating error:", t);
                const e = T_.parse(t.logs);
                if (e) return e;
                const i = v1.parse(t, n);
                if (i) return i;
                if (t.logs) {
                    const r = {
                        get: function(s, o) {
                            return "programErrorStack" === o ? s.programErrorStack.stack : "program" === o ? s.programErrorStack.stack[t.programErrorStack.stack.length - 1] : Reflect.get(...arguments)
                        }
                    };
                    return t.programErrorStack = C_.parse(t.logs), new Proxy(t, r)
                }
                return t
            }
            const w_e = new Map([
                [100, "8 byte instruction identifier not provided"],
                [101, "Fallback functions are not supported"],
                [102, "The program could not deserialize the given instruction"],
                [103, "The program could not serialize the given instruction"],
                [1e3, "The program was compiled without idl instructions"],
                [1001, "The transaction was given an invalid program for the IDL instruction"],
                [2e3, "A mut constraint was violated"],
                [2001, "A has one constraint was violated"],
                [2002, "A signer constraint was violated"],
                [2003, "A raw constraint was violated"],
                [2004, "An owner constraint was violated"],
                [2005, "A rent exemption constraint was violated"],
                [2006, "A seeds constraint was violated"],
                [2007, "An executable constraint was violated"],
                [2008, "Deprecated Error, feel free to replace with something else"],
                [2009, "An associated constraint was violated"],
                [2010, "An associated init constraint was violated"],
                [2011, "A close constraint was violated"],
                [2012, "An address constraint was violated"],
                [2013, "Expected zero account discriminant"],
                [2014, "A token mint constraint was violated"],
                [2015, "A token owner constraint was violated"],
                [2016, "A mint mint authority constraint was violated"],
                [2017, "A mint freeze authority constraint was violated"],
                [2018, "A mint decimals constraint was violated"],
                [2019, "A space constraint was violated"],
                [2020, "A required account for the constraint is None"],
                [2500, "A require expression was violated"],
                [2501, "A require_eq expression was violated"],
                [2502, "A require_keys_eq expression was violated"],
                [2503, "A require_neq expression was violated"],
                [2504, "A require_keys_neq expression was violated"],
                [2505, "A require_gt expression was violated"],
                [2506, "A require_gte expression was violated"],
                [3e3, "The account discriminator was already set on this account"],
                [3001, "No 8 byte discriminator was found on the account"],
                [3002, "8 byte discriminator did not match what was expected"],
                [3003, "Failed to deserialize the account"],
                [3004, "Failed to serialize the account"],
                [3005, "Not enough account keys given to the instruction"],
                [3006, "The given account is not mutable"],
                [3007, "The given account is owned by a different program than expected"],
                [3008, "Program ID was not as expected"],
                [3009, "Program account is not executable"],
                [3010, "The given account did not sign"],
                [3011, "The given account is not owned by the system program"],
                [3012, "The program expected this account to be already initialized"],
                [3013, "The given account is not a program data account"],
                [3014, "The given account is not the associated token account"],
                [3015, "The given public key does not match the required sysvar"],
                [3016, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],
                [3017, "The account was duplicated for more than one reallocation"],
                [4100, "The declared program id does not match the actual program id"],
                [5e3, "The API being used is deprecated and should no longer be used"]
            ]);
            var oI = function() {
                    return oI = Object.assign || function(n) {
                        for (var e, i = 1, r = arguments.length; i < r; i++)
                            for (var s in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
                        return n
                    }, oI.apply(this, arguments)
                },
                aI = function() {
                    return aI = Object.assign || function(n) {
                        for (var e, i = 1, r = arguments.length; i < r; i++)
                            for (var s in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
                        return n
                    }, aI.apply(this, arguments)
                };

            function x_e(t) {
                return t.toLowerCase()
            }
            var C_e = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g],
                T_e = /[^A-Z0-9]+/gi;

            function o7(t, n, e) {
                return n instanceof RegExp ? t.replace(n, e) : n.reduce(function(i, r) {
                    return i.replace(r, e)
                }, t)
            }
            class Qa {
                static fieldLayout(n, e) {
                    const i = void 0 !== n.name ? bs()(n.name) : void 0;
                    switch (n.type) {
                        case "bool":
                            return zi.bool(i);
                        case "u8":
                            return zi.u8(i);
                        case "i8":
                            return zi.i8(i);
                        case "u16":
                            return zi.u16(i);
                        case "i16":
                            return zi.i16(i);
                        case "u32":
                            return zi.u32(i);
                        case "i32":
                            return zi.i32(i);
                        case "f32":
                            return zi.f32(i);
                        case "u64":
                            return zi.u64(i);
                        case "i64":
                            return zi.i64(i);
                        case "f64":
                            return zi.f64(i);
                        case "u128":
                            return zi.u128(i);
                        case "i128":
                            return zi.i128(i);
                        case "u256":
                            return zi.u256(i);
                        case "i256":
                            return zi.i256(i);
                        case "bytes":
                            return zi.vecU8(i);
                        case "string":
                            return zi.str(i);
                        case "publicKey":
                            return zi.publicKey(i);
                        default:
                            if ("vec" in n.type) return zi.vec(Qa.fieldLayout({
                                name: void 0,
                                type: n.type.vec
                            }, e), i);
                            if ("option" in n.type) return zi.option(Qa.fieldLayout({
                                name: void 0,
                                type: n.type.option
                            }, e), i);
                            if ("defined" in n.type) {
                                if (!e) throw new _1("User defined types not provided");
                                const r = n.type.defined,
                                    s = e.filter(o => o.name === r);
                                if (1 !== s.length) throw new _1(`Type not found: ${JSON.stringify(n)}`);
                                return Qa.typeDefLayout(s[0], e, i)
                            }
                            if ("array" in n.type) {
                                let s = n.type.array[1],
                                    o = Qa.fieldLayout({
                                        name: void 0,
                                        type: n.type.array[0]
                                    }, e);
                                return zi.array(o, s, i)
                            }
                            throw new Error(`Not yet implemented: ${n}`)
                    }
                }
                static typeDefLayout(n, e = [], i) {
                    switch (n.type.kind) {
                        case "struct":
                            {
                                const r = n.type.fields.map(s => Qa.fieldLayout(s, e));
                                return zi.struct(r, i)
                            }
                        case "enum":
                            {
                                let r = n.type.variants.map(s => {
                                    const o = bs()(s.name);
                                    if (!s.fields) return zi.struct([], o);
                                    const a = s.fields.map((c, u) => Qa.fieldLayout(c ? .name ? c : {
                                        type: c,
                                        name: u.toString()
                                    }, e));
                                    return zi.struct(a, o)
                                });
                                return void 0 !== i ? zi.rustEnum(r).replicate(i) : zi.rustEnum(r, i)
                            }
                        case "alias":
                            return Qa.fieldLayout({
                                type: n.type.value,
                                name: n.name
                            }, e)
                    }
                }
            }
            class cI {
                constructor(n) {
                    this.idl = n, this.ixLayout = cI.parseIxLayout(n);
                    const e = new Map;
                    n.instructions.forEach(i => {
                        const r = c7("global", i.name);
                        e.set(og().encode(r), {
                            layout: this.ixLayout.get(i.name),
                            name: i.name
                        })
                    }), this.sighashLayouts = e
                }
                encode(n, e) {
                    return this._encode("global", n, e)
                }
                _encode(n, e, i) {
                    const r = Aa.Buffer.alloc(1e3),
                        s = bs()(e),
                        o = this.ixLayout.get(s);
                    if (!o) throw new Error(`Unknown method: ${s}`);
                    const a = o.encode(i, r),
                        c = r.slice(0, a);
                    return Aa.Buffer.concat([c7(n, e), c])
                }
                static parseIxLayout(n) {
                    const e = n.instructions.map(i => {
                        let r = i.args.map(o => {
                            var a, c;
                            return Qa.fieldLayout(o, Array.from([...null !== (a = n.accounts) && void 0 !== a ? a : [], ...null !== (c = n.types) && void 0 !== c ? c : []]))
                        });
                        const s = bs()(i.name);
                        return [s, zi.struct(r, s)]
                    });
                    return new Map(e)
                }
                decode(n, e = "hex") {
                    "string" == typeof n && (n = "hex" === e ? Aa.Buffer.from(n, "hex") : og().decode(n));
                    let i = og().encode(n.slice(0, 8)),
                        r = n.slice(8);
                    const s = this.sighashLayouts.get(i);
                    return s ? {
                        data: s.layout.decode(r),
                        name: s.name
                    } : null
                }
                format(n, e) {
                    return mu.format(n, e, this.idl)
                }
            }
            class mu {
                static format(n, e, i) {
                    const r = i.instructions.filter(c => n.name === c.name)[0];
                    if (void 0 === r) return console.error("Invalid instruction given"), null;
                    const s = r.args.map(c => ({
                            name: c.name,
                            type: mu.formatIdlType(c.type),
                            data: mu.formatIdlData(c, n.data[c.name], i.types)
                        })),
                        o = mu.flattenIdlAccounts(r.accounts);
                    return {
                        args: s,
                        accounts: e.map((c, u) => u < o.length ? {
                            name: o[u].name,
                            ...c
                        } : {
                            name: void 0,
                            ...c
                        })
                    }
                }
                static formatIdlType(n) {
                    if ("string" == typeof n) return n;
                    if ("vec" in n) return `Vec<${this.formatIdlType(n.vec)}>`;
                    if ("option" in n) return `Option<${this.formatIdlType(n.option)}>`;
                    if ("defined" in n) return n.defined;
                    if ("array" in n) return `Array<${n.array[0]}; ${n.array[1]}>`;
                    throw new Error(`Unknown IDL type: ${n}`)
                }
                static formatIdlData(n, e, i) {
                    if ("string" == typeof n.type) return e.toString();
                    if (n.type.hasOwnProperty("vec")) return "[" + e.map(r => this.formatIdlData({
                        name: "",
                        type: n.type.vec
                    }, r)).join(", ") + "]";
                    if (n.type.hasOwnProperty("option")) return null === e ? "null" : this.formatIdlData({
                        name: "",
                        type: n.type.option
                    }, e, i);
                    if (n.type.hasOwnProperty("defined")) {
                        if (void 0 === i) throw new Error("User defined types not provided");
                        const r = i.filter(s => s.name === n.type.defined);
                        if (1 !== r.length) throw new Error(`Type not found: ${n.type.defined}`);
                        return mu.formatIdlDataDefined(r[0], e, i)
                    }
                    return "unknown"
                }
                static formatIdlDataDefined(n, e, i) {
                    switch (n.type.kind) {
                        case "struct":
                            {
                                const r = n.type;
                                return "{ " + Object.keys(e).map(o => {
                                    const a = r.fields.find(c => c.name === o);
                                    if (!a) throw new Error("Unable to find type");
                                    return o + ": " + mu.formatIdlData(a, e[o], i)
                                }).join(", ") + " }"
                            }
                        case "enum":
                            if (0 === n.type.variants.length) return "{}";
                            if (n.type.variants[0].name) {
                                const r = n.type.variants,
                                    s = Object.keys(e)[0],
                                    o = e[s],
                                    a = Object.keys(o).map(u => {
                                        var h;
                                        const m = o[u],
                                            x = null === (h = r[s]) || void 0 === h ? void 0 : h.find(D => D.name === u);
                                        if (!x) throw new Error("Unable to find variant");
                                        return u + ": " + mu.formatIdlData(x, m, i)
                                    }).join(", "),
                                    c = bs()(s, {
                                        pascalCase: !0
                                    });
                                return 0 === a.length ? c : `${c} { ${a} }`
                            }
                            return "Tuple formatting not yet implemented";
                        case "alias":
                            return mu.formatIdlType(n.type.value)
                    }
                }
                static flattenIdlAccounts(n, e) {
                    return n.map(i => {
                        const r = function A_e(t) {
                            const n = t.replace(/([A-Z])/g, " $1");
                            return n.charAt(0).toUpperCase() + n.slice(1)
                        }(i.name);
                        return i.hasOwnProperty("accounts") ? mu.flattenIdlAccounts(i.accounts, e ? `${e} > ${r}` : r) : { ...i,
                            name: e ? `${e} > ${r}` : r
                        }
                    }).flat()
                }
            }

            function c7(t, n) {
                let e = function D_e(t, n) {
                    return void 0 === n && (n = {}),
                        function E_e(t, n) {
                            return void 0 === n && (n = {}),
                                function S_e(t, n) {
                                    void 0 === n && (n = {});
                                    for (var e = n.splitRegexp, r = n.stripRegexp, s = void 0 === r ? T_e : r, o = n.transform, a = void 0 === o ? x_e : o, c = n.delimiter, u = void 0 === c ? " " : c, h = o7(o7(t, void 0 === e ? C_e : e, "$1\0$2"), s, "\0"), m = 0, x = h.length;
                                        "\0" === h.charAt(m);) m++;
                                    for (;
                                        "\0" === h.charAt(x - 1);) x--;
                                    return h.slice(m, x).split("\0").map(a).join(u)
                                }(t, aI({
                                    delimiter: "."
                                }, n))
                        }(t, oI({
                            delimiter: "_"
                        }, n))
                }(n);
                return Aa.Buffer.from((0, e1.J)(`${t}:${e}`).slice(0, 8))
            }

            function lI(t, n) {
                switch (n.type.kind) {
                    case "struct":
                        return n.type.fields.map(e => rp(t, e.type)).reduce((e, i) => e + i, 0);
                    case "enum":
                        {
                            const e = n.type.variants.map(i => i.fields ? i.fields.map(r => rp(t, "object" == typeof r && "name" in r ? r.type : r)).reduce((r, s) => r + s, 0) : 0);
                            return Math.max(...e) + 1
                        }
                    case "alias":
                        return rp(t, n.type.value)
                }
            }

            function rp(t, n) {
                var e, i;
                switch (n) {
                    case "bool":
                    case "u8":
                    case "i8":
                    case "bytes":
                    case "string":
                        return 1;
                    case "i16":
                    case "u16":
                        return 2;
                    case "u32":
                    case "i32":
                    case "f32":
                        return 4;
                    case "u64":
                    case "i64":
                    case "f64":
                        return 8;
                    case "u128":
                    case "i128":
                        return 16;
                    case "u256":
                    case "i256":
                    case "publicKey":
                        return 32;
                    default:
                        if ("vec" in n) return 1;
                        if ("option" in n) return 1 + rp(t, n.option);
                        if ("coption" in n) return 4 + rp(t, n.coption);
                        if ("defined" in n) {
                            const r = null !== (i = null === (e = t.types) || void 0 === e ? void 0 : e.filter(o => o.name === n.defined)) && void 0 !== i ? i : [];
                            if (1 !== r.length) throw new _1(`Type not found: ${JSON.stringify(n)}`);
                            return lI(t, r[0])
                        }
                        if ("array" in n) {
                            let s = n.array[1];
                            return rp(t, n.array[0]) * s
                        }
                        throw new Error(`Invalid type ${JSON.stringify(n)}`)
                }
            }

            function l7(t) {
                return Buffer.from((0, e1.J)(t).slice(0, 8))
            }
            class gg {
                constructor(n) {
                    if (void 0 === n.accounts) return void(this.accountLayouts = new Map);
                    const e = n.accounts.map(i => [i.name, Qa.typeDefLayout(i, n.types)]);
                    this.accountLayouts = new Map(e), this.idl = n
                }
                encode(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const r = Aa.Buffer.alloc(1e3),
                            s = i.accountLayouts.get(n);
                        if (!s) throw new Error(`Unknown account: ${n}`);
                        const o = s.encode(e, r);
                        let a = r.slice(0, o),
                            c = gg.accountDiscriminator(n);
                        return Aa.Buffer.concat([c, a])
                    })()
                }
                decode(n, e) {
                    if (gg.accountDiscriminator(n).compare(e.slice(0, 8))) throw new Error("Invalid account discriminator");
                    return this.decodeUnchecked(n, e)
                }
                decodeAny(n) {
                    const e = n.slice(0, 8),
                        i = Array.from(this.accountLayouts.keys()).find(r => gg.accountDiscriminator(r).equals(e));
                    if (!i) throw new Error("Account descriminator not found");
                    return this.decodeUnchecked(i, n)
                }
                decodeUnchecked(n, e) {
                    const i = e.subarray(8),
                        r = this.accountLayouts.get(n);
                    if (!r) throw new Error(`Unknown account: ${n}`);
                    return r.decode(i)
                }
                memcmp(n, e) {
                    const i = gg.accountDiscriminator(n);
                    return {
                        offset: 0,
                        bytes: og().encode(e ? Aa.Buffer.concat([i, e]) : i)
                    }
                }
                size(n) {
                    var e;
                    return 8 + (null !== (e = lI(this.idl, n)) && void 0 !== e ? e : 0)
                }
                static accountDiscriminator(n) {
                    return l7(`account:${bs()(n,{pascalCase:!0,preserveConsecutiveUppercase:!0})}`)
                }
            }
            class k_e {
                constructor(n) {
                    if (void 0 === n.events) return void(this.layouts = new Map);
                    const e = n.events.map(i => {
                        let r = {
                            name: i.name,
                            type: {
                                kind: "struct",
                                fields: i.fields.map(s => ({
                                    name: s.name,
                                    type: s.type
                                }))
                            }
                        };
                        return [i.name, Qa.typeDefLayout(r, n.types)]
                    });
                    this.layouts = new Map(e), this.discriminators = new Map(void 0 === n.events ? [] : n.events.map(i => {
                        return [jM((t = i.name, l7(`event:${t}`))), i.name];
                        var t
                    }))
                }
                decode(n) {
                    let e;
                    try {
                        e = WM(n)
                    } catch {
                        return null
                    }
                    const i = jM(e.slice(0, 8)),
                        r = this.discriminators.get(i);
                    if (void 0 === r) return null;
                    const s = this.layouts.get(r);
                    if (!s) throw new Error(`Unknown event: ${r}`);
                    return {
                        data: s.decode(e.slice(8)),
                        name: r
                    }
                }
            }
            class I_e {
                constructor(n) {
                    if (void 0 === n.types) return void(this.typeLayouts = new Map);
                    const e = n.types.map(i => [i.name, Qa.typeDefLayout(i, n.types)]);
                    this.typeLayouts = new Map(e), this.idl = n
                }
                encode(n, e) {
                    const i = Aa.Buffer.alloc(1e3),
                        r = this.typeLayouts.get(n);
                    if (!r) throw new Error(`Unknown type: ${n}`);
                    const s = r.encode(e, i);
                    return i.slice(0, s)
                }
                decode(n, e) {
                    const i = this.typeLayouts.get(n);
                    if (!i) throw new Error(`Unknown type: ${n}`);
                    return i.decode(e)
                }
            }
            class u7 {
                constructor(n) {
                    this.instruction = new cI(n), this.accounts = new gg(n), this.events = new k_e(n), this.types = new I_e(n)
                }
            }
            var P_e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
            class Ja {
                constructor(n, e) {
                    if (!Number.isInteger(n)) throw new TypeError("span must be an integer");
                    this.span = n, this.property = e
                }
                makeDestinationObject() {
                    return {}
                }
                decode(n, e) {
                    throw new Error("Layout is abstract")
                }
                encode(n, e, i) {
                    throw new Error("Layout is abstract")
                }
                getSpan(n, e) {
                    if (0 > this.span) throw new RangeError("indeterminate span");
                    return this.span
                }
                replicate(n) {
                    const e = Object.create(this.constructor.prototype);
                    return Object.assign(e, this), e.property = n, e
                }
                fromArray(n) {}
            }
            var b1 = Ja;
            class sp extends Ja {
                isCount() {
                    throw new Error("ExternalLayout is abstract")
                }
            }
            class d7 extends sp {
                constructor(n, e, i) {
                    if (!(n instanceof Ja)) throw new TypeError("layout must be a Layout");
                    if (void 0 === e) e = 0;
                    else if (!Number.isInteger(e)) throw new TypeError("offset must be integer or undefined");
                    super(n.span, i || n.property), this.layout = n, this.offset = e
                }
                isCount() {
                    return this.layout instanceof w1 || this.layout instanceof h7
                }
                decode(n, e) {
                    return void 0 === e && (e = 0), this.layout.decode(n, e + this.offset)
                }
                encode(n, e, i) {
                    return void 0 === i && (i = 0), this.layout.encode(n, e, i + this.offset)
                }
            }
            class w1 extends Ja {
                constructor(n, e) {
                    if (super(n, e), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(n, e) {
                    return void 0 === e && (e = 0), n.readUIntLE(e, this.span)
                }
                encode(n, e, i) {
                    return void 0 === i && (i = 0), e.writeUIntLE(n, i, this.span), this.span
                }
            }
            class h7 extends Ja {
                constructor(n, e) {
                    if (super(n, e), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(n, e) {
                    return void 0 === e && (e = 0), n.readUIntBE(e, this.span)
                }
                encode(n, e, i) {
                    return void 0 === i && (i = 0), e.writeUIntBE(n, i, this.span), this.span
                }
            }
            const dI = Math.pow(2, 32);

            function f7(t) {
                const n = Math.floor(t / dI);
                return {
                    hi32: n,
                    lo32: t - n * dI
                }
            }

            function p7(t, n) {
                return t * dI + n
            }
            class B_e extends Ja {
                constructor(n) {
                    super(8, n)
                }
                decode(n, e) {
                    void 0 === e && (e = 0);
                    const i = n.readUInt32LE(e);
                    return p7(n.readInt32LE(e + 4), i)
                }
                encode(n, e, i) {
                    void 0 === i && (i = 0);
                    const r = f7(n);
                    return e.writeUInt32LE(r.lo32, i), e.writeInt32LE(r.hi32, i + 4), 8
                }
            }
            class N_e extends Ja {
                constructor(n, e, i) {
                    if (!Array.isArray(n) || !n.reduce((s, o) => s && o instanceof Ja, !0)) throw new TypeError("fields must be array of Layout instances");
                    "boolean" == typeof e && void 0 === i && (i = e, e = void 0);
                    for (const s of n)
                        if (0 > s.span && void 0 === s.property) throw new Error("fields cannot contain unnamed variable-length layout");
                    let r = -1;
                    try {
                        r = n.reduce((s, o) => s + o.getSpan(), 0)
                    } catch {}
                    super(r, e), this.fields = n, this.decodePrefixes = !!i
                }
                getSpan(n, e) {
                    if (0 <= this.span) return this.span;
                    void 0 === e && (e = 0);
                    let i = 0;
                    try {
                        i = this.fields.reduce((r, s) => {
                            const o = s.getSpan(n, e);
                            return e += o, r + o
                        }, 0)
                    } catch {
                        throw new RangeError("indeterminate span")
                    }
                    return i
                }
                decode(n, e) {
                    void 0 === e && (e = 0);
                    const i = this.makeDestinationObject();
                    for (const r of this.fields)
                        if (void 0 !== r.property && (i[r.property] = r.decode(n, e)), e += r.getSpan(n, e), this.decodePrefixes && n.length === e) break;
                    return i
                }
                encode(n, e, i) {
                    void 0 === i && (i = 0);
                    const r = i;
                    let s = 0,
                        o = 0;
                    for (const a of this.fields) {
                        let c = a.span;
                        if (o = 0 < c ? c : 0, void 0 !== a.property) {
                            const u = n[a.property];
                            void 0 !== u && (o = a.encode(u, e, i), 0 > c && (c = a.getSpan(e, i)))
                        }
                        s = i, i += c
                    }
                    return s + o - r
                }
                fromArray(n) {
                    const e = this.makeDestinationObject();
                    for (const i of this.fields) void 0 !== i.property && 0 < n.length && (e[i.property] = n.shift());
                    return e
                }
                layoutFor(n) {
                    if ("string" != typeof n) throw new TypeError("property must be string");
                    for (const e of this.fields)
                        if (e.property === n) return e
                }
                offsetOf(n) {
                    if ("string" != typeof n) throw new TypeError("property must be string");
                    let e = 0;
                    for (const i of this.fields) {
                        if (i.property === n) return e;
                        0 > i.span ? e = -1 : 0 <= e && (e += i.span)
                    }
                }
            }
            class m7 {
                constructor(n) {
                    this.property = n
                }
                decode() {
                    throw new Error("UnionDiscriminator is abstract")
                }
                encode() {
                    throw new Error("UnionDiscriminator is abstract")
                }
            }
            class g7 extends m7 {
                constructor(n, e) {
                    if (!(n instanceof sp && n.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                    super(e || n.property || "variant"), this.layout = n
                }
                decode(n, e) {
                    return this.layout.decode(n, e)
                }
                encode(n, e, i) {
                    return this.layout.encode(n, e, i)
                }
            }
            class y7 extends Ja {
                constructor(n, e, i) {
                    const r = n instanceof w1 || n instanceof h7;
                    if (r) n = new g7(new d7(n));
                    else if (n instanceof sp && n.isCount()) n = new g7(n);
                    else if (!(n instanceof m7)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                    if (void 0 === e && (e = null), !(null === e || e instanceof Ja)) throw new TypeError("defaultLayout must be null or a Layout");
                    if (null !== e) {
                        if (0 > e.span) throw new Error("defaultLayout must have constant span");
                        void 0 === e.property && (e = e.replicate("content"))
                    }
                    let s = -1;
                    e && (s = e.span, 0 <= s && r && (s += n.layout.span)), super(s, i), this.discriminator = n, this.usesPrefixDiscriminator = r, this.defaultLayout = e, this.registry = {};
                    let o = this.defaultGetSourceVariant.bind(this);
                    this.getSourceVariant = function(a) {
                        return o(a)
                    }, this.configGetSourceVariant = function(a) {
                        o = a.bind(this)
                    }
                }
                getSpan(n, e) {
                    if (0 <= this.span) return this.span;
                    void 0 === e && (e = 0);
                    const i = this.getVariant(n, e);
                    if (!i) throw new Error("unable to determine span for unrecognized variant");
                    return i.getSpan(n, e)
                }
                defaultGetSourceVariant(n) {
                    if (n.hasOwnProperty(this.discriminator.property)) {
                        if (this.defaultLayout && n.hasOwnProperty(this.defaultLayout.property)) return;
                        const e = this.registry[n[this.discriminator.property]];
                        if (e && (!e.layout || n.hasOwnProperty(e.property))) return e
                    } else
                        for (const e in this.registry) {
                            const i = this.registry[e];
                            if (n.hasOwnProperty(i.property)) return i
                        }
                    throw new Error("unable to infer src variant")
                }
                decode(n, e) {
                    let i;
                    void 0 === e && (e = 0);
                    const r = this.discriminator,
                        s = r.decode(n, e);
                    let o = this.registry[s];
                    if (void 0 === o) {
                        let a = 0;
                        o = this.defaultLayout, this.usesPrefixDiscriminator && (a = r.layout.span), i = this.makeDestinationObject(), i[r.property] = s, i[o.property] = this.defaultLayout.decode(n, e + a)
                    } else i = o.decode(n, e);
                    return i
                }
                encode(n, e, i) {
                    void 0 === i && (i = 0);
                    const r = this.getSourceVariant(n);
                    if (void 0 === r) {
                        const s = this.discriminator,
                            o = this.defaultLayout;
                        let a = 0;
                        return this.usesPrefixDiscriminator && (a = s.layout.span), s.encode(n[s.property], e, i), a + o.encode(n[o.property], e, i + a)
                    }
                    return r.encode(n, e, i)
                }
                addVariant(n, e, i) {
                    const r = new F_e(this, n, e, i);
                    return this.registry[n] = r, r
                }
                getVariant(n, e) {
                    let i = n;
                    return Buffer.isBuffer(n) && (void 0 === e && (e = 0), i = this.discriminator.decode(n, e)), this.registry[i]
                }
            }
            class F_e extends Ja {
                constructor(n, e, i, r) {
                    if (!(n instanceof y7)) throw new TypeError("union must be a Union");
                    if (!Number.isInteger(e) || 0 > e) throw new TypeError("variant must be a (non-negative) integer");
                    if ("string" == typeof i && void 0 === r && (r = i, i = null), i) {
                        if (!(i instanceof Ja)) throw new TypeError("layout must be a Layout");
                        if (null !== n.defaultLayout && 0 <= i.span && i.span > n.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                        if ("string" != typeof r) throw new TypeError("variant must have a String property")
                    }
                    let s = n.span;
                    0 > n.span && (s = i ? i.span : 0, 0 <= s && n.usesPrefixDiscriminator && (s += n.discriminator.layout.span)), super(s, r), this.union = n, this.variant = e, this.layout = i || null
                }
                getSpan(n, e) {
                    if (0 <= this.span) return this.span;
                    void 0 === e && (e = 0);
                    let i = 0;
                    return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), i + this.layout.getSpan(n, e + i)
                }
                decode(n, e) {
                    const i = this.makeDestinationObject();
                    if (void 0 === e && (e = 0), this !== this.union.getVariant(n, e)) throw new Error("variant mismatch");
                    let r = 0;
                    return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? i[this.property] = this.layout.decode(n, e + r) : this.property ? i[this.property] = !0 : this.union.usesPrefixDiscriminator && (i[this.union.discriminator.property] = this.variant), i
                }
                encode(n, e, i) {
                    void 0 === i && (i = 0);
                    let r = 0;
                    if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !n.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                    this.union.discriminator.encode(this.variant, e, i);
                    let s = r;
                    if (this.layout && (this.layout.encode(n[this.property], e, i + r), s += this.layout.getSpan(e, i + r), 0 <= this.union.span && s > this.union.span)) throw new Error("encoded variant overruns containing union");
                    return s
                }
                fromArray(n) {
                    if (this.layout) return this.layout.fromArray(n)
                }
            }
            class V_e extends Ja {
                constructor(n, e) {
                    if (!(n instanceof sp && n.isCount() || Number.isInteger(n) && 0 <= n)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                    let i = -1;
                    n instanceof sp || (i = n), super(i, e), this.length = n
                }
                getSpan(n, e) {
                    let i = this.span;
                    return 0 > i && (i = this.length.decode(n, e)), i
                }
                decode(n, e) {
                    void 0 === e && (e = 0);
                    let i = this.span;
                    return 0 > i && (i = this.length.decode(n, e)), n.slice(e, e + i)
                }
                encode(n, e, i) {
                    let r = this.length;
                    if (this.length instanceof sp && (r = n.length), !Buffer.isBuffer(n) || r !== n.length) throw new TypeError(function L_e(t, n) {
                        return n.property ? t + "[" + n.property + "]" : t
                    }("Blob.encode", this) + " requires (length " + r + ") Buffer as src");
                    if (i + r > e.length) throw new RangeError("encoding overruns Buffer");
                    return e.write(n.toString("hex"), i, r, "hex"), this.length instanceof sp && this.length.encode(r, e, i), r
                }
            }
            var U_e = (t, n, e) => new d7(t, n, e),
                ld = t => new w1(4, t),
                ud = t => new B_e(t),
                bo = (t, n, e) => new N_e(t, n, e),
                _7 = (t, n, e) => new y7(t, n, e),
                S_ = (t, n) => new V_e(t, n);
            class j_e extends b1 {
                constructor(n) {
                    super(-1, n), this.property = n, this.layout = bo([ld("length"), ld("lengthPadding"), S_(U_e(ld(), -8), "chars")], this.property)
                }
                encode(n, e, i = 0) {
                    if (null == n) return this.layout.span;
                    const r = {
                        chars: Buffer.from(n, "utf8")
                    };
                    return this.layout.encode(r, e, i)
                }
                decode(n, e = 0) {
                    return this.layout.decode(n, e).chars.toString()
                }
                getSpan(n, e = 0) {
                    return ld().span + ld().span + new(xU())(new Uint8Array(n).slice(e, e + 4), 10, "le").toNumber()
                }
            }

            function x1(t) {
                return new j_e(t)
            }

            function Xc(t) {
                return S_(32, t)
            }
            const Oo = _7(ld("instruction"));
            Oo.addVariant(0, bo([ud("lamports"), ud("space"), Xc("owner")]), "createAccount"), Oo.addVariant(1, bo([Xc("owner")]), "assign"), Oo.addVariant(2, bo([ud("lamports")]), "transfer"), Oo.addVariant(3, bo([Xc("base"), x1("seed"), ud("lamports"), ud("space"), Xc("owner")]), "createAccountWithSeed"), Oo.addVariant(4, bo([Xc("authorized")]), "advanceNonceAccount"), Oo.addVariant(5, bo([ud("lamports")]), "withdrawNonceAccount"), Oo.addVariant(6, bo([Xc("authorized")]), "initializeNonceAccount"), Oo.addVariant(7, bo([Xc("authorized")]), "authorizeNonceAccount"), Oo.addVariant(8, bo([ud("space")]), "allocate"), Oo.addVariant(9, bo([Xc("base"), x1("seed"), ud("space"), Xc("owner")]), "allocateWithSeed"), Oo.addVariant(10, bo([Xc("base"), x1("seed"), Xc("owner")]), "assignWithSeed"), Oo.addVariant(11, bo([ud("lamports"), x1("seed"), Xc("owner")]), "transferWithSeed"), Math.max(...Object.values(Oo.registry).map(t => t.span));
            class ove extends b1 {
                constructor(n, e, i, r) {
                    super(n.span, r), this.layout = n, this.decoder = e, this.encoder = i
                }
                decode(n, e) {
                    return this.decoder(this.layout.decode(n, e))
                }
                encode(n, e, i) {
                    return this.layout.encode(this.encoder(n), e, i)
                }
                getSpan(n, e) {
                    return this.layout.getSpan(n, e)
                }
            }

            function v7(t) {
                return new ove(S_(32), n => new Mr.PublicKey(n), n => n.toBuffer(), t)
            }
            bo([ld("version"), ld("state"), v7("authorizedPubkey"), v7("nonce"), bo([("lamportsPerSignature", new class R_e extends Ja {
                constructor(n) {
                    super(8, n)
                }
                decode(n, e) {
                    void 0 === e && (e = 0);
                    const i = n.readUInt32LE(e);
                    return p7(n.readUInt32LE(e + 4), i)
                }
                encode(n, e, i) {
                    void 0 === i && (i = 0);
                    const r = f7(n);
                    return e.writeUInt32LE(r.lo32, i), e.writeUInt32LE(r.hi32, i + 4), 8
                }
            }("lamportsPerSignature"))], "feeCalculator")]);
            const hI = new Mr.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                fI = new Mr.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
            var pI = {
                exports: {}
            };

            function bve(t) {
                return "accounts" in t
            }

            function _I() {
                return _I = (0, Ze.Z)(function*(t) {
                    const n = (yield Mr.PublicKey.findProgramAddress([], t))[0];
                    return yield Mr.PublicKey.createWithSeed(n, "anchor:idl", t)
                }), _I.apply(this, arguments)
            }! function(t, n) {
                var s, e = typeof self < "u" ? self : P_e,
                    i = function() {
                        function s() {
                            this.fetch = !1, this.DOMException = e.DOMException
                        }
                        return s.prototype = e, new s
                    }();
                s = i,
                    function(o) {
                        var a_searchParams = "URLSearchParams" in s,
                            a_iterable = "Symbol" in s && "iterator" in Symbol,
                            a_blob = "FileReader" in s && "Blob" in s && function() {
                                try {
                                    return new Blob, !0
                                } catch {
                                    return !1
                                }
                            }(),
                            a_formData = "FormData" in s,
                            a_arrayBuffer = "ArrayBuffer" in s;
                        if (a_arrayBuffer) var u = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                            h = ArrayBuffer.isView || function(ut) {
                                return ut && u.indexOf(Object.prototype.toString.call(ut)) > -1
                            };

                        function m(ut) {
                            if ("string" != typeof ut && (ut = String(ut)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(ut)) throw new TypeError("Invalid character in header field name");
                            return ut.toLowerCase()
                        }

                        function x(ut) {
                            return "string" != typeof ut && (ut = String(ut)), ut
                        }

                        function D(ut) {
                            var Ht = {
                                next: function() {
                                    var Et = ut.shift();
                                    return {
                                        done: void 0 === Et,
                                        value: Et
                                    }
                                }
                            };
                            return a_iterable && (Ht[Symbol.iterator] = function() {
                                return Ht
                            }), Ht
                        }

                        function V(ut) {
                            this.map = {}, ut instanceof V ? ut.forEach(function(Ht, Et) {
                                this.append(Et, Ht)
                            }, this) : Array.isArray(ut) ? ut.forEach(function(Ht) {
                                this.append(Ht[0], Ht[1])
                            }, this) : ut && Object.getOwnPropertyNames(ut).forEach(function(Ht) {
                                this.append(Ht, ut[Ht])
                            }, this)
                        }

                        function te(ut) {
                            if (ut.bodyUsed) return Promise.reject(new TypeError("Already read"));
                            ut.bodyUsed = !0
                        }

                        function ee(ut) {
                            return new Promise(function(Ht, Et) {
                                ut.onload = function() {
                                    Ht(ut.result)
                                }, ut.onerror = function() {
                                    Et(ut.error)
                                }
                            })
                        }

                        function _e(ut) {
                            var Ht = new FileReader,
                                Et = ee(Ht);
                            return Ht.readAsArrayBuffer(ut), Et
                        }

                        function ze(ut) {
                            if (ut.slice) return ut.slice(0);
                            var Ht = new Uint8Array(ut.byteLength);
                            return Ht.set(new Uint8Array(ut)), Ht.buffer
                        }

                        function Xe() {
                            return this.bodyUsed = !1, this._initBody = function(ut) {
                                this._bodyInit = ut, ut ? "string" == typeof ut ? this._bodyText = ut : a_blob && Blob.prototype.isPrototypeOf(ut) ? this._bodyBlob = ut : a_formData && FormData.prototype.isPrototypeOf(ut) ? this._bodyFormData = ut : a_searchParams && URLSearchParams.prototype.isPrototypeOf(ut) ? this._bodyText = ut.toString() : a_arrayBuffer && a_blob && function c(ut) {
                                    return ut && DataView.prototype.isPrototypeOf(ut)
                                }(ut) ? (this._bodyArrayBuffer = ze(ut.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a_arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(ut) || h(ut)) ? this._bodyArrayBuffer = ze(ut) : this._bodyText = ut = Object.prototype.toString.call(ut) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof ut ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a_searchParams && URLSearchParams.prototype.isPrototypeOf(ut) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                            }, a_blob && (this.blob = function() {
                                var ut = te(this);
                                if (ut) return ut;
                                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                                if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                                if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                                return Promise.resolve(new Blob([this._bodyText]))
                            }, this.arrayBuffer = function() {
                                return this._bodyArrayBuffer ? te(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(_e)
                            }), this.text = function() {
                                var ut = te(this);
                                if (ut) return ut;
                                if (this._bodyBlob) return function ye(ut) {
                                    var Ht = new FileReader,
                                        Et = ee(Ht);
                                    return Ht.readAsText(ut), Et
                                }(this._bodyBlob);
                                if (this._bodyArrayBuffer) return Promise.resolve(function Be(ut) {
                                    for (var Ht = new Uint8Array(ut), Et = new Array(Ht.length), Gt = 0; Gt < Ht.length; Gt++) Et[Gt] = String.fromCharCode(Ht[Gt]);
                                    return Et.join("")
                                }(this._bodyArrayBuffer));
                                if (this._bodyFormData) throw new Error("could not read FormData body as text");
                                return Promise.resolve(this._bodyText)
                            }, a_formData && (this.formData = function() {
                                return this.text().then(Cn)
                            }), this.json = function() {
                                return this.text().then(JSON.parse)
                            }, this
                        }
                        V.prototype.append = function(ut, Ht) {
                            ut = m(ut), Ht = x(Ht);
                            var Et = this.map[ut];
                            this.map[ut] = Et ? Et + ", " + Ht : Ht
                        }, V.prototype.delete = function(ut) {
                            delete this.map[m(ut)]
                        }, V.prototype.get = function(ut) {
                            return ut = m(ut), this.has(ut) ? this.map[ut] : null
                        }, V.prototype.has = function(ut) {
                            return this.map.hasOwnProperty(m(ut))
                        }, V.prototype.set = function(ut, Ht) {
                            this.map[m(ut)] = x(Ht)
                        }, V.prototype.forEach = function(ut, Ht) {
                            for (var Et in this.map) this.map.hasOwnProperty(Et) && ut.call(Ht, this.map[Et], Et, this)
                        }, V.prototype.keys = function() {
                            var ut = [];
                            return this.forEach(function(Ht, Et) {
                                ut.push(Et)
                            }), D(ut)
                        }, V.prototype.values = function() {
                            var ut = [];
                            return this.forEach(function(Ht) {
                                ut.push(Ht)
                            }), D(ut)
                        }, V.prototype.entries = function() {
                            var ut = [];
                            return this.forEach(function(Ht, Et) {
                                ut.push([Et, Ht])
                            }), D(ut)
                        }, a_iterable && (V.prototype[Symbol.iterator] = V.prototype.entries);
                        var ht = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                        function jt(ut, Ht) {
                            var Et = (Ht = Ht || {}).body;
                            if (ut instanceof jt) {
                                if (ut.bodyUsed) throw new TypeError("Already read");
                                this.url = ut.url, this.credentials = ut.credentials, Ht.headers || (this.headers = new V(ut.headers)), this.method = ut.method, this.mode = ut.mode, this.signal = ut.signal, !Et && null != ut._bodyInit && (Et = ut._bodyInit, ut.bodyUsed = !0)
                            } else this.url = String(ut);
                            if (this.credentials = Ht.credentials || this.credentials || "same-origin", (Ht.headers || !this.headers) && (this.headers = new V(Ht.headers)), this.method = function vt(ut) {
                                    var Ht = ut.toUpperCase();
                                    return ht.indexOf(Ht) > -1 ? Ht : ut
                                }(Ht.method || this.method || "GET"), this.mode = Ht.mode || this.mode || null, this.signal = Ht.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && Et) throw new TypeError("Body not allowed for GET or HEAD requests");
                            this._initBody(Et)
                        }

                        function Cn(ut) {
                            var Ht = new FormData;
                            return ut.trim().split("&").forEach(function(Et) {
                                if (Et) {
                                    var Gt = Et.split("="),
                                        cn = Gt.shift().replace(/\+/g, " "),
                                        Qt = Gt.join("=").replace(/\+/g, " ");
                                    Ht.append(decodeURIComponent(cn), decodeURIComponent(Qt))
                                }
                            }), Ht
                        }

                        function Xt(ut) {
                            var Ht = new V;
                            return ut.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(Gt) {
                                var cn = Gt.split(":"),
                                    Qt = cn.shift().trim();
                                if (Qt) {
                                    var Ri = cn.join(":").trim();
                                    Ht.append(Qt, Ri)
                                }
                            }), Ht
                        }

                        function Rt(ut, Ht) {
                            Ht || (Ht = {}), this.type = "default", this.status = void 0 === Ht.status ? 200 : Ht.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Ht ? Ht.statusText : "OK", this.headers = new V(Ht.headers), this.url = Ht.url || "", this._initBody(ut)
                        }
                        jt.prototype.clone = function() {
                            return new jt(this, {
                                body: this._bodyInit
                            })
                        }, Xe.call(jt.prototype), Xe.call(Rt.prototype), Rt.prototype.clone = function() {
                            return new Rt(this._bodyInit, {
                                status: this.status,
                                statusText: this.statusText,
                                headers: new V(this.headers),
                                url: this.url
                            })
                        }, Rt.error = function() {
                            var ut = new Rt(null, {
                                status: 0,
                                statusText: ""
                            });
                            return ut.type = "error", ut
                        };
                        var wr = [301, 302, 303, 307, 308];
                        Rt.redirect = function(ut, Ht) {
                            if (-1 === wr.indexOf(Ht)) throw new RangeError("Invalid status code");
                            return new Rt(null, {
                                status: Ht,
                                headers: {
                                    location: ut
                                }
                            })
                        }, o.DOMException = s.DOMException;
                        try {
                            new o.DOMException
                        } catch {
                            o.DOMException = function(Ht, Et) {
                                this.message = Ht, this.name = Et;
                                var Gt = Error(Ht);
                                this.stack = Gt.stack
                            }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException
                        }

                        function xi(ut, Ht) {
                            return new Promise(function(Et, Gt) {
                                var cn = new jt(ut, Ht);
                                if (cn.signal && cn.signal.aborted) return Gt(new o.DOMException("Aborted", "AbortError"));
                                var Qt = new XMLHttpRequest;

                                function Ri() {
                                    Qt.abort()
                                }
                                Qt.onload = function() {
                                    var sr = {
                                        status: Qt.status,
                                        statusText: Qt.statusText,
                                        headers: Xt(Qt.getAllResponseHeaders() || "")
                                    };
                                    sr.url = "responseURL" in Qt ? Qt.responseURL : sr.headers.get("X-Request-URL"), Et(new Rt("response" in Qt ? Qt.response : Qt.responseText, sr))
                                }, Qt.onerror = function() {
                                    Gt(new TypeError("Network request failed"))
                                }, Qt.ontimeout = function() {
                                    Gt(new TypeError("Network request failed"))
                                }, Qt.onabort = function() {
                                    Gt(new o.DOMException("Aborted", "AbortError"))
                                }, Qt.open(cn.method, cn.url, !0), "include" === cn.credentials ? Qt.withCredentials = !0 : "omit" === cn.credentials && (Qt.withCredentials = !1), "responseType" in Qt && a_blob && (Qt.responseType = "blob"), cn.headers.forEach(function(sr, tr) {
                                    Qt.setRequestHeader(tr, sr)
                                }), cn.signal && (cn.signal.addEventListener("abort", Ri), Qt.onreadystatechange = function() {
                                    4 === Qt.readyState && cn.signal.removeEventListener("abort", Ri)
                                }), Qt.send(typeof cn._bodyInit > "u" ? null : cn._bodyInit)
                            })
                        }
                        xi.polyfill = !0, s.fetch || (s.fetch = xi, s.Headers = V, s.Request = jt, s.Response = Rt), o.Headers = V, o.Request = jt, o.Response = Rt, o.fetch = xi, Object.defineProperty(o, "__esModule", {
                            value: !0
                        })
                    }({}), i.fetch.ponyfill = !0, delete i.fetch.polyfill;
                var r = i;
                (n = r.fetch).default = r.fetch, n.fetch = r.fetch, n.Headers = r.Headers, n.Request = r.Request, n.Response = r.Response, t.exports = n
            }(pI, pI.exports), zi.rustEnum([zi.struct([], "uninitialized"), zi.struct([zi.option(zi.publicKey(), "authorityAddress")], "buffer"), zi.struct([zi.publicKey("programdataAddress")], "program"), zi.struct([zi.u64("slot"), zi.option(zi.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, zi.u32());
            const Cve = zi.struct([zi.publicKey("authority"), zi.vecU8("data")]);

            function C1(t, n) {
                var e, i;
                let r = {};
                const s = t.args ? t.args.length : 0;
                if (n.length > s) {
                    if (n.length !== s + 1) throw new Error(`provided too many arguments ${n} to instruction ${t?.name} expecting: ${null!==(i=null===(e=t.args)||void 0===e?void 0:e.map(o=>o.name))&&void 0!==i?i:[]}`);
                    r = n.pop()
                }
                return [n, r]
            }
            class T1 {
                static build(n, e, i) {
                    if ("_inner" === n.name) throw new _1("the _inner name is reserved");
                    const r = (...s) => {
                        const [o, a] = C1(n, [...s]);
                        KH(n.accounts, a.accounts);
                        const c = r.accounts(a.accounts);
                        return void 0 !== a.remainingAccounts && c.push(...a.remainingAccounts), sI("debug-logs") && console.log("Outgoing account metas:", c), new Mr.TransactionInstruction({
                            keys: c,
                            programId: i,
                            data: e(n.name, e_e(n, ...o))
                        })
                    };
                    return r.accounts = s => T1.accountsArray(s, n.accounts, i, n.name), r
                }
                static accountsArray(n, e, i, r) {
                    return n ? e.map(s => {
                        if (void 0 !== ("accounts" in s ? s.accounts : void 0)) return T1.accountsArray(n[s.name], s.accounts, i, r).flat(); {
                            const a = s;
                            let c;
                            try {
                                c = Ec(n[s.name])
                            } catch {
                                throw new Error(`Wrong input type for account "${s.name}" in the instruction accounts object${void 0!==r?' for instruction "'+r+'"':""}. Expected PublicKey or string.`)
                            }
                            const u = a.isOptional && c.equals(i);
                            return {
                                pubkey: c,
                                isWritable: a.isMut && !u,
                                isSigner: a.isSigner && !u
                            }
                        }
                    }).flat() : []
                }
            }
            class Eve {
                static build(n, e) {
                    return (...r) => {
                        var s, o, a;
                        const [, c] = C1(n, [...r]), u = new Mr.Transaction;
                        if (c.preInstructions && c.instructions) throw new Error("instructions is deprecated, use preInstructions");
                        return null === (s = c.preInstructions) || void 0 === s || s.forEach(h => u.add(h)), null === (o = c.instructions) || void 0 === o || o.forEach(h => u.add(h)), u.add(e(...r)), null === (a = c.postInstructions) || void 0 === a || a.forEach(h => u.add(h)), u
                    }
                }
            }
            class Dve {
                static build(n, e, i, r) {
                    return function() {
                        var o = (0, Ze.Z)(function*(...a) {
                            var c;
                            const u = e(...a),
                                [, h] = C1(n, [...a]);
                            if (void 0 === r.sendAndConfirm) throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
                            try {
                                return yield r.sendAndConfirm(u, null !== (c = h.signers) && void 0 !== c ? c : [], h.options)
                            } catch (m) {
                                throw s7(m, i)
                            }
                        });
                        return function() {
                            return o.apply(this, arguments)
                        }
                    }()
                }
            }
            class Ave {
                static build(n, e, i, r) {
                    var s;
                    const o = {};
                    return null === (s = n.accounts) || void 0 === s || s.forEach(a => {
                        const c = bs()(a.name);
                        o[c] = new kve(n, a, i, r, e)
                    }), o
                }
            }
            class kve {
                get size() {
                    return this._size
                }
                get programId() {
                    return this._programId
                }
                get provider() {
                    return this._provider
                }
                get coder() {
                    return this._coder
                }
                get idlAccount() {
                    return this._idlAccount
                }
                constructor(n, e, i, r, s) {
                    this._idlAccount = e, this._programId = i, this._provider = r ? ? y1(), this._coder = s ? ? new u7(n), this._size = this._coder.accounts.size(e)
                }
                fetchNullable(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const {
                            data: r
                        } = yield i.fetchNullableAndContext(n, e);
                        return r
                    })()
                }
                fetchNullableAndContext(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const r = yield i.getAccountInfoAndContext(n, e), {
                            value: s,
                            context: o
                        } = r;
                        return {
                            data: s && 0 !== s.data.length ? i._coder.accounts.decode(i._idlAccount.name, s.data) : null,
                            context: o
                        }
                    })()
                }
                fetch(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const {
                            data: r
                        } = yield i.fetchNullableAndContext(n, e);
                        if (null === r) throw new Error(`Account does not exist or has no data ${n.toString()}`);
                        return r
                    })()
                }
                fetchAndContext(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const {
                            data: r,
                            context: s
                        } = yield i.fetchNullableAndContext(n, e);
                        if (null === r) throw new Error(`Account does not exist ${n.toString()}`);
                        return {
                            data: r,
                            context: s
                        }
                    })()
                }
                fetchMultiple(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        return (yield i.fetchMultipleAndContext(n, e)).map(s => s ? s.data : null)
                    })()
                }
                fetchMultipleAndContext(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        return (yield QM(i._provider.connection, n.map(s => Ec(s)), e)).map(s => {
                            if (null == s) return null;
                            const {
                                account: o,
                                context: a
                            } = s;
                            return {
                                data: i._coder.accounts.decode(i._idlAccount.name, o.data),
                                context: a
                            }
                        })
                    })()
                }
                all(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        const i = e.coder.accounts.memcmp(e._idlAccount.name, n instanceof Buffer ? n : void 0),
                            r = [];
                        return null != i ? .offset && null != i ? .bytes && r.push({
                            memcmp: {
                                offset: i.offset,
                                bytes: i.bytes
                            }
                        }), null != i ? .dataSize && r.push({
                            dataSize: i.dataSize
                        }), (yield e._provider.connection.getProgramAccounts(e._programId, {
                            commitment: e._provider.connection.commitment,
                            filters: [...r, ...Array.isArray(n) ? n : []]
                        })).map(({
                            pubkey: o,
                            account: a
                        }) => ({
                            publicKey: o,
                            account: e._coder.accounts.decode(e._idlAccount.name, a.data)
                        }))
                    })()
                }
                subscribe(n, e) {
                    const i = E_.get(n.toString());
                    if (i) return i.ee;
                    const r = new(Sfe());
                    n = Ec(n);
                    const s = this._provider.connection.onAccountChange(n, o => {
                        const a = this._coder.accounts.decode(this._idlAccount.name, o.data);
                        r.emit("change", a)
                    }, e);
                    return E_.set(n.toString(), {
                        ee: r,
                        listener: s
                    }), r
                }
                unsubscribe(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        let i = E_.get(n.toString());
                        i ? E_ && (yield e._provider.connection.removeAccountChangeListener(i.listener).then(() => {
                            E_.delete(n.toString())
                        }).catch(console.error)) : console.warn("Address is not subscribed")
                    })()
                }
                createInstruction(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const r = i.size;
                        if (void 0 === i._provider.publicKey) throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
                        return Mr.SystemProgram.createAccount({
                            fromPubkey: i._provider.publicKey,
                            newAccountPubkey: n.publicKey,
                            space: e ? ? r,
                            lamports: yield i._provider.connection.getMinimumBalanceForRentExemption(e ? ? r), programId: i._programId
                        })
                    })()
                }
                associated(...n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        const i = yield e.associatedAddress(...n);
                        return yield e.fetch(i)
                    })()
                }
                associatedAddress(...n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        return yield function w7(t, ...n) {
                            let e = [Aa.Buffer.from([97, 110, 99, 104, 111, 114])];
                            n.forEach(r => {
                                e.push(r instanceof Aa.Buffer ? r : Ec(r).toBuffer())
                            });
                            const [i] = Mr.PublicKey.findProgramAddressSync(e, Ec(t));
                            return i
                        }(e._programId, ...n)
                    })()
                }
                getAccountInfo(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        return yield i._provider.connection.getAccountInfo(Ec(n), e)
                    })()
                }
                getAccountInfoAndContext(n, e) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        return yield i._provider.connection.getAccountInfoAndContext(Ec(n), e)
                    })()
                }
            }
            const E_ = new Map,
                vI = "Program log: ";
            class Pve {
                constructor(n, e, i) {
                    this._programId = n, this._provider = e, this._eventParser = new T7(n, i), this._eventCallbacks = new Map, this._eventListeners = new Map, this._listenerIdCount = 0
                }
                addEventListener(n, e) {
                    var i;
                    let r = this._listenerIdCount;
                    return this._listenerIdCount += 1, this._eventListeners.has(n) || this._eventListeners.set(n, []), this._eventListeners.set(n, (null !== (i = this._eventListeners.get(n)) && void 0 !== i ? i : []).concat(r)), this._eventCallbacks.set(r, [n, e]), void 0 !== this._onLogsSubscriptionId || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (s, o) => {
                        if (!s.err)
                            for (const a of this._eventParser.parseLogs(s.logs)) {
                                const c = this._eventListeners.get(a.name);
                                c && c.forEach(u => {
                                    const h = this._eventCallbacks.get(u);
                                    if (h) {
                                        const [, m] = h;
                                        m(a.data, o.slot, s.signature)
                                    }
                                })
                            }
                    })), r
                }
                removeEventListener(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        const i = e._eventCallbacks.get(n);
                        if (!i) throw new Error(`Event listener ${n} doesn't exist!`);
                        const [r] = i;
                        let s = e._eventListeners.get(r);
                        if (!s) throw new Error(`Event listeners don't exist for ${r}!`);
                        if (e._eventCallbacks.delete(n), s = s.filter(o => o !== n), e._eventListeners.set(r, s), 0 === s.length && e._eventListeners.delete(r), 0 === e._eventCallbacks.size) {
                            if (0 !== e._eventListeners.size) throw new Error(`Expected event listeners size to be 0 but got ${e._eventListeners.size}`);
                            void 0 !== e._onLogsSubscriptionId && (yield e._provider.connection.removeOnLogsListener(e._onLogsSubscriptionId), e._onLogsSubscriptionId = void 0)
                        }
                    })()
                }
            }
            class T7 {
                constructor(n, e) {
                    this.coder = e, this.programId = n
                }* parseLogs(n, e = !1) {
                    const i = new Lve(n),
                        r = new Ove;
                    let s = i.next();
                    for (; null !== s;) {
                        let [o, a, c] = this.handleLog(r, s, e);
                        o && (yield o), a && r.push(a), c && r.pop(), s = i.next()
                    }
                }
                handleLog(n, e, i) {
                    return n.stack.length > 0 && n.program() === this.programId.toString() ? this.handleProgramLog(e, i) : [null, ...this.handleSystemLog(e)]
                }
                handleProgramLog(n, e) {
                    if (n.startsWith(vI) || n.startsWith("Program data: ")) {
                        const i = n.startsWith(vI) ? n.slice(13) : n.slice(14),
                            r = this.coder.events.decode(i);
                        if (e && null === r) throw new Error(`Unable to decode event ${i}`);
                        return [r, null, !1]
                    }
                    return [null, ...this.handleSystemLog(n)]
                }
                handleSystemLog(n) {
                    const e = n.split(":")[0];
                    return null !== e.match(/^Program (.*) success/g) ? [null, !0] : e.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : e.includes("invoke") ? ["cpi", !1] : [null, !1]
                }
            }
            class Ove {
                constructor() {
                    this.stack = []
                }
                program() {
                    if (!this.stack.length) throw new Error("Expected the stack to have elements");
                    return this.stack[this.stack.length - 1]
                }
                push(n) {
                    this.stack.push(n)
                }
                pop() {
                    if (!this.stack.length) throw new Error("Expected the stack to have elements");
                    this.stack.pop()
                }
            }
            class Lve {
                constructor(n) {
                    this.logs = n
                }
                next() {
                    if (0 === this.logs.length) return null;
                    let n = this.logs[0];
                    return this.logs = this.logs.slice(1), n
                }
            }
            class Rve {
                static build(n, e, i, r, s, o, a) {
                    return function() {
                        var u = (0, Ze.Z)(function*(...h) {
                            var m;
                            const x = e(...h),
                                [, D] = C1(n, [...h]);
                            let V;
                            if (void 0 === r.simulate) throw new Error("This function requires 'Provider.simulate' to be implemented.");
                            try {
                                V = yield r.simulate(x, D.signers, null === (m = D.options) || void 0 === m ? void 0 : m.commitment)
                            } catch (_e) {
                                throw s7(_e, i)
                            }
                            if (void 0 === V) throw new Error("Unable to simulate transaction");
                            const te = V.logs;
                            if (!te) throw new Error("Simulated logs not found");
                            const ee = [];
                            if (a.events) {
                                let _e = new T7(o, s);
                                for (const ye of _e.parseLogs(te)) ee.push(ye)
                            }
                            return {
                                events: ee,
                                raw: te
                            }
                        });
                        return function() {
                            return u.apply(this, arguments)
                        }
                    }()
                }
            }

            function bI(t) {
                return new S7(S_(8), n => xI.fromBuffer(n), n => n.toBuffer(), t)
            }

            function S1(t) {
                return new S7(S_(32), n => new Mr.PublicKey(n), n => n.toBuffer(), t)
            }

            function wI(t, n) {
                return new Bve(t, n)
            }
            class S7 extends b1 {
                constructor(n, e, i, r) {
                    super(n.span, r), this.layout = n, this.decoder = e, this.encoder = i
                }
                decode(n, e) {
                    return this.decoder(this.layout.decode(n, e))
                }
                encode(n, e, i) {
                    return this.layout.encode(this.encoder(n), e, i)
                }
                getSpan(n, e) {
                    return this.layout.getSpan(n, e)
                }
            }
            class Bve extends b1 {
                constructor(n, e) {
                    super(-1, e), this.layout = n, this.discriminator = ld()
                }
                encode(n, e, i = 0) {
                    return null == n ? this.layout.span + this.discriminator.encode(0, e, i) : (this.discriminator.encode(1, e, i), this.layout.encode(n, e, i + 4) + 4)
                }
                decode(n, e = 0) {
                    const i = this.discriminator.decode(n, e);
                    if (0 === i) return null;
                    if (1 === i) return this.layout.decode(n, e + 4);
                    throw new Error("Invalid coption " + this.layout.property)
                }
                getSpan(n, e = 0) {
                    return this.layout.getSpan(n, e + 4) + 4
                }
            }
            class xI extends(xU()) {
                toBuffer() {
                    const n = super.toArray().reverse(),
                        e = Buffer.from(n);
                    if (8 === e.length) return e;
                    if (e.length >= 8) throw new Error("u64 too large");
                    const i = Buffer.alloc(8);
                    return e.copy(i), i
                }
                static fromBuffer(n) {
                    if (8 !== n.length) throw new Error(`Invalid buffer length: ${n.length}`);
                    return new xI([...n].reverse().map(e => `00${e.toString(16)}`.slice(-2)).join(""), 16)
                }
            }
            const Nve = bo([S1("mint"), S1("owner"), bI("amount"), wI(S1(), "delegate"), (t => {
                const n = _7(new w1(1, "discriminator"), null, "state");
                return n.addVariant(0, bo([]), "uninitialized"), n.addVariant(1, bo([]), "initialized"), n.addVariant(2, bo([]), "frozen"), n
            })(), wI(bI(), "isNative"), bI("delegatedAmount"), wI(S1(), "closeAuthority")]);
            class D_ {
                constructor(n, e, i, r, s, o, a, c) {
                    this._accounts = e, this._provider = i, this._programId = r, this._idlIx = s, this._idlTypes = a, this._customResolver = c, this._args = n, this._accountStore = new Vve(i, o, this._programId)
                }
                args(n) {
                    this._args = n
                }
                resolve() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        for (yield n.resolveConst(n._idlIx.accounts), n._resolveEventCpi(n._idlIx.accounts);
                            (yield n.resolvePdas(n._idlIx.accounts)) + (yield n.resolveRelations(n._idlIx.accounts)) + (yield n.resolveCustom()) > 0;);
                    })()
                }
                resolveCustom() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        if (n._customResolver) {
                            const {
                                accounts: e,
                                resolved: i
                            } = yield n._customResolver({
                                args: n._args,
                                accounts: n._accounts,
                                provider: n._provider,
                                programId: n._programId,
                                idlIx: n._idlIx
                            });
                            return n._accounts = e, i
                        }
                        return 0
                    })()
                }
                resolveOptionalsHelper(n, e) {
                    const i = {};
                    for (const r of e) {
                        const s = r.name,
                            o = n[s];
                        void 0 !== o && (E7(o) ? i[s] = bve(r) ? this.resolveOptionalsHelper(o, r.accounts) : D7(o, !0) : null !== o ? i[s] = Ec(o) : r.isOptional && (i[s] = this._programId))
                    }
                    return i
                }
                resolveOptionals(n) {
                    Object.assign(this._accounts, this.resolveOptionalsHelper(n, this._idlIx.accounts))
                }
                get(n) {
                    const e = n.reduce((i, r) => i && i[r], this._accounts);
                    if (e && e.toBase58) return e
                }
                set(n, e) {
                    let i = this._accounts;
                    n.forEach((r, s) => {
                        s == n.length - 1 && (i[r] = e), i[r] = i[r] || {}, i = i[r]
                    })
                }
                resolveConst(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        for (let r = 0; r < n.length; r += 1) {
                            const s = n[r],
                                o = s.accounts;
                            o && (yield i.resolveConst(o, [...e, bs()(s.name)]));
                            const a = s,
                                c = bs()(s.name);
                            if (a.isSigner && !i.get([...e, c])) {
                                if (void 0 === i._provider.wallet) throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
                                i.set([...e, c], i._provider.wallet.publicKey)
                            }
                            Reflect.has(D_.CONST_ACCOUNTS, c) && !i.get([...e, c]) && i.set([...e, c], D_.CONST_ACCOUNTS[c])
                        }
                    })()
                }
                _resolveEventCpi(n, e = []) {
                    for (const i in n) {
                        const r = n[i],
                            s = r.accounts;
                        s && this._resolveEventCpi(s, [...e, bs()(r.name)]);
                        const o = +i + 1;
                        if (o === n.length) return;
                        const a = bs()(n[i].name),
                            c = bs()(n[o].name);
                        if ("eventAuthority" === a && "program" === c) {
                            const u = [...e, a],
                                h = [...e, c];
                            return this.get(u) || this.set(u, Mr.PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]), void(this.get(h) || this.set(h, this._programId))
                        }
                    }
                }
                resolvePdas(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        let r = 0;
                        for (let s = 0; s < n.length; s += 1) {
                            const o = n[s],
                                a = o.accounts;
                            a && (r += (yield i.resolvePdas(a, [...e, bs()(o.name)])));
                            const c = o,
                                u = bs()(o.name);
                            c.pda && c.pda.seeds.length > 0 && !i.get([...e, u]) && (yield i.autoPopulatePda(c, e)) && (r += 1)
                        }
                        return r
                    })()
                }
                resolveRelations(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        let r = 0;
                        for (let s = 0; s < n.length; s += 1) {
                            const o = n[s],
                                a = o.accounts;
                            a && (r += (yield i.resolveRelations(a, [...e, bs()(o.name)])));
                            const c = o.relations || [],
                                u = bs()(o.name),
                                h = [...e, u],
                                m = i.get(h);
                            if (m) {
                                const x = c.filter(D => !i.get([...e, bs()(D)]));
                                if (r += x.length, x.length > 0) {
                                    const D = yield i._accountStore.fetchAccount({
                                        publicKey: m
                                    });
                                    yield Promise.all(x.map(function() {
                                        var V = (0, Ze.Z)(function*(te) {
                                            const ee = bs()(te);
                                            return i.set([...e, ee], D[ee]), D[ee]
                                        });
                                        return function(te) {
                                            return V.apply(this, arguments)
                                        }
                                    }()))
                                }
                            }
                        }
                        return r
                    })()
                }
                autoPopulatePda(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        if (!n.pda || !n.pda.seeds) throw new Error("Must have seeds");
                        const r = yield Promise.all(n.pda.seeds.map(a => i.toBuffer(a, e)));
                        if (r.some(a => typeof a > "u")) return;
                        const s = yield i.parseProgramId(n, e);
                        if (!s) return;
                        const [o] = yield Mr.PublicKey.findProgramAddress(r, s);
                        i.set([...e, bs()(n.name)], o)
                    })()
                }
                parseProgramId(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        var r;
                        if (null === (r = n.pda) || void 0 === r || !r.programId) return i._programId;
                        switch (n.pda.programId.kind) {
                            case "const":
                                return new Mr.PublicKey(i.toBufferConst(n.pda.programId.value));
                            case "arg":
                                return i.argValue(n.pda.programId);
                            case "account":
                                return yield i.accountValue(n.pda.programId, e);
                            default:
                                throw new Error(`Unexpected program seed kind: ${n.pda.programId.kind}`)
                        }
                    })()
                }
                toBuffer(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        switch (n.kind) {
                            case "const":
                                return i.toBufferConst(n);
                            case "arg":
                                return yield i.toBufferArg(n);
                            case "account":
                                return yield i.toBufferAccount(n, e);
                            default:
                                throw new Error(`Unexpected seed kind: ${n.kind}`)
                        }
                    })()
                }
                getType(n, e = []) {
                    if (e.length > 0 && n.defined) {
                        const i = this._idlTypes.find(o => o.name === n.defined);
                        if (!i) throw new Error(`Cannot find type ${n.defined}`);
                        const s = i.type.fields.find(o => o.name === e[0]);
                        return this.getType(s.type, e.slice(1))
                    }
                    return n
                }
                toBufferConst(n) {
                    return this.toBufferValue(this.getType(n.type, (n.path || "").split(".").slice(1)), n.value)
                }
                toBufferArg(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        const i = e.argValue(n);
                        if (!(typeof i > "u")) return e.toBufferValue(e.getType(n.type, (n.path || "").split(".").slice(1)), i)
                    })()
                }
                argValue(n) {
                    const e = n.path.split("."),
                        i = bs()(e[0]),
                        r = this._idlIx.args.findIndex(s => s.name === i);
                    if (-1 === r) throw new Error(`Unable to find argument for seed: ${i}`);
                    return e.slice(1).reduce((s, o) => (s || {})[o], this._args[r])
                }
                toBufferAccount(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const r = yield i.accountValue(n, e);
                        if (r) return i.toBufferValue(n.type, r)
                    })()
                }
                accountValue(n, e = []) {
                    var i = this;
                    return (0, Ze.Z)(function*() {
                        const r = n.path.split("."),
                            s = r[0],
                            o = i.get([...e, bs()(s)]);
                        if (null === o) throw new Error("fieldPubkey is null");
                        if (1 === r.length) return o;
                        const a = yield i._accountStore.fetchAccount({
                            publicKey: o,
                            name: n.account
                        });
                        return i.parseAccountValue(a, r.slice(1))
                    })()
                }
                parseAccountValue(n, e) {
                    let i;
                    for (; e.length > 0;) i = n[bs()(e[0])], e = e.slice(1);
                    return i
                }
                toBufferValue(n, e) {
                    switch (n) {
                        case "u8":
                            return Buffer.from([e]);
                        case "u16":
                            let i = Buffer.alloc(2);
                            return i.writeUInt16LE(e), i;
                        case "u32":
                            let r = Buffer.alloc(4);
                            return r.writeUInt32LE(e), r;
                        case "u64":
                            let s = Buffer.alloc(8);
                            return s.writeBigUInt64LE(BigInt(e)), s;
                        case "string":
                            return Buffer.from(function GH(t) {
                                return (new TextEncoder).encode(t)
                            }(e));
                        case "publicKey":
                            return e.toBuffer();
                        default:
                            if (n.array) return Buffer.from(e);
                            throw new Error(`Unexpected seed type: ${n}`)
                    }
                }
            }
            D_.CONST_ACCOUNTS = {
                associatedTokenProgram: fI,
                rent: Mr.SYSVAR_RENT_PUBKEY,
                systemProgram: Mr.SystemProgram.programId,
                tokenProgram: hI,
                clock: Mr.SYSVAR_CLOCK_PUBKEY
            };
            class Vve {
                constructor(n, e, i) {
                    this._provider = n, this._programId = i, this._cache = new Map, this._idls = {}, this._idls[i.toBase58()] = e
                }
                ensureIdl(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        if (!e._idls[n.toBase58()]) {
                            const i = yield op.fetchIdl(n, e._provider);
                            if (i) {
                                const r = new op(i, n, e._provider);
                                e._idls[n.toBase58()] = r.account
                            }
                        }
                        return e._idls[n.toBase58()]
                    })()
                }
                fetchAccount({
                    publicKey: n,
                    name: e,
                    programId: i = this._programId
                }) {
                    var r = this;
                    return (0, Ze.Z)(function*() {
                        const s = n.toString();
                        if (!r._cache.has(s))
                            if ("TokenAccount" === e) {
                                const o = yield r._provider.connection.getAccountInfo(n);
                                if (null === o) throw new Error(`invalid account info for ${s}`);
                                const a = function Fve(t) {
                                    return Nve.decode(t)
                                }(o.data);
                                r._cache.set(s, a)
                            } else if (e) {
                            const o = yield r.ensureIdl(i);
                            if (o) {
                                const a = o[bs()(e)];
                                if (a) {
                                    const c = yield a.fetch(n);
                                    r._cache.set(s, c)
                                }
                            }
                        } else {
                            const o = yield r._provider.connection.getAccountInfo(n);
                            if (null === o) throw new Error(`invalid account info for ${s}`);
                            const a = o.data,
                                c = yield r.ensureIdl(o.owner);
                            if (c) {
                                const u = Object.values(c)[0];
                                if (!u) throw new Error("No accounts for this program");
                                const h = u.coder.accounts.decodeAny(a);
                                r._cache.set(s, h)
                            }
                        }
                        return r._cache.get(s)
                    })()
                }
            }
            class Uve {
                static build(n, e, i, r, s, o, a, c, u, h, m) {
                    return (...x) => new Hve(x, r, s, o, a, c, n, e, i, u, h, m)
                }
            }

            function E7(t) {
                return "object" == typeof t && null !== t && !("_bn" in t)
            }

            function D7(t, n) {
                const e = {};
                for (const i in t) {
                    const r = t[i];
                    if (null !== r) e[i] = E7(r) ? D7(r, !0) : Ec(r);
                    else if (n) throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!")
                }
                return e
            }
            class Hve {
                constructor(n, e, i, r, s, o, a, c, u, h, m, x) {
                    this._ixFn = e, this._txFn = i, this._rpcFn = r, this._simulateFn = s, this._viewFn = o, this._programId = c, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._autoResolveAccounts = !0, this._args = n, this._accountsResolver = new D_(n, this._accounts, a, c, u, h, m, x)
                }
                args(n) {
                    this._args = n, this._accountsResolver.args(n)
                }
                pubkeys() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        return n._autoResolveAccounts && (yield n._accountsResolver.resolve()), n._accounts
                    })()
                }
                accounts(n) {
                    return this._autoResolveAccounts = !0, this._accountsResolver.resolveOptionals(n), this
                }
                accountsStrict(n) {
                    return this._autoResolveAccounts = !1, this._accountsResolver.resolveOptionals(n), this
                }
                signers(n) {
                    return this._signers = this._signers.concat(n), this
                }
                remainingAccounts(n) {
                    return this._remainingAccounts = this._remainingAccounts.concat(n), this
                }
                preInstructions(n) {
                    return this._preInstructions = this._preInstructions.concat(n), this
                }
                postInstructions(n) {
                    return this._postInstructions = this._postInstructions.concat(n), this
                }
                rpc(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        return e._autoResolveAccounts && (yield e._accountsResolver.resolve()), e._rpcFn(...e._args, {
                            accounts: e._accounts,
                            signers: e._signers,
                            remainingAccounts: e._remainingAccounts,
                            preInstructions: e._preInstructions,
                            postInstructions: e._postInstructions,
                            options: n
                        })
                    })()
                }
                rpcAndKeys(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        return {
                            pubkeys: yield e.pubkeys(), signature: yield e.rpc(n)
                        }
                    })()
                }
                view(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        if (e._autoResolveAccounts && (yield e._accountsResolver.resolve()), !e._viewFn) throw new Error("Method does not support views");
                        return e._viewFn(...e._args, {
                            accounts: e._accounts,
                            signers: e._signers,
                            remainingAccounts: e._remainingAccounts,
                            preInstructions: e._preInstructions,
                            postInstructions: e._postInstructions,
                            options: n
                        })
                    })()
                }
                simulate(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        return e._autoResolveAccounts && (yield e._accountsResolver.resolve()), e._simulateFn(...e._args, {
                            accounts: e._accounts,
                            signers: e._signers,
                            remainingAccounts: e._remainingAccounts,
                            preInstructions: e._preInstructions,
                            postInstructions: e._postInstructions,
                            options: n
                        })
                    })()
                }
                instruction() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        return n._autoResolveAccounts && (yield n._accountsResolver.resolve()), n._ixFn(...n._args, {
                            accounts: n._accounts,
                            signers: n._signers,
                            remainingAccounts: n._remainingAccounts,
                            preInstructions: n._preInstructions,
                            postInstructions: n._postInstructions
                        })
                    })()
                }
                prepare() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        return {
                            instruction: yield n.instruction(), pubkeys: yield n.pubkeys(), signers: yield n._signers
                        }
                    })()
                }
                transaction() {
                    var n = this;
                    return (0, Ze.Z)(function*() {
                        return n._autoResolveAccounts && (yield n._accountsResolver.resolve()), n._txFn(...n._args, {
                            accounts: n._accounts,
                            signers: n._signers,
                            remainingAccounts: n._remainingAccounts,
                            preInstructions: n._preInstructions,
                            postInstructions: n._postInstructions
                        })
                    })()
                }
            }
            class $ve {
                static build(n, e, i, r) {
                    return e.accounts.find(c => c.isMut) || !e.returns ? void 0 : function() {
                        var c = (0, Ze.Z)(function*(...u) {
                            var h, m;
                            let x = yield i(...u);
                            const D = `Program return: ${n} `;
                            let V = x.raw.find(ye => ye.startsWith(D));
                            if (!V) throw new Error("View expected return log");
                            let te = WM(V.slice(D.length)),
                                ee = e.returns;
                            if (!ee) throw new Error("View expected return type");
                            return Qa.fieldLayout({
                                type: ee
                            }, Array.from([...null !== (h = r.accounts) && void 0 !== h ? h : [], ...null !== (m = r.types) && void 0 !== m ? m : []])).decode(te)
                        });
                        return function() {
                            return c.apply(this, arguments)
                        }
                    }()
                }
            }
            class zve {
                static build(n, e, i, r, s) {
                    const o = {},
                        a = {},
                        c = {},
                        u = {},
                        h = {},
                        m = {},
                        x = function J0e(t) {
                            const n = new Map;
                            return t.errors && t.errors.forEach(e => {
                                var i;
                                let r = null !== (i = e.msg) && void 0 !== i ? i : e.name;
                                n.set(e.code, r)
                            }), n
                        }(n),
                        D = n.accounts ? Ave.build(n, e, i, r) : {};
                    return n.instructions.forEach(V => {
                        const te = T1.build(V, (ht, vt) => e.instruction.encode(ht, vt), i),
                            ee = Eve.build(V, te),
                            _e = Dve.build(V, ee, x, r),
                            ye = Rve.build(V, ee, x, r, e, i, n),
                            Be = $ve.build(i, V, ye, n),
                            ze = Uve.build(r, i, V, te, ee, _e, ye, Be, D, n.types || [], s && s(V)),
                            Xe = bs()(V.name);
                        a[Xe] = te, c[Xe] = ee, o[Xe] = _e, u[Xe] = ye, h[Xe] = ze, Be && (m[Xe] = Be)
                    }), [o, a, c, D, u, h, m]
                }
            }
            class op {
                get programId() {
                    return this._programId
                }
                get idl() {
                    return this._idl
                }
                get coder() {
                    return this._coder
                }
                get provider() {
                    return this._provider
                }
                constructor(n, e, i, r, s) {
                    e = Ec(e), i || (i = y1()), this._idl = n, this._provider = i, this._programId = e, this._coder = r ? ? new u7(n), this._events = new Pve(this._programId, i, this._coder);
                    const [o, a, c, u, h, m, x] = zve.build(n, this._coder, e, i, s ? ? (() => {}));
                    this.rpc = o, this.instruction = a, this.transaction = c, this.account = u, this.simulate = h, this.methods = m, this.views = x
                }
                static at(n, e) {
                    return (0, Ze.Z)(function*() {
                        const i = Ec(n),
                            r = yield op.fetchIdl(i, e);
                        if (!r) throw new Error(`IDL not found for program: ${n.toString()}`);
                        return new op(r, i, e)
                    })()
                }
                static fetchIdl(n, e) {
                    return (0, Ze.Z)(function*() {
                        e = e ? ? y1();
                        const i = Ec(n),
                            r = yield function wve(t) {
                                return _I.apply(this, arguments)
                            }(i), s = yield e.connection.getAccountInfo(r);
                        if (!s) return null;
                        let o = function Tve(t) {
                            return Cve.decode(t)
                        }(s.data.slice(8));
                        const a = jH(o.data);
                        return JSON.parse(function WH(t) {
                            return new TextDecoder("utf-8").decode(t)
                        }(a))
                    })()
                }
                addEventListener(n, e) {
                    return this._events.addEventListener(n, e)
                }
                removeEventListener(n) {
                    var e = this;
                    return (0, Ze.Z)(function*() {
                        return yield e._events.removeEventListener(n)
                    })()
                }
            }
            new Mr.PublicKey("11111111111111111111111111111111");
            var Kve = T(13519),
                CI = T.n(Kve);
            let A_ = (() => {
                class t {
                    constructor() {}
                    messsageAlert(e, i) {
                        let r;
                        r = "error" === e ? "bg-danger" : "success" === e ? "bg-success" : "info" === e ? "bg-info" : "warning" === e ? "bg-warning" : "bg-light";
                        const s = {
                            position: "bottom-end",
                            timer: 4e7,
                            toast: !0,
                            timerProgressBar: !0,
                            showConfirmButton: !1,
                            iconColor: "#fff",
                            icon: e,
                            text: i,
                            customClass: {
                                popup: "d-flex align-items-center rounded-sm " + r,
                                htmlContainer: "fw-semibold fs-5 text-white"
                            }
                        };
                        return CI().fire(s)
                    }
                    messagePopup(e, i, r, s, o, a) {
                        const c = {
                            iconHtml: '<img src="./assets/images/popup-icons/' + e + '.svg" alt="' + e + '" height="80">',
                            titleText: r || void 0,
                            text: i,
                            showDenyButton: !!o,
                            showCancelButton: !!a,
                            confirmButtonText: s || "OK",
                            denyButtonText: o,
                            cancelButtonText: a,
                            buttonsStyling: !1,
                            customClass: {
                                icon: "border-0",
                                popup: "rounded-4 shadow-md",
                                title: "fs-2 fw-semibold pt-4",
                                htmlContainer: "fw-regular fs-5 my-3",
                                confirmButton: "btn btn-sm btn-success w-100 py-2 px-3 rounded-1 border-0",
                                denyButton: "btn btn-sm py-2 w-100 px-3 btn-tertiary mt-2",
                                cancelButton: "btn btn-sm py-2 w-100 px-3 btn-warning"
                            }
                        };
                        return CI().fire(c)
                    }
                    close() {
                        return CI().close()
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            const k7 = T(60949),
                qve = T(16530),
                Zve = T(27008),
                Yve = T(40625),
                Xve = T(91887),
                Qve = T(83447),
                Jve = T(60325),
                ebe = T(13002),
                tbe = T(43771),
                nbe = T(73018),
                ibe = T(71612),
                rbe = T(33997),
                sbe = T(75525),
                Dh = {
                    address: nt.stakingAddress,
                    abi: rbe.abi
                },
                ec = {
                    address: nt.eth.presaleAddress,
                    abi: k7.abi
                },
                M7 = {
                    address: nt.eth.usdTAddress,
                    abi: qve.abi
                },
                ap = {
                    address: nt.bsc.presaleAddress,
                    abi: Zve.abi
                },
                obe = {
                    address: nt.bsc.usdTAddress,
                    abi: Yve.abi
                },
                cp = {
                    address: nt.poly.presaleAddress,
                    abi: Xve.abi
                },
                abe = {
                    address: nt.poly.usdTAddress,
                    abi: Qve.abi
                },
                lp = {
                    address: nt.avalanche.presaleAddress,
                    abi: Jve.abi
                },
                cbe = {
                    address: nt.avalanche.usdTAddress,
                    abi: ebe.abi
                },
                up = {
                    address: nt.base.presaleAddress,
                    abi: tbe.abi
                },
                lbe = {
                    address: nt.base.usdTAddress,
                    abi: nbe.abi
                },
                I7 = {
                    address: nt.tokenAddress,
                    abi: sbe.abi
                };
            let dp = (() => {
                class t {
                    http;
                    appRef;
                    eventService;
                    popupService;
                    transletService;
                    stateInfoAddress;
                    program;
                    provider;
                    connection;
                    swapStatus = Ki.not_started;
                    walletAddress = "";
                    referUrl = "";
                    client;
                    wagmiData;
                    chainId;
                    mode;
                    presaleData;
                    swapHash = "";
                    refreshId;
                    refreshRate = 5e3;
                    metaMaskConnector;
                    walletConnector;
                    walletConnectorBW;
                    uriConnector;
                    coinbaseConnector;
                    balanceData = {
                        nativeBal: 0,
                        usdtBal: 0,
                        ethTokenSold: 0,
                        bscTokenSold: 0,
                        totalTokensSold: 0,
                        ethClaimable: 0,
                        bscClaimable: 0,
                        userClaimable: 0,
                        polyTokenSold: 0,
                        polyClaimable: 0,
                        avalancheTokenSold: 0,
                        avalancheClaimable: 0,
                        baseTokenSold: 0,
                        baseClaimable: 0,
                        startTime: "",
                        endTime: "",
                        paused: !1,
                        currentStep: 0,
                        usdRaised: 0,
                        usdRaisedSol: 0,
                        maxTokensToBuy: 0,
                        oneEth: 0,
                        oneBnb: 0,
                        ethUsdt: 0,
                        bnbUsdt: 0,
                        polyUsdt: 0,
                        onePoly: 0,
                        oneAvalanche: 0,
                        avalancheUsdt: 0,
                        oneBase: 0,
                        baseUsdt: 0,
                        maxAmount: 0
                    };
                    stakeData = {
                        userStaked: 0,
                        totalStaked: 0,
                        rewardPerRound: 0,
                        userPoolPercent: 0,
                        apy: 0,
                        unlockTime: 0,
                        userReward: 0,
                        userBal: 0,
                        isClaimEnabled: !1,
                        userCount: 0,
                        tokenPrice: 0,
                        planId: 0,
                        stackPercent: 0,
                        rewardsPA: 0,
                        rewardsPaid: 0
                    };
                    tokenomics = [{
                        minToken: 0,
                        maxToken: 3e9,
                        maxAmount: 87e4,
                        tokenUSDT: 29e-5,
                        title: "widget.round_title",
                        endDate: 1706954399
                    }, {
                        minToken: 3e9,
                        maxToken: 6e9,
                        maxAmount: 1743e3,
                        tokenUSDT: 291e-6,
                        title: "widget.round_title",
                        endDate: 1707127199
                    }, {
                        minToken: 6e9,
                        maxToken: 9e9,
                        maxAmount: 2619e3,
                        tokenUSDT: 292e-6,
                        title: "widget.round_title",
                        endDate: 1707299999
                    }, {
                        minToken: 9e9,
                        maxToken: 12e9,
                        maxAmount: 3498e3,
                        tokenUSDT: 293e-6,
                        title: "widget.round_title",
                        endDate: 1707472799
                    }, {
                        minToken: 12e9,
                        maxToken: 15e9,
                        maxAmount: 438e4,
                        tokenUSDT: 294e-6,
                        title: "widget.round_title",
                        endDate: 1707645599
                    }, {
                        minToken: 15e9,
                        maxToken: 18e9,
                        maxAmount: 5265e3,
                        tokenUSDT: 295e-6,
                        title: "widget.round_title",
                        endDate: 1707818399
                    }, {
                        minToken: 18e9,
                        maxToken: 21e9,
                        maxAmount: 6153e3,
                        tokenUSDT: 296e-6,
                        title: "widget.round_title",
                        endDate: 1706954399
                    }, {
                        minToken: 21e9,
                        maxToken: 24e9,
                        maxAmount: 7044e3,
                        tokenUSDT: 297e-6,
                        title: "widget.round_title",
                        endDate: 1707127199
                    }, {
                        minToken: 24e9,
                        maxToken: 27e9,
                        maxAmount: 7938e3,
                        tokenUSDT: 298e-6,
                        title: "widget.round_title",
                        endDate: 1707299999
                    }, {
                        minToken: 27e9,
                        maxToken: 3e10,
                        maxAmount: 8835e3,
                        tokenUSDT: 299e-6,
                        title: "widget.round_title",
                        endDate: 1707472799
                    }, {
                        minToken: 3e10,
                        maxToken: 345e8,
                        maxAmount: 10185e3,
                        tokenUSDT: 3e-4,
                        title: "widget.round_title",
                        endDate: 1707645599
                    }, {
                        minToken: 345e8,
                        maxToken: 39e9,
                        maxAmount: 11539500,
                        tokenUSDT: 301e-6,
                        title: "widget.round_title",
                        endDate: 1707818399
                    }, {
                        minToken: 39e9,
                        maxToken: 435e8,
                        maxAmount: 12898500,
                        tokenUSDT: 302e-6,
                        title: "widget.round_title",
                        endDate: 1706954399
                    }, {
                        minToken: 435e8,
                        maxToken: 48e9,
                        maxAmount: 14262e3,
                        tokenUSDT: 303e-6,
                        title: "widget.round_title",
                        endDate: 1707127199
                    }, {
                        minToken: 48e9,
                        maxToken: 525e8,
                        maxAmount: 1563e4,
                        tokenUSDT: 304e-6,
                        title: "widget.round_title",
                        endDate: 1707299999
                    }, {
                        minToken: 525e8,
                        maxToken: 57e9,
                        maxAmount: 17002500,
                        tokenUSDT: 305e-6,
                        title: "widget.round_title",
                        endDate: 1707472799
                    }, {
                        minToken: 57e9,
                        maxToken: 1e11,
                        maxAmount: 30332500,
                        tokenUSDT: 31e-5,
                        title: "widget.round_title",
                        endDate: 1707645599
                    }];
                    tokenomics2;
                    viemClient;
                    isBW = !1;
                    curWalletName = "";
                    programId = new Mr.PublicKey(nt.solana.presaleAddress);
                    constructor(e, i, r, s, o) {
                        this.http = e, this.appRef = i, this.eventService = r, this.popupService = s, this.transletService = o, this.connection = new Mr.Connection(nt.solana.rpcUrl, "processed"), this.provider = new n7(this.connection, this.getWindowObject(), "processed"), this.setProgram();
                        let a = JSON.stringify(this.tokenomics);
                        this.tokenomics2 = JSON.parse(a);
                        const c = nt.production ? [GD, $me, zme, jme, Wme] : [Gme, Kme, qme, Zme, Yme],
                            {
                                chains: u,
                                publicClient: h,
                                webSocketPublicClient: m
                            } = function gme(t, n, {
                                batch: e = {
                                    multicall: {
                                        wait: 32
                                    }
                                },
                                pollingInterval: i = 4e3,
                                rank: r,
                                retryCount: s,
                                retryDelay: o,
                                stallTimeout: a
                            } = {}) {
                                if (!t.length) throw new Error("must have at least one chain");
                                let c = [];
                                const u = {},
                                    h = {};
                                for (const m of t) {
                                    let x = !1;
                                    for (const D of n) {
                                        const V = D(m);
                                        V && (x = !0, c.some(({
                                            id: te
                                        }) => te === m.id) || (c = [...c, V.chain]), u[m.id] = [...u[m.id] || [], ...V.rpcUrls.http], V.rpcUrls.webSocket && (h[m.id] = [...h[m.id] || [], ...V.rpcUrls.webSocket]))
                                    }
                                    if (!x) throw new Error([`Could not find valid provider configuration for chain "${m.name}".\n`, "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.", "Read more: https://wagmi.sh/core/providers/jsonRpc"].join("\n"))
                                }
                                return {
                                    chains: c,
                                    publicClient: ({
                                        chainId: m
                                    }) => {
                                        const x = c.find(te => te.id === m) ? ? t[0],
                                            D = u[x.id];
                                        if (!D || !D[0]) throw new Error(`No providers configured for chain "${x.id}"`);
                                        const V = _k({
                                            batch: e,
                                            chain: x,
                                            transport: qV(D.map(te => JV(te, {
                                                timeout: a
                                            })), {
                                                rank: r,
                                                retryCount: s,
                                                retryDelay: o
                                            }),
                                            pollingInterval: i
                                        });
                                        return Object.assign(V, {
                                            chains: c
                                        })
                                    },
                                    webSocketPublicClient: ({
                                        chainId: m
                                    }) => {
                                        const x = c.find(te => te.id === m) ? ? t[0],
                                            D = h[x.id];
                                        if (!D || !D[0]) return;
                                        const V = _k({
                                            batch: e,
                                            chain: x,
                                            transport: qV(D.map(te => function cme(t, n = {}) {
                                                const {
                                                    key: e = "webSocket",
                                                    name: i = "WebSocket JSON-RPC",
                                                    retryDelay: r
                                                } = n;
                                                return ({
                                                    chain: s,
                                                    retryCount: o,
                                                    timeout: a
                                                }) => {
                                                    const c = n.retryCount ? ? o,
                                                        u = a ? ? n.timeout ? ? 1e4,
                                                        h = t || s ? .rpcUrls.default.webSocket ? .[0];
                                                    if (!h) throw new ZV;
                                                    return Lx({
                                                        key: e,
                                                        name: i,
                                                        request: ({
                                                            method: m,
                                                            params: x
                                                        }) => (0, Ze.Z)(function*() {
                                                            const D = {
                                                                    method: m,
                                                                    params: x
                                                                },
                                                                V = yield xk(h), {
                                                                    error: te,
                                                                    result: ee
                                                                } = yield ng.webSocketAsync(V, {
                                                                    body: D,
                                                                    timeout: u
                                                                });
                                                            if (te) throw new Dl.bs({
                                                                body: D,
                                                                error: te,
                                                                url: h
                                                            });
                                                            return ee
                                                        })(),
                                                        retryCount: c,
                                                        retryDelay: r,
                                                        timeout: u,
                                                        type: "webSocket"
                                                    }, {
                                                        getSocket: () => xk(h),
                                                        subscribe: ({
                                                            params: m,
                                                            onData: x,
                                                            onError: D
                                                        }) => (0, Ze.Z)(function*() {
                                                            const V = yield xk(h), {
                                                                result: te
                                                            } = yield new Promise((ee, _e) => ng.webSocket(V, {
                                                                body: {
                                                                    method: "eth_subscribe",
                                                                    params: m
                                                                },
                                                                onResponse(ye) {
                                                                    if (ye.error) return _e(ye.error), void D ? .(ye.error);
                                                                    "number" != typeof ye.id ? "eth_subscription" === ye.method && x(ye.params) : ee(ye)
                                                                }
                                                            }));
                                                            return {
                                                                subscriptionId: te,
                                                                unsubscribe: () => (0, Ze.Z)(function*() {
                                                                    return new Promise(ee => ng.webSocket(V, {
                                                                        body: {
                                                                            method: "eth_unsubscribe",
                                                                            params: [te]
                                                                        },
                                                                        onResponse: ee
                                                                    }))
                                                                })()
                                                            }
                                                        })()
                                                    })
                                                }
                                            }(te, {
                                                timeout: a
                                            })), {
                                                rank: r,
                                                retryCount: s,
                                                retryDelay: o
                                            }),
                                            pollingInterval: i
                                        });
                                        return Object.assign(V, {
                                            chains: c
                                        })
                                    }
                                }
                            }(c, nt.production ? [nM({
                                rpc: x => ({
                                    http: x.id === nt.eth.chainIdInt ? nt.eth.rpcURL : x.id === nt.bsc.chainIdInt ? nt.bsc.rpcURL : x.id === nt.poly.chainIdInt ? nt.poly.rpcURL : x.id === nt.avalanche.chainIdInt ? nt.avalanche.rpcURL : nt.base.rpcURL
                                })
                            }), nM({
                                rpc: x => ({
                                    http: x.id === nt.eth.chainIdInt ? nt.eth.backupRPC : x.id === nt.bsc.chainIdInt ? nt.bsc.backupRPC : x.id === nt.poly.chainIdInt ? nt.poly.backupRPC : x.id === nt.avalanche.chainIdInt ? nt.avalanche.backupRPC : nt.base.backupRPC
                                })
                            })] : [nM({
                                rpc: x => ({
                                    http: x.id === nt.eth.chainIdInt ? "https://ethereum-sepolia-rpc.publicnode.com" : x.id === nt.bsc.chainIdInt ? "https://bsc-testnet-rpc.publicnode.com" : x.id === nt.poly.chainIdInt ? "https://polygon-mumbai-pokt.nodies.app" : x.id === nt.avalanche.chainIdInt ? "https://avalanche-fuji-c-chain-rpc.publicnode.com" : "https://sepolia.base.org"
                                })
                            })]);
                        this.metaMaskConnector = new Fme({
                                chains: u
                            }), this.walletConnector = new hM({
                                chains: u,
                                options: {
                                    projectId: nt.walletConnectId,
                                    qrModalOptions: {
                                        explorerRecommendedWalletIds: ["fe68cea63541aa53ce020de7398968566dfe8f3725663a564cac89490247ed49", "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"]
                                    }
                                }
                            }), this.walletConnectorBW = new hM({
                                chains: u,
                                options: {
                                    projectId: nt.walletConnectId,
                                    qrModalOptions: {
                                        explorerRecommendedWalletIds: ["fe68cea63541aa53ce020de7398968566dfe8f3725663a564cac89490247ed49"]
                                    }
                                }
                            }), this.coinbaseConnector = new Ume({
                                chains: u,
                                options: {
                                    appName: "PremiumTokene Inu",
                                    appLogoUrl: "https://PremiumTokeninu.com/assets/images/svg-icons/logo.svg"
                                }
                            }), this.uriConnector = new hM({
                                chains: u,
                                options: {
                                    showQrModal: !1,
                                    projectId: nt.walletConnectId,
                                    qrModalOptions: {
                                        explorerRecommendedWalletIds: ["fe68cea63541aa53ce020de7398968566dfe8f3725663a564cac89490247ed49"]
                                    }
                                }
                            }), this.uriConnector.addListener("message", x => {
                                if ("display_uri" === x.type) {
                                    const D = window.navigator.userAgent.toLowerCase(),
                                        V = /iphone|ipod|ipad/.test(D),
                                        te = HD("bwUrl");
                                    console.log("bwUrl=========>", te);
                                    let ee = x.data + "&callbackUrl=" + window.location.href + "&browser=" + function bfe() {
                                        const t = window.navigator.userAgent.toLowerCase();
                                        switch (!0) {
                                            case t.indexOf("edge") > -1:
                                                return "edge";
                                            case t.indexOf("opr") > -1 && !!window.opr:
                                                return "opera";
                                            case t.indexOf("chrome") > -1 && !!window.chrome:
                                                return "chrome";
                                            case t.indexOf("trident") > -1:
                                                return "ie";
                                            case t.indexOf("firefox") > -1:
                                                return "firefox";
                                            case t.indexOf("safari") > -1:
                                                return "safari";
                                            default:
                                                return "other"
                                        }
                                    }();
                                    if (console.log("url params=========>", ee), console.log("wondow log params=========>", window.location.href), V) {
                                        const _e = document.createElement("a");
                                        te && "" != te ? (_e.href = te + ee, _e.click(), this.isBW = !0) : (_e.href = nt.bwDeepLink + ee, _e.click(), this.isBW = !1)
                                    } else if (te && "" != te) {
                                        const _e = document.createElement("a");
                                        _e.href = te + ee, _e.click(), this.isBW = !0
                                    } else {
                                        const _e = document.createElement("a");
                                        _e.href = nt.bwDeepLink + ee, _e.click(), this.isBW = !1
                                    }
                                }
                            }), this.client = kme({
                                autoConnect: !0,
                                connectors: [this.metaMaskConnector, this.walletConnector, this.walletConnectorBW, this.uriConnector, this.coinbaseConnector],
                                publicClient: h,
                                webSocketPublicClient: m
                            }),
                            function Rme(t, {
                                selector: n = (e => e)
                            } = {}) {
                                Ys().subscribe(({
                                    data: s,
                                    chains: o
                                }) => n({
                                    chainId: s ? .chain ? .id,
                                    chains: o
                                }), () => t(pU()), {
                                    equalityFn: Dk
                                })
                            }(x => {
                                this.chainId = x ? .chain ? .id, this.getPresalesData(), setTimeout(() => this.eventService.setNetwork(), 2e3), this.appRef.tick()
                            }),
                            function Lme(t, {
                                selector: n = (e => e)
                            } = {}) {
                                return Ys().subscribe(({
                                    data: s,
                                    connector: o,
                                    status: a
                                }) => n({
                                    address: s ? .account,
                                    connector: o,
                                    status: a
                                }), () => t(function Pme() {
                                    const {
                                        data: t,
                                        connector: n,
                                        status: e
                                    } = Ys();
                                    switch (e) {
                                        case "connected":
                                            return {
                                                address: t ? .account,
                                                connector: n,
                                                isConnected: !0,
                                                isConnecting: !1,
                                                isDisconnected: !1,
                                                isReconnecting: !1,
                                                status: e
                                            };
                                        case "reconnecting":
                                            return {
                                                address: t ? .account,
                                                connector: n,
                                                isConnected: !!t ? .account,
                                                isConnecting: !1,
                                                isDisconnected: !1,
                                                isReconnecting: !0,
                                                status: e
                                            };
                                        case "connecting":
                                            return {
                                                address: t ? .account,
                                                connector: n,
                                                isConnected: !1,
                                                isConnecting: !0,
                                                isDisconnected: !1,
                                                isReconnecting: !1,
                                                status: e
                                            };
                                        case "disconnected":
                                            return {
                                                address: void 0,
                                                connector: void 0,
                                                isConnected: !1,
                                                isConnecting: !1,
                                                isDisconnected: !0,
                                                isReconnecting: !1,
                                                status: e
                                            }
                                    }
                                }()), {
                                    equalityFn: Dk
                                })
                            }(x => this.setData(x))
                    }
                    connectWallet(e, i = !1) {
                        var r = this;
                        return (0, Ze.Z)(function*() {
                            console.log("connectWallet called", e), r.mode = e, r.windowDataLayer("connectWallet", "start", 1, 1, 0, "", "", 0, 0), yield function Mme(t) {
                                return Ik.apply(this, arguments)
                            }({
                                connector: "metamask" === e ? r.metaMaskConnector : "wallet" === e ? r.walletConnector : "walletBW" === e ? r.walletConnectorBW : "coinbase" === e ? r.coinbaseConnector : "bw" === e ? r.uriConnector : r.walletConnector,
                                chainId: i ? nt.bsc.chainIdInt : nt.eth.chainIdInt
                            }).then(s => {
                                console.log("\n==== wallet connected ====\n", r.client, "\n===="), setTimeout(() => {
                                    r.sendDashFx("", 0, 0, !0), r.windowDataLayer("connectWallet", "successful", 2, 1, 0, "", "", 0, 0)
                                }, 2e3)
                            }, s => {
                                console.log("\n==== wallet connection issue ====\n", s, "\n====")
                            })
                        })()
                    }
                    disConnectWallet() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            yield function Ime() {
                                return Pk.apply(this, arguments)
                            }().then(i => {
                                console.log("\n==== wallet disconnected ====\n", e.client), localStorage.clear(), e.chainId = null, e.walletAddress = "", e.referUrl = "", e.balanceData.nativeBal = 0, e.balanceData.usdtBal = 0, e.eventService.setNetwork(), e.eventService.isConnected = !1, e.getPresalesData()
                            }, i => {
                                console.log("\n==== wallet disconnect issue ====\n"), console.log("disconnect issue =", i)
                            })
                        })()
                    }
                    setData(e) {
                        this.wagmiData = e, this.walletAddress = this.wagmiData.address ? .toLowerCase(), this.refreshRate = e.address ? 5e3 : 5e4, this.eventService.isConnected = !!e.address, this.appRef.tick(), this.getPresalesData(), this.viemClient = _k({
                            chain: GD,
                            transport: JV()
                        })
                    }
                    getPresalesData() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            e.walletAddress && "" == e.referUrl && e.refer(), e.getPresaleData();
                            const i = {
                                contracts: [{ ...ec,
                                    functionName: "totalTokensSold",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ec,
                                    functionName: "ethBuyHelper",
                                    chainId: nt.eth.chainIdInt,
                                    args: [1]
                                }, { ...ec,
                                    functionName: "usdtBuyHelper",
                                    chainId: nt.eth.chainIdInt,
                                    args: [1]
                                }, { ...ec,
                                    functionName: "usdRaised",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ec,
                                    functionName: "maxTokensToBuy",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ec,
                                    functionName: "currentStep",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ec,
                                    functionName: "roundDetails",
                                    chainId: nt.eth.chainIdInt,
                                    args: [2]
                                }, { ...ec,
                                    functionName: "trackRemainingTokens",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ec,
                                    functionName: "userDeposits",
                                    chainId: nt.eth.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...ec,
                                    functionName: "paused",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...ap,
                                    functionName: "totalTokensSold",
                                    chainId: nt.bsc.chainIdInt,
                                    args: []
                                }, { ...ap,
                                    functionName: "bnbBuyHelper",
                                    chainId: nt.bsc.chainIdInt,
                                    args: [1]
                                }, { ...ap,
                                    functionName: "usdtBuyHelper",
                                    chainId: nt.bsc.chainIdInt,
                                    args: [1]
                                }, { ...ap,
                                    functionName: "usdRaised",
                                    chainId: nt.bsc.chainIdInt,
                                    args: []
                                }, { ...ap,
                                    functionName: "trackRemainingTokens",
                                    chainId: nt.bsc.chainIdInt,
                                    args: []
                                }, { ...ap,
                                    functionName: "userDeposits",
                                    chainId: nt.bsc.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...cp,
                                    functionName: "totalTokensSold",
                                    chainId: nt.poly.chainIdInt,
                                    args: []
                                }, { ...cp,
                                    functionName: "maticBuyHelper",
                                    chainId: nt.poly.chainIdInt,
                                    args: [1]
                                }, { ...cp,
                                    functionName: "usdtBuyHelper",
                                    chainId: nt.poly.chainIdInt,
                                    args: [1]
                                }, { ...cp,
                                    functionName: "usdRaised",
                                    chainId: nt.poly.chainIdInt,
                                    args: []
                                }, { ...cp,
                                    functionName: "trackRemainingTokens",
                                    chainId: nt.poly.chainIdInt,
                                    args: []
                                }, { ...cp,
                                    functionName: "userDeposits",
                                    chainId: nt.poly.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...Dh,
                                    functionName: "poolStakers",
                                    chainId: nt.eth.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...Dh,
                                    functionName: "getRewards",
                                    chainId: nt.eth.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...Dh,
                                    functionName: "rewardTokensPerBlock",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...Dh,
                                    functionName: "tokensStaked",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...Dh,
                                    functionName: "harvestLock",
                                    chainId: nt.eth.chainIdInt,
                                    args: []
                                }, { ...lp,
                                    functionName: "totalTokensSold",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: []
                                }, { ...lp,
                                    functionName: "avaxBuyHelper",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: [1]
                                }, { ...lp,
                                    functionName: "usdtBuyHelper",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: [1]
                                }, { ...lp,
                                    functionName: "usdRaised",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: []
                                }, { ...lp,
                                    functionName: "trackRemainingTokens",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: []
                                }, { ...lp,
                                    functionName: "userDeposits",
                                    chainId: nt.avalanche.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }, { ...up,
                                    functionName: "totalTokensSold",
                                    chainId: nt.base.chainIdInt,
                                    args: []
                                }, { ...up,
                                    functionName: "ethBuyHelper",
                                    chainId: nt.base.chainIdInt,
                                    args: [1]
                                }, { ...up,
                                    functionName: "usdcBuyHelper",
                                    chainId: nt.base.chainIdInt,
                                    args: [1]
                                }, { ...up,
                                    functionName: "usdRaised",
                                    chainId: nt.base.chainIdInt,
                                    args: []
                                }, { ...up,
                                    functionName: "trackRemainingTokens",
                                    chainId: nt.base.chainIdInt,
                                    args: []
                                }, { ...up,
                                    functionName: "userDeposits",
                                    chainId: nt.base.chainIdInt,
                                    args: [e.walletAddress || "0x0000000000000000000000000000000000000000"]
                                }]
                            };
                            e.presaleData = yield qf(i), console.log("\n******presaleData =", e.presaleData, "\n******\n");
                            try {
                                e.stakeData.userStaked = +(0, Vs.d)(e.presaleData[22].result[0] || 0), e.stakeData.unlockTime = Number(e.presaleData[22].result[3]), e.stakeData.planId = Number(e.presaleData[22].result[4]), e.stakeData.userReward = +(0, Vs.d)(e.presaleData[23] ? .result || 0), e.stakeData.rewardPerRound = +(0, Vs.d)(e.presaleData[24].result || 0), e.stakeData.totalStaked = +(0, Vs.d)(e.presaleData[25].result || 0), e.stakeData.isClaimEnabled = !e.presaleData[26].result || !1, e.stakeData.apy = +(+nt.apyCalcConst / e.stakeData.totalStaked * 100).toFixed(0)
                            } catch (ye) {
                                console.log("Presale over.", ye)
                            }
                            e.balanceData.currentStep = Number(e.presaleData[5].result), e.balanceData.paused = "success" === e.presaleData[9].status && e.presaleData[9].result, e.balanceData.ethTokenSold = Number(e.presaleData[0].result), e.balanceData.bscTokenSold = Number(e.presaleData[10].result), e.balanceData.polyTokenSold = Number(e.presaleData[16].result), e.balanceData.avalancheTokenSold = Number(e.presaleData[27].result), e.balanceData.baseTokenSold = Number(e.presaleData[33].result), e.balanceData.totalTokensSold = e.balanceData.ethTokenSold + e.balanceData.bscTokenSold + e.balanceData.polyTokenSold + e.balanceData.avalancheTokenSold + e.balanceData.baseTokenSold, e.stakeData.stackPercent = +(e.stakeData.totalStaked / e.balanceData.totalTokensSold * 100).toFixed(0);
                            try {
                                e.balanceData.oneEth = +(0, Vs.d)(e.presaleData[1].result), e.balanceData.ethUsdt = Number(e.presaleData[2].result), e.balanceData.oneBnb = +(0, Vs.d)(e.presaleData[11].result), e.balanceData.bnbUsdt = Number(e.presaleData[12].result), e.balanceData.onePoly = +(0, Vs.d)(e.presaleData[17].result), e.balanceData.polyUsdt = Number(e.presaleData[18].result), e.balanceData.oneAvalanche = +(0, Vs.d)(e.presaleData[28].result), e.balanceData.avalancheUsdt = Number(e.presaleData[29].result), e.balanceData.oneBase = +(0, Vs.d)(e.presaleData[34].result), e.balanceData.baseUsdt = Number(e.presaleData[35].result)
                            } catch (ye) {
                                console.log("Presale over.", ye)
                            }
                            e.balanceData.usdRaised = +(0, Vs.d)(e.presaleData[3].result || 0) + +(0, Vs.d)(e.presaleData[13].result || 0) + +(0, Vs.d)(e.presaleData[19].result || 0) + +(0, Vs.d)(e.presaleData[30].result || 0) + +(0, Vs.d)(e.presaleData[36].result || 0) + e.balanceData.usdRaisedSol, e.balanceData.ethClaimable = +(0, Vs.d)(e.presaleData[8].result || 0), e.balanceData.bscClaimable = +(0, Vs.d)(e.presaleData[15].result || 0), e.balanceData.polyClaimable = +(0, Vs.d)(e.presaleData[21].result || 0), e.balanceData.avalancheClaimable = +(0, Vs.d)(e.presaleData[32].result || 0), e.balanceData.baseClaimable = +(0, Vs.d)(e.presaleData[38].result || 0), e.balanceData.userClaimable = e.balanceData.ethClaimable + e.balanceData.bscClaimable + e.balanceData.polyClaimable + e.balanceData.avalancheClaimable + e.balanceData.baseClaimable;
                            const u = e.skipIndexUpdate(e.presaleData[7].result, []),
                                h = e.skipIndexUpdate(e.presaleData[14].result, []),
                                m = e.skipIndexUpdate(e.presaleData[20].result, []),
                                x = e.skipIndexUpdate(e.presaleData[31].result, []),
                                D = e.skipIndexUpdate(e.presaleData[37].result, []);
                            let V = 0,
                                te = 0;
                            for (let ye of e.presaleData[6].result) {
                                let Be = e.tokenomics[V];
                                if (e.tokenomics[V].endDate = 1e3 * Number(ye), V < e.balanceData.currentStep) {
                                    let Cn = 4 * (Be.maxToken - Be.minToken) - ((u[V] || 0) + (h[V] || 0) + (m[V] || 0) + (x[V] || 0) + (D[V] || 0));
                                    Cn *= Be.tokenUSDT, te += Cn, e.tokenomics[V].maxAmount = Math.ceil(e.tokenomics2[V].maxAmount + te), e.tokenomics[V + 1].maxAmount = Math.ceil(e.tokenomics2[V + 1].maxAmount + te)
                                }
                                V++
                            }
                            const ee = Number(e.presaleData[4].result),
                                _e = e.tokenomics[e.balanceData.currentStep].maxToken - e.soldToken;
                            e.balanceData.maxTokensToBuy = _e > ee ? ee : _e, e.wagmiData ? .isConnected && e.getMetaData(), e.refreshId && clearTimeout(e.refreshId), e.refreshId = setTimeout(() => e.getPresalesData(), e.refreshRate)
                        })()
                    }
                    skipIndexUpdate(e, i) {
                        let r = [];
                        for (let s = 0; s < e.length; s++) i.includes(s) || r.push(Number(e[s]));
                        return r
                    }
                    getMetaData() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            const i = yield fU({
                                address: e.walletAddress,
                                formatUnits: "ether"
                            }), r = yield fU({
                                address: e.walletAddress,
                                token: e.getChainData().usdTAddress,
                                chainId: e.getChainData().chainIdInt
                            });
                            e.balanceData.nativeBal = +i.formatted, e.balanceData.usdtBal = +r.formatted
                        })()
                    }
                    get soldToken() {
                        return this.balanceData.totalTokensSold
                    }
                    isEthChain() {
                        return this.chainId === nt.eth.chainIdInt
                    }
                    switchNetwork(e) {
                        var i = this;
                        return (0, Ze.Z)(function*() {
                            yield function Ome(t) {
                                return jk.apply(this, arguments)
                            }({
                                chainId: e
                            }).then(r => {
                                i.appRef.tick()
                            }, r => {
                                console.log("switchNetwork error", r), i.popupService.messagePopup("info", i.transletService.instant("switchNetwork", {
                                    chain_name: nt.eth.chainInfo.params[0].chainName
                                }))
                            })
                        })()
                    }
                    getNativeAmount = (() => {
                        var i, e = this;
                        return i = (0, Ze.Z)(function*(r) {
                                let s = 0;
                                switch (e.getChainData().chainIdInt) {
                                    case nt.eth.chainIdInt:
                                        s = e.balanceData.oneEth;
                                        break;
                                    case nt.bsc.chainIdInt:
                                        s = e.balanceData.oneBnb;
                                        break;
                                    case nt.poly.chainIdInt:
                                        s = e.balanceData.onePoly;
                                        break;
                                    case nt.avalanche.chainIdInt:
                                        s = e.balanceData.oneAvalanche;
                                        break;
                                    case nt.base.chainIdInt:
                                        s = e.balanceData.oneBase;
                                        break;
                                    default:
                                        s = e.balanceData.oneEth
                                }
                                return Math.floor(+r / +s)
                            }),
                            function(r) {
                                return i.apply(this, arguments)
                            }
                    })();
                    getUSDTAmount = (() => {
                        var i, e = this;
                        return i = (0, Ze.Z)(function*(r) {
                                let s = 0;
                                switch (e.getChainData().chainIdInt) {
                                    case nt.eth.chainIdInt:
                                        s = e.balanceData.ethUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.bsc.chainIdInt:
                                        s = e.balanceData.bnbUsdt / Math.pow(10, 18);
                                        break;
                                    case nt.poly.chainIdInt:
                                        s = e.balanceData.ethUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.avalanche.chainIdInt:
                                        s = e.balanceData.avalancheUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.base.chainIdInt:
                                        s = e.balanceData.baseUsdt / Math.pow(10, 6);
                                        break;
                                    default:
                                        s = e.balanceData.ethUsdt / Math.pow(10, 6)
                                }
                                return Math.floor(+r / +s)
                            }),
                            function(r) {
                                return i.apply(this, arguments)
                            }
                    })();
                    getDynamicAmount = (() => {
                        var i, e = this;
                        return i = (0, Ze.Z)(function*(r, s) {
                                let o = 0;
                                switch (e.getChainData().chainIdInt) {
                                    case nt.eth.chainIdInt:
                                        o = "getNativeAmount" === s ? e.balanceData.oneEth : e.balanceData.ethUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.bsc.chainIdInt:
                                        o = "getNativeAmount" === s ? e.balanceData.oneBnb : e.balanceData.bnbUsdt / Math.pow(10, 18);
                                        break;
                                    case nt.poly.chainIdInt:
                                        o = "getNativeAmount" === s ? e.balanceData.onePoly : e.balanceData.polyUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.avalanche.chainIdInt:
                                        o = "getNativeAmount" === s ? e.balanceData.oneAvalanche : e.balanceData.avalancheUsdt / Math.pow(10, 6);
                                        break;
                                    case nt.base.chainIdInt:
                                        o = "getNativeAmount" === s ? e.balanceData.oneBase : e.balanceData.baseUsdt / Math.pow(10, 6);
                                        break;
                                    default:
                                        o = "getNativeAmount" === s ? e.balanceData.oneEth : e.balanceData.ethUsdt / Math.pow(10, 6)
                                }
                                return +r * o
                            }),
                            function(r, s) {
                                return i.apply(this, arguments)
                            }
                    })();
                    swapNativeTokens(e, i, r = !1) {
                        var s = this;
                        return (0, Ze.Z)(function*() {
                            s.swapStatus = Ki.not_started;
                            const {
                                request: o
                            } = yield sd({ ...s.getPresaleContract(),
                                functionName: s.getChainData().nativeFunction,
                                chainId: s.getChainData().chainIdInt,
                                args: s.getChainData().hasStaking ? [e, r] : [e],
                                value: bU(`${i}`),
                                account: s.walletAddress
                            });
                            s.swapStatus = Ki.confirm_pending, yield _h(o).then(a => {
                                console.log("Eth write Contract success", a), s.swapStatus = Ki.in_progess, s.windowDataLayer("swap", "confirmTransaction", 2, 0, 0), s.sendDashFx(s.getChainData().purchaseToken, e, i), s.checkTansaction(a.hash, s.getChainData().purchaseToken, e, i)
                            }, a => {
                                console.log("swapNativeTokens Error =", a), s.swapStatus = 4001 === a.code ? Ki.rejected : Ki.failed
                            })
                        })()
                    }
                    swapCryptoForUSDT(e, i, r = !1, s = !1) {
                        var o = this;
                        return (0, Ze.Z)(function*() {
                            const a = o.getUSDTContract(),
                                c = o.getChainData().presaleAddress,
                                u = yield qf({
                                    contracts: [{ ...a,
                                        functionName: "allowance",
                                        chainId: o.chainId,
                                        args: [o.walletAddress, c]
                                    }]
                                });
                            let h = Number(u[0].result) / Math.pow(10, 6);
                            if (console.log("allowanceValue =", i, h), +i > +h) {
                                const {
                                    request: m
                                } = yield sd({ ...a,
                                    chainId: o.chainId,
                                    functionName: "approve",
                                    args: [c, r || 0 == h ? "100000000000000000000000000" : "0"],
                                    account: o.walletAddress
                                });
                                o.swapStatus = Ki.approval_pending;
                                const {
                                    hash: x
                                } = yield _h(m);
                                console.log("approve allowence hash key =", x), yield eM({
                                    hash: x
                                }).then(D => {
                                    console.log("approve Config success", D), r ? o.buyUSDT(e, i, s) : o.swapCryptoForUSDT(e, i, !0, s)
                                }, D => {
                                    console.log("approve Config error", D), o.swapStatus = Ki.rejected
                                })
                            } else o.buyUSDT(e, i, s)
                        })()
                    }
                    buyUSDT(e, i, r = !1) {
                        var s = this;
                        return (0, Ze.Z)(function*() {
                            console.log("buyUSDT called", s.getChainData().hasStaking);
                            const o = s.getPresaleContract();
                            yield sd({ ...o,
                                functionName: "Base" === s.getChainData().chainName ? "buyWithUSDC" : "buyWithUSDT",
                                chainId: s.chainId,
                                args: s.getChainData().hasStaking ? [e, r] : [e],
                                account: s.walletAddress
                            }).then(function() {
                                var a = (0, Ze.Z)(function*(c) {
                                    console.log("usdtBuyHelper =", c), s.swapStatus = Ki.confirm_pending, yield _h(c.request).then(u => {
                                        console.log("buyUSDT writeContract success", u), s.windowDataLayer("swap", "confirmTransaction", 2, 0, 0), s.sendDashFx("usdt", e, i), s.swapStatus = Ki.in_progess, s.checkTansaction(u.hash, "usdt", e, i)
                                    }, u => {
                                        console.log("buyUSDT writeContract error", u), s.swapStatus = Ki.failed
                                    })
                                });
                                return function(c) {
                                    return a.apply(this, arguments)
                                }
                            }(), a => {
                                s.popupService.messagePopup("warning", s.transletService.instant("widget.max_token_exceed", {
                                    maxTokensToBuy: s.balanceData.maxTokensToBuy
                                }), s.transletService.instant("widget.max_token_title")), s.swapStatus = Ki.rejected, console.log(a.message)
                            })
                        })()
                    }
                    checkTansaction(e, i, r, s, o = !0) {
                        var a = this;
                        return (0, Ze.Z)(function*() {
                            yield eM({
                                hash: e
                            }).then(c => {
                                console.log("checkTansaction success", c), a.getMetaData(), a.swapStatus = Ki.complete, a.swapHash = c.transactionHash, a.sendBWData(i, r, s), o && a.windowDataLayer("swap", "swapSuccessful", 3, 1, 0, i, nt.tokenName, s, r)
                            }, c => {
                                console.log("checkTansaction error", c), a.getMetaData(), a.swapStatus = Ki.failed
                            })
                        })()
                    }
                    windowDataLayer(e, i, r, s, o, a = "", c = "", u = 0, h = 0) {
                        var m = this;
                        return (0, Ze.Z)(function*() {
                            nt.production && (window.dataLayer = window.dataLayer || [], window.dataLayer.push({
                                event: "workflowStep",
                                walletAddress: m.walletAddress,
                                workflowName: e,
                                workflowStepNumber: r,
                                workflowStepName: i,
                                workflowCompleteFlag: s,
                                workflowErrorCode: o,
                                transactionId: 0 === s ? void 0 : m.swapHash,
                                swapFromValue: 0 === s ? void 0 : u,
                                swapToValue: 0 === s ? void 0 : h,
                                swapFromCurrency: 0 === s ? void 0 : a,
                                swapToCurrency: 0 === s ? void 0 : c,
                                presaleStage: 0 === s ? void 0 : m.balanceData.currentStep,
                                stageTokenValue: 0 === s ? void 0 : m.tokenomics[m.balanceData.currentStep].tokenUSDT,
                                swapFromValueUsd: 0 === s ? void 0 : yield m.getDynamicAmount(h, "getUSDTAmount")
                            }))
                        })()
                    }
                    sendDashFx = (e, i, r, s = !1) => {
                        if (nt.production) {
                            const o = this.balanceData.userClaimable || 0,
                                a = {
                                    walletAddress: this.walletAddress,
                                    iid: nt.iidDashFx,
                                    event: s ? "lead_success" : o > i ? "revenue" : "conversion",
                                    purchaseType: s ? null : e,
                                    purchaseTokens: +i,
                                    purchaseTypeAmount: +r,
                                    purchaseUsdAmount: "usdt" === e ? +r : + +(i * this.tokenomics[this.balanceData.currentStep].tokenUSDT).toFixed(2),
                                    ipAddress: "",
                                    clickId: au("clickId"),
                                    source: au("source"),
                                    tid: au("tid"),
                                    pid: au("pid")
                                };
                            console.log("DashFx data =", o, a), this.http.post(nt.urlDashFx, a).subscribe(c => {
                                console.log("DashFx success response", c)
                            }, c => {
                                console.log("DashFx error response", c)
                            })
                        }
                    };
                    claim() {
                        return (0, Ze.Z)(function*() {
                            console.log("Claim called")
                        })()
                    }
                    refer() {
                        this.walletAddress && "" != this.walletAddress && this.http.post(nt.referUrl, {
                            walletAddress: this.walletAddress,
                            iid: nt.iidDashFx
                        }).subscribe(i => {
                            console.log("ReferURL success response", i), this.referUrl = i.data.url
                        }, i => {
                            console.log("ReferURL error response", i)
                        })
                    }
                    claimStake() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            console.log("Claim called"), e.swapStatus = Ki.in_progess;
                            const {
                                request: i
                            } = yield sd({ ...ec,
                                functionName: "claimAndStake",
                                chainId: nt.eth.chainIdInt,
                                args: [],
                                account: e.walletAddress
                            });
                            yield _h(i).then(r => {
                                console.log("claimStake success", r), e.checkTansaction(r.hash, "claimstake", 0, 0)
                            }, r => {
                                console.log("claimStake error", r), e.swapStatus = Ki.failed
                            })
                        })()
                    }
                    claimStakeRewards() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            console.log("Claim called");
                            const {
                                request: i
                            } = yield sd({ ...Dh,
                                functionName: "harvestRewards",
                                chainId: nt.eth.chainIdInt,
                                args: [],
                                account: e.walletAddress
                            });
                            yield _h(i).then(r => {
                                console.log("claimStake success", r)
                            }, r => {
                                console.log("claimStake error", r)
                            })
                        })()
                    }
                    withdrawStake() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            console.log("Claim called");
                            const {
                                request: i
                            } = yield sd({ ...Dh,
                                functionName: "withdraw",
                                chainId: nt.eth.chainIdInt,
                                args: [],
                                account: e.walletAddress
                            });
                            yield _h(i).then(r => {
                                console.log("claimStake success", r)
                            }, r => {
                                console.log("claimStake error", r)
                            })
                        })()
                    }
                    createStake(e) {
                        var i = this;
                        return (0, Ze.Z)(function*() {
                            const r = yield qf({
                                contracts: [{ ...I7,
                                    functionName: "allowance",
                                    chainId: i.chainId,
                                    args: [i.walletAddress, nt.stakingAddress]
                                }]
                            });
                            console.log("createStake allowanceData =", r);
                            const s = +(0, Vs.d)(r[0].result),
                                o = +e;
                            if (console.log(o, s, e), o > +s) {
                                const {
                                    request: a
                                } = yield sd({ ...I7,
                                    chainId: i.chainId,
                                    functionName: "approve",
                                    args: [nt.stakingAddress, "100000000000000000000000000"],
                                    account: i.walletAddress
                                });
                                console.log("approveConfig =", a), i.swapStatus = Ki.approval_pending;
                                const {
                                    hash: c
                                } = yield _h(a);
                                console.log("createStake approveConfig hash =", c), yield eM({
                                    hash: c
                                }).then(u => {
                                    console.log("approveConfig approve Config success", u), i.swapStatus = Ki.confirm_pending, i.proceedCreateStake(e)
                                }, u => {
                                    console.log("approve Config error", u), i.swapStatus = Ki.rejected
                                })
                            } else i.proceedCreateStake(e)
                        })()
                    }
                    proceedCreateStake(e) {
                        var i = this;
                        return (0, Ze.Z)(function*() {
                            const {
                                request: r
                            } = yield sd({ ...Dh,
                                functionName: "deposit",
                                chainId: nt.eth.chainIdInt,
                                args: [bU(e.toString())]
                            });
                            i.swapStatus = Ki.confirm_pending, yield _h(r).then(s => {
                                console.log("proceedCreateStake success", s), i.swapStatus = Ki.in_progess, i.checkTansaction(s.hash, "", e, 0, !1)
                            }, s => {
                                console.log("Eth createStake error", s), i.swapStatus = Ki.rejected
                            })
                        })()
                    }
                    getABI(e, i = !1) {
                        var r = this;
                        return (0, Ze.Z)(function*() {
                            return (0, W0.R)({
                                abi: k7.abi,
                                functionName: "buyWithETHWert",
                                args: [r.walletAddress, e, i]
                            })
                        })()
                    }
                    getDynamicAmountWert = (() => {
                        return e = (0, Ze.Z)(function*(i) {
                                console.log("getDynamicAmountWert", i);
                                const r = yield qf({
                                    contracts: [{ ...ec,
                                        functionName: "ethBuyHelper",
                                        chainId: nt.eth.chainIdInt,
                                        args: [i]
                                    }]
                                });
                                let s = +(0, Vs.d)(r[0].result);
                                return console.log("return DynamicAmountWert", s), +s
                            }),
                            function(i) {
                                return e.apply(this, arguments)
                            };
                        var e
                    })();
                    getChainData() {
                        switch (this.chainId) {
                            case nt.eth.chainIdInt:
                                return nt.eth;
                            case nt.bsc.chainIdInt:
                                return nt.bsc;
                            case nt.poly.chainIdInt:
                                return nt.poly;
                            case nt.avalanche.chainIdInt:
                                return nt.avalanche;
                            case nt.base.chainIdInt:
                                return nt.base;
                            default:
                                return nt.eth
                        }
                    }
                    getPresaleContract() {
                        switch (this.chainId) {
                            case nt.eth.chainIdInt:
                                return ec;
                            case nt.bsc.chainIdInt:
                                return ap;
                            case nt.poly.chainIdInt:
                                return cp;
                            case nt.avalanche.chainIdInt:
                                return lp;
                            case nt.base.chainIdInt:
                                return up;
                            default:
                                return ec
                        }
                    }
                    getUSDTContract() {
                        switch (this.chainId) {
                            case nt.eth.chainIdInt:
                                return M7;
                            case nt.bsc.chainIdInt:
                                return obe;
                            case nt.poly.chainIdInt:
                                return abe;
                            case nt.avalanche.chainIdInt:
                                return cbe;
                            case nt.base.chainIdInt:
                                return lbe;
                            default:
                                return M7
                        }
                    }
                    sendBWData = (e, i, r) => {
                        if (nt.production) {
                            const s = this.balanceData.ethClaimable || 0,
                                o = {
                                    publicAddress: this.walletAddress,
                                    event: s > i ? "revenue" : "conversion",
                                    purchaseType: e,
                                    purchaseTokens: +i,
                                    purchaseTypeAmount: +r,
                                    purchaseUsdAmount: "usdt" === e ? +r : + +(i * this.tokenomics[this.balanceData.currentStep].tokenUSDT).toFixed(2),
                                    ipAddress: "",
                                    clickId: au("clickId"),
                                    source: au("source"),
                                    hash: this.swapHash,
                                    chainId: this.chainId,
                                    presaleName: "DOGEVERSE-TOKEN",
                                    isBW: this.isBW,
                                    rABsZdfEqoXvExie: HD("rABsZdfEqoXvExie") || void 0
                                };
                            console.log("BW data =", s, o), this.http.post(nt.bwApiUrl, o).subscribe(a => {
                                console.log("BW success response", a)
                            }, a => {
                                console.log("BW error response", a)
                            })
                        }
                    };
                    getusdRaised() {
                        return this.http.get(nt.usdRaisedApi)
                    }
                    setProgram() {
                        this.program = new op(ibe, this.programId, this.provider), this.getRequiredAddress()
                    }
                    getRequiredAddress() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            e.stateInfoAddress = Mr.PublicKey.findProgramAddressSync([Buffer.from("state_info")], e.programId), e.getPresaleData()
                        })()
                    }
                    getWindowObject(e = "") {
                        switch ("" !== e ? e : this.curWalletName) {
                            case "Phantom":
                            default:
                                return window.solana;
                            case "Solflare":
                                return window.solflare
                        }
                    }
                    getPresaleData() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            try {
                                const i = yield e.program.account.stateInfo.fetch(e.stateInfoAddress[0]);
                                e.balanceData.usdRaisedSol = Number(i.totalUsdRaised) / 1e6, console.log("\n **** balanceData data ****** ", e.balanceData), console.log("\n **** balanceData data ****** ", e.balanceData.usdRaised + e.balanceData.usdRaisedSol)
                            } catch (i) {
                                console.log(i)
                            }
                        })()
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(_t(Ef), _t(Xl), _t(Ah), _t(A_), _t(bc))
                    };
                    static\ u0275prov = Dt({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    })
                }
                return t
            })();
            const TI = function() {
                return {
                    "width.px": 14,
                    "height.px": 14
                }
            };

            function ube(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 4), gt(1, "div"), J(2, "h4", 5), Oe(3, "misc.connect_wallet"), ce(), J(4, "svg-icon", 6), xt("click", function() {
                        return Nt(e), Ft(Ke().modalRef.hide())
                    }), ce()()
                }
                2 & t && (he(4), Re("svgStyle", Ns(1, TI)))
            }
            const SI = function() {
                    return {
                        "width.px": 32,
                        "height.px": 32
                    }
                },
                dbe = function() {
                    return {
                        "width.px": 20,
                        "height.px": 19,
                        "margin-right.px": 5
                    }
                };

            function hbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 7)(1, "button", 8), xt("click", function() {
                        return Nt(e), Ft(Ke().connectWallet("wallet"))
                    }), J(2, "span", 9), Oe(3, "popup.wallet_connect"), ce(), gt(4, "svg-icon", 10), ce(), J(5, "button", 11), xt("click", function() {
                        Nt(e);
                        const r = Ke(),
                            s = pl(6);
                        return Ft(r.openBestWallet(s))
                    }), J(6, "span", 9), Oe(7, "misc.best_wallet"), ce(), gt(8, "img", 12), ce(), J(9, "button", 13), xt("click", function() {
                        Nt(e);
                        const r = Ke(),
                            s = pl(6);
                        return Ft(r.openBestWallet(s))
                    }), J(10, "span", 9), Oe(11, "misc.best_wallet"), ce(), gt(12, "img", 12), ce(), J(13, "button", 13), xt("click", function() {
                        return Nt(e), Ft(Ke().connectWallet("metamask"))
                    }), J(14, "span", 9), Oe(15, "popup.metamask"), ce(), gt(16, "svg-icon", 14), ce(), J(17, "button", 8), xt("click", function() {
                        return Nt(e), Ft(Ke().connectWallet("coinbase"))
                    }), J(18, "span", 9), Oe(19, "popup.coinbase_connect"), ce(), gt(20, "svg-icon", 15), ce(), J(21, "button", 16), xt("click", function() {
                        return Nt(e), Ft(Ke().step = 1)
                    }), gt(22, "svg-icon", 17), J(23, "span", 18), Oe(24, "popup.no_wallet"), ce()()()
                }
                2 & t && (he(4), Re("svgStyle", Ns(4, SI)), he(12), Re("svgStyle", Ns(5, SI)), he(4), Re("svgStyle", Ns(6, SI)), he(2), Re("svgStyle", Ns(7, dbe)))
            }
            const fbe = function() {
                return {
                    "width.px": 9,
                    "height.px": 16
                }
            };

            function pbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 4)(1, "svg-icon", 19), xt("click", function() {
                        return Nt(e), Ft(Ke().step = 0)
                    }), ce(), J(2, "h4", 20), Oe(3, "popup.get_wallet"), ce(), J(4, "svg-icon", 21), xt("click", function() {
                        return Nt(e), Ft(Ke().modalRef.hide())
                    }), ce()()
                }
                2 & t && (he(1), Re("svgStyle", Ns(2, fbe)), he(3), Re("svgStyle", Ns(3, TI)))
            }
            const mbe = function() {
                return {
                    "width.px": 13,
                    "height.px": 12
                }
            };

            function gbe(t, n) {
                1 & t && (J(0, "div", 7)(1, "div", 22)(2, "div", 23)(3, "div", 24)(4, "div", 25)(5, "div", 26)(6, "div", 27)(7, "div", 28)(8, "div", 29), gt(9, "svg-icon", 30), ce()()()()()(), J(10, "div", 24)(11, "div", 31)(12, "div", 32)(13, "div", 33)(14, "div", 34)(15, "div", 35), gt(16, "svg-icon", 36), ce()()()()()(), J(17, "div", 24)(18, "div", 37)(19, "div", 38)(20, "div", 39)(21, "div", 40)(22, "div", 41), gt(23, "svg-icon", 42), ce()()()()()(), J(24, "div", 24)(25, "div", 43)(26, "div", 44)(27, "div", 45)(28, "div", 46)(29, "div", 47), gt(30, "svg-icon", 48), ce()()()()()(), J(31, "div", 24)(32, "div", 49)(33, "div", 50)(34, "div", 51)(35, "div", 52)(36, "div", 53), gt(37, "svg-icon", 54), ce()()()()()()(), J(38, "div", 55), gt(39, "svg-icon", 56), ce()(), J(40, "div", 57)(41, "h5", 58), Oe(42, "popup.exploring_web"), ce(), J(43, "p", 59), Oe(44, "popup.exploring_des"), ce(), J(45, "a", 60)(46, "span", 61), Oe(47, "popup.choose_first_wallet"), ce(), gt(48, "svg-icon", 62), ce()()()), 2 & t && (he(48), Re("svgStyle", Ns(1, mbe)))
            }

            function ybe(t, n) {
                1 & t && (J(0, "div", 76)(1, "div", 77), Oe(2, "popup.iOS"), ce(), gt(3, "img", 78), J(4, "a", 79), gt(5, "img", 80), ce()())
            }

            function _be(t, n) {
                1 & t && (J(0, "div", 81)(1, "div", 77), Oe(2, "popup.android"), ce(), gt(3, "img", 82), J(4, "a", 83), gt(5, "img", 84), ce()())
            }

            function vbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 0)(1, "div", 4), gt(2, "div"), J(3, "h4", 63), Oe(4, "popup.download_best_wallet"), ce(), J(5, "svg-icon", 64), xt("click", function() {
                        return Nt(e), Ft(Ke().modalRef.hide())
                    }), ce()(), J(6, "div", 65)(7, "div", 66), Oe(8, "popup.install_app"), ce(), J(9, "div", 67), Oe(10, "popup.install_app_mob"), ce(), J(11, "div", 68), tt(12, ybe, 6, 0, "div", 69), tt(13, _be, 6, 0, "div", 70), ce(), J(14, "div", 71), Oe(15, "popup.already_have"), ce(), J(16, "div", 72), Oe(17, "popup.hit_btn_connect"), ce(), J(18, "div", 73), Oe(19, "popup.hit_btn_connect_mob"), ce(), J(20, "button", 74), xt("click", function() {
                        return Nt(e), Ft(Ke().connectWallet("walletBW"))
                    }), J(21, "span", 9), Oe(22, "misc.connect_wallet"), ce()(), J(23, "button", 75), xt("click", function() {
                        return Nt(e), Ft(Ke().connectWallet("bw"))
                    }), J(24, "span", 9), Oe(25, "misc.connect_wallet"), ce()()()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(5), Re("svgStyle", Ns(3, TI)), he(7), Re("ngIf", !e.isAndroid), he(1), Re("ngIf", !e.isIos)
                }
            }
            let E1 = (() => {
                    class t {
                        modalService;
                        platform;
                        modalRef;
                        walletConnectService;
                        step = 0;
                        isBsNetwork = !1;
                        isAndroid = !1;
                        isIos = !1;
                        constructor(e, i, r, s) {
                            this.modalService = e, this.platform = i, this.modalRef = r, this.walletConnectService = s, this.isAndroid = this.platform.ANDROID, this.isIos = this.platform.IOS
                        }
                        ngOnInit() {}
                        connectWallet(e) {
                            this.walletConnectService.connectWallet(e, this.isBsNetwork), this.modalRef.hide()
                        }
                        openBestWallet(e) {
                            this.modalRef.hide(), setTimeout(() => {
                                this.modalRef = this.modalService.show(e, {
                                    class: "modal-md modal-dialog-centered",
                                    backdrop: "static"
                                })
                            }, 500)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(oh), We(xfe), We(Dm), We(dp))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-connect"]
                            ],
                            decls: 7,
                            vars: 4,
                            consts: [
                                [1, "p-4", "connect"],
                                ["class", "d-flex justify-content-between align-items-center", 4, "ngIf"],
                                ["class", "mt-4 content", 4, "ngIf"],
                                ["bestwallet", ""],
                                [1, "d-flex", "justify-content-between", "align-items-center"],
                                ["translate", "", 1, "text-center", "fw-semibold", "fs-5", "m-0", "text-light"],
                                ["src", "/assets/images/svg-icons/close-white.svg", 1, "cursor-pointer", 3, "svgStyle", "click"],
                                [1, "mt-4", "content"],
                                ["type", "button", 1, "btn", "btn-sm", "border-0", "rounded-1", "bg-secondary", "py-2", "px-3", "btn-light", "w-100", "d-flex", "justify-content-between", "align-items-center", "mb-3", 3, "click"],
                                ["translate", "", 1, "d-inline-block", "text-black"],
                                ["src", "/assets/images/svg-icons/wallet.svg", 3, "svgStyle"],
                                ["type", "button", 1, "btn", "btn-sm", "border-0", "rounded-1", "bg-secondary", "py-2", "px-3", "btn-light", "w-100", "d-flex", "d-md-none", "justify-content-between", "align-items-center", "mb-3", 3, "click"],
                                ["src", "/assets/images/bw.png", "height", "32", "width", "32", "alt", ""],
                                ["type", "button", 1, "btn", "btn-sm", "border-0", "rounded-1", "bg-secondary", "py-2", "px-3", "btn-light", "w-100", "d-none", "d-md-flex", "justify-content-between", "align-items-center", "mb-3", 3, "click"],
                                ["src", "/assets/images/svg-icons/metamask.svg", 3, "svgStyle"],
                                ["src", "/assets/images/svg-icons/coinbase.svg", 3, "svgStyle"],
                                ["type", "button", 1, "btn", "btn-clear", "w-100", "d-flex", "justify-content-center", "align-items-center", "aniBtn", 3, "click"],
                                ["src", "/assets/images/svg-icons/ani-wallet.svg", 3, "svgStyle"],
                                ["translate", "", 1, "d-inline-block", "text-light"],
                                ["src", "/assets/images/svg-icons/back.svg", 1, "cursor-pointer", "white", 3, "svgStyle", "click"],
                                ["translate", "", 1, "text-center", "fw-semibold", "fs-5", "m-0", "text-black"],
                                ["src", "/assets/images/svg-icons/close-white.svg", 1, "cursor-pointer", "white", 3, "svgStyle", "click"],
                                [1, "hoHHXf"],
                                [1, "sc-fLcnxK", "fWzKsv"],
                                [1, "sc-ezOQGI", "cSaAIp"],
                                ["data-projection-id", "1250", 1, "sc-iveFHk", "jBAplQ"],
                                ["data-projection-id", "1251", 1, "sc-cwSeag", "fsywKZ"],
                                ["data-projection-id", "1252", 1, "sc-iJnaPW", "iUmxfL"],
                                ["data-projection-id", "1253", 1, "sc-gikAfH", "evkwbC"],
                                ["data-projection-id", "1254", 1, "sc-lllmON", "bPXKDV"],
                                ["src", "/assets/images/svg-icons/animated/1.svg"],
                                ["data-projection-id", "1256", 1, "sc-iveFHk", "jBAplQ"],
                                ["data-projection-id", "1257", 1, "sc-cwSeag", "fsywKZ"],
                                ["data-projection-id", "1258", 1, "sc-iJnaPW", "iUmxfL"],
                                ["data-projection-id", "1259", 1, "sc-gikAfH", "evkwbC"],
                                ["data-projection-id", "1260", 1, "sc-lllmON", "bPXKDV"],
                                ["src", "/assets/images/svg-icons/animated/2.svg"],
                                ["data-projection-id", "1262", 1, "sc-iveFHk", "jBAplQ"],
                                ["data-projection-id", "1263", 1, "sc-cwSeag", "fsywKZ"],
                                ["data-projection-id", "1264", 1, "sc-iJnaPW", "iUmxfL"],
                                ["data-projection-id", "1265", 1, "sc-gikAfH", "evkwbC"],
                                ["data-projection-id", "1266", 1, "sc-lllmON", "bPXKDV"],
                                ["src", "/assets/images/svg-icons/animated/3.svg"],
                                ["data-projection-id", "1268", 1, "sc-iveFHk", "jBAplQ"],
                                ["data-projection-id", "1269", 1, "sc-cwSeag", "fsywKZ"],
                                ["data-projection-id", "1270", 1, "sc-iJnaPW", "iUmxfL"],
                                ["data-projection-id", "1271", 1, "sc-gikAfH", "evkwbC"],
                                ["data-projection-id", "1272", 1, "sc-lllmON", "bPXKDV"],
                                ["src", "/assets/images/svg-icons/animated/4.svg"],
                                ["data-projection-id", "1274", 1, "sc-iveFHk", "jBAplQ"],
                                ["data-projection-id", "1275", 1, "sc-cwSeag", "fsywKZ"],
                                ["data-projection-id", "1276", 1, "sc-iJnaPW", "iUmxfL"],
                                ["data-projection-id", "1277", 1, "sc-gikAfH", "evkwbC"],
                                ["data-projection-id", "1278", 1, "sc-lllmON", "bPXKDV"],
                                ["src", "/assets/images/svg-icons/animated/5.svg"],
                                [1, "sc-bBABsx", "jLseHP"],
                                ["src", "/assets/images/svg-icons/animated/bg.svg"],
                                [1, "text-center"],
                                ["translate", "", 1, "text-light"],
                                ["translate", "", 1, "mt-3", "text-light"],
                                ["type", "button", "href", "https://ethereum.org/en/wallets/find-wallet/", "target", "_blank", 1, "btn", "btn-sm", "btn-secondary", "w-100", "d-flex", "justify-content-center", "align-items-center", "mt-4", "text-light"],
                                ["translate", "", 1, "d-inline-block", "me-2"],
                                ["src", "/assets/images/svg-icons/ani-arrow.svg", 1, "arrow", 3, "svgStyle"],
                                ["translate", "", 1, "text-center", "fw-semibold", "fs-4", "m-0", "w-80"],
                                ["src", "./assets/images/svg-icons/close.svg", 1, "cursor-pointer", 3, "svgStyle", "click"],
                                [1, "mt-4", "content", "d-flex", "flex-column", "align-items-center", "justify-content-between"],
                                ["translate", "", 1, "text-center", "d-none", "d-md-block", "my-1"],
                                ["translate", "", 1, "text-center", "d-block", "d-md-none", "my-1"],
                                [1, "d-flex", "align-items-center", "justify-content-around", "my-2"],
                                ["class", "d-flex flex-column align-items-center me-3", 4, "ngIf"],
                                ["class", "d-flex flex-column align-items-center ms-3", 4, "ngIf"],
                                ["translate", "", 1, "fw-semibold", "my-3", "fs-4"],
                                ["translate", "", 1, "text-center", "mb-3", "d-none", "d-md-block"],
                                ["translate", "", 1, "text-center", "mb-3", "d-md-none", "d-block"],
                                ["type", "button", 1, "btn", "btn-sm", "border-0", "rounded-1", "bg-secondary", "py-2", "px-3", "btn-light", "w-50", "d-flex", "justify-content-center", "align-items-center", "mb-3", "d-none", "d-md-block", 3, "click"],
                                ["type", "button", 1, "btn", "btn-sm", "border-0", "rounded-1", "bg-secondary", "py-2", "px-3", "btn-light", "w-50", "d-flex", "justify-content-center", "align-items-center", "mb-3", "d-block", "d-md-none", 3, "click"],
                                [1, "d-flex", "flex-column", "align-items-center", "me-3"],
                                ["translate", "", 1, "fw-bold", "fs-4", "mb-3", "d-none", "d-md-block"],
                                ["src", "./assets/images/qr-ios.svg", 1, "d-none", "d-md-block"],
                                ["href", "https://apps.apple.com/gb/app/best-wallet/id6451312105", "target", "_blank", 1, "my-4", "my-md-2", "app-img"],
                                ["src", "./assets/images/ios.svg"],
                                [1, "d-flex", "flex-column", "align-items-center", "ms-3"],
                                ["src", "./assets/images/qr-and.svg", 1, "d-none", "d-md-block"],
                                ["href", "https://play.google.com/store/apps/details?id=com.bestwallet.mobile", "target", "_blank", 1, "my-4", "my-md-2", "app-img"],
                                ["src", "./assets/images/and.svg"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "div", 0), tt(1, ube, 5, 2, "div", 1), tt(2, hbe, 25, 8, "div", 2), tt(3, pbe, 5, 4, "div", 1), tt(4, gbe, 49, 2, "div", 2), ce(), tt(5, vbe, 26, 4, "ng-template", null, 3, _l)), 2 & i && (he(1), Re("ngIf", 0 === r.step), he(1), Re("ngIf", 0 === r.step), he(1), Re("ngIf", 1 === r.step), he(1), Re("ngIf", 1 === r.step))
                            },
                            dependencies: [ts, kf, na],
                            styles: ['@keyframes _ngcontent-%COMP%_iJJxDF{0%{opacity:0;transform:scale(0) translateY(40%)}to{opacity:1;transform:none}}@keyframes _ngcontent-%COMP%_fFCEAC{0%,to{transform:none}50%{transform:translateY(-10%)}}@keyframes _ngcontent-%COMP%_hfwTSV{0%,to{transform:rotate(-3deg)}50%{transform:rotate(3deg)}}@keyframes _ngcontent-%COMP%_FUkhV{0%{opacity:0;transform:scale(.9)}to{opacity:1;transform:none}}.content[_ngcontent-%COMP%]{transition:all .6s ease-out}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]{transition:color .2s ease-out 0s,transform .2s ease-out 0s;color:#fff;border:1px solid rgba(255,255,255,.168627451)}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{transition:all .1s ease-out 0s;display:block;position:relative;top:2px;left:-1px;transform:translateZ(0)}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]   path[_ngcontent-%COMP%]:last-of-type{transform-origin:0px 0px;transform:scaleX(1.3) skewY(-12deg);opacity:0}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]   path[_ngcontent-%COMP%], .content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]   circle[_ngcontent-%COMP%]{transition:all .1s ease-out 0s}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]   circle[_ngcontent-%COMP%]{transform:translate(20%,-15%)}.content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]:hover   svg[_ngcontent-%COMP%]   path[_ngcontent-%COMP%], .content[_ngcontent-%COMP%]   .aniBtn[_ngcontent-%COMP%]:hover   svg[_ngcontent-%COMP%]   circle[_ngcontent-%COMP%]{opacity:1;transform:none}.content[_ngcontent-%COMP%]   .white[_ngcontent-%COMP%], .content[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%]{color:#fff}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]{position:relative;margin:16px auto 20px;height:190px;max-width:295px;pointer-events:none;-webkit-user-select:none;user-select:none}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]{position:absolute;inset:0;z-index:2}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]{position:absolute;inset:0;animation:.75s cubic-bezier(.19,1,.22,1) 0s 1 normal both running _ngcontent-%COMP%_iJJxDF}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .sc-cwSeag[_ngcontent-%COMP%]{transform:translate(-50%,-50%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .fsywKZ[_ngcontent-%COMP%]{position:absolute}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .jBAplQ[_ngcontent-%COMP%]{position:absolute;inset:0;animation-duration:0s;animation-timing-function:cubic-bezier(.455,.03,.515,.955);animation-iteration-count:infinite;animation-direction:normal;animation-fill-mode:both;animation-play-state:running;animation-name:none;animation-delay:inherit}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .iUmxfL[_ngcontent-%COMP%]{position:relative;animation:3.6s cubic-bezier(.455,.03,.515,.955) 0s infinite normal both running _ngcontent-%COMP%_fFCEAC}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .evkwbC[_ngcontent-%COMP%]{position:relative;animation:3.2s cubic-bezier(.455,.03,.515,.955) 0s infinite normal both running _ngcontent-%COMP%_hfwTSV}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .bPXKDV[_ngcontent-%COMP%]{position:relative;overflow:hidden;height:58px;width:58px;border-radius:13.84px;box-shadow:#0000000d 0 0 0 1px,#00000008 0 2px 20px}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]   .bPXKDV[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{display:block;width:100%;height:100%}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(1){z-index:2;animation-delay:0ms}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(1)   .sc-iveFHk[_ngcontent-%COMP%]{transform:translate(50%,50%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(1)   .sc-iveFHk[_ngcontent-%COMP%]   .sc-lllmON[_ngcontent-%COMP%]{border-radius:17.2px;width:72px;height:72px}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(1)   .sc-iJnaPW[_ngcontent-%COMP%]{animation-delay:-.2s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(1)   .sc-gikAfH[_ngcontent-%COMP%]{animation-delay:0ms}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(2){z-index:1;animation-delay:60ms}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(2)   .sc-iveFHk[_ngcontent-%COMP%]{transform:translate(21%,21.5%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(2)   .sc-iJnaPW[_ngcontent-%COMP%]{animation-delay:-.6s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(2)   .sc-gikAfH[_ngcontent-%COMP%]{animation-delay:-.6s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(3){z-index:1;animation-delay:30ms}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(3)   .sc-iveFHk[_ngcontent-%COMP%]{transform:translate(78%,14%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(3)   .sc-iJnaPW[_ngcontent-%COMP%]{animation-delay:-.8s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(3)   .sc-gikAfH[_ngcontent-%COMP%]{animation-delay:-1.2s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(4){z-index:1;animation-delay:90ms}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(4)   .sc-iveFHk[_ngcontent-%COMP%]{transform:translate(22.5%,76%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(4)   .sc-iJnaPW[_ngcontent-%COMP%]{animation-delay:-.3s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(4)   .sc-gikAfH[_ngcontent-%COMP%]{animation-delay:-1.8s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(5){z-index:1;animation-delay:.12s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(5)   .sc-iveFHk[_ngcontent-%COMP%]{transform:translate(76%,80%)}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(5)   .sc-iJnaPW[_ngcontent-%COMP%]{animation-delay:-3.2s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .fWzKsv[_ngcontent-%COMP%]   .cSaAIp[_ngcontent-%COMP%]:nth-child(5)   .sc-gikAfH[_ngcontent-%COMP%]{animation-delay:-2.4s}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .jLseHP[_ngcontent-%COMP%]{z-index:1;position:absolute;inset:-2px 0 0;overflow:hidden;animation:1s ease .1s 1 normal both running _ngcontent-%COMP%_FUkhV}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .jLseHP[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{display:block;width:100%;height:auto}.content[_ngcontent-%COMP%]   .hoHHXf[_ngcontent-%COMP%]   .jLseHP[_ngcontent-%COMP%]:before{content:"";position:absolute;background-size:100%;inset:0}.connect[_ngcontent-%COMP%]{border-radius:10px}.app-img[_ngcontent-%COMP%]{border:1px solid white;border-radius:8px}']
                        })
                    }
                    return t
                })(),
                Ah = (() => {
                    class t {
                        translate;
                        modalService;
                        isConnected = !1;
                        eventsSubject = new A;
                        sessionCounter;
                        count = 0;
                        endValue = 900;
                        langUpdated = new A;
                        netWork = new qn(!0);
                        selectedLanguage = "en";
                        currentLanguage;
                        ignoreList = ["api.moonpay", "ramp_transaction", "coingecko"];
                        daysCounter = new qn({
                            _days: 0,
                            _hours: 0,
                            _minutes: 0,
                            _seconds: 0,
                            _diff: 0
                        });
                        stopper = new A;
                        constructor(e, i) {
                            this.translate = e, this.modalService = i
                        }
                        broadcastEvent(e, i) {
                            this.eventsSubject.next({
                                key: e,
                                value: i
                            })
                        }
                        getEvent(e) {
                            return this.eventsSubject.asObservable().pipe(ia(i => i.key === e), Fe(i => i.value))
                        }
                        checkList(e) {
                            return !(this.ignoreList.filter(r => e.includes(r)).length > 0)
                        }
                        setNetwork() {
                            this.netWork.next(!0)
                        }
                        getNetwork() {
                            return this.netWork.asObservable()
                        }
                        getLang() {
                            return this.langUpdated.asObservable()
                        }
                        setLang(e) {
                            localStorage.setItem("currentlang", e), this.currentLanguage = e, this.langUpdated.next(e || "en")
                        }
                        setCounter(e) {
                            let i;
                            console.log("endDate", e),
                                function wfe(t = 0, n = Tw) {
                                    return t < 0 && (t = 0), gN(t, t, n)
                                }(1e3).pipe(vN(this.stopper), Fe(r => {
                                    i = e - Date.parse((new Date).toString())
                                })).subscribe(r => {
                                    if (i <= 0) this.broadcastEvent("PRESALE-END", !0), this.stopper.next(!1);
                                    else {
                                        const s = {
                                            _days: this.getDays(i) < 10 ? "0" + this.getDays(i) : this.getDays(i),
                                            _hours: this.getHours(i) < 10 ? "0" + this.getHours(i) : this.getHours(i),
                                            _minutes: this.getMinutes(i) < 10 ? "0" + this.getMinutes(i) : this.getMinutes(i),
                                            _seconds: this.getSeconds(i) < 10 ? "0" + this.getSeconds(i) : this.getSeconds(i),
                                            _diff: i
                                        };
                                        this.daysCounter.next(s)
                                    }
                                })
                        }
                        getCounter() {
                            return this.daysCounter.asObservable()
                        }
                        getDays(e) {
                            return Math.floor(e / 864e5)
                        }
                        getHours(e) {
                            return Math.floor(e / 36e5 % 24)
                        }
                        getMinutes(e) {
                            return Math.floor(e / 1e3 / 60 % 60)
                        }
                        getSeconds(e) {
                            return Math.floor(e / 1e3 % 60)
                        }
                        scrollToFn(e) {
                            window.location.hash = e, console.log(window.location.hash, "window.location.hash"), window.location.pathname = "/" + this.currentLanguage
                        }
                        showBuyWidget(e = "") {
                            e && !this.isConnected ? (this.scrollToFn(e), setTimeout(() => {
                                this.modalService.show(E1, {
                                    class: "modal-min modal-dialog-centered",
                                    backdrop: "static"
                                })
                            }, 1e3)) : this.scrollToFn(e)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(_t(bc), _t(oh))
                        };
                        static\ u0275prov = Dt({
                            token: t,
                            factory: t.\u0275fac,
                            providedIn: "root"
                        })
                    }
                    return t
                })();
            var EI;
            let bbe = (() => {
                class t {
                    meta;
                    title;
                    eventService;
                    lang;
                    constructor(e, i, r) {
                        this.meta = e, this.title = i, this.eventService = r, au("clickId"), au("source"), au("tid"), au("pid"),
                            function vfe() {
                                let n = "SOL-TA-a",
                                    e = new URLSearchParams(document.location.search),
                                    i = (r => {
                                        let s = document.cookie.match(new RegExp("(?:^|; )" + r.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
                                        return s ? decodeURIComponent(s[1]) : void 0
                                    })(n);
                                return e.get("gb") ? (i = e.get("gb"), document.cookie = n + "=" + i + ";max-age=15778462", {
                                    param: i,
                                    inParam: !0
                                }) : {
                                    param: i || "",
                                    inParam: !1
                                }
                            }().inParam && (document.location.search = ""), this.eventService.getLang().subscribe(o => {
                                EI = o || "en"
                            })
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(bR), We(zS), We(Ah))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-root"]
                        ],
                        decls: 2,
                        vars: 1,
                        consts: [
                            [3, "dir"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "div", 0), gt(1, "router-outlet"), ce()), 2 & i && Re("dir", "ar" !== r.lang ? "ltr" : "rtl")
                        },
                        dependencies: [Lw]
                    })
                }
                return t
            })();
            const wbe = ["navigation"];

            function xbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 20)(1, "a", 21), xt("click", function() {
                        const s = Nt(e).$implicit;
                        return Ft(Ke().navigateToSection(s.routeName))
                    }), Oe(2), ce()()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    he(1), Yd("title", e.routeName), he(1), on(e.title)
                }
            }

            function Cbe(t, n) {
                if (1 & t && (J(0, "li", 22)(1, "a", 23), Oe(2), ce()()), 2 & t) {
                    const e = n.$implicit;
                    he(1), Yd("href", e.link, fo), he(1), on(e.title)
                }
            }
            let P7 = (() => {
                class t {
                    eventService;
                    translate;
                    navigation;
                    isScrolled = !1;
                    modalRef;
                    hashKey = "";
                    windowSize;
                    currentLanguage;
                    languagesList = UD;
                    selectedLanguage;
                    isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                    onResize(e) {
                        this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
                    }
                    lang = localStorage.getItem("currentlang");
                    links = [{
                        title: "top_navigation.about",
                        routeName: "about"
                    }, {
                        title: "top_navigation.howtobuy",
                        routeName: "howto"
                    }, {
                        title: "top_navigation.roadmap",
                        routeName: "roadmap"
                    }, {
                        title: "top_navigation.faq",
                        routeName: "faq"
                    }];
                    items = [{
                        title: "footer_navigation.privacy",
                        link: "../assets/documents/policy.pdf"
                    }, {
                        title: "footer_navigation.cookies",
                        link: "../assets/documents/cookies.pdf"
                    }, {
                        title: "footer_navigation.terms",
                        link: "../assets/documents/terms.pdf"
                    }];
                    social = [{
                        img: "assets/images/svg-icons/white_icon_twitter.svg",
                        alt: "",
                        link: ""
                    }, {
                        img: "assets/images/svg-icons/white_icon_telegram.svg",
                        alt: "",
                        link: ""
                    }, {
                        img: "assets/images/svg-icons/white_icon_discord.svg",
                        alt: "",
                        link: ""
                    }];
                    constructor(e, i) {
                        this.eventService = e, this.translate = i, this.windowSize = window.screen.width, this.eventService.getLang().subscribe(r => {
                            this.currentLanguage = r || "en", this.selectedLanguage = this.languagesList.filter(s => s.value === this.currentLanguage)[0]
                        }), this.selectedLanguage = this.languagesList.filter(r => r.value === this.currentLanguage)[0]
                    }
                    ngOnInit() {
                        this.currentLanguage || (this.currentLanguage = EI, this.selectedLanguage = this.languagesList.filter(e => e.value === this.currentLanguage)[0])
                    }
                    ngAfterViewInit() {
                        window.location.hash && setTimeout(() => {
                            this.hashKey = window.location.hash.substring(1, window.location.hash.length), this.navigateToSection(this.hashKey)
                        })
                    }
                    changeLanguage(e) {
                        this.currentLanguage = e, this.translate.use(this.currentLanguage), this.eventService.setLang(this.currentLanguage), this.selectedLanguage = this.languagesList.filter(i => i.value === this.currentLanguage)[0]
                    }
                    navigateToSection(e) {
                        this.hashKey = e, e && (window.location.hash = e, window.location.pathname = "/" + this.currentLanguage)
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(Ah), We(bc))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-footer"]
                        ],
                        viewQuery: function(i, r) {
                            if (1 & i && $c(wbe, 5), 2 & i) {
                                let s;
                                wa(s = xa()) && (r.navigation = s.first)
                            }
                        },
                        hostBindings: function(i, r) {
                            1 & i && xt("resize", function(o) {
                                return r.onResize(o)
                            }, 0, fl)
                        },
                        decls: 32,
                        vars: 2,
                        consts: [
                            ["id", "footer", 1, "footer"],
                            [1, "footer-info"],
                            [1, "container"],
                            [1, "row"],
                            [1, "col-6", "col-lg-2"],
                            [1, "footer-nav"],
                            ["type", "none", 1, "text-left", "mb-0"],
                            ["class", "font-16 fw-semibold font-md-24 mb-3 text-uppercase", 4, "ngFor", "ngForOf"],
                            [1, "col-6", "col-lg-3"],
                            ["class", "font-16 fw-semibold  font-md-24 mb-3", 4, "ngFor", "ngForOf"],
                            [1, "col-12", "col-lg-7"],
                            [1, "copyright", "d-flex", "flex-column", "align-items-lg-end"],
                            ["translate", "", 1, "font-16", "font-md-24", "fw-semibold", "text-lg-end", "mb-2", "mt-4", "mt-md-0"],
                            ["translate", "", 1, "font-16", "font-md-24", "fw-semibold", "text-lg-end", "mb-2"],
                            ["href", "", "translate", "", 1, "font-16", "font-md-24", "fw-semibold", "text-lg-end", "text-white", "text-decoration-none", "text-uppercase"],
                            [1, "footer-bottom"],
                            ["translate", "", 1, "col-12", "col-md-5", "text-lg-start", "mb-3", "mb-lg-0", "fw-semibold", "text-uppercase"],
                            [1, "col-12", "col-md-7"],
                            ["translate", "", 1, "font-13", "fw-semibold", "text-lg-end", "text-uppercase", "fw-light", "text-light-grey", "mb-2"],
                            ["translate", "", 1, "font-13", "fw-semibold", "text-lg-end", "text-uppercase", "fw-light", "text-light-grey", "mb-0"],
                            [1, "font-16", "fw-semibold", "font-md-24", "mb-3", "text-uppercase"],
                            ["href", "javascript:void(0);", "translate", "", 1, "", 3, "title", "click"],
                            [1, "font-16", "fw-semibold", "font-md-24", "mb-3"],
                            ["target", "_blank", "translate", "", 1, "text-uppercase", 3, "href"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "ul", 6), tt(7, xbe, 3, 2, "li", 7), ce()()(), J(8, "div", 8)(9, "div", 5)(10, "ul", 6), tt(11, Cbe, 3, 2, "li", 9), ce()()(), J(12, "div", 10)(13, "div", 11)(14, "p", 12), Oe(15, "footer_navigation.address_1"), ce(), J(16, "p", 13), Oe(17, "footer_navigation.address_2"), ce(), J(18, "p", 13), Oe(19, "footer_navigation.address_3"), ce(), J(20, "a", 14), Oe(21, "footer_navigation.email"), ce()()()()()(), J(22, "div", 15)(23, "div", 2)(24, "div", 3)(25, "div", 16), Oe(26, "footer_navigation.title"), ce(), J(27, "div", 17)(28, "p", 18), Oe(29, "footer_navigation.copyright"), ce(), J(30, "p", 19), Oe(31, "footer_navigation.disclaimer"), ce()()()()()()), 2 & i && (he(7), Re("ngForOf", r.links), he(4), Re("ngForOf", r.items))
                        },
                        dependencies: [Ao, na],
                        styles: [".footer[_ngcontent-%COMP%]   .footer-info[_ngcontent-%COMP%]{padding:40px 0}@media screen and (max-width: 576px){.footer[_ngcontent-%COMP%]   .footer-info[_ngcontent-%COMP%]{padding:40px 10px}}@media screen and (max-width: 768px){.footer[_ngcontent-%COMP%]   .footer-info[_ngcontent-%COMP%]   .footer-nav[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]{padding-left:0rem!important}}.footer[_ngcontent-%COMP%]   .footer-info[_ngcontent-%COMP%]   .footer-nav[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff}.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]{padding:40px 0}@media screen and (max-width: 576px){.footer[_ngcontent-%COMP%]   .footer-bottom[_ngcontent-%COMP%]{padding:20px 10px 40px}}"]
                    })
                }
                return t
            })();
            const Tbe = function() {
                return {
                    "width.px": 20,
                    "height.px": 20
                }
            };
            let Sbe = (() => {
                class t {
                    modalRef;
                    popupService;
                    translateService;
                    url = "";
                    constructor(e, i, r) {
                        this.modalRef = e, this.popupService = i, this.translateService = r
                    }
                    ngOnInit() {}
                    copy() {
                        this.popupService.messsageAlert("success", this.translateService.instant("successCopy"))
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(Dm), We(A_), We(bc))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-refer"]
                        ],
                        decls: 14,
                        vars: 4,
                        consts: [
                            [1, "modal-header"],
                            ["translate", "", 1, "modal-title", "text-center"],
                            [1, "modal-body"],
                            ["translate", "", 1, "fw-medium", "font-15", "text-center"],
                            ["type", "button", "ngxClipboard", "", 1, "btn", "btn-sm", "btn-outline-primary", "my-3", "d-block", "refer-btn", "wx-250", "mx-auto", 3, "cbContent", "click"],
                            [1, "d-flex", "align-items-center", "justify-content-center"],
                            [1, "d-inline-block", "ellipsis", "font-13", "text-primary"],
                            ["src", "./assets/images/svg-icons/copy.svg", 1, "", 3, "svgStyle"],
                            [1, "footer"],
                            ["type", "button", "translate", "", 1, "btn", "btn-sm", "btn-primary", "w-75", "mx-auto", "mt-3", "icon-btn", "d-block", 3, "click"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "div", 0)(1, "h4", 1), Oe(2, "popup.ref_link"), ce()(), J(3, "div", 2)(4, "div", 3), Oe(5, "popup.ref_text"), ce(), J(6, "button", 4), xt("click", function() {
                                return r.copy()
                            }), J(7, "div", 5)(8, "span", 6), Oe(9), ce(), gt(10, "svg-icon", 7), ce()(), J(11, "div", 8)(12, "button", 9), xt("click", function() {
                                return r.modalRef.hide()
                            }), Oe(13, "misc.close"), ce()()()), 2 & i && (he(6), Re("cbContent", r.url), he(3), on(r.url), he(1), Re("svgStyle", Ns(3, Tbe)))
                        },
                        dependencies: [yte, kf, na],
                        styles: [".ellipsis[_ngcontent-%COMP%]{text-overflow:ellipsis;white-space:nowrap;word-break:break-all;overflow:hidden}"]
                    })
                }
                return t
            })();

            function Ebe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 3)(1, "p", 4), Oe(2), qt(3, "translate"), ce(), J(4, "div", 5)(5, "button", 6), xt("click", function() {
                        return Nt(e), Ft(Ke().modalRef.hide())
                    }), Oe(6, "misc.ok"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(2), on(Dn(3, 1, e.isStake ? "staking.claim_stale_help" : "claim_help"))
                }
            }

            function Dbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 3), gt(1, "img", 7), J(2, "div", 8), Oe(3, "staking.stake_claim_success"), ce(), J(4, "a", 9), xt("click", function() {
                        return Nt(e), Ft(Ke().modalRef.hide())
                    }), Oe(5, "staking.dashboard"), ce()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(4), qs("href", "", e.lang, "/staking", fo)
                }
            }
            let k_ = (() => {
                class t {
                    eventService;
                    modalRef;
                    walletConnectService;
                    SwapStatus = Ki;
                    isStake = !1;
                    lang = "en";
                    isWithdraw = !1;
                    constructor(e, i, r) {
                        this.eventService = e, this.modalRef = i, this.walletConnectService = r, this.eventService.getLang().subscribe(s => {
                            this.lang = s || "en"
                        })
                    }
                    get status() {
                        return this.walletConnectService.swapStatus
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(Ah), We(Dm), We(dp))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-claim"]
                        ],
                        decls: 6,
                        vars: 5,
                        consts: [
                            [1, "modal-header"],
                            [1, "modal-title", "text-center"],
                            ["class", "modal-body text-center", 4, "ngIf"],
                            [1, "modal-body", "text-center"],
                            [1, "text-white", "text-center", "mb-3", "font-sm-15"],
                            [1, "footer"],
                            ["type", "button", "translate", "", 1, "btn", "btn-secondary", "fs-7", "w-50", 3, "click"],
                            ["src", "./assets/images/popup-icons/success.svg", "alt", "complete", 1, "statusIcon"],
                            ["translate", "", 1, "text-secondary", "text-center", "mb-3", "font-sm-15"],
                            ["type", "button", "translate", "", 1, "btn", "btn-secondary", "fs-7", "w-auto", 3, "href", "click"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "div", 0)(1, "h4", 1), Oe(2), qt(3, "translate"), ce()(), tt(4, Ebe, 7, 3, "div", 2), tt(5, Dbe, 6, 1, "div", 2)), 2 & i && (he(2), on(Dn(3, 3, r.isStake ? "staking.claim_stake_title" : r.isWithdraw ? "staking.withdraw_title" : "claim_title")), he(2), Re("ngIf", r.status != r.SwapStatus.complete), he(1), Re("ngIf", r.status == r.SwapStatus.complete))
                        },
                        dependencies: [ts, na, Sf],
                        styles: [".modal-body[_ngcontent-%COMP%]{min-height:auto!important}.modal-body[_ngcontent-%COMP%]   .statusIcon[_ngcontent-%COMP%]{height:55px;margin-bottom:15px}"]
                    })
                }
                return t
            })();
            const O7 = {
                randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
            };
            let D1;
            const Abe = new Uint8Array(16);

            function kbe() {
                if (!D1 && (D1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !D1)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return D1(Abe)
            }
            const Ko = [];
            for (let t = 0; t < 256; ++t) Ko.push((t + 256).toString(16).slice(1));
            const Ibe = function Mbe(t, n, e) {
                if (O7.randomUUID && !n && !t) return O7.randomUUID();
                const i = (t = t || {}).random || (t.rng || kbe)();
                if (i[6] = 15 & i[6] | 64, i[8] = 63 & i[8] | 128, n) {
                    e = e || 0;
                    for (let r = 0; r < 16; ++r) n[e + r] = i[r];
                    return n
                }
                return function L7(t, n = 0) {
                    return Ko[t[n + 0]] + Ko[t[n + 1]] + Ko[t[n + 2]] + Ko[t[n + 3]] + "-" + Ko[t[n + 4]] + Ko[t[n + 5]] + "-" + Ko[t[n + 6]] + Ko[t[n + 7]] + "-" + Ko[t[n + 8]] + Ko[t[n + 9]] + "-" + Ko[t[n + 10]] + Ko[t[n + 11]] + Ko[t[n + 12]] + Ko[t[n + 13]] + Ko[t[n + 14]] + Ko[t[n + 15]]
                }(i)
            };
            var Pbe = T(53703),
                Obe = T.n(Pbe);

            function Lbe(t, n) {
                1 & t && (J(0, "h4", 5), Oe(1, "widget.buy_now"), ce())
            }

            function Rbe(t, n) {
                1 & t && (J(0, "h4", 5), Oe(1, "wert.title"), ce())
            }
            const Bbe = function(t) {
                return {
                    token: t
                }
            };

            function Nbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 6)(1, "p", 7), Oe(2), qt(3, "translate"), ce(), J(4, "button", 8), xt("click", function() {
                        return Nt(e), Ft(Ke().showWidget())
                    }), Oe(5, "wert.continue"), ce()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(2), on(_s(3, 1, "wert.disclaimer", fi(4, Bbe, e.token)))
                }
            }

            function Fbe(t, n) {
                1 & t && (J(0, "div", 6), gt(1, "img", 9), J(2, "p", 10), Oe(3, "wert.desc"), ce()())
            }
            const Vbe = function() {
                return {
                    "width.px": 14,
                    "height.px": 14
                }
            };
            let Ube = (() => {
                    class t {
                        modalRef;
                        http;
                        walletConnect;
                        token = nt.tokenName;
                        baseToken;
                        swapToken;
                        isStake = !1;
                        walletAddress;
                        wertWidget;
                        wertOptions = {
                            partner_id: nt.partnerId,
                            origin: nt.wertOrigin,
                            click_id: Ibe(),
                            lang: "en",
                            theme: "light",
                            currency: "USD",
                            commodity: "ETH",
                            network: nt.production ? "ethereum" : "sepolia",
                            extra: {
                                item_info: {
                                    name: "DOGEVERSE",
                                    image_url: "http://thedogeverse.com/assets/images/svg-icons/logo.svg"
                                }
                            }
                        };
                        SwapStatus = Ki;
                        mountError = !1;
                        wertIframe;
                        closeBtn;
                        currentStep = 0;
                        constructor(e, i, r) {
                            this.modalRef = e, this.http = i, this.walletConnect = r
                        }
                        showWidget() {
                            var e = this;
                            return (0, Ze.Z)(function*() {
                                e.currentStep = 1;
                                const i = yield e.walletConnect.getDynamicAmountWert(e.baseToken);
                                let r = {
                                    address: e.walletAddress,
                                    commodity: "ETH",
                                    network: nt.production ? "ethereum" : "sepolia",
                                    commodity_amount: +(1.02 * i).toFixed(8),
                                    sc_address: nt.eth.presaleAddress,
                                    sc_input_data: yield e.walletConnect.getABI(e.baseToken, e.isStake)
                                };
                                e.http.post(nt.wertUrl, r).subscribe(s => {
                                    const o = s.data;
                                    let a = !1;
                                    const c = { ...o,
                                        ...e.wertOptions
                                    };
                                    console.log("wertOptions =", c), e.wertWidget = new(Obe())({ ...o,
                                        ...e.wertOptions,
                                        listeners: {
                                            loaded: () => {
                                                console.log("widget loaded:"), e.walletConnect.swapStatus = Ki.confirm_pending;
                                                const u = window.parent.document.getElementsByTagName("iframe");
                                                e.wertIframe = u[u.length - 1], e.modalRef.hide()
                                            },
                                            close: () => {
                                                console.log("widget closed:"), e.walletConnect.swapStatus = Ki.rejected
                                            },
                                            position: u => console.log("step:", u.step),
                                            "payment-status": u => {
                                                console.log("payment-status:", u), ("progress" == u.status || "pending" == u.status) && (e.walletConnect.swapStatus = Ki.in_progess), ("progress" == u.status || "success" == u.status) && !a && (e.walletConnect.sendDashFx("eth", e.baseToken, +i.toFixed(8)), a = !0), "success" == u.status && (e.walletConnect.checkTansaction(u.tx_id, "ETH", e.baseToken, +i.toFixed(8)), e.wertWidget.removeEventListeners(), e.wertIframe.remove()), "canceled" == u.status && (e.walletConnect.swapStatus = Ki.rejected)
                                            },
                                            error: u => {
                                                console.log("error:", u), e.walletConnect.swapStatus = Ki.failed
                                            }
                                        }
                                    }), e.wertWidget.open()
                                }, s => {
                                    console.log("wert error response", s), e.mountError = !0, e.walletConnect.swapStatus = Ki.not_started
                                })
                            })()
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(Dm), We(Ef), We(dp))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-wert"]
                            ],
                            decls: 9,
                            vars: 6,
                            consts: [
                                [1, "p-4"],
                                [1, "d-flex", "justify-content-between", "align-items-center"],
                                ["class", "text-center fw-semibold fs-5 m-0 text-white", "translate", "", 4, "ngIf"],
                                ["src", "/assets/images/svg-icons/close.svg", 1, "cursor-pointer", 3, "svgStyle", "click"],
                                ["class", "mt-4 content text-center", 4, "ngIf"],
                                ["translate", "", 1, "text-center", "fw-semibold", "fs-5", "m-0", "text-white"],
                                [1, "mt-4", "content", "text-center"],
                                ["translate", "", 1, "text-white"],
                                ["translate", "", 1, "btn", "btn-primary", "font-14", "mt-2", "mx-auto", 3, "click"],
                                ["src", "/assets/images/svg-icons/logo.svg", "alt", "loading", 1, "worker"],
                                ["translate", "", "translate", "", 1, "text-white"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "div", 0)(1, "div", 1)(2, "div"), Oe(3, "\xa0\xa0\xa0"), ce(), tt(4, Lbe, 2, 0, "h4", 2), tt(5, Rbe, 2, 0, "h4", 2), J(6, "svg-icon", 3), xt("click", function() {
                                    return r.modalRef.hide()
                                }), ce()(), tt(7, Nbe, 6, 6, "div", 4), tt(8, Fbe, 4, 0, "div", 4), ce()), 2 & i && (he(4), Re("ngIf", 0 === r.currentStep), he(1), Re("ngIf", 1 === r.currentStep), he(1), Re("svgStyle", Ns(5, Vbe)), he(1), Re("ngIf", 0 === r.currentStep), he(1), Re("ngIf", 1 === r.currentStep))
                            },
                            dependencies: [ts, kf, na, Sf],
                            styles: [".worker[_ngcontent-%COMP%]{display:block;margin:20px auto;max-width:270px}"]
                        })
                    }
                    return t
                })(),
                Hbe = (() => {
                    class t {
                        el;
                        noDecimal = 10;
                        regex = new RegExp(/^\d*\.?\d{0,2}$/g);
                        specialKeys = ["Backspace", "Tab", "End", "Home", "-", "ArrowLeft", "ArrowRight", "Del", "Delete"];
                        constructor(e) {
                            this.el = e
                        }
                        ngOnChanges(e) {
                            this.setRegex()
                        }
                        ngOnInit() {
                            this.setRegex()
                        }
                        setRegex() {
                            0 !== this.noDecimal && this.noDecimal ? 6 === this.noDecimal ? this.regex = new RegExp(/^\d*\.?\d{0,6}$/g) : 10 === this.noDecimal && (this.regex = new RegExp(/^\d*\.?\d{0,10}$/g)) : this.regex = new RegExp(/^[\d]*$/g)
                        }
                        onPaste(e) {
                            return !1
                        }
                        onKeyDown(e) {
                            if (-1 !== this.specialKeys.indexOf(e.key)) return;
                            let i = this.el.nativeElement.value;
                            const r = this.el.nativeElement.selectionStart,
                                s = [i.slice(0, r), "Decimal" == e.key ? "." : e.key, i.slice(r)].join("");
                            s && !String(s).match(this.regex) && e.preventDefault()
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(ir))
                        };
                        static\ u0275dir = Un({
                            type: t,
                            selectors: [
                                ["", "appTwoDigitDecimalNumber", ""]
                            ],
                            hostBindings: function(i, r) {
                                1 & i && xt("paste", function(o) {
                                    return r.onPaste(o)
                                })("keydown", function(o) {
                                    return r.onKeyDown(o)
                                })
                            },
                            inputs: {
                                noDecimal: "noDecimal"
                            },
                            features: [Xi]
                        })
                    }
                    return t
                })();
            const $be = ["swapIn"],
                R7 = function(t) {
                    return {
                        selected: t
                    }
                };

            function zbe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 5)(1, "button", 6), xt("click", function() {
                        return Nt(e), Ft(Ke().changeTab(!0))
                    }), gt(2, "img", 7), J(3, "span", 8), Oe(4), ce()(), J(5, "button", 6), xt("click", function() {
                        return Nt(e), Ft(Ke().changeTab(!1))
                    }), gt(6, "img", 9), J(7, "span", 10), Oe(8), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(1), Re("ngClass", fi(5, R7, e.isNative)), he(1), qs("src", "/assets/images/svg-icons/", e.modeName, ".svg", fo), he(2), on(e.modeName), he(1), Re("ngClass", fi(7, R7, !e.isNative)), he(3), on("BASE" === e.modeName ? "USDC" : "USDT")
                }
            }

            function jbe(t, n) {
                if (1 & t && (J(0, "div", 13), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), wy("", e.actualModename, " ", Dn(2, 3, "balance"), " ", e.convertNum(e.nativeBal, 4), "")
                }
            }

            function Wbe(t, n) {
                if (1 & t && (J(0, "div", 13), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), wy("", "BASE" === e.modeName ? "USDC" : "USDT", " ", Dn(2, 3, "balance"), " ", e.convertNum(e.usdtBal, 4), "")
                }
            }

            function Gbe(t, n) {
                if (1 & t && (J(0, "div", 11), tt(1, jbe, 3, 5, "div", 12), tt(2, Wbe, 3, 5, "div", 12), ce()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngIf", e.isNative && !e.isWert), he(1), Re("ngIf", !e.isNative && !e.isWert)
                }
            }
            const Kbe = function(t, n) {
                return {
                    gasFees: t,
                    modeName: n
                }
            };

            function qbe(t, n) {
                if (1 & t && (J(0, "div", 34), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "widget.gas_fees", yl(4, Kbe, e.gasFees, e.actualModename)))
                }
            }
            const B7 = function(t) {
                return {
                    modeName: t
                }
            };

            function Zbe(t, n) {
                if (1 & t && (J(0, "div", 34), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "widget.low_gas_fees", fi(4, B7, e.actualModename)))
                }
            }
            const N7 = function(t) {
                return {
                    tokenName: t
                }
            };

            function Ybe(t, n) {
                if (1 & t && (J(0, "div", 34), Oe(1), qt(2, "translate"), qt(3, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(e.lowGas ? _s(2, 1, "widget.low_gas_fees", fi(7, B7, e.actualModename)) : _s(3, 4, "widget.low_usdt", fi(9, N7, e.tokenName)))
                }
            }
            const Xbe = function(t, n) {
                return {
                    minAmount: t,
                    cryptoName: n
                }
            };

            function Qbe(t, n) {
                if (1 & t && (J(0, "div", 35), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), Ln(" ", _s(2, 1, "widget.min_crypto", yl(4, Xbe, e.minAmount, e.cryptoName)), " ")
                }
            }
            const Jbe = function(t, n, e) {
                return {
                    gasFees: t,
                    modeName: n,
                    tokenName: e
                }
            };

            function ewe(t, n) {
                if (1 & t && (J(0, "div", 35), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), Ln(" ", _s(2, 1, "widget.swap_error", g3(4, Jbe, e.gasFees, e.actualModename, e.tokenName)), " ")
                }
            }

            function twe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "button", 39), xt("click", function() {
                        return Nt(e), Ft(Ke(3).confirm(!0))
                    }), Oe(1), qt(2, "translate"), qt(3, "translate"), ce()
                }
                if (2 & t) {
                    const e = Ke(3);
                    Re("disabled", e.isLowBalance && !e.isWert || !e.swapToken || 0 == e.swapToken), he(1), wy("", Dn(2, 4, "staking.buy_stake_for"), " ", e.stakeData.apy, "% ", Dn(3, 6, "staking.rewards"), " ")
                }
            }

            function nwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("ETH"))
                    }), J(1, "div", 51), gt(2, "img", 52), J(3, "a", 53), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " ETH"))
            }

            function iwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("BNB"))
                    }), J(1, "div", 51), gt(2, "img", 54), J(3, "a", 55), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " BNB"))
            }

            function rwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("MATIC"))
                    }), J(1, "div", 51), gt(2, "img", 56), J(3, "a", 55), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " MATIC"))
            }

            function swe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("AVAX"))
                    }), J(1, "div", 51), gt(2, "img", 57), J(3, "a", 55), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " AVAX"))
            }

            function owe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("BASE"))
                    }), J(1, "div", 51), gt(2, "img", 58), J(3, "a", 55), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " BASE"))
            }

            function awe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 50), xt("click", function() {
                        return Nt(e), Ft(Ke(5).changeChain("SOL"))
                    }), J(1, "div", 51), gt(2, "img", 59), J(3, "a", 55), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " SOL"))
            }

            function cwe(t, n) {
                if (1 & t && (J(0, "ul", 48), tt(1, nwe, 6, 3, "li", 49), tt(2, iwe, 6, 3, "li", 49), tt(3, rwe, 6, 3, "li", 49), tt(4, swe, 6, 3, "li", 49), tt(5, owe, 6, 3, "li", 49), tt(6, awe, 6, 3, "li", 49), ce()), 2 & t) {
                    const e = Ke(4);
                    he(1), Re("ngIf", "ETH" != e.modeName), he(1), Re("ngIf", "BNB" != e.modeName), he(1), Re("ngIf", "MATIC" != e.modeName), he(1), Re("ngIf", "AVAX" != e.modeName), he(1), Re("ngIf", "BASE" != e.modeName), he(1), Re("ngIf", "SOL" != e.modeName)
                }
            }
            const lwe = function() {
                return {
                    "width.px": "12",
                    "height.px": 12
                }
            };

            function uwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 40)(1, "button", 41), xt("click", function() {
                        return Nt(e), Ft(Ke(3).confirm())
                    }), Oe(2, "widget.buy_now "), ce(), J(3, "div", 42)(4, "div", 43), gt(5, "img", 44), J(6, "span", 45), Oe(7), qt(8, "translate"), ce(), gt(9, "svg-icon", 46), ce(), tt(10, cwe, 7, 6, "ul", 47), ce()()
                }
                if (2 & t) {
                    const e = Ke(3);
                    he(1), Re("disabled", e.isLowBalance && !e.isWert || !e.swapToken || 0 == e.swapToken), he(2), Re("dropup", !0), he(2), qs("src", "/assets/images/svg-icons/", e.modeName, ".svg", fo), he(2), by("", Dn(8, 6, "widget.switch_to"), " ", e.modeName, ""), he(2), Re("svgStyle", Ns(8, lwe))
                }
            }

            function dwe(t, n) {
                if (1 & t && (J(0, "div", 36), tt(1, twe, 4, 8, "button", 37), tt(2, uwe, 11, 9, "div", 38), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), Re("ngIf", "ETH" == e.modeName), he(1), Re("ngIf", !e.isModal)
                }
            }
            const hp = function(t) {
                    return {
                        "mt-0": t
                    }
                },
                F7 = function() {
                    return {
                        "width.px": 28,
                        "height.px": 28
                    }
                },
                hwe = function(t) {
                    return {
                        cryptoName: t
                    }
                };

            function fwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 14)(1, "div", 15)(2, "div", 16)(3, "div", 17)(4, "label", 18), Oe(5), qt(6, "translate"), ce(), J(7, "div", 19), xt("click", function() {
                        return Nt(e), Ft(Ke().max())
                    }), Oe(8), qt(9, "translate"), ce()(), J(10, "div", 20)(11, "input", 21, 22), xt("ngModelChange", function(r) {
                        return Nt(e), Ft(Ke().swapToken = r)
                    })("ngModelChange", function(r) {
                        return Nt(e), Ft(Ke().swapTokenUpdate.next(r))
                    }), ce(), J(13, "div", 23), gt(14, "svg-icon", 24), ce()()(), J(15, "div", 25)(16, "div", 17)(17, "label", 26), Oe(18), qt(19, "translate"), ce()(), J(20, "div", 27)(21, "input", 28), xt("ngModelChange", function(r) {
                        return Nt(e), Ft(Ke().baseToken = r)
                    })("ngModelChange", function(r) {
                        return Nt(e), Ft(Ke().baseTokenUpdate.next(r))
                    }), ce(), J(22, "div", 23), gt(23, "svg-icon", 29), ce()()(), J(24, "div", 30), tt(25, qbe, 3, 7, "div", 31), tt(26, Zbe, 3, 6, "div", 31), tt(27, Ybe, 4, 11, "div", 31), tt(28, Qbe, 3, 7, "div", 32), tt(29, ewe, 3, 8, "div", 32), ce()(), tt(30, dwe, 3, 2, "div", 33), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(25, hp, e.isModal)), he(5), on(_s(6, 17, "widget.pay_with", fi(27, N7, e.tokenName))), he(3), on(Dn(9, 20, "widget.max")), he(3), Re("noDecimal", e.isNative ? 10 : 6)("ngModel", e.swapToken), he(3), qs("src", "./assets/images/svg-icons/", e.isNative ? e.actualModename : e.isWert ? "usd" : "BASE" === e.modeName ? "usdc" : "usdt", ".svg"), Re("svgStyle", Ns(29, F7)), he(4), on(_s(19, 22, "widget.amount_in", fi(30, hwe, e.cryptoName))), he(3), Re("noDecimal", 0)("ngModel", e.baseToken), he(2), Re("svgStyle", Ns(32, F7)), he(2), Re("ngIf", !e.isLowBalance && !e.isWert && e.walletAddress), he(1), Re("ngIf", e.isNative && e.isLowBalance && !e.isWert && e.walletAddress), he(1), Re("ngIf", !e.isNative && e.isLowBalance && !e.isWert && e.walletAddress), he(1), Re("ngIf", e.baseToken && e.baseToken < e.minAmount && !e.isWert && e.walletAddress), he(1), Re("ngIf", e.baseToken && e.baseToken >= e.minAmount && e.isLowBalance && !e.isWert && e.walletAddress), he(1), Re("ngIf", e.walletAddress)
                }
            }
            const V7 = function(t, n) {
                return {
                    baseToken: t,
                    cryptoName: n
                }
            };

            function pwe(t, n) {
                if (1 & t && (J(0, "p", 64), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "widget.transction_info", yl(4, V7, e.baseToken, e.cryptoName)))
                }
            }
            const U7 = function(t) {
                return {
                    baseToken: t
                }
            };

            function mwe(t, n) {
                if (1 & t && (J(0, "p", 64), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "staking.transction_info_stake", fi(4, U7, e.baseToken)))
                }
            }

            function gwe(t, n) {
                if (1 & t && (J(0, "div", 60), gt(1, "img", 61), J(2, "div", 62), Oe(3), qt(4, "translate"), ce(), tt(5, pwe, 3, 7, "p", 63), tt(6, mwe, 3, 6, "p", 63), ce()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(6, hp, e.isModal)), he(3), on(Dn(4, 4, "widget.transaction_in_progress")), he(2), Re("ngIf", !e.isStake), he(1), Re("ngIf", e.isStake)
                }
            }
            const H7 = function(t, n) {
                return {
                    cryptoName: t,
                    tokenName: n
                }
            };

            function ywe(t, n) {
                if (1 & t && (J(0, "p", 64), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "widget.waiting_confirm", yl(4, H7, e.cryptoName, e.tokenName)))
                }
            }

            function _we(t, n) {
                1 & t && (J(0, "p", 64), Oe(1), qt(2, "translate"), ce()), 2 & t && (he(1), on(Dn(2, 1, "staking.waiting_confirm_stake")))
            }

            function vwe(t, n) {
                1 & t && (J(0, "p", 64), Oe(1), qt(2, "translate"), ce()), 2 & t && (he(1), on(Dn(2, 1, "staking.waiting_confirm_stake_2")))
            }

            function bwe(t, n) {
                if (1 & t && (J(0, "div", 60), gt(1, "img", 61), J(2, "div", 65), Oe(3), qt(4, "translate"), ce(), tt(5, ywe, 3, 7, "p", 63), tt(6, _we, 3, 3, "p", 63), tt(7, vwe, 3, 3, "p", 63), ce()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(7, hp, e.isModal)), he(3), on(Dn(4, 5, "confirm")), he(2), Re("ngIf", !e.isStake), he(1), Re("ngIf", e.isStake), he(1), Re("ngIf", e.isStake)
                }
            }

            function wwe(t, n) {
                if (1 & t && (J(0, "div", 60), gt(1, "img", 61), J(2, "div", 66), Oe(3), qt(4, "translate"), ce(), J(5, "p", 64), Oe(6), qt(7, "translate"), ce()()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(8, hp, e.isModal)), he(3), on(Dn(4, 3, "widget.authorise")), he(3), on(_s(7, 5, "widget.waiting_approve", yl(10, H7, e.cryptoName, e.tokenName)))
                }
            }

            function xwe(t, n) {
                if (1 & t && (J(0, "p", 73), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "staking.transction_info_stake_success", fi(4, U7, e.baseToken)))
                }
            }

            function Cwe(t, n) {
                if (1 & t && (J(0, "p", 73), Oe(1), qt(2, "translate"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), on(_s(2, 1, "widget.transction_info", yl(4, V7, e.baseToken, e.cryptoName)))
                }
            }

            function Twe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 74)(1, "button", 75), xt("click", function() {
                        return Nt(e), Ft(Ke(2).stakeNow())
                    }), Oe(2), qt(3, "translate"), ce()()
                }
                2 & t && (he(2), on(Dn(3, 1, "widget.stake_now")))
            }

            function Swe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 60), gt(1, "img", 67), J(2, "div", 68), Oe(3), qt(4, "translate"), ce(), tt(5, xwe, 3, 6, "p", 69), tt(6, Cwe, 3, 7, "p", 69), tt(7, Twe, 4, 3, "div", 70), J(8, "div", 71)(9, "button", 72), xt("click", function() {
                        return Nt(e), Ft(Ke().viewUrl())
                    }), Oe(10), qt(11, "translate"), ce(), J(12, "button", 72), xt("click", function() {
                        return Nt(e), Ft(Ke().startAgain())
                    }), Oe(13), qt(14, "translate"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(13, hp, e.isModal)), he(3), on(Dn(4, 7, "widget.transaction_success")), he(2), Re("ngIf", e.isStake), he(1), Re("ngIf", !e.isStake), he(1), Re("ngIf", "ETH" == e.modeName && !e.isModal && !e.isStake), he(3), on(Dn(11, 9, "widget.view_transaction")), he(3), on(Dn(14, 11, "widget.start_again"))
                }
            }

            function Ewe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 60), gt(1, "img", 76), J(2, "div", 77), Oe(3), qt(4, "translate"), ce(), J(5, "p", 78), Oe(6), qt(7, "translate"), ce(), J(8, "div", 71)(9, "button", 72), xt("click", function() {
                        return Nt(e), Ft(Ke().viewUrl())
                    }), Oe(10), qt(11, "translate"), ce(), J(12, "button", 72), xt("click", function() {
                        return Nt(e), Ft(Ke().startAgain())
                    }), Oe(13), qt(14, "translate"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(13, hp, e.isModal)), he(3), on(Dn(4, 5, "widget.transaction_failed")), he(3), on(Dn(7, 7, "widget.view_transaction_info")), he(4), on(Dn(11, 9, "widget.view_transaction")), he(3), on(Dn(14, 11, "widget.start_again"))
                }
            }

            function Dwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 60), gt(1, "img", 76), J(2, "div", 79), Oe(3), qt(4, "translate"), ce(), J(5, "div", 80)(6, "button", 81), xt("click", function() {
                        return Nt(e), Ft(Ke().startAgain())
                    }), Oe(7), qt(8, "translate"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(7, hp, e.isModal)), he(3), on(Dn(4, 3, "widget.transaction_rejected")), he(4), on(Dn(8, 5, "widget.start_again"))
                }
            }
            const Awe = function(t) {
                return {
                    "mt-4 mb-2": t
                }
            };
            let DI = (() => {
                class t {
                    walletConnectService;
                    http;
                    eventService;
                    modalService;
                    translate;
                    popupService;
                    router;
                    isNative = !1;
                    isWert = !1;
                    isModal = !1;
                    messageEvent = new zt;
                    swapIn = null;
                    subscriptions = [];
                    environtment = nt;
                    baseToken;
                    swapToken;
                    baseCurrencyValue;
                    swapTokenUpdate = new A;
                    baseTokenUpdate = new A;
                    contractData;
                    currentLang;
                    SwapStatus = Ki;
                    lblockPrice = 0;
                    isLowBalance = !1;
                    inProgress = !1;
                    currentLanguage;
                    isStake = !1;
                    usdtBal = 0;
                    nativeBal = 0;
                    minAmount = nt.minToken;
                    modalRef;
                    lowGas = !1;
                    wertMode = !1;
                    constructor(e, i, r, s, o, a, c) {
                        this.walletConnectService = e, this.http = i, this.eventService = r, this.modalService = s, this.translate = o, this.popupService = a, this.router = c, this.currentLang = this.translate.currentLang, this.translate.onLangChange.subscribe(u => {
                            this.currentLang = u.lang || "en"
                        }), this.eventService.getNetwork().subscribe(u => {
                            this.getBal(), this.isWert || this.max()
                        }), this.subscriptions.push(this.swapTokenUpdate.pipe(FE(500)).subscribe(u => {
                            this.swapToken >= 0 ? this.calculateSwap() : this.baseToken = 0
                        })), this.subscriptions.push(this.baseTokenUpdate.pipe(FE(500)).subscribe(u => {
                            this.baseToken >= 0 ? this.calculateSwapReverse() : this.swapToken = 0
                        }))
                    }
                    ngOnChanges() {
                        setTimeout(() => {
                            this.swapToken = void 0, this.baseToken = void 0, this.walletConnectService.swapStatus = Ki.not_started, this.isLowBalance = !1, this.lowGas = !1, this.getBal(), this.checkLowBalance(), this.isWert || this.max()
                        }, 600)
                    }
                    ngOnInit() {
                        this.walletConnectService.swapStatus = Ki.not_started, this.isLowBalance = !1, setInterval(() => this.getBal(), 500), this.translate.onLangChange.subscribe(e => {
                            this.currentLanguage = e.lang
                        })
                    }
                    max() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            let i = e.isNative ? yield e.walletConnectService.getDynamicAmount(1.02041 * e.maxTokensToBuy, "getNativeAmount"): yield e.walletConnectService.getDynamicAmount(e.maxTokensToBuy, "getUSDTAmount");
                            e.swapToken = +e.floorString((e.isNative ? e.nativeBal - e.gasFees > 0 ? e.nativeBal - e.gasFees : 0 : e.usdtBal).toString()), i < e.swapToken && (e.swapToken = i), e.isWert && (e.swapToken = 0), 0 == e.swapToken && (e.swapToken = void 0, e.baseToken = 0), e.swapTokenUpdate.next(e.swapToken), setTimeout(() => e.swapTokenUpdate.next(e.swapToken), 200)
                        })()
                    }
                    getBal() {
                        this.nativeBal = this.allBalance.native, this.usdtBal = this.allBalance.usdt
                    }
                    get walletAddress() {
                        return this.walletConnectService.walletAddress
                    }
                    get status() {
                        return this.walletConnectService.swapStatus
                    }
                    get hash() {
                        return this.walletConnectService.swapHash
                    }
                    get tokenName() {
                        return this.isNative ? this.actualModename : this.isWert ? "USD" : "BASE" === this.modeName ? "USDC" : "USDT"
                    }
                    get modeName() {
                        return this.walletConnectService.getChainData().purchaseToken
                    }
                    get actualModename() {
                        return "BASE" === this.modeName ? "ETH" : this.modeName
                    }
                    get chainData() {
                        return this.walletConnectService.getChainData()
                    }
                    get gasFees() {
                        return "ETH" === this.modeName ? nt.eth.gasFees : "BNB" === this.modeName ? nt.bsc.gasFees : "MATIC" === this.modeName ? nt.poly.gasFees : "AVAX" === this.modeName ? nt.avalanche.gasFees : nt.base.gasFees
                    }
                    get allBalance() {
                        return {
                            native: +this.walletConnectService.balanceData.nativeBal.toFixed(10).replace(/0{0,10}$/, ""),
                            usdt: this.walletConnectService.balanceData.usdtBal
                        }
                    }
                    get maxTokensToBuy() {
                        return this.walletConnectService.balanceData.maxTokensToBuy
                    }
                    ngOnDestroy() {
                        for (const e of this.subscriptions) e.unsubscribe()
                    }
                    startAgain() {
                        this.getBal(), this.max(), this.walletConnectService.swapStatus = Ki.not_started
                    }
                    confirm(e = !1) {
                        this.isStake = e, this.isWert ? this.modalRef = this.modalService.show(Ube, {
                            class: "modal-xs modal-dialog-centered transak",
                            backdrop: "static",
                            initialState: {
                                walletAddress: this.walletAddress,
                                baseToken: this.baseToken,
                                swapToken: this.swapToken,
                                isStake: this.isStake
                            }
                        }) : 0 !== this.swapToken && this.baseToken >= this.minAmount && this.createSwap(e)
                    }
                    calculateSwap = (() => {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            e.checkLowBalance(), e.baseToken = e.isNative ? yield e.walletConnectService.getNativeAmount(.98 * e.swapToken): yield e.walletConnectService.getUSDTAmount(e.swapToken), e.baseToken = +e.baseToken.toFixed(0).replace(/0{0,0}$/, "")
                        })
                    })();
                    calculateSwapReverse = (() => {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            e.isNative ? (e.swapToken = yield e.walletConnectService.getDynamicAmount(e.baseToken, "getNativeAmount"), e.swapToken = +(1.001 * e.swapToken).toFixed(10).replace(/0{0,10}$/, ""), console.log(e.swapToken)) : e.swapToken = yield e.walletConnectService.getDynamicAmount(e.baseToken, "getUSDTAmount"), e.checkLowBalance()
                        })
                    })();
                    createSwap(e = !1) {
                        var i = this;
                        return (0, Ze.Z)(function*() {
                            if (!i.inProgress)
                                if (i.inProgress = !0, console.log("createSwap called", i.isNative, i.maxTokensToBuy), i.baseToken <= i.maxTokensToBuy) {
                                    i.walletConnectService.swapStatus = Ki.not_started;
                                    try {
                                        i.isNative ? i.nativeBal - i.gasFees >= i.swapToken ? (i.isLowBalance = !1, yield i.walletConnectService.swapNativeTokens(i.baseToken, i.swapToken, e)) : i.isLowBalance = !0 : i.usdtBal >= i.swapToken && i.nativeBal >= i.gasFees ? (i.isLowBalance = !1, yield i.walletConnectService.swapCryptoForUSDT(i.baseToken, i.swapToken, !1, e)) : (i.isLowBalance = !0, i.nativeBal < i.gasFees && (i.lowGas = !0)), i.inProgress = !1
                                    } catch (r) {
                                        console.log("createSwap", r), i.walletConnectService.swapStatus = r && 4001 == r.code ? Ki.rejected : Ki.failed, i.inProgress = !1
                                    }
                                } else i.popupService.messagePopup("warning", i.translate.instant("widget.max_token_exceed", {
                                    maxTokensToBuy: i.maxTokensToBuy
                                }), i.translate.instant("widget.max_token_title")), i.walletConnectService.swapStatus = Ki.not_started, i.inProgress = !1
                        })()
                    }
                    viewUrl() {
                        window.open(this.chainData.blockExplorerURL + this.hash, "_blank")
                    }
                    get cryptoName() {
                        return nt.tokenName
                    }
                    get stakeData() {
                        return this.walletConnectService.stakeData
                    }
                    checkLowBalance() {
                        this.isNative ? this.isLowBalance = !(this.nativeBal - this.gasFees >= this.swapToken) : +this.usdtBal >= +this.swapToken && +this.nativeBal >= this.gasFees ? (this.isLowBalance = !1, this.lowGas = !1) : (this.isLowBalance = !0, this.nativeBal < this.gasFees && (this.lowGas = !0))
                    }
                    openWert() {
                        this.eventService.broadcastEvent("OPEN_WERT", !0)
                    }
                    checkChain() {
                        return !0
                    }
                    convertNum(e, i = 2) {
                        return zD(e, i)
                    }
                    floorString(e) {
                        let i = e.indexOf(".");
                        return i >= 0 ? (e + "00").slice(0, i + 6) : e + ".00"
                    }
                    changeChain(e) {
                        if (e == this.modeName) return;
                        if ("SOL" == e) return void(window.location.href = nt.solDomain + this.currentLanguage);
                        let i = "ETH" == e ? nt.eth : "BNB" == e ? nt.bsc : "MATIC" == e ? nt.poly : "AVAX" == e ? nt.avalanche : nt.base;
                        "ETH" == this.modeName ? this.popupService.messagePopup("info", this.translate.instant("popup.change_swap_text", {
                            apy: this.stakeData.apy,
                            mode: "BNB" == e ? "BNB Smart Chain" : "MATIC" == e ? "Polygon" : "AVAX" == e ? "Avalanche" : "Base"
                        }), this.translate.instant("popup.are_you_sure"), this.translate.instant("popup.buy_with_mode", {
                            mode: e
                        }), this.translate.instant("cancel")).then(r => {
                            r.isConfirmed && (this.walletAddress ? this.walletConnectService.switchNetwork(i.chainIdInt) : this.walletConnectService.chainId = i.chainIdInt)
                        }) : this.walletAddress ? this.walletConnectService.switchNetwork(i.chainIdInt) : this.walletConnectService.chainId = i.chainIdInt
                    }
                    changeTab(e = !0) {
                        this.isNative = e, setTimeout(() => this.max(), 1e3)
                    }
                    stakeNow() {
                        this.walletConnectService.switchNetwork(nt.eth.chainIdInt), this.router.navigateByUrl(this.currentLang + "/staking", {})
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(dp), We(Ef), We(Ah), We(oh), We(bc), We(A_), We(Za))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-swap"]
                        ],
                        viewQuery: function(i, r) {
                            if (1 & i && $c($be, 5), 2 & i) {
                                let s;
                                wa(s = xa()) && (r.swapIn = s.first)
                            }
                        },
                        inputs: {
                            isNative: "isNative",
                            isWert: "isWert",
                            isModal: "isModal"
                        },
                        outputs: {
                            messageEvent: "messageEvent"
                        },
                        features: [Xi],
                        decls: 10,
                        vars: 12,
                        consts: [
                            [1, "swapSection", 3, "ngClass"],
                            ["class", "tab-container gap-2 mb-3", 4, "ngIf"],
                            ["class", "text-center pb-2 font-16", 4, "ngIf"],
                            ["class", "body-section mt-2", 3, "ngClass", 4, "ngIf"],
                            ["class", "body-section mt-1 text-center", 3, "ngClass", 4, "ngIf"],
                            [1, "tab-container", "gap-2", "mb-3"],
                            [1, "btn", "btn-light", "text-uppercase", "d-flex", "align-items-center", "justify-content-center", 3, "ngClass", "click"],
                            ["height", "25", "alt", "", 3, "src"],
                            [1, "px-2"],
                            ["src", "/assets/images/svg-icons/usdt.svg", "height", "25", "alt", ""],
                            [1, "ps-2"],
                            [1, "text-center", "pb-2", "font-16"],
                            ["class", "ms-2 fw-semibold dashTitle text-light", 4, "ngIf"],
                            [1, "ms-2", "fw-semibold", "dashTitle", "text-light"],
                            [1, "body-section", "mt-2", 3, "ngClass"],
                            [1, "row", "my-2"],
                            [1, "col-md-6", "pe-md-2"],
                            [1, "d-flex", "align-items-center", "justify-content-between", "mb-2"],
                            [1, "d-block", "font-12", "text-light"],
                            [1, "text-white", "cursor-pointer", "font-12", "fw-bold", 3, "click"],
                            [1, "amountField", "d-flex", "align-items-start"],
                            ["type", "text", "appTwoDigitDecimalNumber", "", "placeholder", "0", 1, "form-control", "text-truncate", 3, "noDecimal", "ngModel", "ngModelChange"],
                            ["swapIn", ""],
                            [1, "amountType"],
                            [3, "src", "svgStyle"],
                            [1, "col-md-6", "ps-md-2", "mt-3", "mt-md-0"],
                            [1, "d-block", "font-12", "text-truncate", "text-light"],
                            [1, "amountField"],
                            ["type", "text", "appTwoDigitDecimalNumber", "", "min", "minAmount", "pattern", "\\d*", "placeholder", "0", 1, "form-control", "text-truncate", 3, "noDecimal", "ngModel", "ngModelChange"],
                            ["src", "./assets/images/svg-icons/token.svg", 3, "svgStyle"],
                            [1, "col-12", "text-center", "fs-8"],
                            ["class", "lowBalance m-2 text-light", 4, "ngIf"],
                            ["class", "text-center mt-2 w-100 text-warning", 4, "ngIf"],
                            ["class", "d-flex flex-column align-items-center my-2", 4, "ngIf"],
                            [1, "lowBalance", "m-2", "text-light"],
                            [1, "text-center", "mt-2", "w-100", "text-warning"],
                            [1, "d-flex", "flex-column", "align-items-center", "my-2"],
                            ["type", "button", "class", "btn btn-primary text-white font-16 w-100 ", 3, "disabled", "click", 4, "ngIf"],
                            ["class", "d-flex flex-column flex-md-row align-items-center justify-content-between my-2 w-100 gap-2", 4, "ngIf"],
                            ["type", "button", 1, "btn", "btn-primary", "text-white", "font-16", "w-100", 3, "disabled", "click"],
                            [1, "d-flex", "flex-column", "flex-md-row", "align-items-center", "justify-content-between", "my-2", "w-100", "gap-2"],
                            ["type", "button", "translate", "", 1, "btn", "btn-primary", "font-16", "text-white", "w-100", 3, "disabled", "click"],
                            ["dropdown", "", "dropdownToggle", "", 1, "btn", "btn-outline-primary", "fs-7", "w-100", "buyWith", "btn-group", "position-relative", 3, "dropup"],
                            ["type", "button", 1, "dropdown-toggle", "d-flex", "align-items-center", "justify-content-between", "w-100"],
                            ["height", "22", "alt", "", 3, "src"],
                            [1, "text-decoration-none", "selectedMenu", "mx-2"],
                            ["src", "./assets/images/svg-icons/angle-down.svg", 1, "dropdown", 3, "svgStyle"],
                            ["class", "py-2 dropdown-menu dropdown-menu-right fixPos  px-3 ", "role", "menu", 4, "dropdownMenu"],
                            ["role", "menu", 1, "py-2", "dropdown-menu", "dropdown-menu-right", "fixPos", "px-3"],
                            ["class", "cursor-pointer", 3, "click", 4, "ngIf"],
                            [1, "cursor-pointer", 3, "click"],
                            ["type", "button", 1, "dropdown-toggle", "d-flex", "align-items-center", "w-100"],
                            ["src", "/assets/images/svg-icons/ETH.svg", "height", "22", "alt", ""],
                            [1, "text-decoration-none", "selectedMenu", "me-1"],
                            ["src", "/assets/images/svg-icons/BNB.svg", "height", "22", "alt", ""],
                            [1, "text-decoration-none", "selectedMenu", "me-2"],
                            ["src", "/assets/images/svg-icons/MATIC.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/AVAX.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/BASE.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/SOL.svg", "height", "22", "alt", ""],
                            [1, "body-section", "mt-1", "text-center", 3, "ngClass"],
                            ["src", "./assets/images/svg-icons/token.svg", "alt", "loading", 1, "statusIcon", "loading"],
                            [1, "fw-normal", "fw-bold", "font-16", "px-2", "my-1", "text-uppercase", "text-light", "text-center"],
                            ["class", "fs-7 mb-1 text-light", 4, "ngIf"],
                            [1, "fs-7", "mb-1", "text-light"],
                            [1, "fw-semibold", "fs-6", "my-1", "text-uppercase", "text-center", "text-secondary"],
                            [1, "fw-semibold", "fs-6", "my-1", "text-uppercase", "text-secondary"],
                            ["src", "./assets/images/popup-icons/success.svg", "alt", "complete", 1, "statusIcon"],
                            [1, "fw-semibold", "fs-6", "my-1", "text-uppercase", "text-success", "text-center"],
                            ["class", "fs-7 mb-1 text-light mb-lg-4", 4, "ngIf"],
                            ["class", "d-flex align-items-center justify-content-center", 4, "ngIf"],
                            [1, "d-flex", "align-items-center", "justify-content-center", "gap-2"],
                            [1, "btn", "btn-primary", "w-50", "fs-8", "text-uppercase", 3, "click"],
                            [1, "fs-7", "mb-1", "text-light", "mb-lg-4"],
                            [1, "d-flex", "align-items-center", "justify-content-center"],
                            [1, "btn", "btn-md", "mb-2", "btn-primary", "w-100", "fs-7", "text-uppercase", 3, "click"],
                            ["src", "./assets/images/popup-icons/warning.svg", "alt", "failed", 1, "statusIcon"],
                            [1, "fw-semibold", "fs-6", "my-1", "text-uppercase", "text-danger", "text-center"],
                            [1, "fs-7", "mb-1", "mb-lg-4", "text-danger"],
                            [1, "fw-semibold", "fs-6", "text-uppercase", "text-danger", "my-1", "text-center"],
                            [1, "d-flex", "align-items-center", "justify-content-center", "gap-2", "mt-3"],
                            [1, "btn", "btn-primary", "w-100", "fs-7", "bg-secondary", "text-primary", "text-uppercase", 3, "click"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "div", 0), tt(1, zbe, 9, 9, "div", 1), tt(2, Gbe, 3, 2, "div", 2), tt(3, fwe, 31, 33, "div", 3), tt(4, gwe, 7, 8, "div", 4), tt(5, bwe, 8, 9, "div", 4), tt(6, wwe, 8, 13, "div", 4), tt(7, Swe, 15, 15, "div", 4), tt(8, Ewe, 15, 15, "div", 4), tt(9, Dwe, 9, 9, "div", 4), ce()), 2 & i && (Re("ngClass", fi(10, Awe, !r.isModal)), he(1), Re("ngIf", r.isModal), he(1), Re("ngIf", r.walletAddress), he(1), Re("ngIf", r.status === r.SwapStatus.not_started), he(1), Re("ngIf", r.status === r.SwapStatus.in_progess), he(1), Re("ngIf", r.status === r.SwapStatus.confirm_pending), he(1), Re("ngIf", r.status === r.SwapStatus.approval_pending), he(1), Re("ngIf", r.status === r.SwapStatus.complete), he(1), Re("ngIf", r.status === r.SwapStatus.failed), he(1), Re("ngIf", r.status === r.SwapStatus.rejected))
                        },
                        dependencies: [Jd, ts, Qy, z2, aE, ww, B2, N2, lw, kf, Hbe, na, Sf],
                        styles: [".swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{letter-spacing:1px;color:#1ddaff}.swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   .amountField[_ngcontent-%COMP%]{position:relative}.swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   .amountField[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{min-height:45px;padding:8px 15px;font-size:1rem;font-weight:400;border-radius:4px;border:1px solid #FEFEFE;color:#fefefe;background:transparent}.swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   .amountField[_ngcontent-%COMP%]   .amountType[_ngcontent-%COMP%]{position:absolute;top:22px;right:.8rem;transform:translateY(-50%);display:flex;align-items:center}.swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   .lowBalance[_ngcontent-%COMP%]{line-height:20px;font-weight:400}.swapSection[_ngcontent-%COMP%]   .body-section[_ngcontent-%COMP%]   .statusIcon[_ngcontent-%COMP%]{height:55px}.swapSection[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]{width:100%}.swapSection[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]:after{position:absolute;right:12px;opacity:0}.swapSection[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]   .flag-icon[_ngcontent-%COMP%]{border-radius:50%;overflow:hidden;margin-right:3px;min-width:20px;width:20px;height:20px;object-fit:cover}.swapSection[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]   .dropdown[_ngcontent-%COMP%]{cursor:pointer}.swapSection[_ngcontent-%COMP%]   .dropdown-menu.fixPos[_ngcontent-%COMP%]{transform:translateY(-80%)!important}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:hover{background-color:inherit!important}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{height:40px}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover   a[_ngcontent-%COMP%]{color:#1ddaff!important}@media screen and (max-width: 576px){.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]{max-height:210px}}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{display:flex;align-items:center}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border-radius:50%;border:1px solid #ffffff;overflow:hidden;margin-right:10px;min-width:20px;height:20px;width:20px;object-fit:cover}.swapSection[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#fff}.swapSection[_ngcontent-%COMP%]   .dropup[_ngcontent-%COMP%]:hover{opacity:1}"]
                    })
                }
                return t
            })();

            function kwe(t, n) {
                1 & t && (J(0, "div", 26)(1, "h1", 27), Oe(2, "banner.title"), ce(), J(3, "h5", 28), Oe(4, "banner.desc"), ce(), J(5, "div", 29)(6, "a", 30)(7, "span", 31), Oe(8, "misc.whitepaper"), ce()(), J(9, "a", 32)(10, "span", 31), Oe(11, "misc.audit"), ce()()()())
            }

            function Mwe(t, n) {
                1 & t && (J(0, "h1", 27), Oe(1, "banner.title"), ce())
            }

            function Iwe(t, n) {
                1 & t && (J(0, "h5", 33), Oe(1, "banner.desc"), ce())
            }
            const gu = function(t) {
                return {
                    shimmer: t
                }
            };

            function Pwe(t, n) {
                if (1 & t && (J(0, "div", 34)(1, "div", 35)(2, "div", 36), Oe(3, "widget.days"), ce(), J(4, "div", 37), Oe(5), ce()(), J(6, "div", 38)(7, "div", 36), Oe(8, "widget.hours"), ce(), J(9, "div", 37), Oe(10), ce()(), J(11, "div", 38)(12, "div", 36), Oe(13, "widget.minutes"), ce(), J(14, "div", 37), Oe(15), ce()(), J(16, "div", 38)(17, "div", 36), Oe(18, "widget.seconds"), ce(), J(19, "div", 37), Oe(20), ce()()()), 2 & t) {
                    const e = Ke();
                    he(1), Re("ngClass", fi(8, gu, 0 == e.liveCounter._diff)), he(4), on(e.liveCounter._days), he(1), Re("ngClass", fi(10, gu, 0 == e.liveCounter._diff)), he(4), on(e.liveCounter._hours), he(1), Re("ngClass", fi(12, gu, 0 == e.liveCounter._diff)), he(4), on(e.liveCounter._minutes), he(1), Re("ngClass", fi(14, gu, 0 == e.liveCounter._diff)), he(4), on(e.liveCounter._seconds)
                }
            }

            function Owe(t, n) {
                if (1 & t && (J(0, "p", 39)(1, "span", 40), Oe(2), qt(3, "translate"), ce(), J(4, "span", 41), Oe(5), ce()()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(5, gu, !e.usdRaised || e.usdRaised <= 0)), he(2), Ln(" ", Dn(3, 3, "widget.usdt_raised"), " "), he(3), Ln("$", e.convertNum(e.usdRaised), "")
                }
            }

            function Lwe(t, n) {
                1 & t && (J(0, "p", 42)(1, "span", 40), Oe(2), qt(3, "translate"), ce()()), 2 & t && (he(2), Ln(" ", Dn(3, 1, "widget.over_13m"), " "))
            }

            function Rwe(t, n) {
                if (1 & t && (J(0, "div", 43), gt(1, "div", 44), J(2, "div", 45), Oe(3), qt(4, "translate"), ce()()), 2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(7, gu, !e.usdRaised || e.usdRaised <= 0)), he(1), jo("width", e.raisedPercent), he(1), Re("ngClass", fi(9, gu, !e.usdRaised || e.usdRaised <= 0)), he(1), Ln(" ", Dn(4, 5, e.currentStoreData.title), "")
                }
            }

            function Bwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "button", 46), xt("click", function() {
                        return Nt(e), Ft(Ke().referAndEarn())
                    }), Oe(1, "widget.refer_and_earn "), ce()
                }
            }

            function Nwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "button", 74), xt("click", function() {
                        return Nt(e), Ft(Ke(3).connectModal())
                    }), Oe(1, "misc.connect_wallet"), ce()
                }
            }

            function Fwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "button", 74), xt("click", function() {
                        return Nt(e), Ft(Ke(3).connectBestWallet())
                    }), Oe(1, "misc.connect_bw"), ce()
                }
            }

            function Vwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("ETH"))
                    }), J(1, "div", 78), gt(2, "img", 79), J(3, "a", 80), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " ETH"))
            }

            function Uwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("BNB"))
                    }), J(1, "div", 78), gt(2, "img", 81), J(3, "a", 82), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " BNB"))
            }

            function Hwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("MATIC"))
                    }), J(1, "div", 78), gt(2, "img", 83), J(3, "a", 82), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " MATIC"))
            }

            function $we(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("AVAX"))
                    }), J(1, "div", 78), gt(2, "img", 84), J(3, "a", 82), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " AVAX"))
            }

            function zwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("BASE"))
                    }), J(1, "div", 78), gt(2, "img", 85), J(3, "a", 82), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " BASE"))
            }

            function jwe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 77), xt("click", function() {
                        return Nt(e), Ft(Ke(4).changeChain("SOL"))
                    }), J(1, "div", 78), gt(2, "img", 86), J(3, "a", 82), Oe(4), qt(5, "translate"), ce()()()
                }
                2 & t && (he(4), Ln("", Dn(5, 1, "widget.switch_to"), " SOL"))
            }

            function Wwe(t, n) {
                if (1 & t && (J(0, "ul", 75), tt(1, Vwe, 6, 3, "li", 76), tt(2, Uwe, 6, 3, "li", 76), tt(3, Hwe, 6, 3, "li", 76), tt(4, $we, 6, 3, "li", 76), tt(5, zwe, 6, 3, "li", 76), tt(6, jwe, 6, 3, "li", 76), ce()), 2 & t) {
                    const e = Ke(3);
                    he(1), Re("ngIf", "ETH" != e.modeName), he(1), Re("ngIf", "BNB" != e.modeName), he(1), Re("ngIf", "MATIC" != e.modeName), he(1), Re("ngIf", "AVAX" != e.modeName), he(1), Re("ngIf", "BASE" != e.modeName), he(1), Re("ngIf", "SOL" != e.modeName)
                }
            }
            const Gwe = function() {
                return {
                    "width.px": "12",
                    "height.px": 12
                }
            };

            function Kwe(t, n) {
                if (1 & t && (J(0, "div", 66), tt(1, Nwe, 2, 0, "button", 67), tt(2, Fwe, 2, 0, "button", 67), J(3, "div", 68)(4, "div", 69), gt(5, "img", 70), J(6, "span", 71), Oe(7), qt(8, "translate"), ce(), gt(9, "svg-icon", 72), ce(), tt(10, Wwe, 7, 6, "ul", 73), ce()()), 2 & t) {
                    const e = Ke(2);
                    he(1), Re("ngIf", !e.showBW), he(1), Re("ngIf", e.showBW), he(1), Re("dropup", !0), he(2), qs("src", "/assets/images/svg-icons/", e.modeName, ".svg", fo), he(2), by("", Dn(8, 7, "widget.switch_to"), " ", e.modeName, ""), he(2), Re("svgStyle", Ns(9, Gwe))
                }
            }

            function qwe(t, n) {
                1 & t && (J(0, "a", 87), Oe(1, "widget.not_enough_eth "), ce())
            }
            const Zwe = function(t) {
                    return {
                        cover: t
                    }
                },
                AI = function(t) {
                    return {
                        selected: t
                    }
                };

            function Ywe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 47)(1, "p", 48), Oe(2), ce(), J(3, "div", 49)(4, "button", 50), xt("click", function() {
                        return Nt(e), Ft(Ke().openSwap(!0))
                    }), gt(5, "img", 51), J(6, "span", 52), Oe(7), ce()(), J(8, "button", 50), xt("click", function() {
                        return Nt(e), Ft(Ke().openSwap(!1))
                    }), gt(9, "img", 51), J(10, "span", 52), Oe(11), ce()(), J(12, "button", 50), xt("click", function() {
                        return Nt(e), Ft(Ke().openSwap(!1, !0))
                    }), gt(13, "img", 53), J(14, "span", 54), Oe(15, "card"), ce()()(), gt(16, "app-swap", 55, 56), tt(18, Kwe, 11, 10, "div", 57), J(19, "div", 58)(20, "p", 59), tt(21, qwe, 2, 0, "a", 60), ce(), J(22, "p", 61), Oe(23, "widget.powered_by "), J(24, "a", 62), gt(25, "img", 63), ce()(), J(26, "p", 64), gt(27, "a", 65), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(15, Zwe, e.status === e.SwapStatus.in_progess || e.status === e.SwapStatus.confirm_pending || e.status === e.SwapStatus.approval_pending)), he(1), Re("ngClass", fi(17, gu, !e.usdRaised || e.usdRaised <= 0)), he(1), by("1 ", e.tokenName, " = $", e.salePrice, ""), he(2), Re("ngClass", fi(19, AI, "native" === e.swapMode)), he(1), qs("src", "/assets/images/svg-icons/", e.modeName, ".svg", fo), he(2), on(e.modeName), he(1), Re("ngClass", fi(21, AI, "usdt" === e.swapMode)), he(1), qs("src", "/assets/images/svg-icons/", "BASE" === e.modeName ? "usdc" : "usdt", ".svg", fo), he(2), on("BASE" === e.modeName ? "USDC" : "USDT"), he(1), Re("ngClass", fi(23, AI, "card" === e.swapMode)), he(4), Re("isNative", e.isNative)("isWert", e.isWert), he(2), Re("ngIf", !e.walletAddress), he(3), Re("ngIf", "ETH" == e.modeName && e.walletAddress)
                }
            }

            function Xwe(t, n) {
                1 & t && (J(0, "div", 29)(1, "a", 88)(2, "span", 31), Oe(3, "misc.whitepaper"), ce()(), J(4, "a", 89)(5, "span", 31), Oe(6, "misc.audit"), ce()()())
            }
            const Qwe = function(t) {
                    return {
                        arabic: t
                    }
                },
                $7 = function(t) {
                    return {
                        tokenName: t
                    }
                };
            let Jwe = (() => {
                class t {
                    http;
                    translate;
                    popupService;
                    modalService;
                    walletConnectService;
                    eventService;
                    renderer;
                    swapComp;
                    subscriptions = [];
                    lang = localStorage.getItem("currentlang");
                    isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                    modalRef;
                    emailId = "";
                    tokenSold = 0;
                    maxAmount = 0;
                    hashKey = "";
                    windowSize = 0;
                    usdRaised = 0;
                    currentStep = 0;
                    selectedLanguage;
                    userStaked = 0;
                    currentLanguage;
                    connectInterval;
                    usdtBal = 0;
                    ethBal = 0;
                    userClaimable = 0;
                    userEthClaimable = 0;
                    userBscClaimable = 0;
                    refreshId;
                    refreshRate = 1e3;
                    dataLoaded = !1;
                    isSoldOut = !1;
                    futureToken = 0;
                    salePrice = .0337;
                    listPrice = .0337;
                    liveCounter;
                    isLive = !0;
                    claimMode = !1;
                    swapMode = "native";
                    isNative = !0;
                    isWert = !1;
                    showBW = !1;
                    SwapStatus = Ki;
                    timeInterval;
                    referUrl = "";
                    isOverSale = !0;
                    oversaleTimer = 1714733711e3;
                    onResize(e) {
                        this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
                    }
                    constructor(e, i, r, s, o, a, c) {
                        this.http = e, this.translate = i, this.popupService = r, this.modalService = s, this.walletConnectService = o, this.eventService = a, this.renderer = c, this.eventService.getLang().subscribe(u => {
                            this.lang = u || "en"
                        })
                    }
                    ngOnInit() {
                        setTimeout(() => this.getBalanceData(), this.refreshRate), this.timeInterval = setInterval(() => this.setTimer(), 4e3), this.subscriptions.push(this.eventService.getCounter().subscribe(e => {
                            this.liveCounter = e
                        })), this.translate.onLangChange.subscribe(e => {
                            this.currentLanguage = e.lang
                        })
                    }
                    ngAfterViewInit() {
                        const e = HD("bwUrl");
                        e && "" != e && (this.showBW = !0)
                    }
                    getBalanceData() {
                        const e = this.walletConnectService.balanceData;
                        this.currentStep = e.currentStep, this.tokenSold = e.totalTokensSold, this.maxAmount = this.currentStoreData.maxAmount, this.ethBal = e.nativeBal, this.usdtBal = e.usdtBal, this.usdRaised = e.usdRaised, this.userStaked = this.walletConnectService.stakeData.userStaked, this.userClaimable = e.userClaimable, this.userEthClaimable = e.ethClaimable, this.userBscClaimable = e.bscClaimable, this.referUrl = this.walletConnectService.referUrl, this.isSoldOut = this.tokenSold > this.walletConnectService.tokenomics[this.walletConnectService.tokenomics.length - 1].maxToken, this.isSoldOut && (this.usdRaised = this.walletConnectService.tokenomics[this.currentStep].maxAmount), this.dataLoaded = !0, this.getFutureToken(), this.refreshId && clearTimeout(this.refreshId), this.refreshId = setTimeout(() => this.getBalanceData(), this.refreshRate)
                    }
                    connectModal() {
                        this.modalRef = this.modalService.show(E1, {
                            class: "modal-min modal-dialog-centered",
                            backdrop: "static"
                        })
                    }
                    referAndEarn() {
                        this.modalRef = this.modalService.show(Sbe, {
                            class: "modal-min modal-dialog-centered",
                            backdrop: "static",
                            initialState: {
                                url: this.referUrl
                            }
                        })
                    }
                    get tokenLeft() {
                        let e = this.currentStoreData.maxToken - this.tokenSold;
                        e = +(+e).toFixed(3);
                        let i = new Intl.NumberFormat("en-US");
                        return i.format(e), i.format(e > 0 ? e : 0)
                    }
                    convertNum(e) {
                        return zD(e)
                    }
                    openSwap(e = !0, i = !1) {
                        this.swapComp.wertMode ? this.popupService.messagePopup("warning", "", this.translate.instant("popup.are_you_sure"), this.translate.instant("misc.Confirm"), this.translate.instant("misc.Cancel")).then(r => {
                            r.isConfirmed && (this.swapComp.wertMode = !1, this.swapMode = e ? "native" : i ? "card" : "usdt", this.isNative = e, this.isWert = i)
                        }) : (this.swapMode = e ? "native" : i ? "card" : "usdt", this.isNative = e, this.isWert = i), setTimeout(() => this.swapComp.max(), 1e3)
                    }
                    checkEthChain() {
                        return !!this.walletConnectService.isEthChain() || (this.popupService.messagePopup("info", this.translate.instant("popup.wrong_chain", {
                            chainName: nt.eth.chainName
                        }), this.translate.instant("popup.change_network")).then(e => {
                            e.isConfirmed && this.walletConnectService.switchNetwork(nt.eth.chainIdInt)
                        }), !1)
                    }
                    changeChain(e) {
                        if (e == this.modeName) return;
                        if ("SOL" == e) return void(window.location.host = "solana." + window.location.host);
                        let i = "ETH" == e ? nt.eth : "BNB" == e ? nt.bsc : "MATIC" == e ? nt.poly : "AVAX" == e ? nt.avalanche : nt.base;
                        "ETH" == this.modeName ? this.popupService.messagePopup("info", this.translate.instant("popup.change_swap_text", {
                            apy: this.stakeData.apy,
                            mode: "BNB" == e ? "BNB Smart Chain" : "MATIC" == e ? "Polygon" : "AVAX" == e ? "Avalanche" : "Base"
                        }), this.translate.instant("popup.are_you_sure"), this.translate.instant("popup.buy_with_mode", {
                            mode: e
                        }), this.translate.instant("cancel")).then(r => {
                            r.isConfirmed && (this.walletAddress ? this.walletConnectService.switchNetwork(i.chainIdInt) : this.walletConnectService.chainId = i.chainIdInt)
                        }) : this.walletAddress ? this.walletConnectService.switchNetwork(i.chainIdInt) : this.walletConnectService.chainId = i.chainIdInt
                    }
                    getFutureToken() {
                        let e = +this.currentStep;
                        this.futureToken = e != this.walletConnectService.tokenomics.length - 1 ? this.walletConnectService.tokenomics[e + 1].tokenUSDT : this.currentStoreData.tokenUSDT, this.salePrice = this.currentStoreData.tokenUSDT
                    }
                    get raisedPercent() {
                        let e = this.usdRaised / this.maxAmount * 100;
                        return (e >= 100 ? 100 : e) + "%"
                    }
                    get currentStoreData() {
                        return this.walletConnectService.tokenomics[this.currentStep]
                    }
                    get walletAddress() {
                        return this.walletConnectService.walletAddress
                    }
                    get tokenPercent() {
                        let e = (this.tokenSold - this.currentStoreData.minToken) / (this.currentStoreData.maxToken - this.currentStoreData.minToken) * 100;
                        return (e >= 100 ? 100 : +e.toFixed(2)) + "%"
                    }
                    get tokenRemain() {
                        return this.currentStoreData.maxToken - this.tokenSold
                    }
                    get tokenName() {
                        return nt.tokenName
                    }
                    ngOnDestroy() {
                        for (const e of this.subscriptions) e.unsubscribe()
                    }
                    claim() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            (0 !== e.userClaimable || e.checkEthChain()) && (yield e.walletConnectService.claim(), e.modalRef = e.modalService.show(k_, {
                                class: "modal-xs modal-dialog-centered",
                                backdrop: "static"
                            }))
                        })()
                    }
                    get status() {
                        return this.walletConnectService.swapStatus
                    }
                    setTimer() {
                        this.tokenSold && this.tokenSold > 0 && (this.currentStoreData.endDate < Date.parse((new Date).toString()) && this.currentStep < this.walletConnectService.tokenomics.length - 1 ? this.eventService.setCounter(this.walletConnectService.tokenomics[this.currentStep + 1].endDate) : this.eventService.setCounter(this.currentStoreData.endDate), clearInterval(this.timeInterval))
                    }
                    get modeName() {
                        return this.walletConnectService.getChainData().purchaseToken
                    }
                    copy() {
                        var e = this;
                        return (0, Ze.Z)(function*() {
                            yield e.popupService.messsageAlert("success", e.translate.instant("misc.successCopy"))
                        })()
                    }
                    wertWidget(e) {
                        this.modalRef = this.modalService.show(e, {
                            class: "modal-dialog-centered",
                            backdrop: "static"
                        })
                    }
                    yourPurchasedInfo() {
                        this.popupService.messagePopup("info", this.translate.instant("popup.your_purchased_popup_info"))
                    }
                    changeToChain() {
                        this.popupService.messagePopup("info", this.translate.instant("popup.change_chain_info"))
                    }
                    navigateToSection(e) {
                        this.hashKey = e, e && (window.location.hash = e)
                    }
                    stakeInfo() {
                        this.popupService.messagePopup("info", this.translate.instant("staking.stake_popup_info"))
                    }
                    claimStake() {
                        0 == this.userClaimable || !this.checkEthChain() || (this.walletConnectService.claimStake(), this.modalRef = this.modalService.show(k_, {
                            class: "modal-xs modal-dialog-centered",
                            backdrop: "static",
                            initialState: {
                                isStake: !0
                            }
                        }))
                    }
                    get stakeData() {
                        return this.walletConnectService.stakeData
                    }
                    connectBestWallet() {
                        window.scroll({
                            top: 10
                        }), this.walletConnectService.connectWallet("bw")
                    }
                    static\ u0275fac = function(i) {
                        return new(i || t)(We(Ef), We(bc), We(A_), We(oh), We(dp), We(Ah), We(Ks))
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-banner"]
                        ],
                        viewQuery: function(i, r) {
                            if (1 & i && $c(DI, 5), 2 & i) {
                                let s;
                                wa(s = xa()) && (r.swapComp = s.first)
                            }
                        },
                        hostBindings: function(i, r) {
                            1 & i && xt("resize", function(o) {
                                return r.onResize(o)
                            }, 0, fl)
                        },
                        decls: 36,
                        vars: 36,
                        consts: [
                            ["id", "home", 1, "banner", 3, "ngClass"],
                            [1, "container"],
                            [1, "bannerSec", "row", "align-items-end"],
                            [1, "col-12", "col-md-7", "col-lg-8", "leftSec"],
                            ["class", "banner-content", 4, "ngIf"],
                            [1, "col-12", "col-md-5", "col-lg-4", "rightSec"],
                            [1, "walletBox"],
                            [1, "px-2", "px-lg-3", "w-100", "d-flex", "flex-column", "align-items-center", "justify-content-start", "text-center"],
                            ["class", "text-center outline-title", "translate", "", 4, "ngIf"],
                            [1, "font-20", "text-capitalize", "mb-1", "fw-semibold", "shadow-text"],
                            ["class", "mb-2 text-center fw-medium font-13", "translate", "", 4, "ngIf"],
                            ["class", "d-flex align-items-center justify-content-center gap-2 fw-regular  py-2 counter", 4, "ngIf"],
                            ["class", "my-3 font-15 text-center", 3, "ngClass", 4, "ngIf"],
                            ["class", "mt-1 mb-0 font-18 text-center", 4, "ngIf"],
                            ["class", "progress", "data-percent", "0", 3, "ngClass", 4, "ngIf"],
                            [1, "d-flex", "justify-content-center", "align-items-start", "text-center", "mb-2", "font-14", "mt-3", 3, "ngClass"],
                            [1, "text-start", "w-auto"],
                            [1, "fw-semibold", "text-uppercase", "d-block"],
                            [1, "d-flex", "justify-content-start", "align-items-center", "w-auto"],
                            [1, "fw-semibold"],
                            ["src", "/assets/images/svg-icons/info-icon.svg", "alt", "", 1, "img-fluid", "ms-2", "cursor-pointer", 3, "click"],
                            [1, "d-flex", "justify-content-center", "align-items-center", "text-center", "font-13", "mt-0", 3, "ngClass"],
                            [1, "fw-semibold", "text-uppercase"],
                            ["type", "button", "class", "btn btn-sm btn-outline-primary mt-3 mb-2 d-block", "translate", "", 3, "click", 4, "ngIf"],
                            ["class", "px-3 pb-3 mt-3 swapArea", 3, "ngClass", 4, "ngIf"],
                            ["class", "d-flex align-items-center wp-btns justify-content-center gap-3 mt-4", 4, "ngIf"],
                            [1, "banner-content"],
                            ["translate", "", 1, "text-center", "outline-title"],
                            ["translate", "", 1, "banner-desc", "mt-3", "text-center", "outline-title", "mini"],
                            [1, "d-flex", "align-items-center", "wp-btns", "justify-content-center", "gap-3", "mt-4"],
                            ["target", "_blank", "href", "/assets/documents/whitepaper.pdf", 1, "btn", "btn-primary", "w-100", "fs-5", "fw-bold"],
                            ["translate", ""],
                            ["target", "_blank", "href", "https://coinsult.net/projects/dogeverse/", 1, "outline", "w-100", "fs-5", "fw-bold"],
                            ["translate", "", 1, "mb-2", "text-center", "fw-medium", "font-13"],
                            [1, "d-flex", "align-items-center", "justify-content-center", "gap-2", "fw-regular", "py-2", "counter"],
                            [1, "rounded-3", "time-card", "text-center", "d-flex", 3, "ngClass"],
                            ["translate", "", 1, "indicator"],
                            [1, "value"],
                            [1, "rounded-3", "time-card", "text-center", 3, "ngClass"],
                            [1, "my-3", "font-15", "text-center", 3, "ngClass"],
                            [1, "fw-bold", "text-uppercase", "text-white"],
                            [1, "fw-regular", "text-white", "fw-bold"],
                            [1, "mt-1", "mb-0", "font-18", "text-center"],
                            ["data-percent", "0", 1, "progress", 3, "ngClass"],
                            [1, "bar"],
                            [1, "status", "fw-semibold", "text-uppercase", 3, "ngClass"],
                            ["type", "button", "translate", "", 1, "btn", "btn-sm", "btn-outline-primary", "mt-3", "mb-2", "d-block", 3, "click"],
                            [1, "px-3", "pb-3", "mt-3", "swapArea", 3, "ngClass"],
                            [1, "text-center", "mb-3", "font-14", "fw-bold", "dashTitle", "fw-medium", 3, "ngClass"],
                            [1, "tab-container", "gap-2"],
                            [1, "btn", "font-14", "text-uppercase", "d-flex", "align-items-center", "justify-content-center", "w-100", 3, "ngClass", "click"],
                            ["height", "26", "alt", "", 3, "src"],
                            [1, "ps-2", "fw-bold"],
                            ["src", "/assets/images/svg-icons/card.svg", "height", "26", "alt", "", 1, "float-start"],
                            ["translate", "", 1, "ps-2", "fw-bold"],
                            [3, "isNative", "isWert"],
                            ["swap", ""],
                            ["class", "d-flex align-items-center justify-content-center gap-2 mt-4", 4, "ngIf"],
                            [1, "mt-3"],
                            [1, "font-14", "text-center", "mb-1"],
                            ["class", "text-decoration-underline cursor-pointer text-light-grey", "href", "https://widget.wert.io/default/widget/?commodity=ETH%3AEthereum", "target", "_blank", "translate", "", 4, "ngIf"],
                            ["translate", "", 1, "font-14", "text-center", "fw-semibold", "text-white", "mb-0"],
                            ["href", "https://web3paymentsolutions.io/", "target", "_blank"],
                            ["src", "/assets/images/svg-icons/W3P_Black.svg", "alt", "", 1, "poweredByIcon", "text-tertiary"],
                            [1, "font-14", "text-center", "mb-0"],
                            ["href", "https://web3paymentsolutions.io/", "target", "_blank", 1, "text-white", "fw-semibold", "text-decoration-none"],
                            [1, "d-flex", "align-items-center", "justify-content-center", "gap-2", "mt-4"],
                            ["class", "btn btn-primary w-100", "translate", "", 3, "click", 4, "ngIf"],
                            ["dropdown", "", "dropdownToggle", "", 1, "btn", "btn-outline-primary", "fs-7", "w-100", "buyWith", "btn-group", "position-relative", 3, "dropup"],
                            ["type", "button", 1, "dropdown-toggle", "d-flex", "align-items-center", "justify-content-between", "w-100"],
                            ["height", "22", "alt", "", 3, "src"],
                            [1, "text-decoration-none", "selectedMenu", "mx-2"],
                            ["src", "./assets/images/svg-icons/angle-down.svg", 1, "dropdown", 3, "svgStyle"],
                            ["class", "py-2 dropdown-menu dropdown-menu-right fixPos  px-3 ", "role", "menu", 4, "dropdownMenu"],
                            ["translate", "", 1, "btn", "btn-primary", "w-100", 3, "click"],
                            ["role", "menu", 1, "py-2", "dropdown-menu", "dropdown-menu-right", "fixPos", "px-3"],
                            ["class", "cursor-pointer", 3, "click", 4, "ngIf"],
                            [1, "cursor-pointer", 3, "click"],
                            ["type", "button", 1, "dropdown-toggle", "d-flex", "align-items-center", "w-100"],
                            ["src", "/assets/images/svg-icons/ETH.svg", "height", "22", "alt", ""],
                            [1, "text-decoration-none", "selectedMenu", "me-1"],
                            ["src", "/assets/images/svg-icons/BNB.svg", "height", "22", "alt", ""],
                            [1, "text-decoration-none", "selectedMenu", "me-2"],
                            ["src", "/assets/images/svg-icons/MATIC.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/AVAX.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/BASE.svg", "height", "22", "alt", ""],
                            ["src", "/assets/images/svg-icons/SOL.svg", "height", "22", "alt", ""],
                            ["href", "https://widget.wert.io/default/widget/?commodity=ETH%3AEthereum", "target", "_blank", "translate", "", 1, "text-decoration-underline", "cursor-pointer", "text-light-grey"],
                            ["target", "_blank", "href", "/assets/documents/whitepaper.pdf", 1, "btn", "btn-primary", "w-100", "fs-5"],
                            ["target", "_blank", "href", "https://coinsult.net/projects/dogeverse/", 1, "btn", "btn-outline-primary", "w-100", "fs-5"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3), tt(4, kwe, 12, 0, "div", 4), ce(), J(5, "div", 5)(6, "div", 6)(7, "div", 7), tt(8, Mwe, 2, 0, "h1", 8), J(9, "p", 9), Oe(10), qt(11, "translate"), ce(), tt(12, Iwe, 2, 0, "h5", 10), tt(13, Pwe, 21, 16, "div", 11), tt(14, Owe, 6, 7, "p", 12), tt(15, Lwe, 4, 3, "p", 13), tt(16, Rwe, 5, 11, "div", 14), J(17, "div", 15)(18, "div", 16)(19, "span", 17), Oe(20), qt(21, "translate"), ce()(), J(22, "div", 18)(23, "span", 19), Oe(24), ce(), J(25, "img", 20), xt("click", function() {
                                return r.yourPurchasedInfo()
                            }), ce()()(), J(26, "div", 21)(27, "span", 22), Oe(28), qt(29, "translate"), ce(), J(30, "span", 19), Oe(31), ce(), J(32, "img", 20), xt("click", function() {
                                return r.stakeInfo()
                            }), ce()(), tt(33, Bwe, 2, 0, "button", 23), ce(), tt(34, Ywe, 28, 25, "div", 24), ce(), tt(35, Xwe, 7, 0, "div", 25), ce()()()()), 2 & i && (Re("ngClass", fi(26, Qwe, "ar" === r.lang)), he(4), Re("ngIf", !r.isMobile), he(4), Re("ngIf", r.isMobile), he(2), on(Dn(11, 18, r.isOverSale ? "widget.last_chance" : "widget.stage_title")), he(2), Re("ngIf", r.isMobile), he(1), Re("ngIf", !r.isOverSale), he(1), Re("ngIf", !r.isOverSale), he(1), Re("ngIf", r.isOverSale), he(1), Re("ngIf", !r.isOverSale), he(1), Re("ngClass", fi(28, gu, !r.usdRaised || r.usdRaised <= 0)), he(3), on(_s(21, 20, "widget.your_purchased", fi(30, $7, r.tokenName))), he(4), Ln(" = ", r.convertNum(r.userStaked + r.userClaimable), ""), he(2), Re("ngClass", fi(32, gu, !r.usdRaised || r.usdRaised <= 0)), he(2), on(_s(29, 23, "widget.your_claimable", fi(34, $7, r.tokenName))), he(3), Ln("\xa0=\xa0", r.convertNum(r.userEthClaimable), ""), he(2), Re("ngIf", r.walletAddress && "" != r.referUrl), he(1), Re("ngIf", !r.isSoldOut), he(1), Re("ngIf", r.isMobile))
                        },
                        dependencies: [Jd, ts, B2, N2, lw, kf, na, DI, Sf],
                        styles: ['.banner[_ngcontent-%COMP%]{position:relative;padding:140px 0 50px;min-height:864px}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]{padding:267px 0 0}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .banner-content[_ngcontent-%COMP%]{position:absolute;max-width:630px;left:15%;right:0;bottom:21%}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .banner-content[_ngcontent-%COMP%]{padding:22px 0 0;position:unset}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .banner-content[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:50px;font-weight:800}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .banner-content[_ngcontent-%COMP%]   .banner-desc[_ngcontent-%COMP%]{font-size:32px;font-weight:500}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .banner-content[_ngcontent-%COMP%]   .banner-desc[_ngcontent-%COMP%]{font-size:20px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .btn-card[_ngcontent-%COMP%]{border-radius:10px;border-right:4px solid #D0CFB0;border-bottom:6px solid #D0CFB0;background:#FFFAFA}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:start}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]{flex-wrap:wrap}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{min-width:40px;min-height:40px;display:flex;align-items:center;justify-content:center;border:1px solid #888888;background-origin:border-box;background-clip:content-box,border-box;padding:0;border-radius:5px;margin:0 10px 0 0}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{margin:0 10px 10px 0}}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{min-width:35px;min-height:35px}}@media screen and (max-width: 375px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{min-width:30px;min-height:30px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:20px;height:20px}@media screen and (max-width: 375px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:16px;height:16px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .leftSec[_ngcontent-%COMP%]   .social-icons[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{border-color:#1ddaff}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]{position:relative}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]{margin-top:20px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]{width:100%;max-width:520px;z-index:1;margin-left:auto;position:relative;border:3px solid #ffffff;background:linear-gradient(90deg,rgba(111,124,245,.8) 0%,rgba(242,24,115,.8) 100%),rgba(0,0,0,.5);padding:14px 0;border-radius:24px;box-shadow:0 0 15px #00000080}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]{background:#F264FF;padding:5px 15px;border:1px solid #ffffff;border-radius:5px;width:90%;margin:0 auto}@media screen and (max-width: 375px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]{width:100%}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]{min-width:60px;padding:0 12px;display:flex;justify-content:center;flex-direction:column;align-items:center;color:#fff}@media screen and (max-width: 375px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]{min-width:55px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .value[_ngcontent-%COMP%]{font-size:26px;font-weight:600;line-height:1}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .indicator[_ngcontent-%COMP%]{font-size:14px;line-height:25px}@media screen and (max-width: 375px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .indicator[_ngcontent-%COMP%]{font-size:12px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .btn-outline-tertiary[_ngcontent-%COMP%]{min-height:45px}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{width:90%;border-radius:30px;height:24px;background:transparent;border:1px solid #ffffff;margin:0 auto;overflow:hidden;position:relative}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{width:100%}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]   .status[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;font-size:12px;text-align:center;line-height:24px;z-index:1;color:#fff}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]   .bar[_ngcontent-%COMP%]{background:#1DDAFF;color:#fff}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .swapArea[_ngcontent-%COMP%]{position:relative}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .swapArea.cover[_ngcontent-%COMP%]:after{content:"";position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(255,255,255,0);z-index:1;cursor:busy}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .poweredByIcon[_ngcontent-%COMP%]{height:20px}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .whitelist[_ngcontent-%COMP%]{margin:15px 0 0}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]   .whitelist[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{display:block;margin:0 auto 15px;max-width:105px}@media screen and (max-width: 576px){.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .walletBox[_ngcontent-%COMP%]:after{left:unset;right:-17px;top:-22px;width:37px;height:44px}}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .hand-top[_ngcontent-%COMP%]{position:absolute;right:-60px;top:-70px;width:112px;transform:rotate(15deg);z-index:1}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   .hand-bottom[_ngcontent-%COMP%]{position:absolute;right:-27px;bottom:-26px;width:82px;transform:rotate(0);z-index:1}.banner[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .bannerSec[_ngcontent-%COMP%]   .rightSec[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff;max-width:220px}.dropdown-toggle[_ngcontent-%COMP%]{width:100%}.dropdown-toggle[_ngcontent-%COMP%]:after{position:absolute;right:12px;opacity:0}.dropdown-toggle[_ngcontent-%COMP%]   .flag-icon[_ngcontent-%COMP%]{border-radius:50%;overflow:hidden;margin-right:3px;min-width:20px;width:20px;height:20px;object-fit:cover}.dropdown-toggle[_ngcontent-%COMP%]   .dropdown[_ngcontent-%COMP%]{cursor:pointer}.dropdown-menu.fixPos[_ngcontent-%COMP%]{transform:translateY(-80%)!important}.dropdown-menu[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:hover{background-color:inherit!important}.dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{height:40px}.dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover   a[_ngcontent-%COMP%]{color:#1ddaff!important}@media screen and (max-width: 576px){.dropdown-menu[_ngcontent-%COMP%]{max-height:210px}}.dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{display:flex;align-items:center}.dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border-radius:50%;border:1px solid #ffffff;overflow:hidden;margin-right:10px;min-width:20px;height:20px;width:20px;object-fit:cover}.dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#fff}.dropup[_ngcontent-%COMP%]:hover{opacity:1}.wp-btns[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{max-width:260px}.outline[_ngcontent-%COMP%]{display:inline-block;position:relative;color:#fff;font-weight:600;text-transform:uppercase;justify-content:center;display:flex}.outline[_ngcontent-%COMP%]:before{width:100%;aspect-ratio:1;content:"";position:absolute;z-index:-1;padding:2px;border-radius:30px;background:linear-gradient(to right,#11BBFE,#8C41FB);mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);mask-composite:exclude;max-height:48px;inset:-11px 0 0;margin:0 auto;text-align:center}']
                    })
                }
                return t
            })();

            function exe(t, n) {
                1 & t && (J(0, "h1", 14), Oe(1, "faq.title_1"), ce())
            }

            function txe(t, n) {
                1 & t && (J(0, "h1", 15), Oe(1, "faq.title_mob"), ce())
            }
            let nxe = (() => {
                class t {
                    isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                    onResize(e) {
                        this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
                    }
                    items = [{
                        heading: "faq.faq_head_1",
                        content: "faq.faq_cont_1"
                    }, {
                        heading: "faq.faq_head_2",
                        content: "faq.faq_cont_2"
                    }, {
                        heading: "faq.faq_head_3",
                        content: "faq.faq_cont_3"
                    }, {
                        heading: "faq.faq_head_4",
                        content: "faq.faq_cont_4"
                    }, {
                        heading: "faq.faq_head_5",
                        content: "faq.faq_cont_5"
                    }];
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-faq"]
                        ],
                        hostBindings: function(i, r) {
                            1 & i && xt("resize", function(o) {
                                return r.onResize(o)
                            }, 0, fl)
                        },
                        decls: 87,
                        vars: 58,
                        consts: [
                            ["id", "faq", 1, "faq", "section-gap"],
                            [1, "container", "max-container"],
                            ["class", "font-64 text-uppercase fw-bold mb-4", "translate", "", 4, "ngIf"],
                            ["class", "tfont-25 fw-bold mb-2 ms-3", "translate", "", 4, "ngIf"],
                            [1, "faq-wrapper", "mt-0", "mt-lg-5"],
                            [3, "closeOthers", "isAnimated"],
                            ["accordion-heading", "", 1, "text-white", "fw-bold", "position-relative", "w-100"],
                            [1, "icon"],
                            [1, "title", "font-18", "pe-5", "d-flex"],
                            ["accordion-panel", "", 1, "mt-3"],
                            [1, "text-light", "font-20", "fw-regular"],
                            ["href", "https://bestwallet.com/en", "target", "_blank"],
                            ["href", "https://web3paymentsolutions.io/en", "target", "_blank"],
                            ["href", "https://web3toolkit.com/en", "target", "_blank"],
                            ["translate", "", 1, "font-64", "text-uppercase", "fw-bold", "mb-4"],
                            ["translate", "", 1, "tfont-25", "fw-bold", "mb-2", "ms-3"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "section", 0)(1, "div", 1), tt(2, exe, 2, 0, "h1", 2), tt(3, txe, 2, 0, "h1", 3), J(4, "div", 4)(5, "accordion", 5)(6, "accordion-group")(7, "div", 6), gt(8, "span", 7), J(9, "span", 8), Oe(10), qt(11, "translate"), ce()(), J(12, "div", 9)(13, "span", 10), Oe(14), qt(15, "translate"), ce(), gt(16, "br"), ce()(), J(17, "accordion-group")(18, "div", 6), gt(19, "span", 7), J(20, "span", 8), Oe(21), qt(22, "translate"), ce()(), J(23, "div", 9)(24, "span", 10), Oe(25), qt(26, "translate"), J(27, "a", 11), Oe(28), qt(29, "translate"), ce(), Oe(30), qt(31, "translate"), ce(), gt(32, "br"), ce()(), J(33, "accordion-group")(34, "div", 6), gt(35, "span", 7), J(36, "span", 8), Oe(37), qt(38, "translate"), ce()(), J(39, "div", 9)(40, "span", 10), Oe(41), qt(42, "translate"), ce(), gt(43, "br"), ce()(), J(44, "accordion-group")(45, "div", 6), gt(46, "span", 7), J(47, "span", 8), Oe(48), qt(49, "translate"), ce()(), J(50, "div", 9)(51, "span", 10), Oe(52), qt(53, "translate"), ce(), gt(54, "br"), ce()(), J(55, "accordion-group")(56, "div", 6), gt(57, "span", 7), J(58, "span", 8), Oe(59), qt(60, "translate"), ce()(), J(61, "div", 9)(62, "span", 10), Oe(63), qt(64, "translate"), ce(), gt(65, "br"), ce()(), J(66, "accordion-group")(67, "div", 6), gt(68, "span", 7), J(69, "span", 8), Oe(70), qt(71, "translate"), ce()(), J(72, "div", 9)(73, "span", 10), Oe(74), qt(75, "translate"), J(76, "a", 12), Oe(77), qt(78, "translate"), ce(), Oe(79), qt(80, "translate"), J(81, "a", 13), Oe(82), qt(83, "translate"), ce(), Oe(84), qt(85, "translate"), ce(), gt(86, "br"), ce()()()()()()), 2 & i && (he(2), Re("ngIf", !r.isMobile), he(1), Re("ngIf", r.isMobile), he(2), Re("closeOthers", !0)("isAnimated", !0), he(5), Ln(" ", Dn(11, 22, "faq.faq_head_1"), " "), he(4), Ln(" ", Dn(15, 24, "faq.faq_cont_1"), ""), he(7), Ln(" ", Dn(22, 26, "faq.faq_head_2"), " "), he(4), Ln(" ", Dn(26, 28, "faq.faq_cont_2"), " "), he(3), on(Dn(29, 30, "faq.faq_cont_2_1")), he(2), Ln(" ", Dn(31, 32, "faq.faq_cont_2_2"), ""), he(7), Ln(" ", Dn(38, 34, "faq.faq_head_3"), " "), he(4), Ln(" ", Dn(42, 36, "faq.faq_cont_3"), ""), he(7), Ln(" ", Dn(49, 38, "faq.faq_head_4"), " "), he(4), Ln(" ", Dn(53, 40, "faq.faq_cont_4"), ""), he(7), Ln(" ", Dn(60, 42, "faq.faq_head_5"), " "), he(4), Ln(" ", Dn(64, 44, "faq.faq_cont_5"), ""), he(7), Ln(" ", Dn(71, 46, "faq.faq_head_6"), " "), he(4), Ln(" ", Dn(75, 48, "faq.faq_cont_6"), " "), he(3), on(Dn(78, 50, "faq.faq_cont_6_1")), he(2), Ln(" ", Dn(80, 52, "faq.faq_cont_6_2"), " "), he(3), on(Dn(83, 54, "faq.faq_cont_6_3")), he(2), Ln(" ", Dn(85, 56, "faq.faq_cont_6_4"), ""))
                        },
                        dependencies: [ts, iV, pfe, na, Sf],
                        styles: ["@media screen and (max-width: 576px){.faq[_ngcontent-%COMP%]{padding-top:80px}}.faq[_ngcontent-%COMP%]   .max-container[_ngcontent-%COMP%]{max-width:1250px!important}.faq[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{line-height:120%}.faq[_ngcontent-%COMP%]     .panel{max-width:100%;background:transparent;border-bottom:1px solid rgba(218,218,218,.75)}.faq[_ngcontent-%COMP%]     .panel.panel-open .card-header{color:#fff!important}.faq[_ngcontent-%COMP%]     .panel .card{border:none;margin-bottom:0;padding:25px 5px}@media screen and (max-width: 576px){.faq[_ngcontent-%COMP%]     .panel .card{padding:20px 15px}}.faq[_ngcontent-%COMP%]     .panel .card .card-header{background-color:transparent;padding:8px 0;color:#f264ff;border-bottom:0}.faq[_ngcontent-%COMP%]     .panel .card .card-header .icon{position:absolute;height:50px;width:50px;right:0;top:-9px;background:url(/assets/images/svg-icons/plus.svg) no-repeat;transition:.4s}.faq[_ngcontent-%COMP%]     .panel .card .card-header img{position:absolute;right:20px;top:22px}.faq[_ngcontent-%COMP%]     .panel .card .card-body{padding:10px 0}.faq[_ngcontent-%COMP%]     .panel .card .card-body span{display:inline-block}.faq[_ngcontent-%COMP%]     .panel:nth-child(6){border-bottom:none}.faq[_ngcontent-%COMP%]     .panel-open{transition:.5s}.faq[_ngcontent-%COMP%]     .panel-open .icon{background:url(/assets/images/svg-icons/minus.svg) no-repeat!important}.faq[_ngcontent-%COMP%]     .panel-open ul li{list-style-type:none}"]
                    })
                }
                return t
            })();

            function ixe(t, n) {
                if (1 & t && (J(0, "div", 12), gt(1, "img", 13), J(2, "div", 14), gt(3, "img", 15), J(4, "span", 16), Oe(5), ce()()()), 2 & t) {
                    const e = n.$implicit;
                    he(1), Re("src", e.chain, fo), he(2), Re("src", e.status, fo), he(2), on(e.statusName)
                }
            }

            function rxe(t, n) {
                if (1 & t && (J(0, "div", 12), gt(1, "img", 13), J(2, "div", 14), gt(3, "img", 15), J(4, "span", 16), Oe(5), ce()()()), 2 & t) {
                    const e = n.$implicit;
                    he(1), Re("src", e.chain, fo), he(2), Re("src", e.status, fo), he(2), on(e.statusName)
                }
            }

            function sxe(t, n) {
                if (1 & t && (J(0, "div", 17)(1, "div", 18)(2, "h2", 19), Oe(3), ce(), J(4, "p", 20), Oe(5), ce(), gt(6, "img", 21), ce()()), 2 & t) {
                    const e = n.$implicit;
                    he(3), on(e.heading), he(2), on(e.list)
                }
            }
            let oxe = (() => {
                    class t {
                        items = [{
                            heading: "about.head1",
                            list: "about.list1"
                        }, {
                            heading: "about.head2",
                            list: "about.list2"
                        }, {
                            heading: "about.head3",
                            list: "about.list3"
                        }];
                        list = [{
                            chain: "/assets/images/svg-icons/eth.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }, {
                            chain: "/assets/images/svg-icons/bnb.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }, {
                            chain: "/assets/images/svg-icons/polygon.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }];
                        list1 = [{
                            chain: "/assets/images/svg-icons/AVAX.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }, {
                            chain: "/assets/images/svg-icons/BASE.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }, {
                            chain: "/assets/images/svg-icons/sol-about.svg",
                            status: "/assets/images/svg-icons/green.svg",
                            statusName: "about.live"
                        }];
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-about"]
                            ],
                            decls: 17,
                            vars: 3,
                            consts: [
                                ["id", "about", 1, "about", "section-gap"],
                                [1, "container"],
                                [1, "row", "about-top", "justify-content-center"],
                                ["translate", "", 1, "font-22", "font-sm-32", "fw-semibold", "text-center"],
                                ["translate", "", 1, "font-20", "font-sm-24", "fw-medium", "text-center"],
                                ["translate", "", 1, "text-gradient", "mx-1"],
                                [1, "d-sm-flex", "align-items-center", "justify-content-center"],
                                [1, "d-flex", "align-items-center", "justify-content-center", "mt-3", "mx"],
                                ["class", "position-relative mx-2 d-flex flex-column align-items-center", 4, "ngFor", "ngForOf"],
                                [1, "d-flex", "align-items-center", "justify-content-center", "mt-4", "mt-sm-3"],
                                [1, "row"],
                                ["class", "col-lg-4 position-relative", 4, "ngFor", "ngForOf"],
                                [1, "position-relative", "mx-2", "d-flex", "flex-column", "align-items-center"],
                                ["height", "98", "alt", "", 1, "chain", 3, "src"],
                                [1, "status", "d-flex", "align-items-center", "justify-content-center"],
                                ["alt", "", 3, "src"],
                                ["translate", "", 1, "font-10", "text-black", "text-uppercase", "ps-1", "fw-semibold"],
                                [1, "col-lg-4", "position-relative"],
                                [1, "box"],
                                ["translate", "", 1, "fw-bold", "text-white", "font-35", "text-uppercase"],
                                ["translate", "", 1, "text-white", "font-18", "pt-2", "fw-medium"],
                                ["src", "/assets/images/svg-icons/palm.svg", "alt", "", 1, "palm"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "h3", 3), Oe(4, "about.subtitle"), ce(), J(5, "h2", 4), Oe(6, "about.title "), J(7, "span", 5), Oe(8, "about.title1"), ce(), Oe(9, " about.title2"), ce(), J(10, "div", 6)(11, "div", 7), tt(12, ixe, 6, 3, "div", 8), ce(), J(13, "div", 9), tt(14, rxe, 6, 3, "div", 8), ce()()(), J(15, "div", 10), tt(16, sxe, 7, 2, "div", 11), ce()()()), 2 & i && (he(12), Re("ngForOf", r.list), he(2), Re("ngForOf", r.list1), he(2), Re("ngForOf", r.items))
                            },
                            dependencies: [Ao, na],
                            styles: ["@media screen and (max-width: 576px){.about[_ngcontent-%COMP%]{padding-top:70px}}.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]{border-radius:24px;border:.5px solid rgba(255,255,255,.13);background:rgba(31,41,55,.4);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);width:100%;padding:30px 0 43px;max-width:80%;margin:0 auto}@media screen and (max-width: 576px){.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]{background:unset;padding:20px;max-width:100%}}@media screen and (max-width: 576px){.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]   .chain[_ngcontent-%COMP%]{height:98px}}.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]   .text-gradient[_ngcontent-%COMP%]{background:linear-gradient(90deg,#1DDAFF 30.71%,#EA1AF7 49.97%);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}@media screen and (max-width: 576px){.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]   .text-gradient[_ngcontent-%COMP%]{background:linear-gradient(124deg,#1DDAFF 45.71%,#f65eff 79.97%);font-weight:700;background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}.about[_ngcontent-%COMP%]   .about-top[_ngcontent-%COMP%]   .status[_ngcontent-%COMP%]{position:relative;bottom:10px;background-color:#fff;border-radius:30px;padding:3px 6px;width:auto;margin:0 auto}.about[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{border-radius:24px;border:.5px solid rgba(255,255,255,.13);background:rgba(31,41,55,.5);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);padding:40px 8px 20px 29px;min-height:640px;margin-top:30px}@media screen and (max-width: 576px){.about[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{padding:20px;margin-top:20px;min-height:auto}}.about[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{text-shadow:1px 2px 4px rgba(0,0,0,.5)}.about[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{line-height:150%;letter-spacing:1px}.about[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   .palm[_ngcontent-%COMP%]{position:absolute;bottom:0;right:0;z-index:-1}"]
                        })
                    }
                    return t
                })(),
                axe = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-multi-bridge"]
                            ],
                            decls: 20,
                            vars: 0,
                            consts: [
                                ["id", "bridger", 1, "multibridge", "section-gap"],
                                [1, "container"],
                                [1, "font-30", "font-sm-60", "fw-bold", "text-center"],
                                ["translate", ""],
                                ["translate", "", 1, "text-gradient", "me-1"],
                                [1, "row", "align-items-center"],
                                [1, "col-12", "col-lg-6", "order-1", "order-md-0"],
                                [1, "box", "mt-4", "fw-bold"],
                                ["translate", "", 1, "font-18", "text-white", "text-center"],
                                ["translate", "", 1, "font-18", "text-white", "text-center", "pt-2", "pb-2"],
                                [1, "col-12", "col-lg-6"],
                                ["src", "/assets/images/multi-bridger.png", "alt", "", 1, "img-fluid"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "section", 0)(1, "div", 1)(2, "h2", 2)(3, "span", 3), Oe(4, "multi_bridge.title"), ce(), J(5, "span", 4), Oe(6, "multi_bridge.title1"), ce(), J(7, "span", 3), Oe(8, "multi_bridge.title2"), ce()(), J(9, "div", 5)(10, "div", 6)(11, "div", 7)(12, "p", 8), Oe(13, "multi_bridge.desc1"), ce(), J(14, "p", 9), Oe(15, "multi_bridge.desc2"), ce(), J(16, "p", 8), Oe(17, "multi_bridge.desc3"), ce()()(), J(18, "div", 10), gt(19, "img", 11), ce()()()())
                            },
                            dependencies: [na],
                            styles: [".multibridge[_ngcontent-%COMP%]   .text-gradient[_ngcontent-%COMP%]{background:linear-gradient(90deg,#1DDAFF 30.71%,#EA1AF7 49.97%);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}.multibridge[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{border-radius:12px;border:.5px solid rgba(255,255,255,.4);background:rgba(31,41,55,.4);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);padding:40px}"]
                        })
                    }
                    return t
                })(),
                cxe = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-roadmap"]
                            ],
                            decls: 56,
                            vars: 0,
                            consts: [
                                ["id", "roadmap", 1, "roadmap-wrapper", "section-gap"],
                                ["translate", "", 1, "section-title", "text-uppercase", "mb-5", "text-center"],
                                [1, "responsive", "h-100"],
                                [1, "h-100"],
                                [1, "container", "bg", "position-relative"],
                                [1, "roadmap-content", "phase-1"],
                                ["translate", "", 1, "head"],
                                [1, "desc"],
                                ["translate", ""],
                                [1, "roadmap-content", "phase-2"],
                                [1, "roadmap-content", "phase-3"],
                                [1, "roadmap-content", "phase-4"],
                                [1, "roadmap-content", "phase-5"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "div", 0)(1, "h3", 1), Oe(2, "roadmap.title"), ce(), J(3, "div", 2)(4, "div", 3)(5, "div", 4)(6, "div", 5)(7, "h3", 6), Oe(8, "roadmap.phase-1.title"), ce(), J(9, "ul", 7)(10, "li", 8), Oe(11, "roadmap.phase-1.point-1"), ce(), J(12, "li", 8), Oe(13, "roadmap.phase-1.point-2"), ce(), J(14, "li", 8), Oe(15, "roadmap.phase-1.point-3"), ce()()(), J(16, "div", 9)(17, "h3", 6), Oe(18, "roadmap.phase-2.title"), ce(), J(19, "ul", 7)(20, "li", 8), Oe(21, "roadmap.phase-2.point-1"), ce(), J(22, "li", 8), Oe(23, "roadmap.phase-2.point-2"), ce(), J(24, "li", 8), Oe(25, "roadmap.phase-2.point-3"), ce()()(), J(26, "div", 10)(27, "h3", 6), Oe(28, "roadmap.phase-3.title"), ce(), J(29, "ul", 7)(30, "li", 8), Oe(31, "roadmap.phase-3.point-1"), ce(), J(32, "li", 8), Oe(33, "roadmap.phase-3.point-2"), ce(), J(34, "li", 8), Oe(35, "roadmap.phase-3.point-3"), ce()()(), J(36, "div", 11)(37, "h3", 6), Oe(38, "roadmap.phase-4.title"), ce(), J(39, "ul", 7)(40, "li", 8), Oe(41, "roadmap.phase-4.point-1"), ce(), J(42, "li", 8), Oe(43, "roadmap.phase-4.point-2"), ce(), J(44, "li", 8), Oe(45, "roadmap.phase-4.point-3"), ce()()(), J(46, "div", 12)(47, "h3", 6), Oe(48, "roadmap.phase-5.title"), ce(), J(49, "ul", 7)(50, "li", 8), Oe(51, "roadmap.phase-5.point-1"), ce(), J(52, "li", 8), Oe(53, "roadmap.phase-5.point-2"), ce(), J(54, "li", 8), Oe(55, "roadmap.phase-5.point-3"), ce()()()()()()())
                            },
                            dependencies: [na],
                            styles: ['.roadmap-wrapper[_ngcontent-%COMP%]{height:1000px;width:100%;background:url(/assets/images/svg-icons/roadmap-bg.svg) no-repeat center/cover}@media screen and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]{height:100%;padding-top:80px}}.roadmap-wrapper[_ngcontent-%COMP%]   .bg[_ngcontent-%COMP%]{width:100%;height:100%;background:url(/assets/images/svg-icons/roadmap-bg-1.svg) no-repeat center/cover}@media screen and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]   .bg[_ngcontent-%COMP%]{background:url(/assets/images/svg-icons/roadmap--mob-bg-1.svg) no-repeat;display:flex;flex-direction:column;gap:20px;padding-left:65px}}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]{position:absolute}@media screen and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]{position:unset}}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]   .head[_ngcontent-%COMP%]{color:#fffffff2;text-shadow:0px 1px 4px rgba(0,0,0,.2);font-size:24px;font-weight:700;letter-spacing:1px;margin-bottom:20px}@media screen and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]   .head[_ngcontent-%COMP%]{font-size:20px}}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]   .desc[_ngcontent-%COMP%]{color:#fff;font-feature-settings:"clig" off,"liga" off;text-shadow:0px 1px 1px #000;font-size:20px;font-weight:600;letter-spacing:.2px}@media screen and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content[_ngcontent-%COMP%]   .desc[_ngcontent-%COMP%]{font-size:14px}}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content.phase-1[_ngcontent-%COMP%]{bottom:190px;left:0}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content.phase-2[_ngcontent-%COMP%]{top:95px;left:95px}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content.phase-3[_ngcontent-%COMP%]{left:615px;top:240px}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content.phase-4[_ngcontent-%COMP%]{bottom:80px;left:655px}.roadmap-wrapper[_ngcontent-%COMP%]   .roadmap-content.phase-5[_ngcontent-%COMP%]{top:345px;right:-30px}@media (min-width: 576px) and (max-width: 1199px){.roadmap-wrapper[_ngcontent-%COMP%]   .responsive[_ngcontent-%COMP%]{display:flex;justify-content:center}}']
                        })
                    }
                    return t
                })();

            function lxe(t, n) {
                if (1 & t && (J(0, "div", 19)(1, "div", 20), gt(2, "span"), Oe(3), qt(4, "translate"), ce(), J(5, "div", 21), Oe(6), qt(7, "translate"), ce(), J(8, "div", 21), Oe(9), qt(10, "translate"), ce()()), 2 & t) {
                    const e = n.$implicit;
                    he(2), MT("dot ", e.dotColor, ""), he(1), Ln(" ", Dn(4, 6, e.title1), " "), he(3), Ln(" ", Dn(7, 8, e.title2), " "), he(3), Ln(" ", Dn(10, 10, e.title3), " ")
                }
            }

            function uxe(t, n) {
                1 & t && gt(0, "img", 29), 2 & t && Re("src", Ke().$implicit.img, fo)
            }

            function dxe(t, n) {
                if (1 & t && (J(0, "div", 22)(1, "div", 23), tt(2, uxe, 1, 1, "img", 24), J(3, "div", 25)(4, "span", 26), Oe(5), ce()()(), J(6, "div", 27)(7, "div", 28)(8, "div", 10), Oe(9, "tokenomics.allocation_title"), ce(), J(10, "span", 26), Oe(11), ce()(), J(12, "div", 28)(13, "div", 10), Oe(14, "tokenomics.token_title"), ce(), J(15, "span", 26), Oe(16), ce()()()()), 2 & t) {
                    const e = n.$implicit;
                    he(2), Re("ngIf", e.img), he(3), on(e.title1), he(6), on(e.title2), he(5), on(e.title3)
                }
            }
            let hxe = (() => {
                class t {
                    isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                    cards = [{
                        title1: "tokenomics.presale_title1",
                        dotColor: "bgcolor-1",
                        img: "/assets/images/svg-icons/ellipse-1.svg",
                        title2: "tokenomics.presale_title2",
                        title3: "tokenomics.presale_title3"
                    }, {
                        title1: "tokenomics.staking_title1",
                        dotColor: "bgcolor-2",
                        img: "/assets/images/svg-icons/ellipse-2.svg",
                        title2: "tokenomics.staking_title2",
                        title3: "tokenomics.staking_title3"
                    }, {
                        title1: "tokenomics.project_title1",
                        dotColor: "bgcolor-3",
                        img: "/assets/images/svg-icons/ellipse-3.svg",
                        title2: "tokenomics.project_title2",
                        title3: "tokenomics.project_title3"
                    }, {
                        title1: "tokenomics.liquidity_title1",
                        dotColor: "bgcolor-4",
                        img: "/assets/images/svg-icons/ellipse-4.svg",
                        title2: "tokenomics.liquidity_title2",
                        title3: "tokenomics.liquidity_title3"
                    }, {
                        title1: "tokenomics.marketing_title1",
                        dotColor: "bgcolor-5",
                        img: "/assets/images/svg-icons/ellipse-5.svg",
                        title2: "tokenomics.marketing_title2",
                        title3: "tokenomics.marketing_title3"
                    }, {
                        title1: "tokenomics.ecosystem_title1",
                        dotColor: "bgcolor-6",
                        img: "/assets/images/svg-icons/ellipse-6.svg",
                        title2: "tokenomics.ecosystem_title2",
                        title3: "tokenomics.ecosystem_title3"
                    }, {
                        title1: "tokenomics.exchange_title1",
                        dotColor: "bgcolor-7",
                        img: "/assets/images/svg-icons/ellipse-7.svg",
                        title2: "tokenomics.exchange_title2",
                        title3: "tokenomics.exchange_title3"
                    }];
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-tokenomics"]
                        ],
                        decls: 29,
                        vars: 2,
                        consts: [
                            ["id", "tokenomics", 1, "tokenomics", "section-gap"],
                            [1, "container"],
                            [1, "heading-section"],
                            ["translate", "", 1, "section-title", "text-center", "text-uppercase", "mb-5"],
                            [1, "row", "wrapper"],
                            [1, "col-md-6"],
                            [1, "box", "d-none", "d-md-block"],
                            ["translate", "", 1, "heading", "text-white", "font-32", "fw-bold", "text-uppercase"],
                            ["translate", "", 1, "tokenomics-descp", "font-18", "fw-regular", "my-3"],
                            [1, "w-100", "card-row", "card-title", "fw-bold"],
                            ["translate", "", 1, "card-item"],
                            ["class", "w-100 card-row fw-bold", 4, "ngFor", "ngForOf"],
                            [1, "box", "d-block", "d-md-none"],
                            ["translate", "", 1, "heading", "text-white", "font-20", "fw-bold"],
                            ["translate", "", 1, "tokenomics-descp", "font-14"],
                            ["class", "w-100 card-row d-block", 4, "ngFor", "ngForOf"],
                            [1, "col-md-6", "align-self-center"],
                            [1, "d-flex", "align-items-center", "justify-content-center", "mb-5", "mb-lg-0"],
                            ["src", "/assets/images/svg-icons/tokenomics-img.svg", "alt", "", 1, "img-fluid", "mb-4", "mb-md-0"],
                            [1, "w-100", "card-row", "fw-bold"],
                            [1, "card-item", "wd-35", "wd-sm-30"],
                            [1, "card-item"],
                            [1, "w-100", "card-row", "d-block"],
                            ["translate", "", 1, "card-item", "d-flex", "align-items-center", "justify-content-betwen", "mb-1"],
                            ["class", "me-2", "alt", "", 3, "src", 4, "ngIf"],
                            ["translate", ""],
                            ["translate", "", 1, "text-white", "fw-bold"],
                            [1, "d-flex", "align-items-center", "justify-content-between", "ms-4"],
                            ["translate", "", 1, "card-item", "d-block"],
                            ["alt", "", 1, "me-2", 3, "src"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "h1", 3), Oe(4, "tokenomics.title"), ce()(), J(5, "div", 4)(6, "div", 5)(7, "div", 6)(8, "h2", 7), Oe(9, "tokenomics.title_1"), ce(), J(10, "p", 8), Oe(11, "tokenomics.desc"), ce(), J(12, "div", 9)(13, "div", 10), Oe(14, "tokenomics.fund_title"), ce(), J(15, "div", 10), Oe(16, "tokenomics.allocation_title"), ce(), J(17, "div", 10), Oe(18, "tokenomics.token_title"), ce()(), tt(19, lxe, 11, 12, "div", 11), ce(), J(20, "div", 12)(21, "h2", 13), Oe(22, "tokenomics.title_1"), ce(), J(23, "p", 14), Oe(24, "tokenomics.desc"), ce(), tt(25, dxe, 17, 4, "div", 15), ce()(), J(26, "div", 16)(27, "div", 17), gt(28, "img", 18), ce()()()()()), 2 & i && (he(19), Re("ngForOf", r.cards), he(6), Re("ngForOf", r.cards))
                        },
                        dependencies: [Ao, ts, na, Sf],
                        styles: ["@media screen and (max-width: 768px){.tokenomics[_ngcontent-%COMP%]   .wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column-reverse}}.tokenomics[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{border-radius:24px;border:.5px solid rgba(255,255,255,.4);background:rgba(31,41,55,.5);-webkit-backdrop-filter:blur(3px);backdrop-filter:blur(3px);padding:28px}@media screen and (max-width: 768px){.tokenomics[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{padding:20px}}.tokenomics[_ngcontent-%COMP%]   .card-row[_ngcontent-%COMP%]{background:rgb(66,66,66);padding:10px 24px;margin:10px 0;display:flex;align-items:center;justify-content:space-between;border-radius:10px}@media screen and (max-width: 768px){.tokenomics[_ngcontent-%COMP%]   .card-row[_ngcontent-%COMP%]{order:3}}.tokenomics[_ngcontent-%COMP%]   .card-row[_ngcontent-%COMP%]   .card-item[_ngcontent-%COMP%]{display:flex;align-items:center}.card-title[_ngcontent-%COMP%]{background:transparent!important;border-bottom:1px solid rgba(75,94,117,.15)}@media screen and (min-width: 768px){.card-title[_ngcontent-%COMP%]   .card-item[_ngcontent-%COMP%]:nth-child(1){min-width:197px!important}}@media screen and (min-width: 768px){.card-row[_ngcontent-%COMP%]   .card-item[_ngcontent-%COMP%]:nth-child(1){min-width:230px}}.card-row[_ngcontent-%COMP%]   .card-item[_ngcontent-%COMP%]:nth-child(2){min-width:50px}.card-row[_ngcontent-%COMP%]:last-child{margin-bottom:0!important}.dot[_ngcontent-%COMP%]{min-width:15px;width:15px;height:15px;border-radius:15px;margin-right:8px}.dot.bgcolor-1[_ngcontent-%COMP%]{background:rgb(114,232,255)}.dot.bgcolor-2[_ngcontent-%COMP%]{background:rgb(0,194,255)}.dot.bgcolor-3[_ngcontent-%COMP%]{background:rgb(72,141,255)}.dot.bgcolor-4[_ngcontent-%COMP%]{background:rgb(78,87,255)}.dot.bgcolor-5[_ngcontent-%COMP%]{background:rgb(157,97,255)}.dot.bgcolor-6[_ngcontent-%COMP%]{background:rgb(231,127,255)}.dot.bgcolor-7[_ngcontent-%COMP%]{background:rgb(225,84,177)}"]
                    })
                }
                return t
            })();

            function fxe(t, n) {
                if (1 & t && (J(0, "div", 3)(1, "div", 6)(2, "span", 7), Oe(3), ce(), J(4, "h5", 8), Oe(5), ce(), J(6, "p", 9), Oe(7), ce()()()), 2 & t) {
                    const e = n.$implicit;
                    he(3), on(e.subtitle), he(2), on(e.title), he(2), on(e.desc)
                }
            }
            let pxe = (() => {
                class t {
                    items = [{
                        subtitle: "how_to.subtitle",
                        title: "how_to.title",
                        desc: "how_to.desc"
                    }, {
                        subtitle: "how_to.subtitle1",
                        title: "how_to.title1",
                        desc: "how_to.desc1"
                    }, {
                        subtitle: "how_to.subtitle2",
                        title: "how_to.title2",
                        desc: "how_to.desc2"
                    }, {
                        subtitle: "how_to.subtitle3",
                        title: "how_to.title3",
                        desc: "how_to.desc3"
                    }, {
                        subtitle: "how_to.subtitle4",
                        title: "how_to.title4",
                        desc: "how_to.desc4"
                    }];
                    static\ u0275fac = function(i) {
                        return new(i || t)
                    };
                    static\ u0275cmp = xn({
                        type: t,
                        selectors: [
                            ["app-how-to-buy"]
                        ],
                        decls: 7,
                        vars: 1,
                        consts: [
                            ["id", "howto", 1, "howto"],
                            [1, "container"],
                            [1, "row"],
                            [1, "col-12", "col-lg-4"],
                            ["translate", "", 1, "font-32", "font-sm-48", "text", "text-uppercase", "fw-bold", "pt-sm-5"],
                            ["class", "col-12 col-lg-4 ", 4, "ngFor", "ngForOf"],
                            [1, "box"],
                            ["translate", "", 1, "font-18", "fw-semibold"],
                            ["translate", "", 1, "font-26", "fw-semibold", "pt-2"],
                            ["translate", "", 1, "dont-17", "fw-medium", "p-0", "m-0"]
                        ],
                        template: function(i, r) {
                            1 & i && (J(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4), Oe(5, "how_to.heading"), ce()(), tt(6, fxe, 8, 3, "div", 5), ce()()()), 2 & i && (he(6), Re("ngForOf", r.items))
                        },
                        dependencies: [Ao, na],
                        styles: [".howto[_ngcontent-%COMP%]{background:url(/assets/images/howbuy.png) no-repeat;background-size:100%;min-height:704px;padding:100px 80px}@media screen and (max-width: 576px){.howto[_ngcontent-%COMP%]{padding:60px 5px 40px;background:url(/assets/images/howto-mob.png) no-repeat;background-size:cover}}.howto[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]{color:#fefefe;text-shadow:1px 2px 4px rgba(0,0,0,.5)}@media screen and (max-width: 576px){.howto[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]{padding:10px 0 30px}}.howto[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{border-radius:20px;border:.5px solid rgba(255,255,255,.4);background:rgba(31,41,55,.4);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);min-height:240px;padding:29px;margin-top:10px}@media screen and (max-width: 576px){.howto[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{min-height:auto}}"]
                    })
                }
                return t
            })();

            function mxe(t, n) {
                1 & t && (J(0, "div", 4)(1, "div", 5), gt(2, "img", 6)(3, "img", 7)(4, "img", 8)(5, "img", 9), ce()())
            }

            function gxe(t, n) {
                1 & t && gt(0, "img", 14), 2 & t && Re("src", Ke().$implicit.img, fo)
            }

            function yxe(t, n) {
                1 & t && tt(0, gxe, 1, 1, "ng-template", 13)
            }

            function _xe(t, n) {
                if (1 & t && (J(0, "div", 10)(1, "owl-carousel-o", 11), tt(2, yxe, 1, 0, null, 12), ce()()), 2 & t) {
                    const e = Ke();
                    he(1), Re("options", e.slideOption), he(1), Re("ngForOf", e.items)
                }
            }
            let vxe = (() => {
                    class t {
                        isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                        items = [{
                            img: "./assets/images/svg-icons/cointelegraph.svg"
                        }, {
                            img: "./assets/images/svg-icons/techopedia.svg"
                        }, {
                            img: "./assets/images/svg-icons/bitcoinst.svg"
                        }, {
                            img: "./assets/images/svg-icons/cryptonews.svg"
                        }];
                        slideOption = {
                            loop: !0,
                            autoplay: !0,
                            mouseDrag: !0,
                            touchDrag: !0,
                            dots: !1,
                            nav: !1,
                            autoplayTimeout: 2500,
                            center: !0,
                            margin: 15,
                            responsive: {
                                0: {
                                    items: 2.3,
                                    margin: 10
                                },
                                400: {
                                    items: 2.5
                                },
                                768: {
                                    items: 6
                                }
                            }
                        };
                        onResize(e) {
                            this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-feature"]
                            ],
                            hostBindings: function(i, r) {
                                1 & i && xt("resize", function(o) {
                                    return r.onResize(o)
                                }, 0, fl)
                            },
                            decls: 5,
                            vars: 2,
                            consts: [
                                ["id", "feature", 1, "feature", "section-gap"],
                                ["translate", "", 1, "text-center", "text-white", "section-title", "text-uppercase"],
                                ["class", "container", 4, "ngIf"],
                                ["class", "small-container", 4, "ngIf"],
                                [1, "container"],
                                [1, "d-flex", "justify-content-center", "align-items-center", "mt-4"],
                                ["src", "./assets/images/svg-icons/cointelegraph.svg", "alt", "", 1, "featured-img"],
                                ["src", "./assets/images/svg-icons/techopedia.svg", "alt", "", 1, "featured-img"],
                                ["src", "./assets/images/svg-icons/bitcoinst.svg", "alt", "", 1, "featured-img"],
                                ["src", "./assets/images/svg-icons/cryptonews.svg", "alt", "", 1, "featured-img"],
                                [1, "small-container"],
                                [1, "d-flex", "align-self-center", 3, "options"],
                                [4, "ngFor", "ngForOf"],
                                ["carouselSlide", ""],
                                ["alt", "", 1, "img-fluid", "mx-auto", "featured-img", 3, "src"]
                            ],
                            template: function(i, r) {
                                1 & i && (J(0, "section", 0)(1, "p", 1), Oe(2, "feature.title"), ce(), tt(3, mxe, 6, 0, "div", 2), tt(4, _xe, 3, 2, "div", 3), ce()), 2 & i && (he(3), Re("ngIf", !r.isMobile), he(1), Re("ngIf", r.isMobile))
                            },
                            dependencies: [Ao, ts, pre, kF, na],
                            styles: [".feature[_ngcontent-%COMP%]   .featured-img[_ngcontent-%COMP%]{padding:12px;max-width:210px}"]
                        })
                    }
                    return t
                })(),
                bxe = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-home"]
                            ],
                            decls: 10,
                            vars: 0,
                            consts: [
                                [1, "footer"]
                            ],
                            template: function(i, r) {
                                1 & i && (gt(0, "app-banner")(1, "app-about")(2, "app-feature")(3, "app-multi-bridge")(4, "app-roadmap")(5, "app-tokenomics")(6, "app-how-to-buy"), J(7, "div", 0), gt(8, "app-faq")(9, "app-footer"), ce())
                            },
                            dependencies: [P7, Jwe, nxe, oxe, axe, cxe, hxe, pxe, vxe],
                            styles: [".footer[_ngcontent-%COMP%]{background:#000000 url(/assets/images/footer-png.png) no-repeat 0% 0%;background-size:100%}"]
                        })
                    }
                    return t
                })(),
                wxe = (() => {
                    class t {
                        transform(e, ...i) {
                            return e ? e.slice(0, 6) + "..." + e.slice(e.length - 5, e.length) : "--"
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275pipe = Ps({
                            name: "trimAddress",
                            type: t,
                            pure: !0
                        })
                    }
                    return t
                })();
            const xxe = ["navigation"];

            function Cxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "a", 25), xt("click", function(r) {
                        const o = Nt(e).$implicit;
                        return Ft(Ke(2).addActive(r, o.routeName))
                    }), Oe(1), ce()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    qs("routerLink", "/", Ke(2).currentLanguage, ""), Yd("fragment", e.routeName), Yd("title", e.routeName), he(1), on(e.navName)
                }
            }

            function Txe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 26), xt("click", function() {
                        return Nt(e), Ft(Ke(2).showWidget("home"))
                    }), Oe(1, "widget.buy_now"), ce()
                }
            }

            function Sxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 27), xt("click", function() {
                        return Nt(e), Ft(Ke(2).disconnect())
                    }), Oe(1), qt(2, "trimAddress"), ce()
                }
                if (2 & t) {
                    const e = Ke(2);
                    he(1), on(Dn(2, 1, e.walletAddress))
                }
            }

            function Exe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 30), xt("click", function() {
                        const s = Nt(e).$implicit;
                        return Ft(Ke(3).changeLanguage(s.value))
                    }), gt(1, "img", 31), J(2, "span"), Oe(3), ce()()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    he(1), qs("src", "./assets/images/flags/", e.flag, ".svg", fo), he(2), on(e.name)
                }
            }

            function Dxe(t, n) {
                if (1 & t && (J(0, "ul", 28), tt(1, Exe, 4, 2, "li", 29), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), Re("ngForOf", e.languagesList)
                }
            }
            const z7 = function(t) {
                    return {
                        scrolled: t
                    }
                },
                j7 = function() {
                    return {
                        "width.px": "135",
                        "height.px": "36"
                    }
                },
                Axe = function() {
                    return {
                        "width.px": "14",
                        "height.px": "20"
                    }
                };

            function kxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 1)(1, "div", 2)(2, "div", 3)(3, "div", 4)(4, "a", 5, 6), xt("click", function(r) {
                        Nt(e);
                        const s = Ke();
                        return s.navigateToSection("home"), Ft(s.addActive(r, ""))
                    }), gt(6, "svg-icon", 7), ce(), J(7, "div", 8)(8, "a", 9), xt("click", function(r) {
                        return Nt(e), Ft(Ke().addActive(r, ""))
                    }), Oe(9, "top_navigation.stake"), ce(), tt(10, Cxe, 2, 4, "a", 10), ce(), J(11, "div", 11)(12, "div", 12)(13, "a", 13), gt(14, "img", 14), ce(), J(15, "a", 15), gt(16, "img", 16), ce()(), tt(17, Txe, 2, 0, "div", 17), tt(18, Sxe, 3, 3, "div", 18), J(19, "div", 19)(20, "div", 20), gt(21, "img", 21), J(22, "div", 22), Oe(23), ce(), gt(24, "svg-icon", 23), ce(), tt(25, Dxe, 2, 1, "ul", 24), ce()()()()()()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(10, z7, e.isScrolled)), he(4), qs("routerLink", "/", e.currentLanguage, ""), he(2), Re("svgStyle", Ns(12, j7)), he(2), qs("routerLink", "/", e.currentLanguage, "/staking"), he(2), Re("ngForOf", e.navigations), he(7), Re("ngIf", !e.walletAddress), he(1), Re("ngIf", e.walletAddress), he(3), qs("src", "./assets/images/flags/", null == e.selectedLanguage ? null : e.selectedLanguage.flag, ".svg", fo), he(2), on(null == e.selectedLanguage ? null : e.selectedLanguage.value), he(1), Re("svgStyle", Ns(13, Axe))
                }
            }

            function Mxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "a", 52), xt("click", function(r) {
                        const o = Nt(e).$implicit,
                            a = Ke(3);
                        return a.addActive(r, o.routeName), Ft(a.openCloseMenu())
                    }), Oe(1), ce()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    qs("routerLink", "/", Ke(3).currentLanguage, ""), Yd("fragment", e.routeName), Yd("title", e.routeName), he(1), Ln("", e.navName, " ")
                }
            }

            function Ixe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "li", 55), xt("click", function() {
                        const s = Nt(e).$implicit,
                            o = Ke(4);
                        return o.changeLanguage(s.value), Ft(o.openCloseMenu())
                    }), gt(1, "img", 31), J(2, "span"), Oe(3), ce()()
                }
                if (2 & t) {
                    const e = n.$implicit;
                    he(1), qs("src", "./assets/images/flags/", e.flag, ".svg", fo), he(2), on(e.name)
                }
            }

            function Pxe(t, n) {
                if (1 & t && (J(0, "ul", 53), tt(1, Ixe, 4, 2, "li", 54), ce()), 2 & t) {
                    const e = Ke(3);
                    he(1), Re("ngForOf", e.languagesList)
                }
            }

            function Oxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 56), xt("click", function() {
                        Nt(e);
                        const r = Ke(3);
                        return r.showWidget("home"), Ft(r.openCloseMenu())
                    }), J(1, "div", 57), Oe(2, "widget.buy_now"), ce()()
                }
            }

            function Lxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 58), xt("click", function() {
                        Nt(e);
                        const r = Ke(3);
                        return r.disconnect(), Ft(r.openCloseMenu())
                    }), J(1, "div", 59), Oe(2), qt(3, "trimAddress"), ce()()
                }
                if (2 & t) {
                    const e = Ke(3);
                    he(2), on(Dn(3, 1, e.walletAddress))
                }
            }
            const Rxe = function(t) {
                    return {
                        open: t
                    }
                },
                Bxe = function() {
                    return {
                        "width.px": "20",
                        "height.px": "20"
                    }
                };

            function Nxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 38)(1, "div", 39)(2, "div", 40)(3, "a", 41), xt("click", function() {
                        return Nt(e), Ft(Ke(2).openCloseMenu())
                    }), Oe(4, "top_navigation.stake"), ce(), tt(5, Mxe, 2, 4, "a", 42), ce(), J(6, "div", 43)(7, "a", 44), gt(8, "img", 14), ce(), J(9, "a", 45), gt(10, "img", 16), ce()(), J(11, "div", 46)(12, "div", 47)(13, "div"), gt(14, "img", 21), J(15, "span", 48), Oe(16), ce()(), gt(17, "svg-icon", 23), ce(), tt(18, Pxe, 2, 1, "ul", 49), ce(), tt(19, Oxe, 3, 0, "div", 50), tt(20, Lxe, 4, 3, "div", 51), ce()()
                }
                if (2 & t) {
                    const e = Ke(2);
                    he(1), Re("ngClass", fi(8, Rxe, e.openMenu)), he(2), qs("routerLink", "/", e.currentLanguage, "/staking"), he(2), Re("ngForOf", e.navigations), he(9), qs("src", "./assets/images/flags/", null == e.selectedLanguage ? null : e.selectedLanguage.flag, ".svg", fo), he(2), on(null == e.selectedLanguage ? null : e.selectedLanguage.value), he(1), Re("svgStyle", Ns(10, Bxe)), he(2), Re("ngIf", !e.walletAddress), he(1), Re("ngIf", e.walletAddress)
                }
            }
            const Fxe = function() {
                return {
                    "width.px": 20,
                    "height.px": 20
                }
            };

            function Vxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 1)(1, "div", 32)(2, "div", 33)(3, "a", 34, 6), gt(5, "svg-icon", 7), ce()(), J(6, "div", 35), xt("click", function() {
                        return Nt(e), Ft(Ke().openCloseMenu())
                    }), gt(7, "svg-icon", 36), ce()(), tt(8, Nxe, 21, 11, "div", 37), ce()
                }
                if (2 & t) {
                    const e = Ke();
                    Re("ngClass", fi(6, z7, e.isScrolled)), he(3), qs("routerLink", "/", e.currentLanguage, ""), he(2), Re("svgStyle", Ns(8, j7)), he(2), qs("src", "./assets/images/svg-icons/", e.showMenu ? "burger-close" : "burger-icon", ".svg"), Re("svgStyle", Ns(9, Fxe)), he(1), Re("ngIf", e.showMenu)
                }
            }
            let Uxe = (() => {
                    class t {
                        location;
                        eventService;
                        translate;
                        modalService;
                        walletConnectService;
                        navigation;
                        isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024;
                        isScrolled = !1;
                        showMenu = !1;
                        openMenu = !1;
                        modalRef;
                        hashKey = "";
                        windowSize;
                        currentLanguage;
                        languagesList = UD;
                        selectedLanguage;
                        checkScroll() {
                            this.isScrolled = window.pageYOffset >= 50
                        }
                        onResize(e) {
                            this.windowSize = e.target.innerWidth, this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
                        }
                        navigations = [{
                            routeName: "about",
                            navName: "top_navigation.about"
                        }, {
                            routeName: "roadmap",
                            navName: "top_navigation.roadmap"
                        }, {
                            routeName: "howto",
                            navName: "top_navigation.howtobuy"
                        }, {
                            routeName: "faq",
                            navName: "top_navigation.faq"
                        }];
                        affiliates = [{
                            routeName: "coming_soon",
                            navName: ""
                        }];
                        constructor(e, i, r, s, o) {
                            this.location = e, this.eventService = i, this.translate = r, this.modalService = s, this.walletConnectService = o, this.windowSize = window.screen.width, this.eventService.getLang().subscribe(a => {
                                this.currentLanguage = a || "en", this.selectedLanguage = this.languagesList.filter(c => c.value === this.currentLanguage)[0]
                            }), this.selectedLanguage = this.languagesList.filter(a => a.value === this.currentLanguage)[0]
                        }
                        ngOnInit() {
                            this.currentLanguage || (this.currentLanguage = EI, this.selectedLanguage = this.languagesList.filter(e => e.value === this.currentLanguage)[0])
                        }
                        ngAfterViewInit() {
                            this.windowSize = window.innerWidth, window.location.hash && setTimeout(() => {
                                this.hashKey = window.location.hash.substring(1, window.location.hash.length), this.navigateToSection(this.hashKey), this.addActive(this.navigation.nativeElement, this.hashKey)
                            }, 5e3)
                        }
                        changeLanguage(e) {
                            this.currentLanguage = e, this.translate.use(this.currentLanguage), this.eventService.setLang(this.currentLanguage), this.selectedLanguage = this.languagesList.filter(i => i.value === this.currentLanguage)[0], this.replaceURL()
                        }
                        replaceURL() {
                            const e = this.location.path().split("/");
                            e.shift(), e.splice(0, 1, this.currentLanguage);
                            const i = e.join("/");
                            this.location.replaceState("/" + i), window.location.hash = this.hashKey
                        }
                        navigateToSection(e) {
                            this.hashKey = e, e && (window.location.hash = e, window.location.pathname = "/" + this.currentLanguage)
                        }
                        addActive(e, i) {
                            this.hashKey = i, (e.currentTarget ? e.currentTarget : e).parentNode.querySelectorAll("a").forEach(o => {
                                o === e.target || o.title === this.hashKey ? o.classList.add("active") : o.classList.remove("active")
                            })
                        }
                        get walletAddress() {
                            return this.walletConnectService.walletAddress
                        }
                        showWidget(e) {
                            window.location.pathname.includes("staking") ? (window.scroll({
                                top: 0
                            }), this.connectModal()) : this.eventService.showBuyWidget(e)
                        }
                        connectModal() {
                            this.modalRef = this.modalService.show(E1, {
                                class: "modal-xs modal-dialog-centered",
                                backdrop: "static"
                            })
                        }
                        disconnect() {
                            this.walletConnectService.disConnectWallet()
                        }
                        openCloseMenu() {
                            this.showMenu ? (this.openMenu = !this.openMenu, setTimeout(() => this.showMenu = !this.showMenu, 600)) : (this.showMenu = !this.showMenu, setTimeout(() => this.openMenu = !this.openMenu, 300))
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(bb), We(Ah), We(bc), We(oh), We(dp))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-header"]
                            ],
                            viewQuery: function(i, r) {
                                if (1 & i && $c(xxe, 5), 2 & i) {
                                    let s;
                                    wa(s = xa()) && (r.navigation = s.first)
                                }
                            },
                            hostBindings: function(i, r) {
                                1 & i && xt("scroll", function(o) {
                                    return r.checkScroll(o)
                                }, 0, fl)("resize", function(o) {
                                    return r.onResize(o)
                                }, !1, fl)
                            },
                            decls: 2,
                            vars: 2,
                            consts: [
                                ["class", "header", 3, "ngClass", 4, "ngIf"],
                                [1, "header", 3, "ngClass"],
                                [1, "d-flex", "justify-content-between", "align-items-center", "w-100", "menu-header"],
                                [1, "container"],
                                [1, "d-flex", "justify-content-between", "align-items-center", "w-100"],
                                [1, "cursor-pointer", "d-flex", "align-items-center", "p-0", 3, "routerLink", "click"],
                                ["navigation", ""],
                                ["src", "/assets/images/svg-icons/logo.svg", 3, "svgStyle"],
                                [1, "d-flex", "align-items-center"],
                                ["title", "staking", "translate", "", 3, "routerLink", "click"],
                                ["class", "mx-2", "translate", "", 3, "routerLink", "fragment", "title", "click", 4, "ngFor", "ngForOf"],
                                [1, "menu-item", "d-flex", "align-items-center"],
                                [1, "d-flex", "align-items-center", "justify-content-center"],
                                ["href", "https://twitter.com/The_DogeVerse", "target", "_blank", 1, "mx-0"],
                                ["src", "/assets/images/svg-icons/twitter.svg", "alt", ""],
                                ["href", "https://t.me/The_DogeVerse", "target", "_blank", 1, "mx-0"],
                                ["src", "/assets/images/svg-icons/telegram.svg", "alt", ""],
                                ["class", "btn btn-white btn-sm rounded-0 d-flex align-items-center font-14 ms-3 text-uppercase", "translate", "", 3, "click", 4, "ngIf"],
                                ["class", "btn btn-white btn-sm  rounded-0 d-flex align-items-center font-14 ms-3", 3, "click", 4, "ngIf"],
                                ["dropdown", "", 1, "btn-group", "language", "ms-3"],
                                ["dropdownToggle", "", "type", "button", 1, "dropdown-toggle", "amountType", "d-flex", "align-items-center"],
                                ["alt", "", 1, "flag-icon", 3, "src"],
                                [1, "font-13", "mx-1", "text-uppercase", "fw-semibold"],
                                ["src", "./assets/images/svg-icons/angle-down.svg", 1, "dropdown", 3, "svgStyle"],
                                ["class", "dropdown-menu dropdown-menu-right", "role", "menu", 4, "dropdownMenu"],
                                ["translate", "", 1, "mx-2", 3, "routerLink", "fragment", "title", "click"],
                                ["translate", "", 1, "btn", "btn-white", "btn-sm", "rounded-0", "d-flex", "align-items-center", "font-14", "ms-3", "text-uppercase", 3, "click"],
                                [1, "btn", "btn-white", "btn-sm", "rounded-0", "d-flex", "align-items-center", "font-14", "ms-3", 3, "click"],
                                ["role", "menu", 1, "dropdown-menu", "dropdown-menu-right"],
                                ["class", "p-2 cursor-pointer font-14", "role", "menuitem", 3, "click", 4, "ngFor", "ngForOf"],
                                ["role", "menuitem", 1, "p-2", "cursor-pointer", "font-14", 3, "click"],
                                ["alt", "", 3, "src"],
                                [1, "d-flex", "justify-content-between", "align-items-center", "flex-grow-1", "w-100"],
                                [1, "d-flex", "justify-content-start", "align-items-center"],
                                [1, "cursor-pointer", "p-0", 3, "routerLink"],
                                [1, "menu-btn", 3, "click"],
                                [3, "src", "svgStyle"],
                                ["class", "menu-overlay", 4, "ngIf"],
                                [1, "menu-overlay"],
                                [1, "sub-menu", "pull-left", 3, "ngClass"],
                                [1, "d-flex", "flex-column", "justify-content-start", "align-items-start", "w-100"],
                                ["title", "staking", "routerLinkActive", "active", "translate", "", 1, "font-14", "py-2", "pb-2", 3, "routerLink", "click"],
                                ["class", "mx-0 pb-1 text-whitre", "translate", "", 3, "routerLink", "fragment", "title", "click", 4, "ngFor", "ngForOf"],
                                [1, "social-wrapper", "d-flex", "align-items-center", "justify-content-center", "mt-3", "mb-3"],
                                ["href", "https://twitter.com/The_DogeVerse", "target", "_blank", 1, "social"],
                                ["href", "https://t.me/The_DogeVerse", "target", "_blank", 1, "social"],
                                ["dropdown", "", 1, "btn-group", "language", "my-3"],
                                ["dropdownToggle", "", "type", "button", 1, "dropdown-toggle", "amountType", "d-flex", "align-items-center", "justify-content-between"],
                                [1, "ms-1", "font-16", "text-uppercase", "fw-semi-bold"],
                                ["class", "dropdown-menu dropdown-menu-left", "role", "menu", 4, "dropdownMenu"],
                                ["class", "btn btn-primary d-flex bg-white text-black justify-content-center mt-4 p-3", 3, "click", 4, "ngIf"],
                                ["class", "btn btn-primary bg-white text-black d-flex justify-content-center mt-4 p-3", 3, "click", 4, "ngIf"],
                                ["translate", "", 1, "mx-0", "pb-1", "text-whitre", 3, "routerLink", "fragment", "title", "click"],
                                ["role", "menu", 1, "dropdown-menu", "dropdown-menu-left"],
                                ["class", "p-2 cursor-pointer", "role", "menuitem", 3, "click", 4, "ngFor", "ngForOf"],
                                ["role", "menuitem", 1, "p-2", "cursor-pointer", 3, "click"],
                                [1, "btn", "btn-primary", "d-flex", "bg-white", "text-black", "justify-content-center", "mt-4", "p-3", 3, "click"],
                                ["translate", "", 1, "mx-2"],
                                [1, "btn", "btn-primary", "bg-white", "text-black", "d-flex", "justify-content-center", "mt-4", "p-3", 3, "click"],
                                [1, "mx-1", "fs-6"]
                            ],
                            template: function(i, r) {
                                1 & i && (tt(0, kxe, 26, 14, "div", 0), tt(1, Vxe, 9, 10, "div", 0)), 2 & i && (Re("ngIf", r.windowSize > 1024), he(1), Re("ngIf", r.windowSize <= 1024))
                            },
                            dependencies: [Jd, Ao, ts, $w, fF, B2, N2, lw, kf, na, wxe],
                            styles: [".header[_ngcontent-%COMP%]{position:fixed;left:0;top:0;width:100%;z-index:5;padding:15px 10px}.header.scrolled[_ngcontent-%COMP%]{background:rgba(0,0,0,.9);box-shadow:0 4px 8px #0000,0 6px 20px #0000001f}@media screen and (max-width: 576px){.header[_ngcontent-%COMP%]{top:0;padding:10px 14px;background:transparent}}.header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{padding:10px 5px;color:#fff;cursor:pointer;text-decoration:none;font-weight:600;font-size:14px;letter-spacing:1.5px;text-transform:uppercase;margin:0 7px}.header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:first-child{margin-left:0}.header[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#f264ff}@media only screen and (min-width: 577px) and (max-width: 1024px){.header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{padding:10px;margin:0}}.header[_ngcontent-%COMP%]   .cursor-auto[_ngcontent-%COMP%]{cursor:auto!important}.header[_ngcontent-%COMP%]   .connect[_ngcontent-%COMP%]{cursor:pointer;text-transform:capitalize;font-weight:600;color:#f96d1f;background-color:#f264ff;border:1px solid rgba(249,109,31,.5);min-height:50px;min-width:100px;display:flex;align-items:center;justify-content:center;border-radius:15px;font-size:13px;padding:5px 37px;box-shadow:#8e4418 0 .86px 13.754px}.header[_ngcontent-%COMP%]   .connect[_ngcontent-%COMP%]:hover{box-shadow:#8e4418 0 .86px 13.754px;transform:scale(1.03) translateZ(0)}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{text-decoration:none;letter-spacing:.02em;text-transform:capitalize;font-weight:400;padding:.3rem 1rem;border-radius:16px}.header[_ngcontent-%COMP%]   .menu-dropdown[_ngcontent-%COMP%]{padding:10px 0;color:#fff;cursor:pointer;text-decoration:none;text-transform:capitalize;font-weight:400;letter-spacing:1px;font-size:14px;width:auto}.header[_ngcontent-%COMP%]   .menu-dropdown.active[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   .menu-dropdown[_ngcontent-%COMP%]:hover{color:#1ddaff}.header[_ngcontent-%COMP%]   .small-btn[_ngcontent-%COMP%]{min-height:unset;height:42px}.header[_ngcontent-%COMP%]   .menu-btn[_ngcontent-%COMP%]{cursor:pointer;display:flex;padding:10px;border-radius:8px}.header[_ngcontent-%COMP%]   .menu-btn.menu-open[_ngcontent-%COMP%]   .line1[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   .menu-btn.menu-open[_ngcontent-%COMP%]   .line3[_ngcontent-%COMP%]{stroke-dasharray:90 207;stroke-dashoffset:-134}.header[_ngcontent-%COMP%]   .menu-btn.menu-open[_ngcontent-%COMP%]   .line2[_ngcontent-%COMP%]{stroke-dasharray:1 60;stroke-dashoffset:-30}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]{background:rgba(0,0,0,.75);position:fixed;width:100%;height:calc(100vh - 62px);top:62px;left:0;display:flex;justify-content:flex-end}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]{width:100%;height:100vh;background:#000000;padding:20px;position:relative;transition:right .5s;right:-100%;top:0;overflow-y:auto;overflow-x:hidden}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{font-size:18px!important;opacity:0}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu.open[_ngcontent-%COMP%]{right:0}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu.open[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{opacity:1;color:#fff}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   hr.new1[_ngcontent-%COMP%]{border:1px solid #ffffff;width:100%}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .policies[_ngcontent-%COMP%]{color:#fff;font-size:16px}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{width:100%;margin-bottom:20px;padding:5px;cursor:pointer;text-decoration:none;color:#000;letter-spacing:.02em;text-transform:uppercase;font-size:14px;font-weight:500}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a.social[_ngcontent-%COMP%]{width:auto;border:none;text-decoration:none;cursor:pointer}@media screen and (max-width: 576px){.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-transform:capitalize;border-bottom:1px solid rgba(255,255,255,.3607843137)}}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#f264ff}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{width:100%!important;padding:10px;margin:0;border:1px solid #1DDAFF;border-radius:0;text-decoration:none;letter-spacing:.02em;text-transform:uppercase;font-weight:400}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]:after{position:absolute;right:12px}@media screen and (max-width: 576px){.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{width:100%}}@media screen and (max-width: 1024px){.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{margin:0;border-radius:30px;padding:10px 14px}}@media screen and (max-width: 1024px){.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-menu.show[_ngcontent-%COMP%]{min-width:175px}}"]
                        })
                    }
                    return t
                })(),
                Hxe = (() => {
                    class t {
                        route;
                        translate;
                        eventService;
                        lang;
                        constructor(e, i, r) {
                            this.route = e, this.translate = i, this.eventService = r, this.route.params.subscribe(s => {
                                const o = s.lang;
                                if (o && $D(o)) this.lang = o;
                                else {
                                    const a = localStorage.getItem("currentlang");
                                    if (a && $D(a)) this.lang = a;
                                    else {
                                        const c = navigator.language ? .split("-")[0];
                                        this.lang = c && $D(c) ? c : "en"
                                    }
                                }
                            }), this.translate.setDefaultLang("en"), this.translate.use(this.lang), this.eventService.setLang(this.lang)
                        }
                        static\ u0275fac = function(i) {
                            return new(i || t)(We(hh), We(bc), We(Ah))
                        };
                        static\ u0275cmp = xn({
                            type: t,
                            selectors: [
                                ["app-language"]
                            ],
                            decls: 2,
                            vars: 0,
                            template: function(i, r) {
                                1 & i && gt(0, "app-header")(1, "router-outlet")
                            },
                            dependencies: [Lw, Uxe]
                        })
                    }
                    return t
                })();
            const $xe = ["graphCont"];

            function zxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "a", 47), xt("click", function() {
                        return Nt(e), Ft(Ke().claimStake())
                    }), Oe(1, "staking.claim_stake"), ce()
                }
            }

            function jxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "a", 48), xt("click", function() {
                        Nt(e);
                        const r = Ke(),
                            s = pl(104);
                        return Ft(r.buyClaimStake(s))
                    }), Oe(1, "staking.buy_stake"), ce()
                }
            }
            const Wxe = function(t) {
                return {
                    unstakeDate: t
                }
            };

            function Gxe(t, n) {
                if (1 & t && (J(0, "div", 60), Oe(1), qt(2, "translate"), qt(3, "date"), ce()), 2 & t) {
                    const e = Ke(2);
                    he(1), Ln(" ", _s(2, 1, "staking.withdraw_text", fi(7, Wxe, _s(3, 4, e.unstakeDate, "dd/MM/yy HH:mm"))), " ")
                }
            }

            function Kxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 49)(1, "div", 50)(2, "h4", 51), Oe(3, "staking.withdraw_title"), ce()(), J(4, "div", 52)(5, "span", 53), Oe(6, "staking.card_1_title"), ce(), J(7, "h2", 54), Oe(8), J(9, "span", 55), Oe(10, "staking.card_coin"), ce()(), tt(11, Gxe, 4, 9, "div", 56), ce(), J(12, "div", 57)(13, "button", 58), Oe(14, "staking.withdraw"), ce(), J(15, "button", 59), xt("click", function() {
                        return Nt(e), Ft(Ke().closeModal())
                    }), Oe(16, "misc.cancel"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(8), Ln("", e.userStaked, " "), he(3), Re("ngIf", e.stakeData.userStaked > 0), he(2), Re("disabled", !e.canUnstake)
                }
            }

            function qxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 49)(1, "div", 50)(2, "h4", 51), Oe(3, "staking.stake_token"), ce(), J(4, "span", 61), xt("click", function() {
                        return Nt(e), Ft(Ke().closeModal())
                    }), Oe(5, "X"), ce()(), J(6, "div", 52)(7, "span", 62), Oe(8, "user_bal "), ce(), J(9, "h2", 63), Oe(10), J(11, "span", 55), Oe(12, "staking.card_coin"), ce()()(), J(13, "div", 64)(14, "div", 17)(15, "label", 65), Oe(16, "staking.stake_amount"), ce(), J(17, "a", 66), xt("click", function() {
                        return Nt(e), Ft(Ke().max())
                    }), Oe(18, "widget.max"), ce()(), J(19, "input", 67), xt("ngModelChange", function(r) {
                        return Nt(e), Ft(Ke().stakeAmount = r)
                    }), ce(), J(20, "p", 68), Oe(21, "staking.enterAmount"), ce()(), J(22, "div", 69)(23, "button", 70), xt("click", function() {
                        return Nt(e), Ft(Ke().closeModal())
                    }), Oe(24, "misc.cancel"), ce()()()
                }
                if (2 & t) {
                    const e = Ke();
                    he(10), Ln("", e.userBal, " "), he(9), Re("ngModel", e.stakeAmount)
                }
            }
            const W7 = function(t) {
                return {
                    stakeAmount: t
                }
            };

            function Zxe(t, n) {
                if (1 & t && (J(0, "div", 74), gt(1, "img", 75), J(2, "div", 76), Oe(3), qt(4, "translate"), ce(), J(5, "p", 77), Oe(6), qt(7, "translate"), ce()()), 2 & t) {
                    const e = Ke(2);
                    he(3), on(Dn(4, 2, "widget.transaction_in_progress")), he(3), on(_s(7, 4, "staking.stake_transction_info", fi(7, W7, e.stakeAmount)))
                }
            }
            const G7 = function(t) {
                return {
                    cryptoName: t
                }
            };

            function Yxe(t, n) {
                if (1 & t && (J(0, "div", 74), gt(1, "img", 75), J(2, "div", 78), Oe(3), qt(4, "translate"), ce(), J(5, "p", 77), Oe(6), qt(7, "translate"), ce()()), 2 & t) {
                    const e = Ke(2);
                    he(3), on(Dn(4, 2, "misc.confirm")), he(3), on(_s(7, 4, "staking.stake_waiting_confirm", fi(7, G7, e.cryptoName)))
                }
            }

            function Xxe(t, n) {
                if (1 & t && (J(0, "div", 74), gt(1, "img", 75), J(2, "div", 78), Oe(3), qt(4, "translate"), ce(), J(5, "p", 77), Oe(6), qt(7, "translate"), ce()()), 2 & t) {
                    const e = Ke(2);
                    he(3), on(Dn(4, 2, "widget.authorise")), he(3), on(_s(7, 4, "staking.stake_waiting_approve", fi(7, G7, e.cryptoName)))
                }
            }

            function Qxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 74), gt(1, "img", 79), J(2, "div", 80), Oe(3), qt(4, "translate"), ce(), J(5, "p", 81), Oe(6), qt(7, "translate"), ce(), J(8, "div", 82)(9, "button", 83), xt("click", function() {
                        return Nt(e), Ft(Ke(2).viewUrl())
                    }), Oe(10, "widget.view_transaction"), ce(), J(11, "button", 59), xt("click", function() {
                        return Nt(e), Ft(Ke(2).closeModal())
                    }), Oe(12, "misc.done"), ce()()()
                }
                if (2 & t) {
                    const e = Ke(2);
                    he(3), on(Dn(4, 2, "stake_transaction_success")), he(3), on(_s(7, 4, "staking.stake_transction_info", fi(7, W7, e.stakeAmount)))
                }
            }

            function Jxe(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 74), gt(1, "img", 84), J(2, "div", 85), Oe(3), qt(4, "translate"), ce(), J(5, "p", 86), Oe(6), qt(7, "translate"), ce(), J(8, "div", 82)(9, "button", 83), xt("click", function() {
                        return Nt(e), Ft(Ke(2).viewUrl())
                    }), Oe(10, "widget.view_transaction"), ce(), J(11, "button", 59), xt("click", function() {
                        return Nt(e), Ft(Ke(2).closeModal())
                    }), Oe(12, "misc.done"), ce()()()
                }
                2 & t && (he(3), on(Dn(4, 2, "staking.stake_transaction_failed")), he(3), on(Dn(7, 4, "staking.stake_view_transaction_info")))
            }

            function e1e(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 74), gt(1, "img", 84), J(2, "div", 87), Oe(3), qt(4, "translate"), ce(), J(5, "div", 88)(6, "button", 83), xt("click", function() {
                        return Nt(e), Ft(Ke(2).closeModal())
                    }), Oe(7, "misc.done"), ce()()()
                }
                2 & t && (he(3), on(Dn(4, 1, "staking.stake_transaction_rejected")))
            }

            function t1e(t, n) {
                if (1 & t && (J(0, "div", 71)(1, "div", 72), tt(2, Zxe, 8, 9, "div", 73), tt(3, Yxe, 8, 9, "div", 73), tt(4, Xxe, 8, 9, "div", 73), tt(5, Qxe, 13, 9, "div", 73), tt(6, Jxe, 13, 6, "div", 73), tt(7, e1e, 8, 3, "div", 73), ce()()), 2 & t) {
                    const e = Ke();
                    he(2), Re("ngIf", e.status === e.SwapStatus.in_progess), he(1), Re("ngIf", e.status === e.SwapStatus.confirm_pending), he(1), Re("ngIf", e.status === e.SwapStatus.approval_pending), he(1), Re("ngIf", e.status === e.SwapStatus.complete), he(1), Re("ngIf", e.status === e.SwapStatus.failed), he(1), Re("ngIf", e.status === e.SwapStatus.rejected)
                }
            }
            const n1e = function() {
                return {
                    "width.px": 12,
                    "height.px": 12
                }
            };

            function i1e(t, n) {
                if (1 & t) {
                    const e = On();
                    J(0, "div", 89)(1, "h4", 51), Oe(2, "staking.buy_stake"), ce(), J(3, "svg-icon", 90), xt("click", function() {
                        return Nt(e), Ft(Ke().closeModal())
                    }), ce()(), J(4, "div", 49), gt(5, "app-swap", 91), ce()
                }
                2 & t && (he(3), Re("svgStyle", Ns(4, n1e)), he(2), Re("isNative", !0)("isWert", !1)("isModal", !0))
            }
            const r1e = [{
                path: ":lang",
                component: Hxe,
                children: [{
                    path: "",
                    component: bxe
                }, {
                    path: "staking",
                    component: (() => {
                        class t {
                            popupService;
                            translate;
                            walletConnectService;
                            modalService;
                            modalRef;
                            graphCont;
                            rewards = [{
                                name: "Apr-2024",
                                value: 106333333333
                            }, {
                                name: "May-2024",
                                value: 107666666667
                            }, {
                                name: "Jun-2024",
                                value: 109e9
                            }, {
                                name: "Jul-2024",
                                value: 110333333333
                            }, {
                                name: "Aug-2024",
                                value: 111666666667
                            }, {
                                name: "Sep-2024",
                                value: 113e9
                            }, {
                                name: "Oct-2024",
                                value: 114333333333
                            }, {
                                name: "Nov-2024",
                                value: 115666666667
                            }, {
                                name: "Dec-2024",
                                value: 117e9
                            }, {
                                name: "Jan-2025",
                                value: 118333333333
                            }, {
                                name: "Feb-2025",
                                value: 119666666667
                            }, {
                                name: "Mar-2025",
                                value: 121e9
                            }, {
                                name: "Apr-2025",
                                value: 121333333333
                            }, {
                                name: "May-2025",
                                value: 121666666667
                            }, {
                                name: "Jun-2025",
                                value: 122e9
                            }, {
                                name: "Jul-2025",
                                value: 122333333333
                            }, {
                                name: "Aug-2025",
                                value: 122666666667
                            }, {
                                name: "Sep-2025",
                                value: 123e9
                            }, {
                                name: "Oct-2025",
                                value: 123333333333
                            }, {
                                name: "Nov-2025",
                                value: 123666666667
                            }, {
                                name: "Dec-2025",
                                value: 124e9
                            }, {
                                name: "Jan-2026",
                                value: 124333333333
                            }, {
                                name: "Feb-2026",
                                value: 124666666667
                            }, {
                                name: "Mar-2026",
                                value: 125e9
                            }];
                            fitContainer = !0;
                            view = [void 0, void 0];
                            showXAxis = !0;
                            showYAxis = !0;
                            gradient = !1;
                            legendTitle = "Total Rewards";
                            legendPosition = "below";
                            showLegend = !1;
                            showXAxisLabel = !0;
                            xAxisLabel = "Months";
                            showYAxisLabel = !0;
                            yAxisLabel = "Supply";
                            SwapStatus = Ki;
                            showGridLines = !0;
                            showDataLabel = !1;
                            maxYAxis = 100;
                            minYAxis = 0;
                            stakeAmount;
                            colorScheme = {
                                name: "myScheme",
                                selectable: !0,
                                group: gi.Ordinal,
                                domain: ["#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e", "#11322e"]
                            };
                            lang = localStorage.getItem("currentlang");
                            timeInterval;
                            onResize(e) {
                                this.view = [+this.graphCont.nativeElement.offsetWidth / 1.05, 400]
                            }
                            constructor(e, i, r, s) {
                                this.popupService = e, this.translate = i, this.walletConnectService = r, this.modalService = s;
                                let o = 0;
                                const a = new Date,
                                    c = a.getUTCDate(),
                                    u = a.getUTCMonth(),
                                    h = a.getUTCFullYear();
                                this.rewards.forEach((m, x) => {
                                    const D = new Date(m.name),
                                        V = D.getUTCMonth();
                                    D.getUTCFullYear() === h && V === u && c >= D.getUTCDate() && (o = x)
                                }), this.colorScheme.domain[o] = "#EA1AF7"
                            }
                            ngOnInit() {}
                            ngAfterViewInit() {
                                this.view = [+this.graphCont.nativeElement.offsetWidth / 1.05, 400], setTimeout(() => {
                                    this.walletAddress || this.connectModal()
                                }, 4e3)
                            }
                            get stakeData() {
                                return this.walletConnectService.stakeData
                            }
                            get walletAddress() {
                                return this.walletConnectService.walletAddress
                            }
                            get poolPercent() {
                                return this.walletAddress && 0 !== this.stakeData.totalStaked && +(100 * this.stakeData.userStaked / this.stakeData.totalStaked).toFixed(5) || 0
                            }
                            checkEthChain() {
                                return this.walletAddress ? !!this.walletConnectService.isEthChain() || (this.popupService.messagePopup("info", this.translate.instant("popup.wrong_chain", {
                                    chainName: nt.eth.chainName
                                }), this.translate.instant("popup.change_network")).then(e => {
                                    e.isConfirmed && this.walletConnectService.switchNetwork(nt.eth.chainIdInt)
                                }), !1) : (this.connectModal(), !1)
                            }
                            openModal(e) {
                                this.modalRef = this.modalService.show(e, {
                                    class: "modal-xs modal-dialog-centered",
                                    backdrop: "static"
                                })
                            }
                            buyClaimStake(e) {
                                this.checkEthChain() ? this.walletAddress && 0 == this.ethClaimable && this.openModal(e) : this.timeInterval = setInterval(() => this.startConnectInterval(e), 2e3)
                            }
                            startConnectInterval(e) {
                                this.walletAddress && this.walletConnectService.isEthChain() && (this.openModal(e), clearInterval(this.timeInterval))
                            }
                            claimStake() {
                                0 == this.ethClaimable || !this.checkEthChain() || (this.walletConnectService.claimStake(), this.modalRef = this.modalService.show(k_, {
                                    class: "modal-xs modal-dialog-centered",
                                    backdrop: "static",
                                    initialState: {
                                        isStake: !0
                                    }
                                }))
                            }
                            closeModal() {
                                this.modalRef.hide()
                            }
                            yAxisTickFormattingFn = this.yAxisTickFormatting.bind(this);
                            yAxisTickFormatting(e) {
                                return this.formatNumber(e / 1e6) + "M"
                            }
                            onSelect(e) {
                                console.log(e)
                            }
                            onActivate(e) {
                                console.log("Activate", JSON.parse(JSON.stringify(e)))
                            }
                            onDeactivate(e) {
                                console.log("Deactivate", JSON.parse(JSON.stringify(e)))
                            }
                            formatString(e) {
                                return e.toUpperCase()
                            }
                            formatNumber(e) {
                                return zD(e)
                            }
                            get userReward() {
                                return this.walletAddress ? this.formatNumber(+this.stakeData.userReward.toFixed(0)) : 0
                            }
                            get status() {
                                return this.walletConnectService.swapStatus
                            }
                            get userStaked() {
                                return this.walletAddress ? this.formatNumber(+this.stakeData.userStaked.toFixed(0)) : 0
                            }
                            get ethClaimable() {
                                return this.walletAddress ? this.formatNumber(+this.walletConnectService.balanceData.ethClaimable.toFixed(0)) : 0
                            }
                            get ethTokens() {
                                return this.walletAddress ? this.walletConnectService.balanceData.ethClaimable : 0
                            }
                            get totalStaked() {
                                return this.formatNumber(+this.stakeData.totalStaked.toFixed(0))
                            }
                            get userBal() {
                                return this.formatNumber(this.stakeData.userBal)
                            }
                            get unstakeDate() {
                                return new Date(1e3 * this.stakeData.unlockTime)
                            }
                            get canUnstake() {
                                return new Date(1e3 * this.stakeData.unlockTime) < new Date
                            }
                            get cryptoName() {
                                return nt.tokenName
                            }
                            get hash() {
                                return this.walletConnectService.swapHash
                            }
                            withdrawStake() {
                                0 == this.stakeData.userStaked || !this.checkEthChain() || (this.walletConnectService.withdrawStake(), this.modalRef.hide(), setTimeout(() => {
                                    this.modalRef = this.modalService.show(k_, {
                                        class: "modal-xs modal-dialog-centered",
                                        backdrop: "static",
                                        initialState: {
                                            isWithdraw: !0
                                        }
                                    })
                                }, 500))
                            }
                            claim() {
                                this.stakeData.isClaimEnabled ? 0 == this.stakeData.userReward || !this.checkEthChain() || (this.walletConnectService.claimStakeRewards(), this.modalRef ? .hide(), setTimeout(() => {
                                    this.modalRef = this.modalService.show(k_, {
                                        class: "modal-xs modal-dialog-centered",
                                        backdrop: "static"
                                    })
                                }, 500)) : this.popupService.messagePopup("info", this.translate.instant("popup.claim_not_live"))
                            }
                            max() {
                                this.stakeAmount = this.stakeData.userBal
                            }
                            stakeToken(e) {
                                !this.checkEthChain() || this.stakeAmount > this.stakeData.userBal || (this.walletConnectService.createStake(this.stakeAmount), this.modalRef.hide(), setTimeout(() => {
                                    this.modalRef = this.modalService.show(e, {
                                        class: "modal-xs modal-dialog-centered",
                                        backdrop: "static"
                                    })
                                }, 1e3))
                            }
                            connectModal() {
                                this.modalRef = this.modalService.show(E1, {
                                    class: "modal-min modal-dialog-centered",
                                    backdrop: "static",
                                    initialState: {
                                        isBsNetwork: !1
                                    }
                                })
                            }
                            poolInfo() {
                                this.popupService.messagePopup("info", this.translate.instant("staking.pool_share"))
                            }
                            viewUrl() {
                                window.open(nt.eth.blockExplorerURL + this.hash, "_blank")
                            }
                            static\ u0275fac = function(i) {
                                return new(i || t)(We(A_), We(bc), We(dp), We(oh))
                            };
                            static\ u0275cmp = xn({
                                type: t,
                                selectors: [
                                    ["app-stake-dashboard"]
                                ],
                                viewQuery: function(i, r) {
                                    if (1 & i && $c($xe, 5), 2 & i) {
                                        let s;
                                        wa(s = xa()) && (r.graphCont = s.first)
                                    }
                                },
                                hostBindings: function(i, r) {
                                    1 & i && xt("resize", function(o) {
                                        return r.onResize(o)
                                    }, 0, fl)
                                },
                                decls: 106,
                                vars: 26,
                                consts: [
                                    [1, "dashboard"],
                                    [1, "container"],
                                    [1, "row", "d-flex", "align-items-center"],
                                    [1, "col-lg-7", "col-12"],
                                    ["translate", "", 1, "heading", "pb-3", "m-0", "text-uppercase", "pe-2", "text-start", "text-light", "fw-bold"],
                                    ["translate", "", 1, "font-16", "sub-head", "text-light"],
                                    [1, "col-lg-5", "col-12", "justify-content-md-end", "d-flex"],
                                    ["translate", "", 1, "btn", "btn-primary", "fw-bold", 3, "click"],
                                    [1, "col-lg-12", "col-12", "mt-4"],
                                    [1, "box-wrap"],
                                    [1, "box"],
                                    ["translate", "", 1, "title", "fw-bold", "text-uppercase", "mb-1", "d-inline-block"],
                                    [1, "font-25", "mt-2", "d-flex", "align-items-start"],
                                    ["translate", "", 1, "d-inline-block", "ms-2", "font-12", "fw-bold"],
                                    ["class", "btn btn-primary fs-6 fw-bold w-100", "translate", "", "title", "staking", 3, "click", 4, "ngIf"],
                                    ["class", "text-decoration-none btn btn-primary fs-6 fw-bold w-100 cursor-pointer", "translate", "", 3, "click", 4, "ngIf"],
                                    [1, "w-100"],
                                    [1, "d-flex", "align-items-center", "justify-content-between"],
                                    ["translate", "", 1, "title", "font-14", "fw-bold", "text-uppercase", "mb-1", "d-inline-block"],
                                    ["src", "/assets/images/svg-icons/info-icon.svg", "alt", "", 1, "img-fluid", "cursor-pointer", 3, "click"],
                                    [1, "font-25", "mt-2", "fw-bold"],
                                    ["translate", "", 1, "title", "font-14", "text-uppercase", "fw-bold", "mb-1", "d-inline-block"],
                                    [1, "font-25", "mt-2"],
                                    ["translate", "", 1, "mb-2", "font-12", "fw-bold", "title", "ps-2"],
                                    [1, "p-0", "mt-3", "mb-0"],
                                    ["translate", ""],
                                    ["src", "/assets/images/svg-icons/ani-arrow.svg", "height", "8px", "alt", "", 1, "me-2"],
                                    ["translate", "", 1, "title", "font-14", "text-uppercase", "mb-1", "d-inline-block", "fw-bold"],
                                    ["translate", "", 1, "btn", "btn-primary", "fs-6", "fw-bold", "w-100", 3, "click"],
                                    [1, "row", "mt-5", "align-items-center", "justify-content-between"],
                                    [1, "col-lg-8", "mb-3"],
                                    [1, "chart-wrapper"],
                                    [1, "d-flex", "justify-content-center", "px-3", "align-items-center"],
                                    ["translate", "", 1, "mt-4", "mb-3", "text-center"],
                                    [1, "w-100", "graph-parent"],
                                    ["graphCont", ""],
                                    [3, "view", "scheme", "results", "gradient", "xAxis", "yAxis", "legendTitle", "legend", "yScaleMin", "yScaleMax", "showXAxisLabel", "showYAxisLabel", "showGridLines", "showDataLabel", "xAxisLabel", "yAxisLabel", "yAxisTickFormatting", "select"],
                                    ["translate", "", 1, "stake-text", "d-flex", "align-items-center", "mt-3"],
                                    ["translate", "", 1, "text-light", "me-2"],
                                    ["href", "https://web3paymentsolutions.io/", "target", "_blank"],
                                    ["src", "/assets/images/svg-icons/W3P_Black.svg", "alt", "Web3Payments"],
                                    [1, "col-lg-4", "d-none", "d-sm-block"],
                                    ["src", "/assets/images/svg-icons/token.svg", "alt", "", 1, "img-fluid", "mx-auto", "token", "d-flex", "align-items-center", "justify-content-center"],
                                    ["withdraw", ""],
                                    ["stake", ""],
                                    ["successfull", ""],
                                    ["buy_stake", ""],
                                    ["translate", "", "title", "staking", 1, "btn", "btn-primary", "fs-6", "fw-bold", "w-100", 3, "click"],
                                    ["translate", "", 1, "text-decoration-none", "btn", "btn-primary", "fs-6", "fw-bold", "w-100", "cursor-pointer", 3, "click"],
                                    [1, "modal-body"],
                                    [1, "d-flex", "align-items-center", "justify-content-center", "w-100", "mb-3"],
                                    ["translate", "", 1, "modal-title", "pull-left", "text-light"],
                                    [1, "text-center", "my-4"],
                                    ["translate", "", 1, "font-14", "text-uppercase", "mb-1", "d-inline-block", "text-light"],
                                    [1, "font-25", "mt-2", "d-flex", "align-items-start", "fw-bold", "justify-content-center", "text-light"],
                                    ["translate", "", 1, "d-inline-block", "text-light", "ms-2", "font-12", "fw-bold"],
                                    ["class", "d-inline-block text-light ms-2 font-14", 4, "ngIf"],
                                    [1, "d-flex", "align-items-center", "gap-3"],
                                    ["translate", "", 1, "btn", "btn-primary", "w-100", 3, "disabled"],
                                    ["translate", "", 1, "btn", "btn-secondary", "w-100", 3, "click"],
                                    [1, "d-inline-block", "text-light", "ms-2", "font-14"],
                                    ["aria-hidden", "true", 1, "cursor-pointer", "stake-close", 3, "click"],
                                    ["translate", "", 1, "staking-title", "font-14", "text-uppercase", "mb-1", "d-inline-block"],
                                    [1, "font-25", "mt-2", "text-light", "d-flex", "align-items-start", "fw-bold", "justify-content-center"],
                                    [1, "form-group"],
                                    ["translate", "", 1, "font-12"],
                                    ["translate", "", 1, "font-12", "text-decoration-underline", "cursor-pointer", "text-light", 3, "click"],
                                    ["type", "text", "placeholder", "0", 1, "form-control", "text-light", 3, "ngModel", "ngModelChange"],
                                    ["translate", "", 1, "font-13"],
                                    [1, "d-flex", "align-items-center"],
                                    ["translate", "", 1, "btn", "btn-secondary", "fs-7", "w-100", 3, "click"],
                                    [1, "modal-body", "d-flex", "align-items-center", "flex-column", "justify-content-center"],
                                    [1, "text-center", "w-100", "mb-3"],
                                    ["class", "body-section text-center", 4, "ngIf"],
                                    [1, "body-section", "text-center"],
                                    ["src", "/assets/images/svg-icons/token.svg", "alt", "loading", 1, "statusIcon", "loading"],
                                    [1, "fw-normal", "fw-bold", "font-16", "px-2", "my-3", "text-uppercase", "text-light", "text-center"],
                                    [1, "fs-7", "mb-0", "text-light"],
                                    [1, "fw-semibold", "fs-6", "my-3", "text-uppercase", "text-light", "text-center"],
                                    ["src", "/assets/images/popup-icons/success.svg", "alt", "complete", 1, "statusIcon"],
                                    [1, "fw-semibold", "fs-6", "my-3", "text-uppercase", "text-success", "text-center"],
                                    [1, "fs-7", "mb-3", "mb-lg-4", "text-black"],
                                    [1, "d-flex", "align-items-center", "justify-content-center", "gap-3"],
                                    ["translate", "", 1, "btn", "btn-primary", "w-100", 3, "click"],
                                    ["src", "/assets/images/popup-icons/warning.svg", "alt", "failed", 1, "statusIcon"],
                                    [1, "fw-semibold", "fs-6", "my-3", "text-uppercase", "text-danger", "text-center"],
                                    [1, "fs-7", "mb-3", "mb-lg-4", "text-warning"],
                                    [1, "fw-semibold", "fs-6", "text-uppercase", "text-warning", "my-3", "text-center"],
                                    [1, "d-flex", "align-items-center", "justify-content-center", "gap-3", "mt-4"],
                                    [1, "modal-header", "d-flex", "align-items-center", "justify-content-center", "position-relative"],
                                    ["src", "/assets/images/svg-icons/close-white.svg", 1, "cursor-pointer", "stake-close", 3, "svgStyle", "click"],
                                    [3, "isNative", "isWert", "isModal"]
                                ],
                                template: function(i, r) {
                                    if (1 & i) {
                                        const s = On();
                                        J(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4), Oe(5, "staking.title"), ce(), J(6, "p", 5), Oe(7, "staking.desc"), ce()(), J(8, "div", 6)(9, "button", 7), xt("click", function() {
                                            Nt(s);
                                            const a = pl(98);
                                            return Ft(r.openModal(a))
                                        }), Oe(10, "staking.withdraw_title"), ce()(), J(11, "div", 8)(12, "div", 9)(13, "div", 10)(14, "div")(15, "span", 11), Oe(16, "staking.card_1_title"), ce(), J(17, "h2", 12), Oe(18), J(19, "span", 13), Oe(20, "staking.card_coin"), ce()()(), J(21, "div")(22, "span", 11), Oe(23, "staking.your_stakeable "), ce(), J(24, "h2", 12), Oe(25), J(26, "span", 13), Oe(27, "staking.card_coin"), ce()()(), tt(28, zxe, 2, 0, "a", 14), tt(29, jxe, 2, 0, "a", 15), ce(), J(30, "div", 10)(31, "div", 16)(32, "div", 17)(33, "span", 18), Oe(34, "staking.card_2_title "), ce(), J(35, "img", 19), xt("click", function() {
                                            return r.poolInfo()
                                        }), ce()(), J(36, "h2", 20), Oe(37), ce(), J(38, "div")(39, "span", 21), Oe(40, "staking.total_staked "), ce(), J(41, "h2", 12), Oe(42), J(43, "span", 13), Oe(44, "staking.card_coin"), ce()()()()(), J(45, "div", 10)(46, "div")(47, "span", 21), Oe(48, "staking.card_3_title"), ce(), J(49, "h2", 22), Oe(50), J(51, "sup", 23), Oe(52, "staking.stake_pa"), ce()()(), J(53, "ul", 24)(54, "li", 25), gt(55, "img", 26), Oe(56, "staking.card_3_para_1"), ce(), J(57, "li", 25), gt(58, "img", 26), Oe(59, "staking.card_3_para_2"), ce(), J(60, "li", 25), gt(61, "img", 26), Oe(62, "staking.card_3_para_3"), ce()()(), J(63, "div", 10)(64, "div")(65, "span", 27), Oe(66, "staking.card_4_title"), ce(), J(67, "h2", 12), Oe(68), J(69, "span", 13), Oe(70, "staking.card_block"), ce()()()(), J(71, "div", 10)(72, "div")(73, "span", 27), Oe(74, "staking.card_5_title"), ce(), J(75, "h2", 12), Oe(76), J(77, "span", 13), Oe(78, "staking.card_coin"), ce()()(), J(79, "button", 28), xt("click", function() {
                                            return r.claim()
                                        }), Oe(80, "staking.rewards_btn"), ce()()()()(), J(81, "div", 29)(82, "div", 30)(83, "div", 31)(84, "div", 32)(85, "h4", 33), Oe(86, "staking.total_rewards"), ce()(), J(87, "div", 34, 35)(89, "ngx-charts-bar-vertical", 36), xt("select", function(a) {
                                            return r.onSelect(a)
                                        }), ce()()(), J(90, "div", 37)(91, "span", 38), Oe(92, "staking.staking_powered_by"), ce(), J(93, "a", 39), gt(94, "img", 40), ce()()(), J(95, "div", 41), gt(96, "img", 42), ce()()()(), tt(97, Kxe, 17, 3, "ng-template", null, 43, _l), tt(99, qxe, 25, 2, "ng-template", null, 44, _l), tt(101, t1e, 8, 6, "ng-template", null, 45, _l), tt(103, i1e, 6, 5, "ng-template", null, 46, _l), gt(105, "app-footer")
                                    }
                                    2 & i && (he(18), Ln("", r.userStaked, " "), he(7), Ln("", r.ethClaimable, " "), he(3), Re("ngIf", r.ethTokens && r.ethTokens > 0), he(1), Re("ngIf", 0 == r.ethTokens), he(8), Ln("", r.poolPercent, "%"), he(5), Ln("", r.totalStaked, " "), he(8), Ln("", r.stakeData.apy, "%"), he(18), Ln("", r.stakeData.rewardPerRound, " "), he(8), Ln("", r.userReward, " "), he(13), Re("view", r.view)("scheme", r.colorScheme)("results", r.rewards)("gradient", r.gradient)("xAxis", r.showXAxis)("yAxis", r.showYAxis)("legendTitle", r.legendTitle)("legend", r.showLegend)("yScaleMin", r.minYAxis)("yScaleMax", r.maxYAxis)("showXAxisLabel", r.showXAxisLabel)("showYAxisLabel", r.showYAxisLabel)("showGridLines", r.showGridLines)("showDataLabel", r.showDataLabel)("xAxisLabel", r.xAxisLabel)("yAxisLabel", r.yAxisLabel)("yAxisTickFormatting", r.yAxisTickFormattingFn))
                                },
                                dependencies: [ts, Qy, z2, ww, kf, zhe, na, P7, DI, eR, Sf],
                                styles: [".dashboard[_ngcontent-%COMP%]{padding:150px 0 105px;min-height:864px;background:rgba(0,0,0,.6)}@media screen and (max-width: 576px){.dashboard[_ngcontent-%COMP%]{padding:70px 0}}.dashboard[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%]{font-size:50px;font-weight:400;color:#fefefe}@media screen and (max-width: 576px){.dashboard[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%]{padding-top:30px;font-size:34px}}.dashboard[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{color:#1ddaff;font-size:50px;margin:auto;max-width:500px;font-weight:800}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]{display:grid;grid-template-columns:repeat(5,1fr);gap:20px}@media screen and (max-width: 1024px){.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]{grid-template-columns:repeat(4,1fr)}}@media screen and (max-width: 768px){.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]{grid-template-columns:repeat(3,1fr)}}@media screen and (max-width: 576px){.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]{grid-template-columns:repeat(1,1fr)}}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{padding:20px;display:flex;flex-direction:column;align-items:flex-start;justify-content:space-between;color:#fff;border-radius:20px;border:.5px solid rgba(255,255,255,.4);background:rgba(31,41,55,.4);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);box-shadow:2px 4px 12px #00000014;width:100%;margin:0 auto}@media screen and (max-width: 576px){.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]{max-width:unset}}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   sup[_ngcontent-%COMP%]{vertical-align:super}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{color:#fff;font-weight:700}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#fff}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{letter-spacing:1.4px;color:#fefefe}.dashboard[_ngcontent-%COMP%]   .box-wrap[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{color:#fefefe;font-size:12px;font-style:normal;font-weight:500;list-style:none;margin-bottom:3px;display:flex;align-items:baseline}.dashboard[_ngcontent-%COMP%]   google-chart[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > svg[_ngcontent-%COMP%] > g[_ngcontent-%COMP%] > rect[_ngcontent-%COMP%]{fill:#888!important}.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]{border-radius:20px;border:.5px solid rgba(255,255,255,.4);background:rgba(31,41,55,.4);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);box-shadow:0 6px 5px #00000008;min-height:431px}.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]   .calendar[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{display:none}.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]   .graph-parent[_ngcontent-%COMP%]{height:450px;width:100%}.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%]{color:#fefefe;font-size:20px;font-weight:600;letter-spacing:1.4px;text-transform:uppercase}.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]   ngx-charts-bar-vertical[_ngcontent-%COMP%]{fill:#fff!important;font-weight:500}@media screen and (max-width: 1024px){.dashboard[_ngcontent-%COMP%]   .chart-wrapper[_ngcontent-%COMP%]{min-height:unset}}.dashboard[_ngcontent-%COMP%]   .token[_ngcontent-%COMP%]{height:260px}.dashboard[_ngcontent-%COMP%]   .ngx-daterangepicker-action[_ngcontent-%COMP%]{position:absolute;right:15px;top:10px}.footer[_ngcontent-%COMP%]{background:#000000 url(/assets/images/footer-png.png) no-repeat 0% 0%;background-size:100%}.staking-title[_ngcontent-%COMP%]{color:#f264ff}.success-msg[_ngcontent-%COMP%]{color:#22282d;font-size:16px}.stake-close[_ngcontent-%COMP%]{position:absolute;right:20px}.button[_ngcontent-%COMP%]{border:1px solid #7f756b;background:rgba(255,255,255,.46);display:flex;height:40px;padding:10px 24px;justify-content:center;align-items:center;text-decoration:none}@media screen and (max-width: 576px){.button[_ngcontent-%COMP%]{padding:10px 15px;font-size:14px!important}}.form-group[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{color:#f264ff}.form-group[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]{border:1px solid #dbd1c9;background:#ffffff;padding:8px 10px}.modal-body[_ngcontent-%COMP%]{min-height:auto!important}.stake-text[_ngcontent-%COMP%]   span[_ngcontent-%COMP%], .stake-text[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{font-size:14px;line-height:1}.stake-text[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:20px;width:auto;display:inline-block}.form-group[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{font-size:16px;color:#f264ff;font-weight:600;margin-bottom:5px}.form-group[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]{font-size:16px;font-weight:600;box-shadow:none;border-radius:10px;border:6px solid #DAD9C7;background-color:#1ddaff;padding:16px 25px;color:#f264ff}.form-group[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]::placeholder{opacity:.5;color:#f264ff}.form-group[_ngcontent-%COMP%]   .form-select[_ngcontent-%COMP%]{font-size:16px;font-weight:600;box-shadow:none;border-radius:10px;background-color:#1ddaff;padding:16px 25px;color:#f264ff;background-image:url(/assets/images/svg-icons/angle-down.svg)}.form-group[_ngcontent-%COMP%]   .form-select[_ngcontent-%COMP%]::placeholder{opacity:.5;color:#f264ff}.statusIcon[_ngcontent-%COMP%]{height:55px}.orange-btn[_ngcontent-%COMP%]{cursor:pointer;text-transform:capitalize;font-weight:600;color:#f96d1f;background-color:#f96d1f1a;border:1px solid rgba(249,109,31,.5);min-height:50px;min-width:100px;display:flex;align-items:center;justify-content:center;border-radius:15px;font-size:13px;padding:5px 37px;box-shadow:#8e4418 0 .86px 13.754px}"]
                            })
                        }
                        return t
                    })()
                }]
            }, {
                path: "**",
                redirectTo: "/en",
                pathMatch: "full"
            }];
            let s1e = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275mod = _i({
                            type: t
                        });
                        static\ u0275inj = wi({
                            imports: [wF.forRoot(r1e, {
                                anchorScrolling: "enabled"
                            }), uN, wF]
                        })
                    }
                    return t
                })(),
                o1e = (() => {
                    class t {
                        static\ u0275fac = function(i) {
                            return new(i || t)
                        };
                        static\ u0275mod = _i({
                            type: t,
                            bootstrap: [bbe]
                        });
                        static\ u0275inj = wi({
                            imports: [mQ, s1e, uN, pte, _te, yee.forRoot(), XJ.forRoot(), oJ.forRoot(), gfe.forRoot(), yfe, ZQ, ife, mre, mfe, SQ.forRoot({
                                loader: {
                                    provide: $y,
                                    useFactory: a1e,
                                    deps: [Ef]
                                }
                            })]
                        })
                    }
                    return t
                })();

            function a1e(t) {
                return new tJ(t, "./assets/i18n/", ".json")
            }
            uY().bootstrapModule(o1e).catch(t => console.error(t)), nt.production && window && window.console && (window.console.log = function() {})
        },
        18846: (et, I, T) => {
            "use strict";
            I._O = I.Jq = I.KB = I.u8 = I.cv = void 0, I.Ik = I.A9 = I.n_ = I.gM = void 0;
            const K = T(39007);

            function q(N) {
                if (!(N instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
            }

            function ne(N) {
                return q(N), K.Buffer.from(N.buffer, N.byteOffset, N.length)
            }
            class S {
                constructor(R, Q) {
                    if (!Number.isInteger(R)) throw new TypeError("span must be an integer");
                    this.span = R, this.property = Q
                }
                makeDestinationObject() {
                    return {}
                }
                getSpan(R, Q) {
                    if (0 > this.span) throw new RangeError("indeterminate span");
                    return this.span
                }
                replicate(R) {
                    const Q = Object.create(this.constructor.prototype);
                    return Object.assign(Q, this), Q.property = R, Q
                }
                fromArray(R) {}
            }

            function j(N, R) {
                return R.property ? N + "[" + R.property + "]" : N
            }
            class z extends S {
                isCount() {
                    throw new Error("ExternalLayout is abstract")
                }
            }
            class Y extends z {
                constructor(R, Q = 0, Ee) {
                    if (!(R instanceof S)) throw new TypeError("layout must be a Layout");
                    if (!Number.isInteger(Q)) throw new TypeError("offset must be integer or undefined");
                    super(R.span, Ee || R.property), this.layout = R, this.offset = Q
                }
                isCount() {
                    return this.layout instanceof Z || this.layout instanceof le
                }
                decode(R, Q = 0) {
                    return this.layout.decode(R, Q + this.offset)
                }
                encode(R, Q, Ee = 0) {
                    return this.layout.encode(R, Q, Ee + this.offset)
                }
            }
            class Z extends S {
                constructor(R, Q) {
                    if (super(R, Q), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(R, Q = 0) {
                    return ne(R).readUIntLE(Q, this.span)
                }
                encode(R, Q, Ee = 0) {
                    return ne(Q).writeUIntLE(R, Ee, this.span), this.span
                }
            }
            class le extends S {
                constructor(R, Q) {
                    if (super(R, Q), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(R, Q = 0) {
                    return ne(R).readUIntBE(Q, this.span)
                }
                encode(R, Q, Ee = 0) {
                    return ne(Q).writeUIntBE(R, Ee, this.span), this.span
                }
            }
            const Se = Math.pow(2, 32);

            function me(N) {
                const R = Math.floor(N / Se);
                return {
                    hi32: R,
                    lo32: N - R * Se
                }
            }

            function Ce(N, R) {
                return N * Se + R
            }
            class we extends S {
                constructor(R) {
                    super(8, R)
                }
                decode(R, Q = 0) {
                    const Ee = ne(R),
                        Fe = Ee.readUInt32LE(Q);
                    return Ce(Ee.readUInt32LE(Q + 4), Fe)
                }
                encode(R, Q, Ee = 0) {
                    const Fe = me(R),
                        Ge = ne(Q);
                    return Ge.writeUInt32LE(Fe.lo32, Ee), Ge.writeUInt32LE(Fe.hi32, Ee + 4), 8
                }
            }
            class De extends S {
                constructor(R) {
                    super(8, R)
                }
                decode(R, Q = 0) {
                    const Ee = ne(R),
                        Fe = Ee.readUInt32LE(Q);
                    return Ce(Ee.readInt32LE(Q + 4), Fe)
                }
                encode(R, Q, Ee = 0) {
                    const Fe = me(R),
                        Ge = ne(Q);
                    return Ge.writeUInt32LE(Fe.lo32, Ee), Ge.writeInt32LE(Fe.hi32, Ee + 4), 8
                }
            }
            class Te extends S {
                constructor(R, Q, Ee) {
                    if (!(R instanceof S)) throw new TypeError("elementLayout must be a Layout");
                    if (!(Q instanceof z && Q.isCount() || Number.isInteger(Q) && 0 <= Q)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                    let Fe = -1;
                    !(Q instanceof z) && 0 < R.span && (Fe = Q * R.span), super(Fe, Ee), this.elementLayout = R, this.count = Q
                }
                getSpan(R, Q = 0) {
                    if (0 <= this.span) return this.span;
                    let Ee = 0,
                        Fe = this.count;
                    if (Fe instanceof z && (Fe = Fe.decode(R, Q)), 0 < this.elementLayout.span) Ee = Fe * this.elementLayout.span;
                    else {
                        let Ge = 0;
                        for (; Ge < Fe;) Ee += this.elementLayout.getSpan(R, Q + Ee), ++Ge
                    }
                    return Ee
                }
                decode(R, Q = 0) {
                    const Ee = [];
                    let Fe = 0,
                        Ge = this.count;
                    for (Ge instanceof z && (Ge = Ge.decode(R, Q)); Fe < Ge;) Ee.push(this.elementLayout.decode(R, Q)), Q += this.elementLayout.getSpan(R, Q), Fe += 1;
                    return Ee
                }
                encode(R, Q, Ee = 0) {
                    const Fe = this.elementLayout,
                        Ge = R.reduce((wt, Vt) => wt + Fe.encode(Vt, Q, Ee + wt), 0);
                    return this.count instanceof z && this.count.encode(R.length, Q, Ee), Ge
                }
            }
            class xe extends S {
                constructor(R, Q, Ee) {
                    if (!Array.isArray(R) || !R.reduce((Ge, wt) => Ge && wt instanceof S, !0)) throw new TypeError("fields must be array of Layout instances");
                    "boolean" == typeof Q && void 0 === Ee && (Ee = Q, Q = void 0);
                    for (const Ge of R)
                        if (0 > Ge.span && void 0 === Ge.property) throw new Error("fields cannot contain unnamed variable-length layout");
                    let Fe = -1;
                    try {
                        Fe = R.reduce((Ge, wt) => Ge + wt.getSpan(), 0)
                    } catch {}
                    super(Fe, Q), this.fields = R, this.decodePrefixes = !!Ee
                }
                getSpan(R, Q = 0) {
                    if (0 <= this.span) return this.span;
                    let Ee = 0;
                    try {
                        Ee = this.fields.reduce((Fe, Ge) => {
                            const wt = Ge.getSpan(R, Q);
                            return Q += wt, Fe + wt
                        }, 0)
                    } catch {
                        throw new RangeError("indeterminate span")
                    }
                    return Ee
                }
                decode(R, Q = 0) {
                    q(R);
                    const Ee = this.makeDestinationObject();
                    for (const Fe of this.fields)
                        if (void 0 !== Fe.property && (Ee[Fe.property] = Fe.decode(R, Q)), Q += Fe.getSpan(R, Q), this.decodePrefixes && R.length === Q) break;
                    return Ee
                }
                encode(R, Q, Ee = 0) {
                    const Fe = Ee;
                    let Ge = 0,
                        wt = 0;
                    for (const Vt of this.fields) {
                        let Mt = Vt.span;
                        if (wt = 0 < Mt ? Mt : 0, void 0 !== Vt.property) {
                            const sn = R[Vt.property];
                            void 0 !== sn && (wt = Vt.encode(sn, Q, Ee), 0 > Mt && (Mt = Vt.getSpan(Q, Ee)))
                        }
                        Ge = Ee, Ee += Mt
                    }
                    return Ge + wt - Fe
                }
                fromArray(R) {
                    const Q = this.makeDestinationObject();
                    for (const Ee of this.fields) void 0 !== Ee.property && 0 < R.length && (Q[Ee.property] = R.shift());
                    return Q
                }
                layoutFor(R) {
                    if ("string" != typeof R) throw new TypeError("property must be string");
                    for (const Q of this.fields)
                        if (Q.property === R) return Q
                }
                offsetOf(R) {
                    if ("string" != typeof R) throw new TypeError("property must be string");
                    let Q = 0;
                    for (const Ee of this.fields) {
                        if (Ee.property === R) return Q;
                        0 > Ee.span ? Q = -1 : 0 <= Q && (Q += Ee.span)
                    }
                }
            }
            class y extends S {
                constructor(R, Q) {
                    if (!(R instanceof z && R.isCount() || Number.isInteger(R) && 0 <= R)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                    let Ee = -1;
                    R instanceof z || (Ee = R), super(Ee, Q), this.length = R
                }
                getSpan(R, Q) {
                    let Ee = this.span;
                    return 0 > Ee && (Ee = this.length.decode(R, Q)), Ee
                }
                decode(R, Q = 0) {
                    let Ee = this.span;
                    return 0 > Ee && (Ee = this.length.decode(R, Q)), ne(R).slice(Q, Q + Ee)
                }
                encode(R, Q, Ee) {
                    let Fe = this.length;
                    if (this.length instanceof z && (Fe = R.length), !(R instanceof Uint8Array && Fe === R.length)) throw new TypeError(j("Blob.encode", this) + " requires (length " + Fe + ") Uint8Array as src");
                    if (Ee + Fe > Q.length) throw new RangeError("encoding overruns Uint8Array");
                    const Ge = ne(R);
                    return ne(Q).write(Ge.toString("hex"), Ee, Fe, "hex"), this.length instanceof z && this.length.encode(Fe, Q, Ee), Fe
                }
            }
            I.cv = (N, R, Q) => new Y(N, R, Q), I.u8 = N => new Z(1, N), I.KB = N => new Z(2, N), I.Jq = N => new Z(4, N), I._O = N => new we(N), I.gM = N => new De(N), I.n_ = (N, R, Q) => new xe(N, R, Q), I.A9 = (N, R, Q) => new Te(N, R, Q), I.Ik = (N, R) => new y(N, R)
        },
        45151: (et, I, T) => {
            "use strict";
            T.r(I), T.d(I, {
                Account: () => M1,
                AddressLookupTableAccount: () => Og,
                AddressLookupTableInstruction: () => aC,
                AddressLookupTableProgram: () => fv,
                Authorized: () => jd,
                BLOCKHASH_CACHE_TIMEOUT_MS: () => Mp,
                BPF_LOADER_DEPRECATED_PROGRAM_ID: () => I1,
                BPF_LOADER_PROGRAM_ID: () => V1,
                BpfLoader: () => It,
                COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => dl,
                ComputeBudgetInstruction: () => cC,
                ComputeBudgetProgram: () => $o,
                Connection: () => hv,
                Ed25519Program: () => Up,
                Enum: () => L_,
                EpochSchedule: () => $_,
                FeeCalculatorLayout: () => mi,
                Keypair: () => ul,
                LAMPORTS_PER_SOL: () => UI,
                LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => va,
                Loader: () => Ig,
                Lockup: () => sf,
                MAX_SEED_LENGTH: () => Su,
                Message: () => lc,
                MessageAccountKeys: () => wp,
                MessageV0: () => Vl,
                NONCE_ACCOUNT_LENGTH: () => U_,
                NonceAccount: () => Dp,
                PACKET_DATA_SIZE: () => Eu,
                PUBLIC_KEY_LENGTH: () => ac,
                PublicKey: () => ln,
                SIGNATURE_LENGTH_IN_BYTES: () => Du,
                SOLANA_SCHEMA: () => Nl,
                STAKE_CONFIG_ID: () => gv,
                STAKE_INSTRUCTION_LAYOUTS: () => Os,
                SYSTEM_INSTRUCTION_LAYOUTS: () => qr,
                SYSVAR_CLOCK_PUBKEY: () => Bc,
                SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => V_,
                SYSVAR_INSTRUCTIONS_PUBKEY: () => kd,
                SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => So,
                SYSVAR_RENT_PUBKEY: () => Md,
                SYSVAR_REWARDS_PUBKEY: () => R1,
                SYSVAR_SLOT_HASHES_PUBKEY: () => B1,
                SYSVAR_SLOT_HISTORY_PUBKEY: () => Ul,
                SYSVAR_STAKE_HISTORY_PUBKEY: () => Kh,
                Secp256k1Program: () => zd,
                SendTransactionError: () => z_,
                SolanaJSONRPCError: () => wn,
                SolanaJSONRPCErrorCode: () => j_,
                StakeAuthorizationLayout: () => Hp,
                StakeInstruction: () => yv,
                StakeProgram: () => af,
                Struct: () => bp,
                SystemInstruction: () => Id,
                SystemProgram: () => ro,
                Transaction: () => Fi,
                TransactionExpiredBlockheightExceededError: () => Eg,
                TransactionExpiredNonceInvalidError: () => Gh,
                TransactionExpiredTimeoutError: () => Wh,
                TransactionInstruction: () => Hr,
                TransactionMessage: () => Tp,
                TransactionStatus: () => al,
                VALIDATOR_INFO_KEY: () => fC,
                VERSION_PREFIX_MASK: () => jh,
                VOTE_PROGRAM_ID: () => FI,
                ValidatorInfo: () => Zg,
                VersionedMessage: () => Cp,
                VersionedTransaction: () => Sp,
                VoteAccount: () => Yg,
                VoteAuthorizationLayout: () => cf,
                VoteInit: () => _v,
                VoteInstruction: () => hC,
                VoteProgram: () => Wd,
                clusterApiUrl: () => xv,
                sendAndConfirmRawTransaction: () => VI,
                sendAndConfirmTransaction: () => kg
            });
            var F = {};
            T.r(F), T.d(F, {
                gk: () => Mt,
                dQ: () => Qe,
                ci: () => ei,
                bytesToNumberBE: () => ji,
                ty: () => Wn,
                eV: () => Ii,
                n$: () => Kn,
                ql: () => en,
                hexToBytes: () => Mi,
                _t: () => Vt,
                tL: () => kn,
                S5: () => Bi,
                FF: () => $n
            });
            var K = T(15861),
                q = T(39007),
                ne = T(58165);
            const S = BigInt(2 ** 32 - 1),
                j = BigInt(32);

            function C(g, l = !1) {
                return l ? {
                    h: Number(g & S),
                    l: Number(g >> j & S)
                } : {
                    h: 0 | Number(g >> j & S),
                    l: 0 | Number(g & S)
                }
            }

            function z(g, l = !1) {
                let d = new Uint32Array(g.length),
                    p = new Uint32Array(g.length);
                for (let _ = 0; _ < g.length; _++) {
                    const {
                        h: k,
                        l: B
                    } = C(g[_], l);
                    [d[_], p[_]] = [k, B]
                }
                return [d, p]
            }
            const we = (g, l, d) => g << d | l >>> 32 - d,
                ve = (g, l, d) => l << d | g >>> 32 - d,
                De = (g, l, d) => l << d - 32 | g >>> 64 - d,
                ae = (g, l, d) => g << d - 32 | l >>> 64 - d,
                $ = {
                    fromBig: C,
                    split: z,
                    toBig: (g, l) => BigInt(g >>> 0) << j | BigInt(l >>> 0),
                    shrSH: (g, l, d) => g >>> d,
                    shrSL: (g, l, d) => g << 32 - d | l >>> d,
                    rotrSH: (g, l, d) => g >>> d | l << 32 - d,
                    rotrSL: (g, l, d) => g << 32 - d | l >>> d,
                    rotrBH: (g, l, d) => g << 64 - d | l >>> d - 32,
                    rotrBL: (g, l, d) => g >>> d - 32 | l << 64 - d,
                    rotr32H: (g, l) => l,
                    rotr32L: (g, l) => g,
                    rotlSH: we,
                    rotlSL: ve,
                    rotlBH: De,
                    rotlBL: ae,
                    add: function Me(g, l, d, p) {
                        const _ = (l >>> 0) + (p >>> 0);
                        return {
                            h: g + d + (_ / 2 ** 32 | 0) | 0,
                            l: 0 | _
                        }
                    },
                    add3L: (g, l, d) => (g >>> 0) + (l >>> 0) + (d >>> 0),
                    add3H: (g, l, d, p) => l + d + p + (g / 2 ** 32 | 0) | 0,
                    add4L: (g, l, d, p) => (g >>> 0) + (l >>> 0) + (d >>> 0) + (p >>> 0),
                    add4H: (g, l, d, p, _) => l + d + p + _ + (g / 2 ** 32 | 0) | 0,
                    add5H: (g, l, d, p, _, k) => l + d + p + _ + k + (g / 2 ** 32 | 0) | 0,
                    add5L: (g, l, d, p, _) => (g >>> 0) + (l >>> 0) + (d >>> 0) + (p >>> 0) + (_ >>> 0)
                };
            var f = T(40512);
            const [v, M] = (() => $.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(g => BigInt(g))))(), U = new Uint32Array(80), G = new Uint32Array(80);
            class y extends ne.VR {
                constructor() {
                    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                }
                get() {
                    const {
                        Ah: l,
                        Al: d,
                        Bh: p,
                        Bl: _,
                        Ch: k,
                        Cl: B,
                        Dh: se,
                        Dl: fe,
                        Eh: Pe,
                        El: Ne,
                        Fh: Je,
                        Fl: yt,
                        Gh: bt,
                        Gl: dt,
                        Hh: qe,
                        Hl: it
                    } = this;
                    return [l, d, p, _, k, B, se, fe, Pe, Ne, Je, yt, bt, dt, qe, it]
                }
                set(l, d, p, _, k, B, se, fe, Pe, Ne, Je, yt, bt, dt, qe, it) {
                    this.Ah = 0 | l, this.Al = 0 | d, this.Bh = 0 | p, this.Bl = 0 | _, this.Ch = 0 | k, this.Cl = 0 | B, this.Dh = 0 | se, this.Dl = 0 | fe, this.Eh = 0 | Pe, this.El = 0 | Ne, this.Fh = 0 | Je, this.Fl = 0 | yt, this.Gh = 0 | bt, this.Gl = 0 | dt, this.Hh = 0 | qe, this.Hl = 0 | it
                }
                process(l, d) {
                    for (let Bt = 0; Bt < 16; Bt++, d += 4) U[Bt] = l.getUint32(d), G[Bt] = l.getUint32(d += 4);
                    for (let Bt = 16; Bt < 80; Bt++) {
                        const pn = 0 | U[Bt - 15],
                            rn = 0 | G[Bt - 15],
                            Tn = $.rotrSH(pn, rn, 1) ^ $.rotrSH(pn, rn, 8) ^ $.shrSH(pn, rn, 7),
                            si = $.rotrSL(pn, rn, 1) ^ $.rotrSL(pn, rn, 8) ^ $.shrSL(pn, rn, 7),
                            Qn = 0 | U[Bt - 2],
                            Fr = 0 | G[Bt - 2],
                            pr = $.rotrSH(Qn, Fr, 19) ^ $.rotrBH(Qn, Fr, 61) ^ $.shrSH(Qn, Fr, 6),
                            Vi = $.rotrSL(Qn, Fr, 19) ^ $.rotrBL(Qn, Fr, 61) ^ $.shrSL(Qn, Fr, 6),
                            Ls = $.add4L(si, Vi, G[Bt - 7], G[Bt - 16]),
                            Ts = $.add4H(Ls, Tn, pr, U[Bt - 7], U[Bt - 16]);
                        U[Bt] = 0 | Ts, G[Bt] = 0 | Ls
                    }
                    let {
                        Ah: p,
                        Al: _,
                        Bh: k,
                        Bl: B,
                        Ch: se,
                        Cl: fe,
                        Dh: Pe,
                        Dl: Ne,
                        Eh: Je,
                        El: yt,
                        Fh: bt,
                        Fl: dt,
                        Gh: qe,
                        Gl: it,
                        Hh: ft,
                        Hl: Pt
                    } = this;
                    for (let Bt = 0; Bt < 80; Bt++) {
                        const pn = $.rotrSH(Je, yt, 14) ^ $.rotrSH(Je, yt, 18) ^ $.rotrBH(Je, yt, 41),
                            rn = $.rotrSL(Je, yt, 14) ^ $.rotrSL(Je, yt, 18) ^ $.rotrBL(Je, yt, 41),
                            Tn = Je & bt ^ ~Je & qe,
                            Qn = $.add5L(Pt, rn, yt & dt ^ ~yt & it, M[Bt], G[Bt]),
                            Fr = $.add5H(Qn, ft, pn, Tn, v[Bt], U[Bt]),
                            pr = 0 | Qn,
                            Vi = $.rotrSH(p, _, 28) ^ $.rotrBH(p, _, 34) ^ $.rotrBH(p, _, 39),
                            Ls = $.rotrSL(p, _, 28) ^ $.rotrBL(p, _, 34) ^ $.rotrBL(p, _, 39),
                            Ts = p & k ^ p & se ^ k & se,
                            za = _ & B ^ _ & fe ^ B & fe;
                        ft = 0 | qe, Pt = 0 | it, qe = 0 | bt, it = 0 | dt, bt = 0 | Je, dt = 0 | yt, ({
                            h: Je,
                            l: yt
                        } = $.add(0 | Pe, 0 | Ne, 0 | Fr, 0 | pr)), Pe = 0 | se, Ne = 0 | fe, se = 0 | k, fe = 0 | B, k = 0 | p, B = 0 | _;
                        const hn = $.add3L(pr, Ls, za);
                        p = $.add3H(hn, Fr, Vi, Ts), _ = 0 | hn
                    }({
                        h: p,
                        l: _
                    } = $.add(0 | this.Ah, 0 | this.Al, 0 | p, 0 | _)), ({
                        h: k,
                        l: B
                    } = $.add(0 | this.Bh, 0 | this.Bl, 0 | k, 0 | B)), ({
                        h: se,
                        l: fe
                    } = $.add(0 | this.Ch, 0 | this.Cl, 0 | se, 0 | fe)), ({
                        h: Pe,
                        l: Ne
                    } = $.add(0 | this.Dh, 0 | this.Dl, 0 | Pe, 0 | Ne)), ({
                        h: Je,
                        l: yt
                    } = $.add(0 | this.Eh, 0 | this.El, 0 | Je, 0 | yt)), ({
                        h: bt,
                        l: dt
                    } = $.add(0 | this.Fh, 0 | this.Fl, 0 | bt, 0 | dt)), ({
                        h: qe,
                        l: it
                    } = $.add(0 | this.Gh, 0 | this.Gl, 0 | qe, 0 | it)), ({
                        h: ft,
                        l: Pt
                    } = $.add(0 | this.Hh, 0 | this.Hl, 0 | ft, 0 | Pt)), this.set(p, _, k, B, se, fe, Pe, Ne, Je, yt, bt, dt, qe, it, ft, Pt)
                }
                roundClean() {
                    U.fill(0), G.fill(0)
                }
                destroy() {
                    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                }
            }
            const N = (0, f.hE)(() => new y),
                Ge = (BigInt(0), BigInt(1)),
                wt = BigInt(2);

            function Vt(g) {
                return g instanceof Uint8Array || null != g && "object" == typeof g && "Uint8Array" === g.constructor.name
            }

            function Mt(g) {
                if (!Vt(g)) throw new Error("Uint8Array expected")
            }
            const sn = Array.from({
                length: 256
            }, (g, l) => l.toString(16).padStart(2, "0"));

            function ei(g) {
                Mt(g);
                let l = "";
                for (let d = 0; d < g.length; d++) l += sn[g[d]];
                return l
            }

            function jn(g) {
                if ("string" != typeof g) throw new Error("hex string expected, got " + typeof g);
                return BigInt("" === g ? "0" : `0x${g}`)
            }
            const An = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };

            function ui(g) {
                return g >= An._0 && g <= An._9 ? g - An._0 : g >= An._A && g <= An._F ? g - (An._A - 10) : g >= An._a && g <= An._f ? g - (An._a - 10) : void 0
            }

            function Mi(g) {
                if ("string" != typeof g) throw new Error("hex string expected, got " + typeof g);
                const l = g.length,
                    d = l / 2;
                if (l % 2) throw new Error("padded hex string expected, got unpadded hex of length " + l);
                const p = new Uint8Array(d);
                for (let _ = 0, k = 0; _ < d; _++, k += 2) {
                    const B = ui(g.charCodeAt(k)),
                        se = ui(g.charCodeAt(k + 1));
                    if (void 0 === B || void 0 === se) throw new Error('hex string expected, got non-hex character "' + (g[k] + g[k + 1]) + '" at index ' + k);
                    p[_] = 16 * B + se
                }
                return p
            }

            function ji(g) {
                return jn(ei(g))
            }

            function Wn(g) {
                return Mt(g), jn(ei(Uint8Array.from(g).reverse()))
            }

            function kn(g, l) {
                return Mi(g.toString(16).padStart(2 * l, "0"))
            }

            function Bi(g, l) {
                return kn(g, l).reverse()
            }

            function en(g, l, d) {
                let p;
                if ("string" == typeof l) try {
                    p = Mi(l)
                } catch (k) {
                    throw new Error(`${g} must be valid hex string, got "${l}". Cause: ${k}`)
                } else {
                    if (!Vt(l)) throw new Error(`${g} must be hex string or Uint8Array`);
                    p = Uint8Array.from(l)
                }
                const _ = p.length;
                if ("number" == typeof d && _ !== d) throw new Error(`${g} expected ${d} bytes, got ${_}`);
                return p
            }

            function Ii(...g) {
                let l = 0;
                for (let p = 0; p < g.length; p++) {
                    const _ = g[p];
                    Mt(_), l += _.length
                }
                const d = new Uint8Array(l);
                for (let p = 0, _ = 0; p < g.length; p++) {
                    const k = g[p];
                    d.set(k, _), _ += k.length
                }
                return d
            }
            const Qe = g => (wt << BigInt(g - 1)) - Ge,
                st = g => new Uint8Array(g),
                tn = g => Uint8Array.from(g);

            function Kn(g, l, d) {
                if ("number" != typeof g || g < 2) throw new Error("hashLen must be a number");
                if ("number" != typeof l || l < 2) throw new Error("qByteLen must be a number");
                if ("function" != typeof d) throw new Error("hmacFn must be a function");
                let p = st(g),
                    _ = st(g),
                    k = 0;
                const B = () => {
                        p.fill(1), _.fill(0), k = 0
                    },
                    se = (...Je) => d(_, p, ...Je),
                    fe = (Je = st()) => {
                        _ = se(tn([0]), Je), p = se(), 0 !== Je.length && (_ = se(tn([1]), Je), p = se())
                    },
                    Pe = () => {
                        if (k++ >= 1e3) throw new Error("drbg: tried 1000 values");
                        let Je = 0;
                        const yt = [];
                        for (; Je < l;) {
                            p = se();
                            const bt = p.slice();
                            yt.push(bt), Je += p.length
                        }
                        return Ii(...yt)
                    };
                return (Je, yt) => {
                    let bt;
                    for (B(), fe(Je); !(bt = yt(Pe()));) fe();
                    return B(), bt
                }
            }
            const mn = {
                bigint: g => "bigint" == typeof g,
                function: g => "function" == typeof g,
                boolean: g => "boolean" == typeof g,
                string: g => "string" == typeof g,
                stringOrUint8Array: g => "string" == typeof g || Vt(g),
                isSafeInteger: g => Number.isSafeInteger(g),
                array: g => Array.isArray(g),
                field: (g, l) => l.Fp.isValid(g),
                hash: g => "function" == typeof g && Number.isSafeInteger(g.outputLen)
            };

            function $n(g, l, d = {}) {
                const p = (_, k, B) => {
                    const se = mn[k];
                    if ("function" != typeof se) throw new Error(`Invalid validator "${k}", expected function`);
                    const fe = g[_];
                    if (!(B && void 0 === fe || se(fe, g))) throw new Error(`Invalid param ${String(_)}=${fe} (${typeof fe}), expected ${k}`)
                };
                for (const [_, k] of Object.entries(l)) p(_, k, !1);
                for (const [_, k] of Object.entries(d)) p(_, k, !0);
                return g
            }
            const _n = BigInt(0),
                Sn = BigInt(1),
                pi = BigInt(2),
                ca = BigInt(3),
                yi = BigInt(4),
                hr = BigInt(5),
                qo = BigInt(8);

            function Ti(g, l) {
                const d = g % l;
                return d >= _n ? d : l + d
            }

            function Ji(g, l, d) {
                if (d <= _n || l < _n) throw new Error("Expected power/modulo > 0");
                if (d === Sn) return _n;
                let p = Sn;
                for (; l > _n;) l & Sn && (p = p * g % d), g = g * g % d, l >>= Sn;
                return p
            }

            function gn(g, l, d) {
                let p = g;
                for (; l-- > _n;) p *= p, p %= d;
                return p
            }

            function Si(g, l) {
                if (g === _n || l <= _n) throw new Error(`invert: expected positive integers, got n=${g} mod=${l}`);
                let d = Ti(g, l),
                    p = l,
                    _ = _n,
                    k = Sn,
                    B = Sn,
                    se = _n;
                for (; d !== _n;) {
                    const Pe = p / d,
                        Ne = p % d,
                        Je = _ - B * Pe,
                        yt = k - se * Pe;
                    p = d, d = Ne, _ = B, k = se, B = Je, se = yt
                }
                if (p !== Sn) throw new Error("invert: does not exist");
                return Ti(_, l)
            }
            BigInt(9), BigInt(16);
            const pt = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function ti(g, l) {
                const d = void 0 !== l ? l : g.toString(2).length;
                return {
                    nBitLength: d,
                    nByteLength: Math.ceil(d / 8)
                }
            }

            function qi(g, l, d = !1, p = {}) {
                if (g <= _n) throw new Error(`Expected Field ORDER > 0, got ${g}`);
                const {
                    nBitLength: _,
                    nByteLength: k
                } = ti(g, l);
                if (k > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const B = function Ve(g) {
                        if (g % yi === ca) {
                            const l = (g + Sn) / yi;
                            return function(p, _) {
                                const k = p.pow(_, l);
                                if (!p.eql(p.sqr(k), _)) throw new Error("Cannot find square root");
                                return k
                            }
                        }
                        if (g % qo === hr) {
                            const l = (g - hr) / qo;
                            return function(p, _) {
                                const k = p.mul(_, pi),
                                    B = p.pow(k, l),
                                    se = p.mul(_, B),
                                    fe = p.mul(p.mul(se, pi), B),
                                    Pe = p.mul(se, p.sub(fe, p.ONE));
                                if (!p.eql(p.sqr(Pe), _)) throw new Error("Cannot find square root");
                                return Pe
                            }
                        }
                        return function qn(g) {
                            const l = (g - Sn) / pi;
                            let d, p, _;
                            for (d = g - Sn, p = 0; d % pi === _n; d /= pi, p++);
                            for (_ = pi; _ < g && Ji(_, l, g) !== g - Sn; _++);
                            if (1 === p) {
                                const B = (g + Sn) / yi;
                                return function(fe, Pe) {
                                    const Ne = fe.pow(Pe, B);
                                    if (!fe.eql(fe.sqr(Ne), Pe)) throw new Error("Cannot find square root");
                                    return Ne
                                }
                            }
                            const k = (d + Sn) / pi;
                            return function(se, fe) {
                                if (se.pow(fe, l) === se.neg(se.ONE)) throw new Error("Cannot find square root");
                                let Pe = p,
                                    Ne = se.pow(se.mul(se.ONE, _), d),
                                    Je = se.pow(fe, k),
                                    yt = se.pow(fe, d);
                                for (; !se.eql(yt, se.ONE);) {
                                    if (se.eql(yt, se.ZERO)) return se.ZERO;
                                    let bt = 1;
                                    for (let qe = se.sqr(yt); bt < Pe && !se.eql(qe, se.ONE); bt++) qe = se.sqr(qe);
                                    const dt = se.pow(Ne, Sn << BigInt(Pe - bt - 1));
                                    Ne = se.sqr(dt), Je = se.mul(Je, dt), yt = se.mul(yt, Ne), Pe = bt
                                }
                                return Je
                            }
                        }(g)
                    }(g),
                    se = Object.freeze({
                        ORDER: g,
                        BITS: _,
                        BYTES: k,
                        MASK: Qe(_),
                        ZERO: _n,
                        ONE: Sn,
                        create: fe => Ti(fe, g),
                        isValid: fe => {
                            if ("bigint" != typeof fe) throw new Error("Invalid field element: expected bigint, got " + typeof fe);
                            return _n <= fe && fe < g
                        },
                        is0: fe => fe === _n,
                        isOdd: fe => (fe & Sn) === Sn,
                        neg: fe => Ti(-fe, g),
                        eql: (fe, Pe) => fe === Pe,
                        sqr: fe => Ti(fe * fe, g),
                        add: (fe, Pe) => Ti(fe + Pe, g),
                        sub: (fe, Pe) => Ti(fe - Pe, g),
                        mul: (fe, Pe) => Ti(fe * Pe, g),
                        pow: (fe, Pe) => function Bn(g, l, d) {
                            if (d < _n) throw new Error("Expected power > 0");
                            if (d === _n) return g.ONE;
                            if (d === Sn) return l;
                            let p = g.ONE,
                                _ = l;
                            for (; d > _n;) d & Sn && (p = g.mul(p, _)), _ = g.sqr(_), d >>= Sn;
                            return p
                        }(se, fe, Pe),
                        div: (fe, Pe) => Ti(fe * Si(Pe, g), g),
                        sqrN: fe => fe * fe,
                        addN: (fe, Pe) => fe + Pe,
                        subN: (fe, Pe) => fe - Pe,
                        mulN: (fe, Pe) => fe * Pe,
                        inv: fe => Si(fe, g),
                        sqrt: p.sqrt || (fe => B(se, fe)),
                        invertBatch: fe => function Nn(g, l) {
                            const d = new Array(l.length),
                                p = l.reduce((k, B, se) => g.is0(B) ? k : (d[se] = k, g.mul(k, B)), g.ONE),
                                _ = g.inv(p);
                            return l.reduceRight((k, B, se) => g.is0(B) ? k : (d[se] = g.mul(k, d[se]), g.mul(k, B)), _), d
                        }(se, fe),
                        cmov: (fe, Pe, Ne) => Ne ? Pe : fe,
                        toBytes: fe => d ? Bi(fe, k) : kn(fe, k),
                        fromBytes: fe => {
                            if (fe.length !== k) throw new Error(`Fp.fromBytes: expected ${k}, got ${fe.length}`);
                            return d ? Wn(fe) : ji(fe)
                        }
                    });
                return Object.freeze(se)
            }

            function As(g) {
                if ("bigint" != typeof g) throw new Error("field order must be bigint");
                const l = g.toString(2).length;
                return Math.ceil(l / 8)
            }

            function wo(g) {
                const l = As(g);
                return l + Math.ceil(l / 2)
            }
            const Wr = BigInt(0),
                mt = BigInt(1);

            function xo(g, l) {
                const d = (_, k) => {
                        const B = k.negate();
                        return _ ? B : k
                    },
                    p = _ => ({
                        windows: Math.ceil(l / _) + 1,
                        windowSize: 2 ** (_ - 1)
                    });
                return {
                    constTimeNegate: d,
                    unsafeLadder(_, k) {
                        let B = g.ZERO,
                            se = _;
                        for (; k > Wr;) k & mt && (B = B.add(se)), se = se.double(), k >>= mt;
                        return B
                    },
                    precomputeWindow(_, k) {
                        const {
                            windows: B,
                            windowSize: se
                        } = p(k), fe = [];
                        let Pe = _,
                            Ne = Pe;
                        for (let Je = 0; Je < B; Je++) {
                            Ne = Pe, fe.push(Ne);
                            for (let yt = 1; yt < se; yt++) Ne = Ne.add(Pe), fe.push(Ne);
                            Pe = Ne.double()
                        }
                        return fe
                    },
                    wNAF(_, k, B) {
                        const {
                            windows: se,
                            windowSize: fe
                        } = p(_);
                        let Pe = g.ZERO,
                            Ne = g.BASE;
                        const Je = BigInt(2 ** _ - 1),
                            yt = 2 ** _,
                            bt = BigInt(_);
                        for (let dt = 0; dt < se; dt++) {
                            const qe = dt * fe;
                            let it = Number(B & Je);
                            B >>= bt, it > fe && (it -= yt, B += mt);
                            const ft = qe,
                                Pt = qe + Math.abs(it) - 1,
                                pn = it < 0;
                            0 === it ? Ne = Ne.add(d(dt % 2 != 0, k[ft])) : Pe = Pe.add(d(pn, k[Pt]))
                        }
                        return {
                            p: Pe,
                            f: Ne
                        }
                    },
                    wNAFCached(_, k, B, se) {
                        const fe = _._WINDOW_SIZE || 1;
                        let Pe = k.get(_);
                        return Pe || (Pe = this.precomputeWindow(_, fe), 1 !== fe && k.set(_, se(Pe))), this.wNAF(fe, Pe, B)
                    }
                }
            }

            function Zn(g) {
                return function St(g) {
                    $n(g, pt.reduce((p, _) => (p[_] = "function", p), {
                        ORDER: "bigint",
                        MASK: "bigint",
                        BYTES: "isSafeInteger",
                        BITS: "isSafeInteger"
                    }))
                }(g.Fp), $n(g, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({ ...ti(g.n, g.nBitLength),
                    ...g,
                    p: g.Fp.ORDER
                })
            }
            const di = BigInt(0),
                Nr = BigInt(1),
                la = BigInt(2),
                ua = BigInt(8),
                Qs = {
                    zip215: !0
                };

            function ao(g) {
                const l = function Ir(g) {
                        const l = Zn(g);
                        return $n(g, {
                            hash: "function",
                            a: "bigint",
                            d: "bigint",
                            randomBytes: "function"
                        }, {
                            adjustScalarBytes: "function",
                            domain: "function",
                            uvRatio: "function",
                            mapToCurve: "function"
                        }), Object.freeze({ ...l
                        })
                    }(g),
                    {
                        Fp: d,
                        n: p,
                        prehash: _,
                        hash: k,
                        randomBytes: B,
                        nByteLength: se,
                        h: fe
                    } = l,
                    Pe = la << BigInt(8 * se) - Nr,
                    Ne = d.create,
                    Je = l.uvRatio || ((Yt, Lt) => {
                        try {
                            return {
                                isValid: !0,
                                value: d.sqrt(Yt * d.inv(Lt))
                            }
                        } catch {
                            return {
                                isValid: !1,
                                value: di
                            }
                        }
                    }),
                    yt = l.adjustScalarBytes || (Yt => Yt),
                    bt = l.domain || ((Yt, Lt, In) => {
                        if (Lt.length || In) throw new Error("Contexts/pre-hash are not supported");
                        return Yt
                    }),
                    dt = Yt => "bigint" == typeof Yt && di < Yt,
                    qe = (Yt, Lt) => dt(Yt) && dt(Lt) && Yt < Lt,
                    it = Yt => Yt === di || qe(Yt, Pe);

                function ft(Yt, Lt) {
                    if (qe(Yt, Lt)) return Yt;
                    throw new Error(`Expected valid scalar < ${Lt}, got ${typeof Yt} ${Yt}`)
                }

                function Pt(Yt) {
                    return Yt === di ? Yt : ft(Yt, p)
                }
                const Bt = new Map;

                function pn(Yt) {
                    if (!(Yt instanceof rn)) throw new Error("ExtendedPoint expected")
                }
                class rn {
                    constructor(Lt, In, Jn, Gn) {
                        if (this.ex = Lt, this.ey = In, this.ez = Jn, this.et = Gn, !it(Lt)) throw new Error("x required");
                        if (!it(In)) throw new Error("y required");
                        if (!it(Jn)) throw new Error("z required");
                        if (!it(Gn)) throw new Error("t required")
                    }
                    get x() {
                        return this.toAffine().x
                    }
                    get y() {
                        return this.toAffine().y
                    }
                    static fromAffine(Lt) {
                        if (Lt instanceof rn) throw new Error("extended point not allowed");
                        const {
                            x: In,
                            y: Jn
                        } = Lt || {};
                        if (!it(In) || !it(Jn)) throw new Error("invalid affine point");
                        return new rn(In, Jn, Nr, Ne(In * Jn))
                    }
                    static normalizeZ(Lt) {
                        const In = d.invertBatch(Lt.map(Jn => Jn.ez));
                        return Lt.map((Jn, Gn) => Jn.toAffine(In[Gn])).map(rn.fromAffine)
                    }
                    _setWindowSize(Lt) {
                        this._WINDOW_SIZE = Lt, Bt.delete(this)
                    }
                    assertValidity() {
                        const {
                            a: Lt,
                            d: In
                        } = l;
                        if (this.is0()) throw new Error("bad point: ZERO");
                        const {
                            ex: Jn,
                            ey: Gn,
                            ez: Ai,
                            et: Gi
                        } = this, br = Ne(Jn * Jn), dr = Ne(Gn * Gn), mr = Ne(Ai * Ai), Rs = Ne(mr * mr), hs = Ne(br * Lt);
                        if (Ne(mr * Ne(hs + dr)) !== Ne(Rs + Ne(In * Ne(br * dr)))) throw new Error("bad point: equation left != right (1)");
                        if (Ne(Jn * Gn) !== Ne(Ai * Gi)) throw new Error("bad point: equation left != right (2)")
                    }
                    equals(Lt) {
                        pn(Lt);
                        const {
                            ex: In,
                            ey: Jn,
                            ez: Gn
                        } = this, {
                            ex: Ai,
                            ey: Gi,
                            ez: br
                        } = Lt, dr = Ne(In * br), mr = Ne(Ai * Gn), Rs = Ne(Jn * br), hs = Ne(Gi * Gn);
                        return dr === mr && Rs === hs
                    }
                    is0() {
                        return this.equals(rn.ZERO)
                    }
                    negate() {
                        return new rn(Ne(-this.ex), this.ey, this.ez, Ne(-this.et))
                    }
                    double() {
                        const {
                            a: Lt
                        } = l, {
                            ex: In,
                            ey: Jn,
                            ez: Gn
                        } = this, Ai = Ne(In * In), Gi = Ne(Jn * Jn), br = Ne(la * Ne(Gn * Gn)), dr = Ne(Lt * Ai), mr = In + Jn, Rs = Ne(Ne(mr * mr) - Ai - Gi), hs = dr + Gi, ho = hs - br, so = dr - Gi, Gs = Ne(Rs * ho), Eo = Ne(hs * so), dc = Ne(Rs * so), hl = Ne(ho * hs);
                        return new rn(Gs, Eo, hl, dc)
                    }
                    add(Lt) {
                        pn(Lt);
                        const {
                            a: In,
                            d: Jn
                        } = l, {
                            ex: Gn,
                            ey: Ai,
                            ez: Gi,
                            et: br
                        } = this, {
                            ex: dr,
                            ey: mr,
                            ez: Rs,
                            et: hs
                        } = Lt;
                        if (In === BigInt(-1)) {
                            const Xg = Ne((Ai - Gn) * (mr + dr)),
                                Iu = Ne((Ai + Gn) * (mr - dr)),
                                Kd = Ne(Iu - Xg);
                            if (Kd === di) return this.double();
                            const Qg = Ne(Gi * la * hs),
                                zp = Ne(br * la * Rs),
                                df = zp + Qg,
                                Sv = Iu + Xg,
                                Ev = zp - Qg,
                                _C = Ne(df * Kd),
                                vC = Ne(Sv * Ev),
                                bC = Ne(df * Ev),
                                wC = Ne(Kd * Sv);
                            return new rn(_C, vC, wC, bC)
                        }
                        const ho = Ne(Gn * dr),
                            so = Ne(Ai * mr),
                            Gs = Ne(br * Jn * hs),
                            Eo = Ne(Gi * Rs),
                            dc = Ne((Gn + Ai) * (dr + mr) - ho - so),
                            hl = Eo - Gs,
                            uf = Eo + Gs,
                            Gd = Ne(so - In * ho),
                            gC = Ne(dc * hl),
                            yC = Ne(uf * Gd),
                            Cv = Ne(dc * Gd),
                            Tv = Ne(hl * uf);
                        return new rn(gC, yC, Tv, Cv)
                    }
                    subtract(Lt) {
                        return this.add(Lt.negate())
                    }
                    wNAF(Lt) {
                        return Qn.wNAFCached(this, Bt, Lt, rn.normalizeZ)
                    }
                    multiply(Lt) {
                        const {
                            p: In,
                            f: Jn
                        } = this.wNAF(ft(Lt, p));
                        return rn.normalizeZ([In, Jn])[0]
                    }
                    multiplyUnsafe(Lt) {
                        let In = Pt(Lt);
                        return In === di ? si : this.equals(si) || In === Nr ? this : this.equals(Tn) ? this.wNAF(In).p : Qn.unsafeLadder(this, In)
                    }
                    isSmallOrder() {
                        return this.multiplyUnsafe(fe).is0()
                    }
                    isTorsionFree() {
                        return Qn.unsafeLadder(this, p).is0()
                    }
                    toAffine(Lt) {
                        const {
                            ex: In,
                            ey: Jn,
                            ez: Gn
                        } = this, Ai = this.is0();
                        null == Lt && (Lt = Ai ? ua : d.inv(Gn));
                        const Gi = Ne(In * Lt),
                            br = Ne(Jn * Lt),
                            dr = Ne(Gn * Lt);
                        if (Ai) return {
                            x: di,
                            y: Nr
                        };
                        if (dr !== Nr) throw new Error("invZ was invalid");
                        return {
                            x: Gi,
                            y: br
                        }
                    }
                    clearCofactor() {
                        const {
                            h: Lt
                        } = l;
                        return Lt === Nr ? this : this.multiplyUnsafe(Lt)
                    }
                    static fromHex(Lt, In = !1) {
                        const {
                            d: Jn,
                            a: Gn
                        } = l, Ai = d.BYTES, Gi = (Lt = en("pointHex", Lt, Ai)).slice(), br = Lt[Ai - 1];
                        Gi[Ai - 1] = -129 & br;
                        const dr = Wn(Gi);
                        dr === di || ft(dr, In ? Pe : d.ORDER);
                        const mr = Ne(dr * dr),
                            Rs = Ne(mr - Nr),
                            hs = Ne(Jn * mr - Gn);
                        let {
                            isValid: ho,
                            value: so
                        } = Je(Rs, hs);
                        if (!ho) throw new Error("Point.fromHex: invalid y coordinate");
                        const Gs = (so & Nr) === Nr,
                            Eo = 0 != (128 & br);
                        if (!In && so === di && Eo) throw new Error("Point.fromHex: x=0 and x_0=1");
                        return Eo !== Gs && (so = Ne(-so)), rn.fromAffine({
                            x: so,
                            y: dr
                        })
                    }
                    static fromPrivateKey(Lt) {
                        return Vi(Lt).point
                    }
                    toRawBytes() {
                        const {
                            x: Lt,
                            y: In
                        } = this.toAffine(), Jn = Bi(In, d.BYTES);
                        return Jn[Jn.length - 1] |= Lt & Nr ? 128 : 0, Jn
                    }
                    toHex() {
                        return ei(this.toRawBytes())
                    }
                }
                rn.BASE = new rn(l.Gx, l.Gy, Nr, Ne(l.Gx * l.Gy)), rn.ZERO = new rn(di, Nr, Nr, di);
                const {
                    BASE: Tn,
                    ZERO: si
                } = rn, Qn = xo(rn, 8 * se);

                function Fr(Yt) {
                    return Ti(Yt, p)
                }

                function pr(Yt) {
                    return Fr(Wn(Yt))
                }

                function Vi(Yt) {
                    const Lt = se;
                    Yt = en("private key", Yt, Lt);
                    const In = en("hashed private key", k(Yt), 2 * Lt),
                        Jn = yt(In.slice(0, Lt)),
                        Gn = In.slice(Lt, 2 * Lt),
                        Ai = pr(Jn),
                        Gi = Tn.multiply(Ai),
                        br = Gi.toRawBytes();
                    return {
                        head: Jn,
                        prefix: Gn,
                        scalar: Ai,
                        point: Gi,
                        pointBytes: br
                    }
                }

                function Ts(Yt = new Uint8Array, ...Lt) {
                    const In = Ii(...Lt);
                    return pr(k(bt(In, en("context", Yt), !!_)))
                }
                const hn = Qs;
                return Tn._setWindowSize(8), {
                    CURVE: l,
                    getPublicKey: function Ls(Yt) {
                        return Vi(Yt).pointBytes
                    },
                    sign: function za(Yt, Lt, In = {}) {
                        Yt = en("message", Yt), _ && (Yt = _(Yt));
                        const {
                            prefix: Jn,
                            scalar: Gn,
                            pointBytes: Ai
                        } = Vi(Lt), Gi = Ts(In.context, Jn, Yt), br = Tn.multiply(Gi).toRawBytes(), mr = Fr(Gi + Ts(In.context, br, Ai, Yt) * Gn);
                        return Pt(mr), en("result", Ii(br, Bi(mr, d.BYTES)), 2 * se)
                    },
                    verify: function zn(Yt, Lt, In, Jn = hn) {
                        const {
                            context: Gn,
                            zip215: Ai
                        } = Jn, Gi = d.BYTES;
                        Yt = en("signature", Yt, 2 * Gi), Lt = en("message", Lt), _ && (Lt = _(Lt));
                        const br = Wn(Yt.slice(Gi, 2 * Gi));
                        let dr, mr, Rs;
                        try {
                            dr = rn.fromHex(In, Ai), mr = rn.fromHex(Yt.slice(0, Gi), Ai), Rs = Tn.multiplyUnsafe(br)
                        } catch {
                            return !1
                        }
                        if (!Ai && dr.isSmallOrder()) return !1;
                        const hs = Ts(Gn, mr.toRawBytes(), dr.toRawBytes(), Lt);
                        return mr.add(dr.multiplyUnsafe(hs)).subtract(Rs).clearCofactor().equals(rn.ZERO)
                    },
                    ExtendedPoint: rn,
                    utils: {
                        getExtendedPublicKey: Vi,
                        randomPrivateKey: () => B(d.BYTES),
                        precompute: (Yt = 8, Lt = rn.BASE) => (Lt._setWindowSize(Yt), Lt.multiply(BigInt(3)), Lt)
                    }
                }
            }
            const da = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
                nc = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),
                Js = (BigInt(0), BigInt(1)),
                Zi = BigInt(2),
                hd = BigInt(5),
                ic = BigInt(10),
                yu = BigInt(20),
                fd = BigInt(40),
                kl = BigInt(80);
            const un = qi(da, void 0, !0),
                Dt = ao({
                    a: BigInt(-1),
                    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
                    Fp: un,
                    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
                    h: BigInt(8),
                    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
                    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
                    hash: N,
                    randomBytes: f.O6,
                    adjustScalarBytes: function fs(g) {
                        return g[0] &= 248, g[31] &= 127, g[31] |= 64, g
                    },
                    uvRatio: function Mn(g, l) {
                        const d = da,
                            p = Ti(l * l * l, d),
                            k = function Jc(g) {
                                const l = da,
                                    p = g * g % l * g % l,
                                    _ = gn(p, Zi, l) * p % l,
                                    k = gn(_, Js, l) * g % l,
                                    B = gn(k, hd, l) * k % l,
                                    se = gn(B, ic, l) * B % l,
                                    fe = gn(se, yu, l) * se % l,
                                    Pe = gn(fe, fd, l) * fe % l,
                                    Ne = gn(Pe, kl, l) * Pe % l,
                                    Je = gn(Ne, kl, l) * Pe % l,
                                    yt = gn(Je, ic, l) * B % l;
                                return {
                                    pow_p_5_8: gn(yt, Zi, l) * g % l,
                                    b2: p
                                }
                            }(g * Ti(p * p * l, d)).pow_p_5_8;
                        let B = Ti(g * p * k, d);
                        const se = Ti(l * B * B, d),
                            fe = B,
                            Pe = Ti(B * nc, d),
                            Ne = se === g,
                            Je = se === Ti(-g, d),
                            yt = se === Ti(-g * nc, d);
                        return Ne && (B = fe), (Je || yt) && (B = Pe), ((g, l) => (Ti(g, l) & Sn) === Sn)(B, d) && (B = Ti(-B, d)), {
                            isValid: Ne || Je,
                            value: B
                        }
                    }
                });
            const lt = (un.ORDER + BigInt(3)) / BigInt(8);
            un.pow(Zi, lt), un.sqrt(un.neg(un.ONE)), BigInt(5), BigInt(8), BigInt(486662),
                function Xn(g, l) {
                    if (!g.isOdd) throw new Error("Field doesn't have isOdd");
                    const d = g.sqrt(l);
                    g.isOdd(d) && g.neg(d)
                }(un, un.neg(BigInt(486664))), BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
            var $s = T(62662),
                Ml = T.n($s),
                Mc = T(71109),
                ps = T.n(Mc),
                vu = T(87501),
                Il = T(84946),
                He = T(18846),
                La = T(49347);
            class Ic extends TypeError {
                constructor(l, d) {
                    let p;
                    const {
                        message: _,
                        ...k
                    } = l, {
                        path: B
                    } = l;
                    super(0 === B.length ? _ : "At path: " + B.join(".") + " -- " + _), Object.assign(this, k), this.name = this.constructor.name, this.failures = () => {
                        var fe;
                        return null != (fe = p) ? fe : p = [l, ...d()]
                    }
                }
            }

            function Ro(g) {
                return "object" == typeof g && null != g
            }

            function ns(g) {
                return "string" == typeof g ? JSON.stringify(g) : "" + g
            }

            function sc(g, l, d, p) {
                if (!0 === g) return;
                !1 === g ? g = {} : "string" == typeof g && (g = {
                    message: g
                });
                const {
                    path: _,
                    branch: k
                } = l, {
                    type: B
                } = d, {
                    refinement: se,
                    message: fe = "Expected a value of type `" + B + "`" + (se ? " with refinement `" + se + "`" : "") + ", but received: `" + ns(p) + "`"
                } = g;
                return {
                    value: p,
                    type: B,
                    refinement: se,
                    key: _[_.length - 1],
                    path: _,
                    branch: k,
                    ...g,
                    message: fe
                }
            }

            function* Pc(g, l, d, p) {
                (function Ra(g) {
                    return Ro(g) && "function" == typeof g[Symbol.iterator]
                })(g) || (g = [g]);
                for (const _ of g) {
                    const k = sc(_, l, d, p);
                    k && (yield k)
                }
            }

            function* Is(g, l, d = {}) {
                const {
                    path: p = [],
                    branch: _ = [g],
                    coerce: k = !1,
                    mask: B = !1
                } = d, se = {
                    path: p,
                    branch: _
                };
                if (k && (g = l.coercer(g, se), B && "type" !== l.type && Ro(l.schema) && Ro(g) && !Array.isArray(g)))
                    for (const Pe in g) void 0 === l.schema[Pe] && delete g[Pe];
                let fe = !0;
                for (const Pe of l.validator(g, se)) fe = !1, yield [Pe, void 0];
                for (let [Pe, Ne, Je] of l.entries(g, se)) {
                    const yt = Is(Ne, Je, {
                        path: void 0 === Pe ? p : [...p, Pe],
                        branch: void 0 === Pe ? _ : [..._, Ne],
                        coerce: k,
                        mask: B
                    });
                    for (const bt of yt) bt[0] ? (fe = !1, yield [bt[0], void 0]) : k && (Ne = bt[1], void 0 === Pe ? g = Ne : g instanceof Map ? g.set(Pe, Ne) : g instanceof Set ? g.add(Ne) : Ro(g) && (g[Pe] = Ne))
                }
                if (fe)
                    for (const Pe of l.refiner(g, se)) fe = !1, yield [Pe, void 0];
                fe && (yield [void 0, g])
            }
            class is {
                constructor(l) {
                    const {
                        type: d,
                        schema: p,
                        validator: _,
                        refiner: k,
                        coercer: B = (fe => fe),
                        entries: se = function*() {}
                    } = l;
                    this.type = d, this.schema = p, this.entries = se, this.coercer = B, this.validator = _ ? (fe, Pe) => Pc(_(fe, Pe), Pe, this, fe) : () => [], this.refiner = k ? (fe, Pe) => Pc(k(fe, Pe), Pe, this, fe) : () => []
                }
                assert(l) {
                    return bu(l, this)
                }
                create(l) {
                    return $t(l, this)
                }
                is(l) {
                    return pa(l, this)
                }
                mask(l) {
                    return function zs(g, l) {
                        const d = ls(g, l, {
                            coerce: !0,
                            mask: !0
                        });
                        if (d[0]) throw d[0];
                        return d[1]
                    }(l, this)
                }
                validate(l, d = {}) {
                    return ls(l, this, d)
                }
            }

            function bu(g, l) {
                const d = ls(g, l);
                if (d[0]) throw d[0]
            }

            function $t(g, l) {
                const d = ls(g, l, {
                    coerce: !0
                });
                if (d[0]) throw d[0];
                return d[1]
            }

            function pa(g, l) {
                return !ls(g, l)[0]
            }

            function ls(g, l, d = {}) {
                const p = Is(g, l, d),
                    _ = function vn(g) {
                        const {
                            done: l,
                            value: d
                        } = g.next();
                        return l ? void 0 : d
                    }(p);
                return _[0] ? [new Ic(_[0], function*() {
                    for (const B of p) B[0] && (yield B[0])
                }), void 0] : [void 0, _[1]]
            }

            function Vn(g, l) {
                return new is({
                    type: g,
                    schema: null,
                    validator: l
                })
            }

            function dn(g) {
                return new is({
                    type: "array",
                    schema: g,
                    * entries(l) {
                        if (g && Array.isArray(l))
                            for (const [d, p] of l.entries()) yield [d, p, g]
                    },
                    coercer: l => Array.isArray(l) ? l.slice() : l,
                    validator: l => Array.isArray(l) || "Expected an array value, but received: " + ns(l)
                })
            }

            function Bo() {
                return Vn("boolean", g => "boolean" == typeof g)
            }

            function Ll(g) {
                return Vn("instance", l => l instanceof g || "Expected a `" + g.name + "` instance, but received: " + ns(l))
            }

            function Pr(g) {
                const l = ns(g),
                    d = typeof g;
                return new is({
                    type: "literal",
                    schema: "string" === d || "number" === d || "boolean" === d ? g : null,
                    validator: p => p === g || "Expected the literal `" + l + "`, but received: " + ns(p)
                })
            }

            function fn(g) {
                return new is({ ...g,
                    validator: (l, d) => null === l || g.validator(l, d),
                    refiner: (l, d) => null === l || g.refiner(l, d)
                })
            }

            function ct() {
                return Vn("number", g => "number" == typeof g && !isNaN(g) || "Expected a number, but received: " + ns(g))
            }

            function Yn(g) {
                return new is({ ...g,
                    validator: (l, d) => void 0 === l || g.validator(l, d),
                    refiner: (l, d) => void 0 === l || g.refiner(l, d)
                })
            }

            function vd(g, l) {
                return new is({
                    type: "record",
                    schema: null,
                    * entries(d) {
                        if (Ro(d))
                            for (const p in d) {
                                const _ = d[p];
                                yield [p, p, g], yield [p, _, l]
                            }
                    },
                    validator: d => Ro(d) || "Expected an object, but received: " + ns(d)
                })
            }

            function Jt() {
                return Vn("string", g => "string" == typeof g || "Expected a string, but received: " + ns(g))
            }

            function Rl(g) {
                const l = function to() {
                    return Vn("never", () => !1)
                }();
                return new is({
                    type: "tuple",
                    schema: null,
                    * entries(d) {
                        if (Array.isArray(d)) {
                            const p = Math.max(g.length, d.length);
                            for (let _ = 0; _ < p; _++) yield [_, d[_], g[_] || l]
                        }
                    },
                    validator: d => Array.isArray(d) || "Expected an array, but received: " + ns(d)
                })
            }

            function Ot(g) {
                const l = Object.keys(g);
                return new is({
                    type: "type",
                    schema: g,
                    * entries(d) {
                        if (Ro(d))
                            for (const p of l) yield [p, d[p], g[p]]
                    },
                    validator: d => Ro(d) || "Expected an object, but received: " + ns(d)
                })
            }

            function xn(g) {
                const l = g.map(d => d.type).join(" | ");
                return new is({
                    type: "union",
                    schema: null,
                    validator(d, p) {
                        const _ = [];
                        for (const k of g) {
                            const [...B] = Is(d, k, p), [se] = B;
                            if (!se[0]) return [];
                            for (const [fe] of B) fe && _.push(fe)
                        }
                        return ["Expected the value to satisfy a union of `" + l + "`, but received: " + ns(d), ..._]
                    }
                })
            }

            function Na() {
                return Vn("unknown", () => !0)
            }

            function Fa(g, l, d) {
                return new is({ ...g,
                    coercer: (p, _) => pa(p, l) ? g.coercer(d(p, _), _) : g.coercer(p, _)
                })
            }
            var js = T(8508),
                Va = T.n(js),
                lo = T(84463),
                X = T(56910),
                be = T(93284);
            const Ue = [],
                rt = [],
                At = [],
                Wt = BigInt(0),
                Ct = BigInt(1),
                bn = BigInt(2),
                vi = BigInt(7),
                ni = BigInt(256),
                fr = BigInt(113);
            for (let g = 0, l = Ct, d = 1, p = 0; g < 24; g++) {
                [d, p] = [p, (2 * d + 3 * p) % 5], Ue.push(2 * (5 * p + d)), rt.push((g + 1) * (g + 2) / 2 % 64);
                let _ = Wt;
                for (let k = 0; k < 7; k++) l = (l << Ct ^ (l >> vi) * fr) % ni, l & bn && (_ ^= Ct << (Ct << BigInt(k)) - Ct);
                At.push(_)
            }
            const [ii, no] = z(At, !0), vr = (g, l, d) => d > 32 ? De(g, l, d) : we(g, l, d), Zr = (g, l, d) => d > 32 ? ae(g, l, d) : ve(g, l, d);
            class Hn extends f.kb {
                constructor(l, d, p, _ = !1, k = 24) {
                    if (super(), this.blockLen = l, this.suffix = d, this.outputLen = p, this.enableXOF = _, this.rounds = k, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, be.Rx)(p), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200), this.state32 = (0, f.Jq)(this.state)
                }
                keccak() {
                    f.iA || (0, f.l1)(this.state32),
                        function rs(g, l = 24) {
                            const d = new Uint32Array(10);
                            for (let p = 24 - l; p < 24; p++) {
                                for (let B = 0; B < 10; B++) d[B] = g[B] ^ g[B + 10] ^ g[B + 20] ^ g[B + 30] ^ g[B + 40];
                                for (let B = 0; B < 10; B += 2) {
                                    const se = (B + 8) % 10,
                                        fe = (B + 2) % 10,
                                        Pe = d[fe],
                                        Ne = d[fe + 1],
                                        Je = vr(Pe, Ne, 1) ^ d[se],
                                        yt = Zr(Pe, Ne, 1) ^ d[se + 1];
                                    for (let bt = 0; bt < 50; bt += 10) g[B + bt] ^= Je, g[B + bt + 1] ^= yt
                                }
                                let _ = g[2],
                                    k = g[3];
                                for (let B = 0; B < 24; B++) {
                                    const se = rt[B],
                                        fe = vr(_, k, se),
                                        Pe = Zr(_, k, se),
                                        Ne = Ue[B];
                                    _ = g[Ne], k = g[Ne + 1], g[Ne] = fe, g[Ne + 1] = Pe
                                }
                                for (let B = 0; B < 50; B += 10) {
                                    for (let se = 0; se < 10; se++) d[se] = g[B + se];
                                    for (let se = 0; se < 10; se++) g[B + se] ^= ~d[(se + 2) % 10] & d[(se + 4) % 10]
                                }
                                g[0] ^= ii[p], g[1] ^= no[p]
                            }
                            d.fill(0)
                        }(this.state32, this.rounds), f.iA || (0, f.l1)(this.state32), this.posOut = 0, this.pos = 0
                }
                update(l) {
                    (0, be.Gg)(this);
                    const {
                        blockLen: d,
                        state: p
                    } = this, _ = (l = (0, f.O0)(l)).length;
                    for (let k = 0; k < _;) {
                        const B = Math.min(d - this.pos, _ - k);
                        for (let se = 0; se < B; se++) p[this.pos++] ^= l[k++];
                        this.pos === d && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished) return;
                    this.finished = !0;
                    const {
                        state: l,
                        suffix: d,
                        pos: p,
                        blockLen: _
                    } = this;
                    l[p] ^= d, 128 & d && p === _ - 1 && this.keccak(), l[_ - 1] ^= 128, this.keccak()
                }
                writeInto(l) {
                    (0, be.Gg)(this, !1), (0, be.aI)(l), this.finish();
                    const d = this.state,
                        {
                            blockLen: p
                        } = this;
                    for (let _ = 0, k = l.length; _ < k;) {
                        this.posOut >= p && this.keccak();
                        const B = Math.min(p - this.posOut, k - _);
                        l.set(d.subarray(this.posOut, this.posOut + B), _), this.posOut += B, _ += B
                    }
                    return l
                }
                xofInto(l) {
                    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                    return this.writeInto(l)
                }
                xof(l) {
                    return (0, be.Rx)(l), this.xofInto(new Uint8Array(l))
                }
                digestInto(l) {
                    if ((0, be.J8)(l, this), this.finished) throw new Error("digest() was already called");
                    return this.writeInto(l), this.destroy(), l
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0, this.state.fill(0)
                }
                _cloneInto(l) {
                    const {
                        blockLen: d,
                        suffix: p,
                        outputLen: _,
                        rounds: k,
                        enableXOF: B
                    } = this;
                    return l || (l = new Hn(d, p, _, B, k)), l.state32.set(this.state32), l.pos = this.pos, l.posOut = this.posOut, l.finished = this.finished, l.rounds = k, l.suffix = p, l.outputLen = _, l.enableXOF = B, l.destroyed = this.destroyed, l
                }
            }
            const ma = ((g, l, d) => (0, f.hE)(() => new Hn(136, 1, 32)))();
            class Bl extends f.kb {
                constructor(l, d) {
                    super(), this.finished = !1, this.destroyed = !1, (0, be.vp)(l);
                    const p = (0, f.O0)(d);
                    if (this.iHash = l.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    const _ = this.blockLen,
                        k = new Uint8Array(_);
                    k.set(p.length > _ ? l.create().update(p).digest() : p);
                    for (let B = 0; B < k.length; B++) k[B] ^= 54;
                    this.iHash.update(k), this.oHash = l.create();
                    for (let B = 0; B < k.length; B++) k[B] ^= 106;
                    this.oHash.update(k), k.fill(0)
                }
                update(l) {
                    return (0, be.Gg)(this), this.iHash.update(l), this
                }
                digestInto(l) {
                    (0, be.Gg)(this), (0, be.aI)(l, this.outputLen), this.finished = !0, this.iHash.digestInto(l), this.oHash.update(l), this.oHash.digestInto(l), this.destroy()
                }
                digest() {
                    const l = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(l), l
                }
                _cloneInto(l) {
                    l || (l = Object.create(Object.getPrototypeOf(this), {}));
                    const {
                        oHash: d,
                        iHash: p,
                        finished: _,
                        destroyed: k,
                        blockLen: B,
                        outputLen: se
                    } = this;
                    return l.finished = _, l.destroyed = k, l.blockLen = B, l.outputLen = se, l.oHash = d._cloneInto(l.oHash), l.iHash = p._cloneInto(l.iHash), l
                }
                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            }
            const Ni = (g, l, d) => new Bl(g, l).update(d).digest();
            Ni.create = (g, l) => new Bl(g, l);
            const {
                bytesToNumberBE: Cd,
                hexToBytes: pp
            } = F, io = {
                Err: class extends Error {
                    constructor(l = "") {
                        super(l)
                    }
                },
                _parseInt(g) {
                    const {
                        Err: l
                    } = io;
                    if (g.length < 2 || 2 !== g[0]) throw new l("Invalid signature integer tag");
                    const d = g[1],
                        p = g.subarray(2, d + 2);
                    if (!d || p.length !== d) throw new l("Invalid signature integer: wrong length");
                    if (128 & p[0]) throw new l("Invalid signature integer: negative");
                    if (0 === p[0] && !(128 & p[1])) throw new l("Invalid signature integer: unnecessary leading zero");
                    return {
                        d: Cd(p),
                        l: g.subarray(d + 2)
                    }
                },
                toSig(g) {
                    const {
                        Err: l
                    } = io, d = "string" == typeof g ? pp(g) : g;
                    Mt(d);
                    let p = d.length;
                    if (p < 2 || 48 != d[0]) throw new l("Invalid signature tag");
                    if (d[1] !== p - 2) throw new l("Invalid signature: incorrect length");
                    const {
                        d: _,
                        l: k
                    } = io._parseInt(d.subarray(2)), {
                        d: B,
                        l: se
                    } = io._parseInt(k);
                    if (se.length) throw new l("Invalid signature: left bytes after parsing");
                    return {
                        r: _,
                        s: B
                    }
                },
                hexFromSig(g) {
                    const l = Pe => 8 & Number.parseInt(Pe[0], 16) ? "00" + Pe : Pe,
                        d = Pe => {
                            const Ne = Pe.toString(16);
                            return 1 & Ne.length ? `0${Ne}` : Ne
                        },
                        p = l(d(g.s)),
                        _ = l(d(g.r)),
                        k = p.length / 2,
                        B = _.length / 2,
                        se = d(k),
                        fe = d(B);
                    return `30${d(B+k+4)}02${fe}${_}02${se}${p}`
                }
            }, Co = BigInt(0), Or = BigInt(1), ms = (BigInt(2), BigInt(3));

            function oc(g) {
                const l = function uo(g) {
                        const l = Zn(g);
                        return $n(l, {
                            hash: "hash",
                            hmac: "function",
                            randomBytes: "function"
                        }, {
                            bits2int: "function",
                            bits2int_modN: "function",
                            lowS: "boolean"
                        }), Object.freeze({
                            lowS: !0,
                            ...l
                        })
                    }(g),
                    {
                        Fp: d,
                        n: p
                    } = l,
                    _ = d.BYTES + 1,
                    k = 2 * d.BYTES + 1;

                function se(hn) {
                    return Ti(hn, p)
                }

                function fe(hn) {
                    return Si(hn, p)
                }
                const {
                    ProjectivePoint: Pe,
                    normPrivateKeyToScalar: Ne,
                    weierstrassEquation: Je,
                    isWithinCurveOrder: yt
                } = function To(g) {
                    const l = function I_(g) {
                            const l = Zn(g);
                            $n(l, {
                                a: "field",
                                b: "field"
                            }, {
                                allowedPrivateKeyLengths: "array",
                                wrapPrivateKey: "boolean",
                                isTorsionFree: "function",
                                clearCofactor: "function",
                                allowInfinityPoint: "boolean",
                                fromBytes: "function",
                                toBytes: "function"
                            });
                            const {
                                endo: d,
                                Fp: p,
                                a: _
                            } = l;
                            if (d) {
                                if (!p.eql(_, p.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                                if ("object" != typeof d || "bigint" != typeof d.beta || "function" != typeof d.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                            }
                            return Object.freeze({ ...l
                            })
                        }(g),
                        {
                            Fp: d
                        } = l,
                        p = l.toBytes || ((dt, qe, it) => {
                            const ft = qe.toAffine();
                            return Ii(Uint8Array.from([4]), d.toBytes(ft.x), d.toBytes(ft.y))
                        }),
                        _ = l.fromBytes || (dt => {
                            const qe = dt.subarray(1);
                            return {
                                x: d.fromBytes(qe.subarray(0, d.BYTES)),
                                y: d.fromBytes(qe.subarray(d.BYTES, 2 * d.BYTES))
                            }
                        });

                    function k(dt) {
                        const {
                            a: qe,
                            b: it
                        } = l, ft = d.sqr(dt), Pt = d.mul(ft, dt);
                        return d.add(d.add(Pt, d.mul(dt, qe)), it)
                    }
                    if (!d.eql(d.sqr(l.Gy), k(l.Gx))) throw new Error("bad generator point: equation left != right");

                    function B(dt) {
                        return "bigint" == typeof dt && Co < dt && dt < l.n
                    }

                    function se(dt) {
                        if (!B(dt)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
                    }

                    function fe(dt) {
                        const {
                            allowedPrivateKeyLengths: qe,
                            nByteLength: it,
                            wrapPrivateKey: ft,
                            n: Pt
                        } = l;
                        if (qe && "bigint" != typeof dt) {
                            if (Vt(dt) && (dt = ei(dt)), "string" != typeof dt || !qe.includes(dt.length)) throw new Error("Invalid key");
                            dt = dt.padStart(2 * it, "0")
                        }
                        let Bt;
                        try {
                            Bt = "bigint" == typeof dt ? dt : ji(en("private key", dt, it))
                        } catch {
                            throw new Error(`private key must be ${it} bytes, hex or bigint, not ${typeof dt}`)
                        }
                        return ft && (Bt = Ti(Bt, Pt)), se(Bt), Bt
                    }
                    const Pe = new Map;

                    function Ne(dt) {
                        if (!(dt instanceof Je)) throw new Error("ProjectivePoint expected")
                    }
                    class Je {
                        constructor(qe, it, ft) {
                            if (this.px = qe, this.py = it, this.pz = ft, null == qe || !d.isValid(qe)) throw new Error("x required");
                            if (null == it || !d.isValid(it)) throw new Error("y required");
                            if (null == ft || !d.isValid(ft)) throw new Error("z required")
                        }
                        static fromAffine(qe) {
                            const {
                                x: it,
                                y: ft
                            } = qe || {};
                            if (!qe || !d.isValid(it) || !d.isValid(ft)) throw new Error("invalid affine point");
                            if (qe instanceof Je) throw new Error("projective point not allowed");
                            const Pt = Bt => d.eql(Bt, d.ZERO);
                            return Pt(it) && Pt(ft) ? Je.ZERO : new Je(it, ft, d.ONE)
                        }
                        get x() {
                            return this.toAffine().x
                        }
                        get y() {
                            return this.toAffine().y
                        }
                        static normalizeZ(qe) {
                            const it = d.invertBatch(qe.map(ft => ft.pz));
                            return qe.map((ft, Pt) => ft.toAffine(it[Pt])).map(Je.fromAffine)
                        }
                        static fromHex(qe) {
                            const it = Je.fromAffine(_(en("pointHex", qe)));
                            return it.assertValidity(), it
                        }
                        static fromPrivateKey(qe) {
                            return Je.BASE.multiply(fe(qe))
                        }
                        _setWindowSize(qe) {
                            this._WINDOW_SIZE = qe, Pe.delete(this)
                        }
                        assertValidity() {
                            if (this.is0()) {
                                if (l.allowInfinityPoint && !d.is0(this.py)) return;
                                throw new Error("bad point: ZERO")
                            }
                            const {
                                x: qe,
                                y: it
                            } = this.toAffine();
                            if (!d.isValid(qe) || !d.isValid(it)) throw new Error("bad point: x or y not FE");
                            const ft = d.sqr(it),
                                Pt = k(qe);
                            if (!d.eql(ft, Pt)) throw new Error("bad point: equation left != right");
                            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                        }
                        hasEvenY() {
                            const {
                                y: qe
                            } = this.toAffine();
                            if (d.isOdd) return !d.isOdd(qe);
                            throw new Error("Field doesn't support isOdd")
                        }
                        equals(qe) {
                            Ne(qe);
                            const {
                                px: it,
                                py: ft,
                                pz: Pt
                            } = this, {
                                px: Bt,
                                py: pn,
                                pz: rn
                            } = qe, Tn = d.eql(d.mul(it, rn), d.mul(Bt, Pt)), si = d.eql(d.mul(ft, rn), d.mul(pn, Pt));
                            return Tn && si
                        }
                        negate() {
                            return new Je(this.px, d.neg(this.py), this.pz)
                        }
                        double() {
                            const {
                                a: qe,
                                b: it
                            } = l, ft = d.mul(it, ms), {
                                px: Pt,
                                py: Bt,
                                pz: pn
                            } = this;
                            let rn = d.ZERO,
                                Tn = d.ZERO,
                                si = d.ZERO,
                                Qn = d.mul(Pt, Pt),
                                Fr = d.mul(Bt, Bt),
                                pr = d.mul(pn, pn),
                                Vi = d.mul(Pt, Bt);
                            return Vi = d.add(Vi, Vi), si = d.mul(Pt, pn), si = d.add(si, si), rn = d.mul(qe, si), Tn = d.mul(ft, pr), Tn = d.add(rn, Tn), rn = d.sub(Fr, Tn), Tn = d.add(Fr, Tn), Tn = d.mul(rn, Tn), rn = d.mul(Vi, rn), si = d.mul(ft, si), pr = d.mul(qe, pr), Vi = d.sub(Qn, pr), Vi = d.mul(qe, Vi), Vi = d.add(Vi, si), si = d.add(Qn, Qn), Qn = d.add(si, Qn), Qn = d.add(Qn, pr), Qn = d.mul(Qn, Vi), Tn = d.add(Tn, Qn), pr = d.mul(Bt, pn), pr = d.add(pr, pr), Qn = d.mul(pr, Vi), rn = d.sub(rn, Qn), si = d.mul(pr, Fr), si = d.add(si, si), si = d.add(si, si), new Je(rn, Tn, si)
                        }
                        add(qe) {
                            Ne(qe);
                            const {
                                px: it,
                                py: ft,
                                pz: Pt
                            } = this, {
                                px: Bt,
                                py: pn,
                                pz: rn
                            } = qe;
                            let Tn = d.ZERO,
                                si = d.ZERO,
                                Qn = d.ZERO;
                            const Fr = l.a,
                                pr = d.mul(l.b, ms);
                            let Vi = d.mul(it, Bt),
                                Ls = d.mul(ft, pn),
                                Ts = d.mul(Pt, rn),
                                za = d.add(it, ft),
                                hn = d.add(Bt, pn);
                            za = d.mul(za, hn), hn = d.add(Vi, Ls), za = d.sub(za, hn), hn = d.add(it, Pt);
                            let zn = d.add(Bt, rn);
                            return hn = d.mul(hn, zn), zn = d.add(Vi, Ts), hn = d.sub(hn, zn), zn = d.add(ft, Pt), Tn = d.add(pn, rn), zn = d.mul(zn, Tn), Tn = d.add(Ls, Ts), zn = d.sub(zn, Tn), Qn = d.mul(Fr, hn), Tn = d.mul(pr, Ts), Qn = d.add(Tn, Qn), Tn = d.sub(Ls, Qn), Qn = d.add(Ls, Qn), si = d.mul(Tn, Qn), Ls = d.add(Vi, Vi), Ls = d.add(Ls, Vi), Ts = d.mul(Fr, Ts), hn = d.mul(pr, hn), Ls = d.add(Ls, Ts), Ts = d.sub(Vi, Ts), Ts = d.mul(Fr, Ts), hn = d.add(hn, Ts), Vi = d.mul(Ls, hn), si = d.add(si, Vi), Vi = d.mul(zn, hn), Tn = d.mul(za, Tn), Tn = d.sub(Tn, Vi), Vi = d.mul(za, Ls), Qn = d.mul(zn, Qn), Qn = d.add(Qn, Vi), new Je(Tn, si, Qn)
                        }
                        subtract(qe) {
                            return this.add(qe.negate())
                        }
                        is0() {
                            return this.equals(Je.ZERO)
                        }
                        wNAF(qe) {
                            return bt.wNAFCached(this, Pe, qe, it => {
                                const ft = d.invertBatch(it.map(Pt => Pt.pz));
                                return it.map((Pt, Bt) => Pt.toAffine(ft[Bt])).map(Je.fromAffine)
                            })
                        }
                        multiplyUnsafe(qe) {
                            const it = Je.ZERO;
                            if (qe === Co) return it;
                            if (se(qe), qe === Or) return this;
                            const {
                                endo: ft
                            } = l;
                            if (!ft) return bt.unsafeLadder(this, qe);
                            let {
                                k1neg: Pt,
                                k1: Bt,
                                k2neg: pn,
                                k2: rn
                            } = ft.splitScalar(qe), Tn = it, si = it, Qn = this;
                            for (; Bt > Co || rn > Co;) Bt & Or && (Tn = Tn.add(Qn)), rn & Or && (si = si.add(Qn)), Qn = Qn.double(), Bt >>= Or, rn >>= Or;
                            return Pt && (Tn = Tn.negate()), pn && (si = si.negate()), si = new Je(d.mul(si.px, ft.beta), si.py, si.pz), Tn.add(si)
                        }
                        multiply(qe) {
                            se(qe);
                            let ft, Pt, it = qe;
                            const {
                                endo: Bt
                            } = l;
                            if (Bt) {
                                const {
                                    k1neg: pn,
                                    k1: rn,
                                    k2neg: Tn,
                                    k2: si
                                } = Bt.splitScalar(it);
                                let {
                                    p: Qn,
                                    f: Fr
                                } = this.wNAF(rn), {
                                    p: pr,
                                    f: Vi
                                } = this.wNAF(si);
                                Qn = bt.constTimeNegate(pn, Qn), pr = bt.constTimeNegate(Tn, pr), pr = new Je(d.mul(pr.px, Bt.beta), pr.py, pr.pz), ft = Qn.add(pr), Pt = Fr.add(Vi)
                            } else {
                                const {
                                    p: pn,
                                    f: rn
                                } = this.wNAF(it);
                                ft = pn, Pt = rn
                            }
                            return Je.normalizeZ([ft, Pt])[0]
                        }
                        multiplyAndAddUnsafe(qe, it, ft) {
                            const Pt = Je.BASE,
                                Bt = (rn, Tn) => Tn !== Co && Tn !== Or && rn.equals(Pt) ? rn.multiply(Tn) : rn.multiplyUnsafe(Tn),
                                pn = Bt(this, it).add(Bt(qe, ft));
                            return pn.is0() ? void 0 : pn
                        }
                        toAffine(qe) {
                            const {
                                px: it,
                                py: ft,
                                pz: Pt
                            } = this, Bt = this.is0();
                            null == qe && (qe = Bt ? d.ONE : d.inv(Pt));
                            const pn = d.mul(it, qe),
                                rn = d.mul(ft, qe),
                                Tn = d.mul(Pt, qe);
                            if (Bt) return {
                                x: d.ZERO,
                                y: d.ZERO
                            };
                            if (!d.eql(Tn, d.ONE)) throw new Error("invZ was invalid");
                            return {
                                x: pn,
                                y: rn
                            }
                        }
                        isTorsionFree() {
                            const {
                                h: qe,
                                isTorsionFree: it
                            } = l;
                            if (qe === Or) return !0;
                            if (it) return it(Je, this);
                            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                        }
                        clearCofactor() {
                            const {
                                h: qe,
                                clearCofactor: it
                            } = l;
                            return qe === Or ? this : it ? it(Je, this) : this.multiplyUnsafe(l.h)
                        }
                        toRawBytes(qe = !0) {
                            return this.assertValidity(), p(Je, this, qe)
                        }
                        toHex(qe = !0) {
                            return ei(this.toRawBytes(qe))
                        }
                    }
                    Je.BASE = new Je(l.Gx, l.Gy, d.ONE), Je.ZERO = new Je(d.ZERO, d.ONE, d.ZERO);
                    const yt = l.nBitLength,
                        bt = xo(Je, l.endo ? Math.ceil(yt / 2) : yt);
                    return {
                        CURVE: l,
                        ProjectivePoint: Je,
                        normPrivateKeyToScalar: fe,
                        weierstrassEquation: k,
                        isWithinCurveOrder: B
                    }
                }({ ...l,
                    toBytes(hn, zn, Qi) {
                        const Yt = zn.toAffine(),
                            Lt = d.toBytes(Yt.x),
                            In = Ii;
                        return Qi ? In(Uint8Array.from([zn.hasEvenY() ? 2 : 3]), Lt) : In(Uint8Array.from([4]), Lt, d.toBytes(Yt.y))
                    },
                    fromBytes(hn) {
                        const zn = hn.length,
                            Qi = hn[0],
                            Yt = hn.subarray(1);
                        if (zn !== _ || 2 !== Qi && 3 !== Qi) {
                            if (zn === k && 4 === Qi) return {
                                x: d.fromBytes(Yt.subarray(0, d.BYTES)),
                                y: d.fromBytes(Yt.subarray(d.BYTES, 2 * d.BYTES))
                            };
                            throw new Error(`Point of length ${zn} was invalid. Expected ${_} compressed bytes or ${k} uncompressed bytes`)
                        } {
                            const Lt = ji(Yt);
                            if (! function B(hn) {
                                    return Co < hn && hn < d.ORDER
                                }(Lt)) throw new Error("Point is not on curve");
                            const In = Je(Lt);
                            let Jn;
                            try {
                                Jn = d.sqrt(In)
                            } catch (Gi) {
                                const br = Gi instanceof Error ? ": " + Gi.message : "";
                                throw new Error("Point is not on curve" + br)
                            }
                            return 1 == (1 & Qi) != ((Jn & Or) === Or) && (Jn = d.neg(Jn)), {
                                x: Lt,
                                y: Jn
                            }
                        }
                    }
                }), bt = hn => ei(kn(hn, l.nByteLength));

                function dt(hn) {
                    return hn > p >> Or
                }
                const it = (hn, zn, Qi) => ji(hn.slice(zn, Qi));
                class ft {
                    constructor(zn, Qi, Yt) {
                        this.r = zn, this.s = Qi, this.recovery = Yt, this.assertValidity()
                    }
                    static fromCompact(zn) {
                        const Qi = l.nByteLength;
                        return zn = en("compactSignature", zn, 2 * Qi), new ft(it(zn, 0, Qi), it(zn, Qi, 2 * Qi))
                    }
                    static fromDER(zn) {
                        const {
                            r: Qi,
                            s: Yt
                        } = io.toSig(en("DER", zn));
                        return new ft(Qi, Yt)
                    }
                    assertValidity() {
                        if (!yt(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                        if (!yt(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                    }
                    addRecoveryBit(zn) {
                        return new ft(this.r, this.s, zn)
                    }
                    recoverPublicKey(zn) {
                        const {
                            r: Qi,
                            s: Yt,
                            recovery: Lt
                        } = this, In = si(en("msgHash", zn));
                        if (null == Lt || ![0, 1, 2, 3].includes(Lt)) throw new Error("recovery id invalid");
                        const Jn = 2 === Lt || 3 === Lt ? Qi + l.n : Qi;
                        if (Jn >= d.ORDER) throw new Error("recovery id 2 or 3 invalid");
                        const Ai = Pe.fromHex((1 & Lt ? "03" : "02") + bt(Jn)),
                            Gi = fe(Jn),
                            br = se(-In * Gi),
                            dr = se(Yt * Gi),
                            mr = Pe.BASE.multiplyAndAddUnsafe(Ai, br, dr);
                        if (!mr) throw new Error("point at infinify");
                        return mr.assertValidity(), mr
                    }
                    hasHighS() {
                        return dt(this.s)
                    }
                    normalizeS() {
                        return this.hasHighS() ? new ft(this.r, se(-this.s), this.recovery) : this
                    }
                    toDERRawBytes() {
                        return Mi(this.toDERHex())
                    }
                    toDERHex() {
                        return io.hexFromSig({
                            r: this.r,
                            s: this.s
                        })
                    }
                    toCompactRawBytes() {
                        return Mi(this.toCompactHex())
                    }
                    toCompactHex() {
                        return bt(this.r) + bt(this.s)
                    }
                }
                const Pt = {
                    isValidPrivateKey(hn) {
                        try {
                            return Ne(hn), !0
                        } catch {
                            return !1
                        }
                    },
                    normPrivateKeyToScalar: Ne,
                    randomPrivateKey: () => {
                        const hn = wo(l.n);
                        return function Dc(g, l, d = !1) {
                            const p = g.length,
                                _ = As(l),
                                k = wo(l);
                            if (p < 16 || p < k || p > 1024) throw new Error(`expected ${k}-1024 bytes of input, got ${p}`);
                            const se = Ti(d ? ji(g) : Wn(g), l - Sn) + Sn;
                            return d ? Bi(se, _) : kn(se, _)
                        }(l.randomBytes(hn), l.n)
                    },
                    precompute: (hn = 8, zn = Pe.BASE) => (zn._setWindowSize(hn), zn.multiply(BigInt(3)), zn)
                };

                function pn(hn) {
                    const zn = Vt(hn),
                        Qi = "string" == typeof hn,
                        Yt = (zn || Qi) && hn.length;
                    return zn ? Yt === _ || Yt === k : Qi ? Yt === 2 * _ || Yt === 2 * k : hn instanceof Pe
                }
                const Tn = l.bits2int || function(hn) {
                        const zn = ji(hn),
                            Qi = 8 * hn.length - l.nBitLength;
                        return Qi > 0 ? zn >> BigInt(Qi) : zn
                    },
                    si = l.bits2int_modN || function(hn) {
                        return se(Tn(hn))
                    },
                    Qn = Qe(l.nBitLength);

                function Fr(hn) {
                    if ("bigint" != typeof hn) throw new Error("bigint expected");
                    if (!(Co <= hn && hn < Qn)) throw new Error(`bigint expected < 2^${l.nBitLength}`);
                    return kn(hn, l.nByteLength)
                }
                const Vi = {
                        lowS: l.lowS,
                        prehash: !1
                    },
                    Ls = {
                        lowS: l.lowS,
                        prehash: !1
                    };
                return Pe.BASE._setWindowSize(8), {
                    CURVE: l,
                    getPublicKey: function Bt(hn, zn = !0) {
                        return Pe.fromPrivateKey(hn).toRawBytes(zn)
                    },
                    getSharedSecret: function rn(hn, zn, Qi = !0) {
                        if (pn(hn)) throw new Error("first arg must be private key");
                        if (!pn(zn)) throw new Error("second arg must be public key");
                        return Pe.fromHex(zn).multiply(Ne(hn)).toRawBytes(Qi)
                    },
                    sign: function Ts(hn, zn, Qi = Vi) {
                        const {
                            seed: Yt,
                            k2sig: Lt
                        } = function pr(hn, zn, Qi = Vi) {
                            if (["recovered", "canonical"].some(hs => hs in Qi)) throw new Error("sign() legacy options not supported");
                            const {
                                hash: Yt,
                                randomBytes: Lt
                            } = l;
                            let {
                                lowS: In,
                                prehash: Jn,
                                extraEntropy: Gn
                            } = Qi;
                            null == In && (In = !0), hn = en("msgHash", hn), Jn && (hn = en("prehashed msgHash", Yt(hn)));
                            const Ai = si(hn),
                                Gi = Ne(zn),
                                br = [Fr(Gi), Fr(Ai)];
                            if (null != Gn && !1 !== Gn) {
                                const hs = !0 === Gn ? Lt(d.BYTES) : Gn;
                                br.push(en("extraEntropy", hs))
                            }
                            const dr = Ii(...br),
                                mr = Ai;
                            return {
                                seed: dr,
                                k2sig: function Rs(hs) {
                                    const ho = Tn(hs);
                                    if (!yt(ho)) return;
                                    const so = fe(ho),
                                        Gs = Pe.BASE.multiply(ho).toAffine(),
                                        Eo = se(Gs.x);
                                    if (Eo === Co) return;
                                    const dc = se(so * se(mr + Eo * Gi));
                                    if (dc === Co) return;
                                    let hl = (Gs.x === Eo ? 0 : 2) | Number(Gs.y & Or),
                                        uf = dc;
                                    return In && dt(dc) && (uf = function qe(hn) {
                                        return dt(hn) ? se(-hn) : hn
                                    }(dc), hl ^= 1), new ft(Eo, uf, hl)
                                }
                            }
                        }(hn, zn, Qi);
                        return Kn(l.hash.outputLen, l.nByteLength, l.hmac)(Yt, Lt)
                    },
                    verify: function za(hn, zn, Qi, Yt = Ls) {
                        const Lt = hn;
                        if (zn = en("msgHash", zn), Qi = en("publicKey", Qi), "strict" in Yt) throw new Error("options.strict was renamed to lowS");
                        const {
                            lowS: In,
                            prehash: Jn
                        } = Yt;
                        let Gn, Ai;
                        try {
                            if ("string" == typeof Lt || Vt(Lt)) try {
                                Gn = ft.fromDER(Lt)
                            } catch (Gs) {
                                if (!(Gs instanceof io.Err)) throw Gs;
                                Gn = ft.fromCompact(Lt)
                            } else {
                                if ("object" != typeof Lt || "bigint" != typeof Lt.r || "bigint" != typeof Lt.s) throw new Error("PARSE"); {
                                    const {
                                        r: Gs,
                                        s: Eo
                                    } = Lt;
                                    Gn = new ft(Gs, Eo)
                                }
                            }
                            Ai = Pe.fromHex(Qi)
                        } catch (Gs) {
                            if ("PARSE" === Gs.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                            return !1
                        }
                        if (In && Gn.hasHighS()) return !1;
                        Jn && (zn = l.hash(zn));
                        const {
                            r: Gi,
                            s: br
                        } = Gn, dr = si(zn), mr = fe(br), Rs = se(dr * mr), hs = se(Gi * mr), ho = Pe.BASE.multiplyAndAddUnsafe(Ai, Rs, hs) ? .toAffine();
                        return !!ho && se(ho.x) === Gi
                    },
                    ProjectivePoint: Pe,
                    Signature: ft,
                    utils: Pt
                }
            }

            function ga(g) {
                return {
                    hash: g,
                    hmac: (l, ...d) => Ni(g, l, (0, f.eV)(...d)),
                    randomBytes: f.O6
                }
            }
            BigInt(4);
            const Td = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                Sd = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                mp = BigInt(1),
                Ed = BigInt(2),
                gp = (g, l) => (g + l / Ed) / l;
            const ya = qi(Td, void 0, void 0, {
                    sqrt: function vg(g) {
                        const l = Td,
                            d = BigInt(3),
                            p = BigInt(6),
                            _ = BigInt(11),
                            k = BigInt(22),
                            B = BigInt(23),
                            se = BigInt(44),
                            fe = BigInt(88),
                            Pe = g * g * g % l,
                            Ne = Pe * Pe * g % l,
                            Je = gn(Ne, d, l) * Ne % l,
                            yt = gn(Je, d, l) * Ne % l,
                            bt = gn(yt, Ed, l) * Pe % l,
                            dt = gn(bt, _, l) * bt % l,
                            qe = gn(dt, k, l) * dt % l,
                            it = gn(qe, se, l) * qe % l,
                            ft = gn(it, fe, l) * it % l,
                            Pt = gn(ft, se, l) * qe % l,
                            Bt = gn(Pt, d, l) * Ne % l,
                            pn = gn(Bt, B, l) * dt % l,
                            rn = gn(pn, p, l) * Pe % l,
                            Tn = gn(rn, Ed, l);
                        if (!ya.eql(ya.sqr(Tn), g)) throw new Error("Cannot find square root");
                        return Tn
                    }
                }),
                ol = function $h(g, l) {
                    const d = p => oc({ ...g,
                        ...ga(p)
                    });
                    return Object.freeze({ ...d(l),
                        create: d
                    })
                }({
                    a: BigInt(0),
                    b: BigInt(7),
                    Fp: ya,
                    n: Sd,
                    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                    h: BigInt(1),
                    lowS: !0,
                    endo: {
                        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                        splitScalar: g => {
                            const l = Sd,
                                d = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                                p = -mp * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                                _ = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                                k = d,
                                B = BigInt("0x100000000000000000000000000000000"),
                                se = gp(k * g, l),
                                fe = gp(-p * g, l);
                            let Pe = Ti(g - se * d - fe * _, l),
                                Ne = Ti(-se * p - fe * k, l);
                            const Je = Pe > B,
                                yt = Ne > B;
                            if (Je && (Pe = l - Pe), yt && (Ne = l - Ne), Pe > B || Ne > B) throw new Error("splitScalar: Endomorphism failed, k=" + g);
                            return {
                                k1neg: Je,
                                k1: Pe,
                                k2neg: yt,
                                k2: Ne
                            }
                        }
                    }
                }, vu.J);
            BigInt(0);
            const O_ = Dt.utils.randomPrivateKey,
                Cg = () => {
                    const g = Dt.utils.randomPrivateKey(),
                        l = Dd(g),
                        d = new Uint8Array(64);
                    return d.set(g), d.set(l, 32), {
                        publicKey: l,
                        secretKey: d
                    }
                },
                Dd = Dt.getPublicKey;

            function Tg(g) {
                try {
                    return Dt.ExtendedPoint.fromHex(g), !0
                } catch {
                    return !1
                }
            }
            const zh = (g, l) => Dt.sign(g, l.slice(0, 32)),
                Sg = Dt.verify,
                Oi = g => q.Buffer.isBuffer(g) ? g : g instanceof Uint8Array ? q.Buffer.from(g.buffer, g.byteOffset, g.byteLength) : q.Buffer.from(g);
            class bp {
                constructor(l) {
                    Object.assign(this, l)
                }
                encode() {
                    return q.Buffer.from((0, Il.serialize)(Nl, this))
                }
                static decode(l) {
                    return (0, Il.deserialize)(Nl, this, l)
                }
                static decodeUnchecked(l) {
                    return (0, Il.deserializeUnchecked)(Nl, this, l)
                }
            }
            class L_ extends bp {
                constructor(l) {
                    if (super(l), this.enum = "", 1 !== Object.keys(l).length) throw new Error("Enum can only take single value");
                    Object.keys(l).map(d => {
                        this.enum = d
                    })
                }
            }
            const Nl = new Map,
                Su = 32,
                ac = 32;
            let k1 = 1;
            class ln extends bp {
                constructor(l) {
                    if (super({}), this._bn = void 0, function kI(g) {
                            return void 0 !== g._bn
                        }(l)) this._bn = l._bn;
                    else {
                        if ("string" == typeof l) {
                            const d = ps().decode(l);
                            if (d.length != ac) throw new Error("Invalid public key input");
                            this._bn = new(Ml())(d)
                        } else this._bn = new(Ml())(l);
                        if (this._bn.byteLength() > ac) throw new Error("Invalid public key input")
                    }
                }
                static unique() {
                    const l = new ln(k1);
                    return k1 += 1, new ln(l.toBuffer())
                }
                equals(l) {
                    return this._bn.eq(l._bn)
                }
                toBase58() {
                    return ps().encode(this.toBytes())
                }
                toJSON() {
                    return this.toBase58()
                }
                toBytes() {
                    const l = this.toBuffer();
                    return new Uint8Array(l.buffer, l.byteOffset, l.byteLength)
                }
                toBuffer() {
                    const l = this._bn.toArrayLike(q.Buffer);
                    if (l.length === ac) return l;
                    const d = q.Buffer.alloc(32);
                    return l.copy(d, 32 - l.length), d
                }
                get[Symbol.toStringTag]() {
                    return `PublicKey(${this.toString()})`
                }
                toString() {
                    return this.toBase58()
                }
                static createWithSeed(l, d, p) {
                    return (0, K.Z)(function*() {
                        const _ = q.Buffer.concat([l.toBuffer(), q.Buffer.from(d), p.toBuffer()]),
                            k = (0, vu.J)(_);
                        return new ln(k)
                    })()
                }
                static createProgramAddressSync(l, d) {
                    let p = q.Buffer.alloc(0);
                    l.forEach(function(k) {
                        if (k.length > Su) throw new TypeError("Max seed length exceeded");
                        p = q.Buffer.concat([p, Oi(k)])
                    }), p = q.Buffer.concat([p, d.toBuffer(), q.Buffer.from("ProgramDerivedAddress")]);
                    const _ = (0, vu.J)(p);
                    if (Tg(_)) throw new Error("Invalid seeds, address must fall off the curve");
                    return new ln(_)
                }
                static createProgramAddress(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        return p.createProgramAddressSync(l, d)
                    })()
                }
                static findProgramAddressSync(l, d) {
                    let _, p = 255;
                    for (; 0 != p;) {
                        try {
                            const k = l.concat(q.Buffer.from([p]));
                            _ = this.createProgramAddressSync(k, d)
                        } catch (k) {
                            if (k instanceof TypeError) throw k;
                            p--;
                            continue
                        }
                        return [_, p]
                    }
                    throw new Error("Unable to find a viable program address nonce")
                }
                static findProgramAddress(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        return p.findProgramAddressSync(l, d)
                    })()
                }
                static isOnCurve(l) {
                    return Tg(new ln(l).toBytes())
                }
            }
            ln.default = new ln("11111111111111111111111111111111"), Nl.set(ln, {
                kind: "struct",
                fields: [
                    ["_bn", "u256"]
                ]
            });
            class M1 {
                constructor(l) {
                    if (this._publicKey = void 0, this._secretKey = void 0, l) {
                        const d = Oi(l);
                        if (64 !== l.length) throw new Error("bad secret key size");
                        this._publicKey = d.slice(32, 64), this._secretKey = d.slice(0, 32)
                    } else this._secretKey = Oi(O_()), this._publicKey = Oi(Dd(this._secretKey))
                }
                get publicKey() {
                    return new ln(this._publicKey)
                }
                get secretKey() {
                    return q.Buffer.concat([this._secretKey, this._publicKey], 64)
                }
            }
            const I1 = new ln("BPFLoader1111111111111111111111111111111111"),
                Eu = 1232,
                jh = 127,
                Du = 64;
            class Eg extends Error {
                constructor(l) {
                    super(`Signature ${l} has expired: block height exceeded.`), this.signature = void 0, this.signature = l
                }
            }
            Object.defineProperty(Eg.prototype, "name", {
                value: "TransactionExpiredBlockheightExceededError"
            });
            class Wh extends Error {
                constructor(l, d) {
                    super(`Transaction was not confirmed in ${d.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${l} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = l
                }
            }
            Object.defineProperty(Wh.prototype, "name", {
                value: "TransactionExpiredTimeoutError"
            });
            class Gh extends Error {
                constructor(l) {
                    super(`Signature ${l} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = l
                }
            }
            Object.defineProperty(Gh.prototype, "name", {
                value: "TransactionExpiredNonceInvalidError"
            });
            class wp {
                constructor(l, d) {
                    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = l, this.accountKeysFromLookups = d
                }
                keySegments() {
                    const l = [this.staticAccountKeys];
                    return this.accountKeysFromLookups && (l.push(this.accountKeysFromLookups.writable), l.push(this.accountKeysFromLookups.readonly)), l
                }
                get(l) {
                    for (const d of this.keySegments()) {
                        if (l < d.length) return d[l];
                        l -= d.length
                    }
                }
                get length() {
                    return this.keySegments().flat().length
                }
                compileInstructions(l) {
                    if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
                    const p = new Map;
                    this.keySegments().flat().forEach((k, B) => {
                        p.set(k.toBase58(), B)
                    });
                    const _ = k => {
                        const B = p.get(k.toBase58());
                        if (void 0 === B) throw new Error("Encountered an unknown instruction account key during compilation");
                        return B
                    };
                    return l.map(k => ({
                        programIdIndex: _(k.programId),
                        accountKeyIndexes: k.keys.map(B => _(B.pubkey)),
                        data: k.data
                    }))
                }
            }
            const er = (g = "publicKey") => He.Ik(32, g),
                R_ = (g = "signature") => He.Ik(64, g),
                Fl = (g = "string") => {
                    const l = He.n_([He.Jq("length"), He.Jq("lengthPadding"), He.Ik(He.cv(He.Jq(), -8), "chars")], g),
                        d = l.decode.bind(l),
                        p = l.encode.bind(l),
                        _ = l;
                    return _.decode = (k, B) => d(k, B).chars.toString(), _.encode = (k, B, se) => {
                        const fe = {
                            chars: q.Buffer.from(k, "utf8")
                        };
                        return p(fe, B, se)
                    }, _.alloc = k => He.Jq().span + He.Jq().span + q.Buffer.from(k, "utf8").length, _
                };

            function N_(g, l) {
                const d = _ => {
                    if (_.span >= 0) return _.span;
                    if ("function" == typeof _.alloc) return _.alloc(l[_.property]);
                    if ("count" in _ && "elementLayout" in _) {
                        const k = l[_.property];
                        if (Array.isArray(k)) return k.length * d(_.elementLayout)
                    } else if ("fields" in _) return N_({
                        layout: _
                    }, l[_.property]);
                    return 0
                };
                let p = 0;
                return g.layout.fields.forEach(_ => {
                    p += d(_)
                }), p
            }

            function Fo(g) {
                let l = 0,
                    d = 0;
                for (;;) {
                    let p = g.shift();
                    if (l |= (127 & p) << 7 * d, d += 1, !(128 & p)) break
                }
                return l
            }

            function _a(g, l) {
                let d = l;
                for (;;) {
                    let p = 127 & d;
                    if (d >>= 7, 0 == d) {
                        g.push(p);
                        break
                    }
                    p |= 128, g.push(p)
                }
            }

            function Tr(g, l) {
                if (!g) throw new Error(l || "Assertion failed")
            }
            class xp {
                constructor(l, d) {
                    this.payer = void 0, this.keyMetaMap = void 0, this.payer = l, this.keyMetaMap = d
                }
                static compile(l, d) {
                    const p = new Map,
                        _ = B => {
                            const se = B.toBase58();
                            let fe = p.get(se);
                            return void 0 === fe && (fe = {
                                isSigner: !1,
                                isWritable: !1,
                                isInvoked: !1
                            }, p.set(se, fe)), fe
                        },
                        k = _(d);
                    k.isSigner = !0, k.isWritable = !0;
                    for (const B of l) {
                        _(B.programId).isInvoked = !0;
                        for (const se of B.keys) {
                            const fe = _(se.pubkey);
                            fe.isSigner || = se.isSigner, fe.isWritable || = se.isWritable
                        }
                    }
                    return new xp(d, p)
                }
                getMessageComponents() {
                    const l = [...this.keyMetaMap.entries()];
                    Tr(l.length <= 256, "Max static account keys length exceeded");
                    const d = l.filter(([, fe]) => fe.isSigner && fe.isWritable),
                        p = l.filter(([, fe]) => fe.isSigner && !fe.isWritable),
                        _ = l.filter(([, fe]) => !fe.isSigner && fe.isWritable),
                        k = l.filter(([, fe]) => !fe.isSigner && !fe.isWritable),
                        B = {
                            numRequiredSignatures: d.length + p.length,
                            numReadonlySignedAccounts: p.length,
                            numReadonlyUnsignedAccounts: k.length
                        }; {
                        Tr(d.length > 0, "Expected at least one writable signer key");
                        const [fe] = d[0];
                        Tr(fe === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
                    }
                    return [B, [...d.map(([fe]) => new ln(fe)), ...p.map(([fe]) => new ln(fe)), ..._.map(([fe]) => new ln(fe)), ...k.map(([fe]) => new ln(fe))]]
                }
                extractTableLookup(l) {
                    const [d, p] = this.drainKeysFoundInLookupTable(l.state.addresses, B => !B.isSigner && !B.isInvoked && B.isWritable), [_, k] = this.drainKeysFoundInLookupTable(l.state.addresses, B => !B.isSigner && !B.isInvoked && !B.isWritable);
                    if (0 !== d.length || 0 !== _.length) return [{
                        accountKey: l.key,
                        writableIndexes: d,
                        readonlyIndexes: _
                    }, {
                        writable: p,
                        readonly: k
                    }]
                }
                drainKeysFoundInLookupTable(l, d) {
                    const p = new Array,
                        _ = new Array;
                    for (const [k, B] of this.keyMetaMap.entries())
                        if (d(B)) {
                            const se = new ln(k),
                                fe = l.findIndex(Pe => Pe.equals(se));
                            fe >= 0 && (Tr(fe < 256, "Max lookup table index exceeded"), p.push(fe), _.push(se), this.keyMetaMap.delete(k))
                        }
                    return [p, _]
                }
            }
            const Xi = "Reached end of buffer unexpectedly";

            function cc(g) {
                if (0 === g.length) throw new Error(Xi);
                return g.shift()
            }

            function Jo(g, ...l) {
                const [d] = l;
                if (2 === l.length ? d + (l[1] ? ? 0) > g.length : d >= g.length) throw new Error(Xi);
                return g.splice(...l)
            }
            class lc {
                constructor(l) {
                    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = l.header, this.accountKeys = l.accountKeys.map(d => new ln(d)), this.recentBlockhash = l.recentBlockhash, this.instructions = l.instructions, this.instructions.forEach(d => this.indexToProgramIds.set(d.programIdIndex, this.accountKeys[d.programIdIndex]))
                }
                get version() {
                    return "legacy"
                }
                get staticAccountKeys() {
                    return this.accountKeys
                }
                get compiledInstructions() {
                    return this.instructions.map(l => ({
                        programIdIndex: l.programIdIndex,
                        accountKeyIndexes: l.accounts,
                        data: ps().decode(l.data)
                    }))
                }
                get addressTableLookups() {
                    return []
                }
                getAccountKeys() {
                    return new wp(this.staticAccountKeys)
                }
                static compile(l) {
                    const d = xp.compile(l.instructions, l.payerKey),
                        [p, _] = d.getMessageComponents(),
                        B = new wp(_).compileInstructions(l.instructions).map(se => ({
                            programIdIndex: se.programIdIndex,
                            accounts: se.accountKeyIndexes,
                            data: ps().encode(se.data)
                        }));
                    return new lc({
                        header: p,
                        accountKeys: _,
                        recentBlockhash: l.recentBlockhash,
                        instructions: B
                    })
                }
                isAccountSigner(l) {
                    return l < this.header.numRequiredSignatures
                }
                isAccountWritable(l) {
                    const d = this.header.numRequiredSignatures;
                    return l >= this.header.numRequiredSignatures ? l - d < this.accountKeys.length - d - this.header.numReadonlyUnsignedAccounts : l < d - this.header.numReadonlySignedAccounts
                }
                isProgramId(l) {
                    return this.indexToProgramIds.has(l)
                }
                programIds() {
                    return [...this.indexToProgramIds.values()]
                }
                nonProgramIds() {
                    return this.accountKeys.filter((l, d) => !this.isProgramId(d))
                }
                serialize() {
                    const l = this.accountKeys.length;
                    let d = [];
                    _a(d, l);
                    const p = this.instructions.map(Je => {
                        const {
                            accounts: yt,
                            programIdIndex: bt
                        } = Je, dt = Array.from(ps().decode(Je.data));
                        let qe = [];
                        _a(qe, yt.length);
                        let it = [];
                        return _a(it, dt.length), {
                            programIdIndex: bt,
                            keyIndicesCount: q.Buffer.from(qe),
                            keyIndices: yt,
                            dataLength: q.Buffer.from(it),
                            data: dt
                        }
                    });
                    let _ = [];
                    _a(_, p.length);
                    let k = q.Buffer.alloc(Eu);
                    q.Buffer.from(_).copy(k);
                    let B = _.length;
                    p.forEach(Je => {
                        const bt = He.n_([He.u8("programIdIndex"), He.Ik(Je.keyIndicesCount.length, "keyIndicesCount"), He.A9(He.u8("keyIndex"), Je.keyIndices.length, "keyIndices"), He.Ik(Je.dataLength.length, "dataLength"), He.A9(He.u8("userdatum"), Je.data.length, "data")]).encode(Je, k, B);
                        B += bt
                    }), k = k.slice(0, B);
                    const se = He.n_([He.Ik(1, "numRequiredSignatures"), He.Ik(1, "numReadonlySignedAccounts"), He.Ik(1, "numReadonlyUnsignedAccounts"), He.Ik(d.length, "keyCount"), He.A9(er("key"), l, "keys"), er("recentBlockhash")]),
                        fe = {
                            numRequiredSignatures: q.Buffer.from([this.header.numRequiredSignatures]),
                            numReadonlySignedAccounts: q.Buffer.from([this.header.numReadonlySignedAccounts]),
                            numReadonlyUnsignedAccounts: q.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                            keyCount: q.Buffer.from(d),
                            keys: this.accountKeys.map(Je => Oi(Je.toBytes())),
                            recentBlockhash: ps().decode(this.recentBlockhash)
                        };
                    let Pe = q.Buffer.alloc(2048);
                    const Ne = se.encode(fe, Pe);
                    return k.copy(Pe, Ne), Pe.slice(0, Ne + k.length)
                }
                static from(l) {
                    let d = [...l];
                    const p = cc(d);
                    if (p !== (p & jh)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
                    const _ = cc(d),
                        k = cc(d),
                        B = Fo(d);
                    let se = [];
                    for (let yt = 0; yt < B; yt++) {
                        const bt = Jo(d, 0, ac);
                        se.push(new ln(q.Buffer.from(bt)))
                    }
                    const fe = Jo(d, 0, ac),
                        Pe = Fo(d);
                    let Ne = [];
                    for (let yt = 0; yt < Pe; yt++) {
                        const bt = cc(d),
                            qe = Jo(d, 0, Fo(d)),
                            ft = Jo(d, 0, Fo(d)),
                            Pt = ps().encode(q.Buffer.from(ft));
                        Ne.push({
                            programIdIndex: bt,
                            accounts: qe,
                            data: Pt
                        })
                    }
                    const Je = {
                        header: {
                            numRequiredSignatures: p,
                            numReadonlySignedAccounts: _,
                            numReadonlyUnsignedAccounts: k
                        },
                        recentBlockhash: ps().encode(q.Buffer.from(fe)),
                        accountKeys: se,
                        instructions: Ne
                    };
                    return new lc(Je)
                }
            }
            class Vl {
                constructor(l) {
                    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = l.header, this.staticAccountKeys = l.staticAccountKeys, this.recentBlockhash = l.recentBlockhash, this.compiledInstructions = l.compiledInstructions, this.addressTableLookups = l.addressTableLookups
                }
                get version() {
                    return 0
                }
                get numAccountKeysFromLookups() {
                    let l = 0;
                    for (const d of this.addressTableLookups) l += d.readonlyIndexes.length + d.writableIndexes.length;
                    return l
                }
                getAccountKeys(l) {
                    let d;
                    if (l && "accountKeysFromLookups" in l && l.accountKeysFromLookups) {
                        if (this.numAccountKeysFromLookups != l.accountKeysFromLookups.writable.length + l.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                        d = l.accountKeysFromLookups
                    } else if (l && "addressLookupTableAccounts" in l && l.addressLookupTableAccounts) d = this.resolveAddressTableLookups(l.addressLookupTableAccounts);
                    else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
                    return new wp(this.staticAccountKeys, d)
                }
                isAccountSigner(l) {
                    return l < this.header.numRequiredSignatures
                }
                isAccountWritable(l) {
                    const d = this.header.numRequiredSignatures,
                        p = this.staticAccountKeys.length;
                    return l >= p ? l - p < this.addressTableLookups.reduce((B, se) => B + se.writableIndexes.length, 0) : l >= this.header.numRequiredSignatures ? l - d < p - d - this.header.numReadonlyUnsignedAccounts : l < d - this.header.numReadonlySignedAccounts
                }
                resolveAddressTableLookups(l) {
                    const d = {
                        writable: [],
                        readonly: []
                    };
                    for (const p of this.addressTableLookups) {
                        const _ = l.find(k => k.key.equals(p.accountKey));
                        if (!_) throw new Error(`Failed to find address lookup table account for table key ${p.accountKey.toBase58()}`);
                        for (const k of p.writableIndexes) {
                            if (!(k < _.state.addresses.length)) throw new Error(`Failed to find address for index ${k} in address lookup table ${p.accountKey.toBase58()}`);
                            d.writable.push(_.state.addresses[k])
                        }
                        for (const k of p.readonlyIndexes) {
                            if (!(k < _.state.addresses.length)) throw new Error(`Failed to find address for index ${k} in address lookup table ${p.accountKey.toBase58()}`);
                            d.readonly.push(_.state.addresses[k])
                        }
                    }
                    return d
                }
                static compile(l) {
                    const d = xp.compile(l.instructions, l.payerKey),
                        p = new Array,
                        _ = {
                            writable: new Array,
                            readonly: new Array
                        },
                        k = l.addressLookupTableAccounts || [];
                    for (const Ne of k) {
                        const Je = d.extractTableLookup(Ne);
                        if (void 0 !== Je) {
                            const [yt, {
                                writable: bt,
                                readonly: dt
                            }] = Je;
                            p.push(yt), _.writable.push(...bt), _.readonly.push(...dt)
                        }
                    }
                    const [B, se] = d.getMessageComponents(), Pe = new wp(se, _).compileInstructions(l.instructions);
                    return new Vl({
                        header: B,
                        staticAccountKeys: se,
                        recentBlockhash: l.recentBlockhash,
                        compiledInstructions: Pe,
                        addressTableLookups: p
                    })
                }
                serialize() {
                    const l = Array();
                    _a(l, this.staticAccountKeys.length);
                    const d = this.serializeInstructions(),
                        p = Array();
                    _a(p, this.compiledInstructions.length);
                    const _ = this.serializeAddressTableLookups(),
                        k = Array();
                    _a(k, this.addressTableLookups.length);
                    const B = He.n_([He.u8("prefix"), He.n_([He.u8("numRequiredSignatures"), He.u8("numReadonlySignedAccounts"), He.u8("numReadonlyUnsignedAccounts")], "header"), He.Ik(l.length, "staticAccountKeysLength"), He.A9(er(), this.staticAccountKeys.length, "staticAccountKeys"), er("recentBlockhash"), He.Ik(p.length, "instructionsLength"), He.Ik(d.length, "serializedInstructions"), He.Ik(k.length, "addressTableLookupsLength"), He.Ik(_.length, "serializedAddressTableLookups")]),
                        se = new Uint8Array(Eu),
                        Pe = B.encode({
                            prefix: 128,
                            header: this.header,
                            staticAccountKeysLength: new Uint8Array(l),
                            staticAccountKeys: this.staticAccountKeys.map(Ne => Ne.toBytes()),
                            recentBlockhash: ps().decode(this.recentBlockhash),
                            instructionsLength: new Uint8Array(p),
                            serializedInstructions: d,
                            addressTableLookupsLength: new Uint8Array(k),
                            serializedAddressTableLookups: _
                        }, se);
                    return se.slice(0, Pe)
                }
                serializeInstructions() {
                    let l = 0;
                    const d = new Uint8Array(Eu);
                    for (const p of this.compiledInstructions) {
                        const _ = Array();
                        _a(_, p.accountKeyIndexes.length);
                        const k = Array();
                        _a(k, p.data.length), l += He.n_([He.u8("programIdIndex"), He.Ik(_.length, "encodedAccountKeyIndexesLength"), He.A9(He.u8(), p.accountKeyIndexes.length, "accountKeyIndexes"), He.Ik(k.length, "encodedDataLength"), He.Ik(p.data.length, "data")]).encode({
                            programIdIndex: p.programIdIndex,
                            encodedAccountKeyIndexesLength: new Uint8Array(_),
                            accountKeyIndexes: p.accountKeyIndexes,
                            encodedDataLength: new Uint8Array(k),
                            data: p.data
                        }, d, l)
                    }
                    return d.slice(0, l)
                }
                serializeAddressTableLookups() {
                    let l = 0;
                    const d = new Uint8Array(Eu);
                    for (const p of this.addressTableLookups) {
                        const _ = Array();
                        _a(_, p.writableIndexes.length);
                        const k = Array();
                        _a(k, p.readonlyIndexes.length), l += He.n_([er("accountKey"), He.Ik(_.length, "encodedWritableIndexesLength"), He.A9(He.u8(), p.writableIndexes.length, "writableIndexes"), He.Ik(k.length, "encodedReadonlyIndexesLength"), He.A9(He.u8(), p.readonlyIndexes.length, "readonlyIndexes")]).encode({
                            accountKey: p.accountKey.toBytes(),
                            encodedWritableIndexesLength: new Uint8Array(_),
                            writableIndexes: p.writableIndexes,
                            encodedReadonlyIndexesLength: new Uint8Array(k),
                            readonlyIndexes: p.readonlyIndexes
                        }, d, l)
                    }
                    return d.slice(0, l)
                }
                static deserialize(l) {
                    let d = [...l];
                    const p = cc(d),
                        _ = p & jh;
                    Tr(p !== _, "Expected versioned message but received legacy message"), Tr(0 === _, `Expected versioned message with version 0 but found version ${_}`);
                    const B = {
                            numRequiredSignatures: cc(d),
                            numReadonlySignedAccounts: cc(d),
                            numReadonlyUnsignedAccounts: cc(d)
                        },
                        se = [],
                        fe = Fo(d);
                    for (let dt = 0; dt < fe; dt++) se.push(new ln(Jo(d, 0, ac)));
                    const Pe = ps().encode(Jo(d, 0, ac)),
                        Ne = Fo(d),
                        Je = [];
                    for (let dt = 0; dt < Ne; dt++) {
                        const qe = cc(d),
                            ft = Jo(d, 0, Fo(d)),
                            Pt = Fo(d),
                            Bt = new Uint8Array(Jo(d, 0, Pt));
                        Je.push({
                            programIdIndex: qe,
                            accountKeyIndexes: ft,
                            data: Bt
                        })
                    }
                    const yt = Fo(d),
                        bt = [];
                    for (let dt = 0; dt < yt; dt++) {
                        const qe = new ln(Jo(d, 0, ac)),
                            ft = Jo(d, 0, Fo(d)),
                            Bt = Jo(d, 0, Fo(d));
                        bt.push({
                            accountKey: qe,
                            writableIndexes: ft,
                            readonlyIndexes: Bt
                        })
                    }
                    return new Vl({
                        header: B,
                        staticAccountKeys: se,
                        recentBlockhash: Pe,
                        compiledInstructions: Je,
                        addressTableLookups: bt
                    })
                }
            }
            const Cp = {
                deserializeMessageVersion(g) {
                    const l = g[0],
                        d = l & jh;
                    return d === l ? "legacy" : d
                },
                deserialize: g => {
                    const l = Cp.deserializeMessageVersion(g);
                    if ("legacy" === l) return lc.from(g);
                    if (0 === l) return Vl.deserialize(g);
                    throw new Error(`Transaction message version ${l} deserialization is not supported`)
                }
            };
            let al = function(g) {
                return g[g.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", g[g.PROCESSED = 1] = "PROCESSED", g[g.TIMED_OUT = 2] = "TIMED_OUT", g[g.NONCE_INVALID = 3] = "NONCE_INVALID", g
            }({});
            const Dg = q.Buffer.alloc(Du).fill(0);
            class Hr {
                constructor(l) {
                    this.keys = void 0, this.programId = void 0, this.data = q.Buffer.alloc(0), this.programId = l.programId, this.keys = l.keys, l.data && (this.data = l.data)
                }
                toJSON() {
                    return {
                        keys: this.keys.map(({
                            pubkey: l,
                            isSigner: d,
                            isWritable: p
                        }) => ({
                            pubkey: l.toJSON(),
                            isSigner: d,
                            isWritable: p
                        })),
                        programId: this.programId.toJSON(),
                        data: [...this.data]
                    }
                }
            }
            class Fi {
                get signature() {
                    return this.signatures.length > 0 ? this.signatures[0].signature : null
                }
                constructor(l) {
                    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, l)
                        if (l.feePayer && (this.feePayer = l.feePayer), l.signatures && (this.signatures = l.signatures), Object.prototype.hasOwnProperty.call(l, "nonceInfo")) {
                            const {
                                minContextSlot: d,
                                nonceInfo: p
                            } = l;
                            this.minNonceContextSlot = d, this.nonceInfo = p
                        } else if (Object.prototype.hasOwnProperty.call(l, "lastValidBlockHeight")) {
                        const {
                            blockhash: d,
                            lastValidBlockHeight: p
                        } = l;
                        this.recentBlockhash = d, this.lastValidBlockHeight = p
                    } else {
                        const {
                            recentBlockhash: d,
                            nonceInfo: p
                        } = l;
                        p && (this.nonceInfo = p), this.recentBlockhash = d
                    }
                }
                toJSON() {
                    return {
                        recentBlockhash: this.recentBlockhash || null,
                        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                        nonceInfo: this.nonceInfo ? {
                            nonce: this.nonceInfo.nonce,
                            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                        } : null,
                        instructions: this.instructions.map(l => l.toJSON()),
                        signers: this.signatures.map(({
                            publicKey: l
                        }) => l.toJSON())
                    }
                }
                add(...l) {
                    if (0 === l.length) throw new Error("No instructions");
                    return l.forEach(d => {
                        "instructions" in d ? this.instructions = this.instructions.concat(d.instructions) : this.instructions.push("data" in d && "programId" in d && "keys" in d ? d : new Hr(d))
                    }), this
                }
                compileMessage() {
                    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
                    let l, d, p;
                    if (this.nonceInfo ? (l = this.nonceInfo.nonce, d = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (l = this.recentBlockhash, d = this.instructions), !l) throw new Error("Transaction recentBlockhash required");
                    if (d.length < 1 && console.warn("No instructions provided"), this.feePayer) p = this.feePayer;
                    else {
                        if (!(this.signatures.length > 0 && this.signatures[0].publicKey)) throw new Error("Transaction fee payer required");
                        p = this.signatures[0].publicKey
                    }
                    for (let qe = 0; qe < d.length; qe++)
                        if (void 0 === d[qe].programId) throw new Error(`Transaction instruction index ${qe} has undefined program id`);
                    const _ = [],
                        k = [];
                    d.forEach(qe => {
                        qe.keys.forEach(ft => {
                            k.push({ ...ft
                            })
                        });
                        const it = qe.programId.toString();
                        _.includes(it) || _.push(it)
                    }), _.forEach(qe => {
                        k.push({
                            pubkey: new ln(qe),
                            isSigner: !1,
                            isWritable: !1
                        })
                    });
                    const B = [];
                    k.forEach(qe => {
                        const it = qe.pubkey.toString(),
                            ft = B.findIndex(Pt => Pt.pubkey.toString() === it);
                        ft > -1 ? (B[ft].isWritable = B[ft].isWritable || qe.isWritable, B[ft].isSigner = B[ft].isSigner || qe.isSigner) : B.push(qe)
                    }), B.sort(function(qe, it) {
                        return qe.isSigner !== it.isSigner ? qe.isSigner ? -1 : 1 : qe.isWritable !== it.isWritable ? qe.isWritable ? -1 : 1 : qe.pubkey.toBase58().localeCompare(it.pubkey.toBase58(), "en", {
                            localeMatcher: "best fit",
                            usage: "sort",
                            sensitivity: "variant",
                            ignorePunctuation: !1,
                            numeric: !1,
                            caseFirst: "lower"
                        })
                    });
                    const se = B.findIndex(qe => qe.pubkey.equals(p));
                    if (se > -1) {
                        const [qe] = B.splice(se, 1);
                        qe.isSigner = !0, qe.isWritable = !0, B.unshift(qe)
                    } else B.unshift({
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !0
                    });
                    for (const qe of this.signatures) {
                        const it = B.findIndex(ft => ft.pubkey.equals(qe.publicKey));
                        if (!(it > -1)) throw new Error(`unknown signer: ${qe.publicKey.toString()}`);
                        B[it].isSigner || (B[it].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
                    }
                    let fe = 0,
                        Pe = 0,
                        Ne = 0;
                    const Je = [],
                        yt = [];
                    B.forEach(({
                        pubkey: qe,
                        isSigner: it,
                        isWritable: ft
                    }) => {
                        it ? (Je.push(qe.toString()), fe += 1, ft || (Pe += 1)) : (yt.push(qe.toString()), ft || (Ne += 1))
                    });
                    const bt = Je.concat(yt),
                        dt = d.map(qe => {
                            const {
                                data: it,
                                programId: ft
                            } = qe;
                            return {
                                programIdIndex: bt.indexOf(ft.toString()),
                                accounts: qe.keys.map(Pt => bt.indexOf(Pt.pubkey.toString())),
                                data: ps().encode(it)
                            }
                        });
                    return dt.forEach(qe => {
                        Tr(qe.programIdIndex >= 0), qe.accounts.forEach(it => Tr(it >= 0))
                    }), new lc({
                        header: {
                            numRequiredSignatures: fe,
                            numReadonlySignedAccounts: Pe,
                            numReadonlyUnsignedAccounts: Ne
                        },
                        accountKeys: bt,
                        recentBlockhash: l,
                        instructions: dt
                    })
                }
                _compile() {
                    const l = this.compileMessage(),
                        d = l.accountKeys.slice(0, l.header.numRequiredSignatures);
                    return this.signatures.length === d.length && this.signatures.every((_, k) => d[k].equals(_.publicKey)) || (this.signatures = d.map(p => ({
                        signature: null,
                        publicKey: p
                    }))), l
                }
                serializeMessage() {
                    return this._compile().serialize()
                }
                getEstimatedFee(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        return (yield l.getFeeForMessage(d.compileMessage())).value
                    })()
                }
                setSigners(...l) {
                    if (0 === l.length) throw new Error("No signers");
                    const d = new Set;
                    this.signatures = l.filter(p => {
                        const _ = p.toString();
                        return !d.has(_) && (d.add(_), !0)
                    }).map(p => ({
                        signature: null,
                        publicKey: p
                    }))
                }
                sign(...l) {
                    if (0 === l.length) throw new Error("No signers");
                    const d = new Set,
                        p = [];
                    for (const k of l) {
                        const B = k.publicKey.toString();
                        d.has(B) || (d.add(B), p.push(k))
                    }
                    this.signatures = p.map(k => ({
                        signature: null,
                        publicKey: k.publicKey
                    }));
                    const _ = this._compile();
                    this._partialSign(_, ...p)
                }
                partialSign(...l) {
                    if (0 === l.length) throw new Error("No signers");
                    const d = new Set,
                        p = [];
                    for (const k of l) {
                        const B = k.publicKey.toString();
                        d.has(B) || (d.add(B), p.push(k))
                    }
                    const _ = this._compile();
                    this._partialSign(_, ...p)
                }
                _partialSign(l, ...d) {
                    const p = l.serialize();
                    d.forEach(_ => {
                        const k = zh(p, _.secretKey);
                        this._addSignature(_.publicKey, Oi(k))
                    })
                }
                addSignature(l, d) {
                    this._compile(), this._addSignature(l, d)
                }
                _addSignature(l, d) {
                    Tr(64 === d.length);
                    const p = this.signatures.findIndex(_ => l.equals(_.publicKey));
                    if (p < 0) throw new Error(`unknown signer: ${l.toString()}`);
                    this.signatures[p].signature = q.Buffer.from(d)
                }
                verifySignatures(l = !0) {
                    return !this._getMessageSignednessErrors(this.serializeMessage(), l)
                }
                _getMessageSignednessErrors(l, d) {
                    const p = {};
                    for (const {
                            signature: _,
                            publicKey: k
                        } of this.signatures) null === _ ? d && (p.missing || = []).push(k) : Sg(_, l, k.toBytes()) || (p.invalid || = []).push(k);
                    return p.invalid || p.missing ? p : void 0
                }
                serialize(l) {
                    const {
                        requireAllSignatures: d,
                        verifySignatures: p
                    } = Object.assign({
                        requireAllSignatures: !0,
                        verifySignatures: !0
                    }, l), _ = this.serializeMessage();
                    if (p) {
                        const k = this._getMessageSignednessErrors(_, d);
                        if (k) {
                            let B = "Signature verification failed.";
                            throw k.invalid && (B += `\nInvalid signature for public key${1===k.invalid.length?"":"(s)"} [\`${k.invalid.map(se=>se.toBase58()).join("`, `")}\`].`), k.missing && (B += `\nMissing signature for public key${1===k.missing.length?"":"(s)"} [\`${k.missing.map(se=>se.toBase58()).join("`, `")}\`].`), new Error(B)
                        }
                    }
                    return this._serialize(_)
                }
                _serialize(l) {
                    const {
                        signatures: d
                    } = this, p = [];
                    _a(p, d.length);
                    const k = q.Buffer.alloc(p.length + 64 * d.length + l.length);
                    return Tr(d.length < 256), q.Buffer.from(p).copy(k, 0), d.forEach(({
                        signature: B
                    }, se) => {
                        null !== B && (Tr(64 === B.length, "signature has invalid length"), q.Buffer.from(B).copy(k, p.length + 64 * se))
                    }), l.copy(k, p.length + 64 * d.length), Tr(k.length <= Eu, `Transaction too large: ${k.length} > ${Eu}`), k
                }
                get keys() {
                    return Tr(1 === this.instructions.length), this.instructions[0].keys.map(l => l.pubkey)
                }
                get programId() {
                    return Tr(1 === this.instructions.length), this.instructions[0].programId
                }
                get data() {
                    return Tr(1 === this.instructions.length), this.instructions[0].data
                }
                static from(l) {
                    let d = [...l];
                    const p = Fo(d);
                    let _ = [];
                    for (let k = 0; k < p; k++) {
                        const B = Jo(d, 0, Du);
                        _.push(ps().encode(q.Buffer.from(B)))
                    }
                    return Fi.populate(lc.from(d), _)
                }
                static populate(l, d = []) {
                    const p = new Fi;
                    return p.recentBlockhash = l.recentBlockhash, l.header.numRequiredSignatures > 0 && (p.feePayer = l.accountKeys[0]), d.forEach((_, k) => {
                        const B = {
                            signature: _ == ps().encode(Dg) ? null : ps().decode(_),
                            publicKey: l.accountKeys[k]
                        };
                        p.signatures.push(B)
                    }), l.instructions.forEach(_ => {
                        const k = _.accounts.map(B => {
                            const se = l.accountKeys[B];
                            return {
                                pubkey: se,
                                isSigner: p.signatures.some(fe => fe.publicKey.toString() === se.toString()) || l.isAccountSigner(B),
                                isWritable: l.isAccountWritable(B)
                            }
                        });
                        p.instructions.push(new Hr({
                            keys: k,
                            programId: l.accountKeys[_.programIdIndex],
                            data: ps().decode(_.data)
                        }))
                    }), p._message = l, p._json = p.toJSON(), p
                }
            }
            class Tp {
                constructor(l) {
                    this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = l.payerKey, this.instructions = l.instructions, this.recentBlockhash = l.recentBlockhash
                }
                static decompile(l, d) {
                    const {
                        header: p,
                        compiledInstructions: _,
                        recentBlockhash: k
                    } = l, {
                        numRequiredSignatures: B,
                        numReadonlySignedAccounts: se,
                        numReadonlyUnsignedAccounts: fe
                    } = p, Pe = B - se;
                    Tr(Pe > 0, "Message header is invalid");
                    const Ne = l.staticAccountKeys.length - B - fe;
                    Tr(Ne >= 0, "Message header is invalid");
                    const Je = l.getAccountKeys(d),
                        yt = Je.get(0);
                    if (void 0 === yt) throw new Error("Failed to decompile message because no account keys were found");
                    const bt = [];
                    for (const dt of _) {
                        const qe = [];
                        for (const ft of dt.accountKeyIndexes) {
                            const Pt = Je.get(ft);
                            if (void 0 === Pt) throw new Error(`Failed to find key for account key index ${ft}`);
                            let pn;
                            pn = ft < B ? ft < Pe : ft < Je.staticAccountKeys.length ? ft - B < Ne : ft - Je.staticAccountKeys.length < Je.accountKeysFromLookups.writable.length, qe.push({
                                pubkey: Pt,
                                isSigner: ft < p.numRequiredSignatures,
                                isWritable: pn
                            })
                        }
                        const it = Je.get(dt.programIdIndex);
                        if (void 0 === it) throw new Error(`Failed to find program id for program id index ${dt.programIdIndex}`);
                        bt.push(new Hr({
                            programId: it,
                            data: Oi(dt.data),
                            keys: qe
                        }))
                    }
                    return new Tp({
                        payerKey: yt,
                        instructions: bt,
                        recentBlockhash: k
                    })
                }
                compileToLegacyMessage() {
                    return lc.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions
                    })
                }
                compileToV0Message(l) {
                    return Vl.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions,
                        addressLookupTableAccounts: l
                    })
                }
            }
            class Sp {
                get version() {
                    return this.message.version
                }
                constructor(l, d) {
                    if (this.signatures = void 0, this.message = void 0, void 0 !== d) Tr(d.length === l.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = d;
                    else {
                        const p = [];
                        for (let _ = 0; _ < l.header.numRequiredSignatures; _++) p.push(new Uint8Array(Du));
                        this.signatures = p
                    }
                    this.message = l
                }
                serialize() {
                    const l = this.message.serialize(),
                        d = Array();
                    _a(d, this.signatures.length);
                    const p = He.n_([He.Ik(d.length, "encodedSignaturesLength"), He.A9(R_(), this.signatures.length, "signatures"), He.Ik(l.length, "serializedMessage")]),
                        _ = new Uint8Array(2048),
                        k = p.encode({
                            encodedSignaturesLength: new Uint8Array(d),
                            signatures: this.signatures,
                            serializedMessage: l
                        }, _);
                    return _.slice(0, k)
                }
                static deserialize(l) {
                    let d = [...l];
                    const p = [],
                        _ = Fo(d);
                    for (let B = 0; B < _; B++) p.push(new Uint8Array(Jo(d, 0, Du)));
                    const k = Cp.deserialize(new Uint8Array(d));
                    return new Sp(k, p)
                }
                sign(l) {
                    const d = this.message.serialize(),
                        p = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
                    for (const _ of l) {
                        const k = p.findIndex(B => B.equals(_.publicKey));
                        Tr(k >= 0, `Cannot sign with non signer key ${_.publicKey.toBase58()}`), this.signatures[k] = zh(d, _.secretKey)
                    }
                }
                addSignature(l, d) {
                    Tr(64 === d.byteLength, "Signature must be 64 bytes long");
                    const _ = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(k => k.equals(l));
                    Tr(_ >= 0, `Can not add signature; \`${l.toBase58()}\` is not required to sign this transaction`), this.signatures[_] = d
                }
            }
            const Bc = new ln("SysvarC1ock11111111111111111111111111111111"),
                V_ = new ln("SysvarEpochSchedu1e111111111111111111111111"),
                kd = new ln("Sysvar1nstructions1111111111111111111111111"),
                So = new ln("SysvarRecentB1ockHashes11111111111111111111"),
                Md = new ln("SysvarRent111111111111111111111111111111111"),
                R1 = new ln("SysvarRewards111111111111111111111111111111"),
                B1 = new ln("SysvarS1otHashes111111111111111111111111111"),
                Ul = new ln("SysvarS1otHistory11111111111111111111111111"),
                Kh = new ln("SysvarStakeHistory1111111111111111111111111");

            function kg(g, l, d, p) {
                return Ep.apply(this, arguments)
            }

            function Ep() {
                return (Ep = (0, K.Z)(function*(g, l, d, p) {
                    const _ = p && {
                            skipPreflight: p.skipPreflight,
                            preflightCommitment: p.preflightCommitment || p.commitment,
                            maxRetries: p.maxRetries,
                            minContextSlot: p.minContextSlot
                        },
                        k = yield g.sendTransaction(l, d, _);
                    let B;
                    if (null != l.recentBlockhash && null != l.lastValidBlockHeight) B = (yield g.confirmTransaction({
                        abortSignal: p ? .abortSignal,
                        signature: k,
                        blockhash: l.recentBlockhash,
                        lastValidBlockHeight: l.lastValidBlockHeight
                    }, p && p.commitment)).value;
                    else if (null != l.minNonceContextSlot && null != l.nonceInfo) {
                        const {
                            nonceInstruction: se
                        } = l.nonceInfo, fe = se.keys[0].pubkey;
                        B = (yield g.confirmTransaction({
                            abortSignal: p ? .abortSignal,
                            minContextSlot: l.minNonceContextSlot,
                            nonceAccountPubkey: fe,
                            nonceValue: l.nonceInfo.nonce,
                            signature: k
                        }, p && p.commitment)).value
                    } else null != p ? .abortSignal && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), B = (yield g.confirmTransaction(k, p && p.commitment)).value;
                    if (B.err) throw new Error(`Transaction ${k} failed (${JSON.stringify(B)})`);
                    return k
                })).apply(this, arguments)
            }

            function Hl(g) {
                return new Promise(l => setTimeout(l, g))
            }

            function ar(g, l) {
                const d = g.layout.span >= 0 ? g.layout.span : N_(g, l),
                    p = q.Buffer.alloc(d),
                    _ = Object.assign({
                        instruction: g.index
                    }, l);
                return g.layout.encode(_, p), p
            }

            function Dr(g, l) {
                let d;
                try {
                    d = g.layout.decode(l)
                } catch (p) {
                    throw new Error("invalid instruction; " + p)
                }
                if (d.instruction !== g.index) throw new Error(`invalid instruction; instruction index mismatch ${d.instruction} != ${g.index}`);
                return d
            }
            const mi = He._O("lamportsPerSignature"),
                Mg = He.n_([He.Jq("version"), He.Jq("state"), er("authorizedPubkey"), er("nonce"), He.n_([mi], "feeCalculator")]),
                U_ = Mg.span;
            class Dp {
                constructor(l) {
                    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = l.authorizedPubkey, this.nonce = l.nonce, this.feeCalculator = l.feeCalculator
                }
                static fromAccountData(l) {
                    const d = Mg.decode(Oi(l), 0);
                    return new Dp({
                        authorizedPubkey: new ln(d.authorizedPubkey),
                        nonce: new ln(d.nonce).toString(),
                        feeCalculator: d.feeCalculator
                    })
                }
            }
            const Au = l => {
                const d = (0, He.Ik)(8, l),
                    {
                        encode: p,
                        decode: _
                    } = {
                        decode: (g = d).decode.bind(g),
                        encode: g.encode.bind(g)
                    },
                    k = d;
                var g;
                return k.decode = (B, se) => {
                    const fe = _(B, se);
                    return (0, La.oU)(q.Buffer.from(fe))
                }, k.encode = (B, se, fe) => {
                    const Pe = (0, La.k$)(B, 8);
                    return p(Pe, se, fe)
                }, k
            };
            class Id {
                constructor() {}
                static decodeInstructionType(l) {
                    this.checkProgramId(l.programId);
                    const p = He.Jq("instruction").decode(l.data);
                    let _;
                    for (const [k, B] of Object.entries(qr))
                        if (B.index == p) {
                            _ = k;
                            break
                        }
                    if (!_) throw new Error("Instruction type incorrect; not a SystemInstruction");
                    return _
                }
                static decodeCreateAccount(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        lamports: d,
                        space: p,
                        programId: _
                    } = Dr(qr.Create, l.data);
                    return {
                        fromPubkey: l.keys[0].pubkey,
                        newAccountPubkey: l.keys[1].pubkey,
                        lamports: d,
                        space: p,
                        programId: new ln(_)
                    }
                }
                static decodeTransfer(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        lamports: d
                    } = Dr(qr.Transfer, l.data);
                    return {
                        fromPubkey: l.keys[0].pubkey,
                        toPubkey: l.keys[1].pubkey,
                        lamports: d
                    }
                }
                static decodeTransferWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        lamports: d,
                        seed: p,
                        programId: _
                    } = Dr(qr.TransferWithSeed, l.data);
                    return {
                        fromPubkey: l.keys[0].pubkey,
                        basePubkey: l.keys[1].pubkey,
                        toPubkey: l.keys[2].pubkey,
                        lamports: d,
                        seed: p,
                        programId: new ln(_)
                    }
                }
                static decodeAllocate(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 1);
                    const {
                        space: d
                    } = Dr(qr.Allocate, l.data);
                    return {
                        accountPubkey: l.keys[0].pubkey,
                        space: d
                    }
                }
                static decodeAllocateWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 1);
                    const {
                        base: d,
                        seed: p,
                        space: _,
                        programId: k
                    } = Dr(qr.AllocateWithSeed, l.data);
                    return {
                        accountPubkey: l.keys[0].pubkey,
                        basePubkey: new ln(d),
                        seed: p,
                        space: _,
                        programId: new ln(k)
                    }
                }
                static decodeAssign(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 1);
                    const {
                        programId: d
                    } = Dr(qr.Assign, l.data);
                    return {
                        accountPubkey: l.keys[0].pubkey,
                        programId: new ln(d)
                    }
                }
                static decodeAssignWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 1);
                    const {
                        base: d,
                        seed: p,
                        programId: _
                    } = Dr(qr.AssignWithSeed, l.data);
                    return {
                        accountPubkey: l.keys[0].pubkey,
                        basePubkey: new ln(d),
                        seed: p,
                        programId: new ln(_)
                    }
                }
                static decodeCreateWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        base: d,
                        seed: p,
                        lamports: _,
                        space: k,
                        programId: B
                    } = Dr(qr.CreateWithSeed, l.data);
                    return {
                        fromPubkey: l.keys[0].pubkey,
                        newAccountPubkey: l.keys[1].pubkey,
                        basePubkey: new ln(d),
                        seed: p,
                        lamports: _,
                        space: k,
                        programId: new ln(B)
                    }
                }
                static decodeNonceInitialize(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        authorized: d
                    } = Dr(qr.InitializeNonceAccount, l.data);
                    return {
                        noncePubkey: l.keys[0].pubkey,
                        authorizedPubkey: new ln(d)
                    }
                }
                static decodeNonceAdvance(l) {
                    return this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3), Dr(qr.AdvanceNonceAccount, l.data), {
                        noncePubkey: l.keys[0].pubkey,
                        authorizedPubkey: l.keys[2].pubkey
                    }
                }
                static decodeNonceWithdraw(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 5);
                    const {
                        lamports: d
                    } = Dr(qr.WithdrawNonceAccount, l.data);
                    return {
                        noncePubkey: l.keys[0].pubkey,
                        toPubkey: l.keys[1].pubkey,
                        authorizedPubkey: l.keys[4].pubkey,
                        lamports: d
                    }
                }
                static decodeNonceAuthorize(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        authorized: d
                    } = Dr(qr.AuthorizeNonceAccount, l.data);
                    return {
                        noncePubkey: l.keys[0].pubkey,
                        authorizedPubkey: l.keys[1].pubkey,
                        newAuthorizedPubkey: new ln(d)
                    }
                }
                static checkProgramId(l) {
                    if (!l.equals(ro.programId)) throw new Error("invalid instruction; programId is not SystemProgram")
                }
                static checkKeyLength(l, d) {
                    if (l.length < d) throw new Error(`invalid instruction; found ${l.length} keys, expected at least ${d}`)
                }
            }
            const qr = Object.freeze({
                Create: {
                    index: 0,
                    layout: He.n_([He.Jq("instruction"), He.gM("lamports"), He.gM("space"), er("programId")])
                },
                Assign: {
                    index: 1,
                    layout: He.n_([He.Jq("instruction"), er("programId")])
                },
                Transfer: {
                    index: 2,
                    layout: He.n_([He.Jq("instruction"), Au("lamports")])
                },
                CreateWithSeed: {
                    index: 3,
                    layout: He.n_([He.Jq("instruction"), er("base"), Fl("seed"), He.gM("lamports"), He.gM("space"), er("programId")])
                },
                AdvanceNonceAccount: {
                    index: 4,
                    layout: He.n_([He.Jq("instruction")])
                },
                WithdrawNonceAccount: {
                    index: 5,
                    layout: He.n_([He.Jq("instruction"), He.gM("lamports")])
                },
                InitializeNonceAccount: {
                    index: 6,
                    layout: He.n_([He.Jq("instruction"), er("authorized")])
                },
                AuthorizeNonceAccount: {
                    index: 7,
                    layout: He.n_([He.Jq("instruction"), er("authorized")])
                },
                Allocate: {
                    index: 8,
                    layout: He.n_([He.Jq("instruction"), He.gM("space")])
                },
                AllocateWithSeed: {
                    index: 9,
                    layout: He.n_([He.Jq("instruction"), er("base"), Fl("seed"), He.gM("space"), er("programId")])
                },
                AssignWithSeed: {
                    index: 10,
                    layout: He.n_([He.Jq("instruction"), er("base"), Fl("seed"), er("programId")])
                },
                TransferWithSeed: {
                    index: 11,
                    layout: He.n_([He.Jq("instruction"), Au("lamports"), Fl("seed"), er("programId")])
                },
                UpgradeNonceAccount: {
                    index: 12,
                    layout: He.n_([He.Jq("instruction")])
                }
            });
            class ro {
                constructor() {}
                static createAccount(l) {
                    const p = ar(qr.Create, {
                        lamports: l.lamports,
                        space: l.space,
                        programId: Oi(l.programId.toBuffer())
                    });
                    return new Hr({
                        keys: [{
                            pubkey: l.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: l.newAccountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }],
                        programId: this.programId,
                        data: p
                    })
                }
                static transfer(l) {
                    let d, p;
                    return "basePubkey" in l ? (d = ar(qr.TransferWithSeed, {
                        lamports: BigInt(l.lamports),
                        seed: l.seed,
                        programId: Oi(l.programId.toBuffer())
                    }), p = [{
                        pubkey: l.fromPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: l.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: l.toPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }]) : (d = ar(qr.Transfer, {
                        lamports: BigInt(l.lamports)
                    }), p = [{
                        pubkey: l.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: l.toPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }]), new Hr({
                        keys: p,
                        programId: this.programId,
                        data: d
                    })
                }
                static assign(l) {
                    let d, p;
                    return "basePubkey" in l ? (d = ar(qr.AssignWithSeed, {
                        base: Oi(l.basePubkey.toBuffer()),
                        seed: l.seed,
                        programId: Oi(l.programId.toBuffer())
                    }), p = [{
                        pubkey: l.accountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: l.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }]) : (d = ar(qr.Assign, {
                        programId: Oi(l.programId.toBuffer())
                    }), p = [{
                        pubkey: l.accountPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }]), new Hr({
                        keys: p,
                        programId: this.programId,
                        data: d
                    })
                }
                static createAccountWithSeed(l) {
                    const p = ar(qr.CreateWithSeed, {
                        base: Oi(l.basePubkey.toBuffer()),
                        seed: l.seed,
                        lamports: l.lamports,
                        space: l.space,
                        programId: Oi(l.programId.toBuffer())
                    });
                    let _ = [{
                        pubkey: l.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: l.newAccountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }];
                    return l.basePubkey != l.fromPubkey && _.push({
                        pubkey: l.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }), new Hr({
                        keys: _,
                        programId: this.programId,
                        data: p
                    })
                }
                static createNonceAccount(l) {
                    const d = new Fi;
                    return d.add("basePubkey" in l && "seed" in l ? ro.createAccountWithSeed({
                        fromPubkey: l.fromPubkey,
                        newAccountPubkey: l.noncePubkey,
                        basePubkey: l.basePubkey,
                        seed: l.seed,
                        lamports: l.lamports,
                        space: U_,
                        programId: this.programId
                    }) : ro.createAccount({
                        fromPubkey: l.fromPubkey,
                        newAccountPubkey: l.noncePubkey,
                        lamports: l.lamports,
                        space: U_,
                        programId: this.programId
                    })), d.add(this.nonceInitialize({
                        noncePubkey: l.noncePubkey,
                        authorizedPubkey: l.authorizedPubkey
                    })), d
                }
                static nonceInitialize(l) {
                    const p = ar(qr.InitializeNonceAccount, {
                        authorized: Oi(l.authorizedPubkey.toBuffer())
                    });
                    return new Hr({
                        keys: [{
                            pubkey: l.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: So,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Md,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: p
                    })
                }
                static nonceAdvance(l) {
                    const p = ar(qr.AdvanceNonceAccount);
                    return new Hr({
                        keys: [{
                            pubkey: l.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: So,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: l.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: p
                    })
                }
                static nonceWithdraw(l) {
                    const p = ar(qr.WithdrawNonceAccount, {
                        lamports: l.lamports
                    });
                    return new Hr({
                        keys: [{
                            pubkey: l.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: So,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Md,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: l.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: p
                    })
                }
                static nonceAuthorize(l) {
                    const p = ar(qr.AuthorizeNonceAccount, {
                        authorized: Oi(l.newAuthorizedPubkey.toBuffer())
                    });
                    return new Hr({
                        keys: [{
                            pubkey: l.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: p
                    })
                }
                static allocate(l) {
                    let d, p;
                    return "basePubkey" in l ? (d = ar(qr.AllocateWithSeed, {
                        base: Oi(l.basePubkey.toBuffer()),
                        seed: l.seed,
                        space: l.space,
                        programId: Oi(l.programId.toBuffer())
                    }), p = [{
                        pubkey: l.accountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: l.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }]) : (d = ar(qr.Allocate, {
                        space: l.space
                    }), p = [{
                        pubkey: l.accountPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }]), new Hr({
                        keys: p,
                        programId: this.programId,
                        data: d
                    })
                }
            }
            ro.programId = new ln("11111111111111111111111111111111");
            const F1 = Eu - 300;
            let Ig = (() => {
                class g {
                    constructor() {}
                    static getMinNumSignatures(d) {
                        return 2 * (Math.ceil(d / g.chunkSize) + 1 + 1)
                    }
                    static load(d, p, _, k, B) {
                        return (0, K.Z)(function*() {
                            {
                                const yt = yield d.getMinimumBalanceForRentExemption(B.length), bt = yield d.getAccountInfo(_.publicKey, "confirmed");
                                let dt = null;
                                if (null !== bt) {
                                    if (bt.executable) return console.error("Program load failed, account is already executable"), !1;
                                    bt.data.length !== B.length && (dt = dt || new Fi, dt.add(ro.allocate({
                                        accountPubkey: _.publicKey,
                                        space: B.length
                                    }))), bt.owner.equals(k) || (dt = dt || new Fi, dt.add(ro.assign({
                                        accountPubkey: _.publicKey,
                                        programId: k
                                    }))), bt.lamports < yt && (dt = dt || new Fi, dt.add(ro.transfer({
                                        fromPubkey: p.publicKey,
                                        toPubkey: _.publicKey,
                                        lamports: yt - bt.lamports
                                    })))
                                } else dt = (new Fi).add(ro.createAccount({
                                    fromPubkey: p.publicKey,
                                    newAccountPubkey: _.publicKey,
                                    lamports: yt > 0 ? yt : 1,
                                    space: B.length,
                                    programId: k
                                }));
                                null !== dt && (yield kg(d, dt, [p, _], {
                                    commitment: "confirmed"
                                }))
                            }
                            const se = He.n_([He.Jq("instruction"), He.Jq("offset"), He.Jq("bytesLength"), He.Jq("bytesLengthPadding"), He.A9(He.u8("byte"), He.cv(He.Jq(), -8), "bytes")]),
                                fe = g.chunkSize;
                            let Pe = 0,
                                Ne = B,
                                Je = [];
                            for (; Ne.length > 0;) {
                                const yt = Ne.slice(0, fe),
                                    bt = q.Buffer.alloc(fe + 16);
                                se.encode({
                                    instruction: 0,
                                    offset: Pe,
                                    bytes: yt,
                                    bytesLength: 0,
                                    bytesLengthPadding: 0
                                }, bt);
                                const dt = (new Fi).add({
                                    keys: [{
                                        pubkey: _.publicKey,
                                        isSigner: !0,
                                        isWritable: !0
                                    }],
                                    programId: k,
                                    data: bt
                                });
                                Je.push(kg(d, dt, [p, _], {
                                    commitment: "confirmed"
                                })), d._rpcEndpoint.includes("solana.com") && (yield Hl(250)), Pe += fe, Ne = Ne.slice(fe)
                            }
                            yield Promise.all(Je); {
                                const yt = He.n_([He.Jq("instruction")]),
                                    bt = q.Buffer.alloc(yt.span);
                                yt.encode({
                                    instruction: 1
                                }, bt);
                                const dt = (new Fi).add({
                                        keys: [{
                                            pubkey: _.publicKey,
                                            isSigner: !0,
                                            isWritable: !0
                                        }, {
                                            pubkey: Md,
                                            isSigner: !1,
                                            isWritable: !1
                                        }],
                                        programId: k,
                                        data: bt
                                    }),
                                    qe = "processed",
                                    it = yield d.sendTransaction(dt, [p, _], {
                                        preflightCommitment: qe
                                    }), {
                                        context: ft,
                                        value: Pt
                                    } = yield d.confirmTransaction({
                                        signature: it,
                                        lastValidBlockHeight: dt.lastValidBlockHeight,
                                        blockhash: dt.recentBlockhash
                                    }, qe);
                                if (Pt.err) throw new Error(`Transaction ${it} failed (${JSON.stringify(Pt)})`);
                                for (;;) {
                                    try {
                                        if ((yield d.getSlot({
                                                commitment: qe
                                            })) > ft.slot) break
                                    } catch {}
                                    yield new Promise(Bt => setTimeout(Bt, Math.round(200)))
                                }
                            }
                            return !0
                        })()
                    }
                }
                return g.chunkSize = F1, g
            })();
            const V1 = new ln("BPFLoader2111111111111111111111111111111111");
            class It {
                static getMinNumSignatures(l) {
                    return Ig.getMinNumSignatures(l)
                }
                static load(l, d, p, _, k) {
                    return Ig.load(l, d, p, k, _)
                }
            }

            function ur(g) {
                return g && g.__esModule && Object.prototype.hasOwnProperty.call(g, "default") ? g.default : g
            }
            var Nt = Object.prototype.toString,
                Ft = Object.keys || function(g) {
                    var l = [];
                    for (var d in g) l.push(d);
                    return l
                };

            function Cs(g, l) {
                var d, p, _, k, B, se, fe;
                if (!0 === g) return "true";
                if (!1 === g) return "false";
                switch (typeof g) {
                    case "object":
                        if (null === g) return null;
                        if (g.toJSON && "function" == typeof g.toJSON) return Cs(g.toJSON(), l);
                        if ("[object Array]" === (fe = Nt.call(g))) {
                            for (_ = "[", p = g.length - 1, d = 0; d < p; d++) _ += Cs(g[d], !0) + ",";
                            return p > -1 && (_ += Cs(g[d], !0)), _ + "]"
                        }
                        if ("[object Object]" === fe) {
                            for (p = (k = Ft(g).sort()).length, _ = "", d = 0; d < p;) void 0 !== (se = Cs(g[B = k[d]], !1)) && (_ && (_ += ","), _ += JSON.stringify(B) + ":" + se), d++;
                            return "{" + _ + "}"
                        }
                        return JSON.stringify(g);
                    case "function":
                    case "undefined":
                        return l ? null : void 0;
                    case "string":
                        return JSON.stringify(g);
                    default:
                        return isFinite(g) ? g : null
                }
            }
            var Pd = ur(function(g) {
                var l = Cs(g, !1);
                if (void 0 !== l) return "" + l
            });

            function qh(g) {
                let l = 0;
                for (; g > 1;) g /= 2, l++;
                return l
            }
            class $_ {
                constructor(l, d, p, _, k) {
                    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = l, this.leaderScheduleSlotOffset = d, this.warmup = p, this.firstNormalEpoch = _, this.firstNormalSlot = k
                }
                getEpoch(l) {
                    return this.getEpochAndSlotIndex(l)[0]
                }
                getEpochAndSlotIndex(l) {
                    if (l < this.firstNormalSlot) {
                        const d = qh(function Pg(g) {
                            return 0 === g ? 1 : (g--, g |= g >> 1, g |= g >> 2, g |= g >> 4, g |= g >> 8, g |= g >> 16, 1 + (g |= g >> 32))
                        }(l + 32 + 1)) - qh(32) - 1;
                        return [d, l - (this.getSlotsInEpoch(d) - 32)]
                    } {
                        const d = l - this.firstNormalSlot,
                            p = Math.floor(d / this.slotsPerEpoch);
                        return [this.firstNormalEpoch + p, d % this.slotsPerEpoch]
                    }
                }
                getFirstSlotInEpoch(l) {
                    return l <= this.firstNormalEpoch ? 32 * (Math.pow(2, l) - 1) : (l - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
                }
                getLastSlotInEpoch(l) {
                    return this.getFirstSlotInEpoch(l) + this.getSlotsInEpoch(l) - 1
                }
                getSlotsInEpoch(l) {
                    return l < this.firstNormalEpoch ? Math.pow(2, l + qh(32)) : this.slotsPerEpoch
                }
            }
            class z_ extends Error {
                constructor(l, d) {
                    super(l), this.logs = void 0, this.logs = d
                }
            }
            const j_ = {
                JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
                JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
                JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
                JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
                JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
                JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
                JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
                JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
                JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
                JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
                JSON_RPC_SCAN_ERROR: -32012,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
                JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
                JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
                JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
            };
            class wn extends Error {
                constructor({
                    code: l,
                    message: d,
                    data: p
                }, _) {
                    super(null != _ ? `${_}: ${d}` : d), this.code = void 0, this.data = void 0, this.code = l, this.data = p, this.name = "SolanaJSONRPCError"
                }
            }
            var cl = globalThis.fetch;
            class W_ extends lo.Z {
                constructor(l, d, p) {
                    super(k => {
                        const B = (0, X.Z)(k, {
                            autoconnect: !0,
                            max_reconnects: 5,
                            reconnect: !0,
                            reconnect_interval: 1e3,
                            ...d
                        });
                        return this.underlyingSocket = "socket" in B ? B.socket : B, B
                    }, l, d, p), this.underlyingSocket = void 0
                }
                call(...l) {
                    const d = this.underlyingSocket ? .readyState;
                    return 1 === d ? super.call(...l) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + l[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + d + ")"))
                }
                notify(...l) {
                    const d = this.underlyingSocket ? .readyState;
                    return 1 === d ? super.notify(...l) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + l[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + d + ")"))
                }
            }
            class Og {
                constructor(l) {
                    this.key = void 0, this.state = void 0, this.key = l.key, this.state = l.state
                }
                isActive() {
                    const l = BigInt("0xffffffffffffffff");
                    return this.state.deactivationSlot === l
                }
                static deserialize(l) {
                    const d = function Od(g, l) {
                            let d;
                            try {
                                d = g.layout.decode(l)
                            } catch (p) {
                                throw new Error("invalid instruction; " + p)
                            }
                            if (d.typeIndex !== g.index) throw new Error(`invalid account data; account type mismatch ${d.typeIndex} != ${g.index}`);
                            return d
                        }(G_, l),
                        p = l.length - 56;
                    Tr(p >= 0, "lookup table is invalid"), Tr(p % 32 == 0, "lookup table is invalid");
                    const _ = p / 32,
                        {
                            addresses: k
                        } = He.n_([He.A9(er(), _, "addresses")]).decode(l.slice(56));
                    return {
                        deactivationSlot: d.deactivationSlot,
                        lastExtendedSlot: d.lastExtendedSlot,
                        lastExtendedSlotStartIndex: d.lastExtendedStartIndex,
                        authority: 0 !== d.authority.length ? new ln(d.authority[0]) : void 0,
                        addresses: k.map(B => new ln(B))
                    }
                }
            }
            const G_ = {
                    index: 1,
                    layout: He.n_([He.Jq("typeIndex"), Au("deactivationSlot"), He._O("lastExtendedSlot"), He.u8("lastExtendedStartIndex"), He.u8(), He.A9(er(), He.cv(He.u8(), -1), "authority")])
                },
                U1 = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i,
                gs = Fa(Ll(ln), Jt(), g => new ln(g)),
                Ap = Rl([Jt(), Pr("base64")]),
                kp = Fa(Ll(q.Buffer), Ap, g => q.Buffer.from(g[0], "base64")),
                Mp = 3e4;

            function Qr(g) {
                let l, d;
                if ("string" == typeof g) l = g;
                else if (g) {
                    const {
                        commitment: p,
                        ..._
                    } = g;
                    l = p, d = _
                }
                return {
                    commitment: l,
                    config: d
                }
            }

            function Ip(g) {
                return xn([Ot({
                    jsonrpc: Pr("2.0"),
                    id: Jt(),
                    result: g
                }), Ot({
                    jsonrpc: Pr("2.0"),
                    id: Jt(),
                    error: Ot({
                        code: Na(),
                        message: Jt(),
                        data: Yn(Vn("any", () => !0))
                    })
                })])
            }
            const K_ = Ip(Na());

            function Li(g) {
                return Fa(Ip(g), K_, l => "error" in l ? l : { ...l,
                    result: $t(l.result, g)
                })
            }

            function us(g) {
                return Li(Ot({
                    context: Ot({
                        slot: ct()
                    }),
                    value: g
                }))
            }

            function Zh(g) {
                return Ot({
                    context: Ot({
                        slot: ct()
                    }),
                    value: g
                })
            }

            function Yh(g, l) {
                return 0 === g ? new Vl({
                    header: l.header,
                    staticAccountKeys: l.accountKeys.map(d => new ln(d)),
                    recentBlockhash: l.recentBlockhash,
                    compiledInstructions: l.instructions.map(d => ({
                        programIdIndex: d.programIdIndex,
                        accountKeyIndexes: d.accounts,
                        data: ps().decode(d.data)
                    })),
                    addressTableLookups: l.addressTableLookups
                }) : new lc(l)
            }
            const z1 = Ot({
                    foundation: ct(),
                    foundationTerm: ct(),
                    initial: ct(),
                    taper: ct(),
                    terminal: ct()
                }),
                j1 = Li(dn(fn(Ot({
                    epoch: ct(),
                    effectiveSlot: ct(),
                    amount: ct(),
                    postBalance: ct(),
                    commission: Yn(fn(ct()))
                })))),
                Uo = dn(Ot({
                    slot: ct(),
                    prioritizationFee: ct()
                })),
                ku = Ot({
                    total: ct(),
                    validator: ct(),
                    foundation: ct(),
                    epoch: ct()
                }),
                ds = Ot({
                    epoch: ct(),
                    slotIndex: ct(),
                    slotsInEpoch: ct(),
                    absoluteSlot: ct(),
                    blockHeight: Yn(ct()),
                    transactionCount: Yn(ct())
                }),
                Pn = Ot({
                    slotsPerEpoch: ct(),
                    leaderScheduleSlotOffset: ct(),
                    warmup: Bo(),
                    firstNormalEpoch: ct(),
                    firstNormalSlot: ct()
                }),
                W1 = vd(Jt(), dn(ct())),
                Fc = fn(xn([Ot({}), Jt()])),
                G1 = Ot({
                    err: Fc
                }),
                q_ = Pr("receivedSignature"),
                Z_ = Ot({
                    "solana-core": Jt(),
                    "feature-set": Yn(ct())
                }),
                Xh = us(Ot({
                    err: fn(xn([Ot({}), Jt()])),
                    logs: fn(dn(Jt())),
                    accounts: Yn(fn(dn(fn(Ot({
                        executable: Bo(),
                        owner: Jt(),
                        lamports: ct(),
                        data: dn(Jt()),
                        rentEpoch: Yn(ct())
                    }))))),
                    unitsConsumed: Yn(ct()),
                    returnData: Yn(fn(Ot({
                        programId: Jt(),
                        data: Rl([Jt(), Pr("base64")])
                    })))
                })),
                $l = us(Ot({
                    byIdentity: vd(Jt(), dn(ct())),
                    range: Ot({
                        firstSlot: ct(),
                        lastSlot: ct()
                    })
                })),
                Lp = Li(z1),
                Lg = Li(ku),
                Y_ = Li(Uo),
                X_ = Li(ds),
                q1 = Li(Pn),
                Ld = Li(W1),
                Qh = Li(ct()),
                Z1 = us(Ot({
                    total: ct(),
                    circulating: ct(),
                    nonCirculating: ct(),
                    nonCirculatingAccounts: dn(gs)
                })),
                Q_ = Ot({
                    amount: Jt(),
                    uiAmount: fn(ct()),
                    decimals: ct(),
                    uiAmountString: Yn(Jt())
                }),
                Rg = us(dn(Ot({
                    address: gs,
                    amount: Jt(),
                    uiAmount: fn(ct()),
                    decimals: ct(),
                    uiAmountString: Yn(Jt())
                }))),
                II = us(dn(Ot({
                    pubkey: gs,
                    account: Ot({
                        executable: Bo(),
                        owner: gs,
                        lamports: ct(),
                        data: kp,
                        rentEpoch: ct()
                    })
                }))),
                Bg = Ot({
                    program: Jt(),
                    parsed: Na(),
                    space: ct()
                }),
                Y1 = us(dn(Ot({
                    pubkey: gs,
                    account: Ot({
                        executable: Bo(),
                        owner: gs,
                        lamports: ct(),
                        data: Bg,
                        rentEpoch: ct()
                    })
                }))),
                PI = us(dn(Ot({
                    lamports: ct(),
                    address: gs
                }))),
                Rp = Ot({
                    executable: Bo(),
                    owner: gs,
                    lamports: ct(),
                    data: kp,
                    rentEpoch: ct()
                }),
                Ng = Ot({
                    pubkey: gs,
                    account: Rp
                }),
                Jh = Fa(xn([Ll(q.Buffer), Bg]), xn([Ap, Bg]), g => Array.isArray(g) ? $t(g, kp) : g),
                Fg = Ot({
                    executable: Bo(),
                    owner: gs,
                    lamports: ct(),
                    data: Jh,
                    rentEpoch: ct()
                }),
                ef = Ot({
                    pubkey: gs,
                    account: Fg
                }),
                Vg = Ot({
                    state: xn([Pr("active"), Pr("inactive"), Pr("activating"), Pr("deactivating")]),
                    active: ct(),
                    inactive: ct()
                }),
                Bp = Li(dn(Ot({
                    signature: Jt(),
                    slot: ct(),
                    err: Fc,
                    memo: fn(Jt()),
                    blockTime: Yn(fn(ct()))
                }))),
                OI = Li(dn(Ot({
                    signature: Jt(),
                    slot: ct(),
                    err: Fc,
                    memo: fn(Jt()),
                    blockTime: Yn(fn(ct()))
                }))),
                J_ = Ot({
                    subscription: ct(),
                    result: Zh(Rp)
                }),
                ev = Ot({
                    pubkey: gs,
                    account: Rp
                }),
                X1 = Ot({
                    subscription: ct(),
                    result: Zh(ev)
                }),
                Vc = Ot({
                    parent: ct(),
                    slot: ct(),
                    root: ct()
                }),
                Q1 = Ot({
                    subscription: ct(),
                    result: Vc
                }),
                Np = xn([Ot({
                    type: xn([Pr("firstShredReceived"), Pr("completed"), Pr("optimisticConfirmation"), Pr("root")]),
                    slot: ct(),
                    timestamp: ct()
                }), Ot({
                    type: Pr("createdBank"),
                    parent: ct(),
                    slot: ct(),
                    timestamp: ct()
                }), Ot({
                    type: Pr("frozen"),
                    slot: ct(),
                    timestamp: ct(),
                    stats: Ot({
                        numTransactionEntries: ct(),
                        numSuccessfulTransactions: ct(),
                        numFailedTransactions: ct(),
                        maxTransactionsPerEntry: ct()
                    })
                }), Ot({
                    type: Pr("dead"),
                    slot: ct(),
                    timestamp: ct(),
                    err: Jt()
                })]),
                Ug = Ot({
                    subscription: ct(),
                    result: Np
                }),
                tv = Ot({
                    subscription: ct(),
                    result: Zh(xn([G1, q_]))
                }),
                Fp = Ot({
                    subscription: ct(),
                    result: ct()
                }),
                Hg = Ot({
                    pubkey: Jt(),
                    gossip: fn(Jt()),
                    tpu: fn(Jt()),
                    rpc: fn(Jt()),
                    version: fn(Jt())
                }),
                nv = Ot({
                    votePubkey: Jt(),
                    nodePubkey: Jt(),
                    activatedStake: ct(),
                    epochVoteAccount: Bo(),
                    epochCredits: dn(Rl([ct(), ct(), ct()])),
                    commission: ct(),
                    lastVote: ct(),
                    rootSlot: fn(ct())
                }),
                iv = Li(Ot({
                    current: dn(nv),
                    delinquent: dn(nv)
                })),
                rv = xn([Pr("processed"), Pr("confirmed"), Pr("finalized")]),
                sv = Ot({
                    slot: ct(),
                    confirmations: fn(ct()),
                    err: Fc,
                    confirmationStatus: Yn(rv)
                }),
                ov = us(dn(fn(sv))),
                J1 = Li(ct()),
                tf = Ot({
                    accountKey: gs,
                    writableIndexes: dn(ct()),
                    readonlyIndexes: dn(ct())
                }),
                ll = Ot({
                    signatures: dn(Jt()),
                    message: Ot({
                        accountKeys: dn(Jt()),
                        header: Ot({
                            numRequiredSignatures: ct(),
                            numReadonlySignedAccounts: ct(),
                            numReadonlyUnsignedAccounts: ct()
                        }),
                        instructions: dn(Ot({
                            accounts: dn(ct()),
                            data: Jt(),
                            programIdIndex: ct()
                        })),
                        recentBlockhash: Jt(),
                        addressTableLookups: Yn(dn(tf))
                    })
                }),
                av = Ot({
                    pubkey: gs,
                    signer: Bo(),
                    writable: Bo(),
                    source: Yn(xn([Pr("transaction"), Pr("lookupTable")]))
                }),
                $g = Ot({
                    accountKeys: dn(av),
                    signatures: dn(Jt())
                }),
                zg = Ot({
                    parsed: Na(),
                    program: Jt(),
                    programId: gs
                }),
                Rd = Ot({
                    accounts: dn(gs),
                    data: Jt(),
                    programId: gs
                }),
                cv = Fa(xn([Rd, zg]), xn([Ot({
                    parsed: Na(),
                    program: Jt(),
                    programId: Jt()
                }), Ot({
                    accounts: dn(Jt()),
                    data: Jt(),
                    programId: Jt()
                })]), g => $t(g, "accounts" in g ? Rd : zg)),
                ys = Ot({
                    signatures: dn(Jt()),
                    message: Ot({
                        accountKeys: dn(av),
                        instructions: dn(cv),
                        recentBlockhash: Jt(),
                        addressTableLookups: Yn(fn(dn(tf)))
                    })
                }),
                Bd = Ot({
                    accountIndex: ct(),
                    mint: Jt(),
                    owner: Yn(Jt()),
                    uiTokenAmount: Q_
                }),
                lv = Ot({
                    writable: dn(gs),
                    readonly: dn(gs)
                }),
                nf = Ot({
                    err: Fc,
                    fee: ct(),
                    innerInstructions: Yn(fn(dn(Ot({
                        index: ct(),
                        instructions: dn(Ot({
                            accounts: dn(ct()),
                            data: Jt(),
                            programIdIndex: ct()
                        }))
                    })))),
                    preBalances: dn(ct()),
                    postBalances: dn(ct()),
                    logMessages: Yn(fn(dn(Jt()))),
                    preTokenBalances: Yn(fn(dn(Bd))),
                    postTokenBalances: Yn(fn(dn(Bd))),
                    loadedAddresses: Yn(lv),
                    computeUnitsConsumed: Yn(ct())
                }),
                Nd = Ot({
                    err: Fc,
                    fee: ct(),
                    innerInstructions: Yn(fn(dn(Ot({
                        index: ct(),
                        instructions: dn(cv)
                    })))),
                    preBalances: dn(ct()),
                    postBalances: dn(ct()),
                    logMessages: Yn(fn(dn(Jt()))),
                    preTokenBalances: Yn(fn(dn(Bd))),
                    postTokenBalances: Yn(fn(dn(Bd))),
                    loadedAddresses: Yn(lv),
                    computeUnitsConsumed: Yn(ct())
                }),
                uc = xn([Pr(0), Pr("legacy")]),
                Ha = Ot({
                    pubkey: Jt(),
                    lamports: ct(),
                    postBalance: fn(ct()),
                    rewardType: fn(Jt()),
                    commission: Yn(fn(ct()))
                }),
                Fd = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    transactions: dn(Ot({
                        transaction: ll,
                        meta: fn(nf),
                        version: Yn(uc)
                    })),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                uv = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                jg = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    transactions: dn(Ot({
                        transaction: $g,
                        meta: fn(nf),
                        version: Yn(uc)
                    })),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                Vd = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    transactions: dn(Ot({
                        transaction: ys,
                        meta: fn(Nd),
                        version: Yn(uc)
                    })),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                LI = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    transactions: dn(Ot({
                        transaction: $g,
                        meta: fn(Nd),
                        version: Yn(uc)
                    })),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                tC = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct()),
                    blockHeight: fn(ct())
                }))),
                RI = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    transactions: dn(Ot({
                        transaction: ll,
                        meta: fn(nf)
                    })),
                    rewards: Yn(dn(Ha)),
                    blockTime: fn(ct())
                }))),
                nC = Li(fn(Ot({
                    blockhash: Jt(),
                    previousBlockhash: Jt(),
                    parentSlot: ct(),
                    signatures: dn(Jt()),
                    blockTime: fn(ct())
                }))),
                dv = Li(fn(Ot({
                    slot: ct(),
                    meta: fn(nf),
                    blockTime: Yn(fn(ct())),
                    transaction: ll,
                    version: Yn(uc)
                }))),
                Wg = Li(fn(Ot({
                    slot: ct(),
                    transaction: ys,
                    meta: fn(Nd),
                    blockTime: Yn(fn(ct())),
                    version: Yn(uc)
                }))),
                BI = us(Ot({
                    blockhash: Jt(),
                    feeCalculator: Ot({
                        lamportsPerSignature: ct()
                    })
                })),
                NI = us(Ot({
                    blockhash: Jt(),
                    lastValidBlockHeight: ct()
                })),
                Ud = us(Bo()),
                rC = Li(dn(Ot({
                    slot: ct(),
                    numTransactions: ct(),
                    numSlots: ct(),
                    samplePeriodSecs: ct()
                }))),
                Ws = us(fn(Ot({
                    feeCalculator: Ot({
                        lamportsPerSignature: ct()
                    })
                }))),
                sC = Li(Jt()),
                rf = Li(Jt()),
                oC = Ot({
                    err: Fc,
                    logs: dn(Jt()),
                    signature: Jt()
                }),
                $a = Ot({
                    result: Zh(oC),
                    subscription: ct()
                }),
                Hd = {
                    "solana-client": "js/0.0.0-development"
                };
            class hv {
                constructor(l, d) {
                    var p = this;
                    let _, k, B, se, fe, Pe;
                    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
                        latestBlockhash: null,
                        lastFetch: 0,
                        transactionSignatures: [],
                        simulatedSignatures: []
                    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, this.getBlockHeight = (() => {
                        const Ne = {};
                        return function() {
                            var Je = (0, K.Z)(function*(yt) {
                                const {
                                    commitment: bt,
                                    config: dt
                                } = Qr(yt), qe = p._buildArgs([], bt, void 0, dt), it = Pd(qe);
                                return Ne[it] = Ne[it] ? ? (0, K.Z)(function*() {
                                    try {
                                        const Pt = $t(yield p._rpcRequest("getBlockHeight", qe), Li(ct()));
                                        if ("error" in Pt) throw new wn(Pt.error, "failed to get block height information");
                                        return Pt.result
                                    } finally {
                                        delete Ne[it]
                                    }
                                })(), yield Ne[it]
                            });
                            return function(yt) {
                                return Je.apply(this, arguments)
                            }
                        }()
                    })(), d && "string" == typeof d ? this._commitment = d : d && (this._commitment = d.commitment, this._confirmTransactionInitialTimeout = d.confirmTransactionInitialTimeout, _ = d.wsEndpoint, k = d.httpHeaders, B = d.fetch, se = d.fetchMiddleware, fe = d.disableRetryOnRateLimit, Pe = d.httpAgent), this._rpcEndpoint = function $1(g) {
                        if (!1 === /^https?:/.test(g)) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
                        return g
                    }(l), this._rpcWsEndpoint = _ || function H1(g) {
                        const l = g.match(U1);
                        if (null == l) throw TypeError(`Failed to validate endpoint URL \`${g}\``);
                        const [d, p, _, k] = l, B = g.startsWith("https:") ? "wss:" : "ws:", se = null == _ ? null : parseInt(_.slice(1), 10);
                        return `${B}//${p}${null==se?"":`:${se+1}`}${k}`
                    }(l), this._rpcClient = function K1(g, l, d, p, _, k) {
                        const B = d || cl;
                        let fe;
                        return null != k && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."), p && (fe = function() {
                            var Ne = (0, K.Z)(function*(Je, yt) {
                                const bt = yield new Promise((dt, qe) => {
                                    try {
                                        p(Je, yt, (it, ft) => dt([it, ft]))
                                    } catch (it) {
                                        qe(it)
                                    }
                                });
                                return yield B(...bt)
                            });
                            return function(yt, bt) {
                                return Ne.apply(this, arguments)
                            }
                        }()), new(Va())(function() {
                            var Ne = (0, K.Z)(function*(Je, yt) {
                                const bt = {
                                    method: "POST",
                                    body: Je,
                                    agent: void 0,
                                    headers: Object.assign({
                                        "Content-Type": "application/json"
                                    }, l || {}, Hd)
                                };
                                try {
                                    let qe, dt = 5,
                                        it = 500;
                                    for (; qe = fe ? yield fe(g, bt): yield B(g, bt), 429 === qe.status && !0 !== _ && (dt -= 1, 0 !== dt);) console.error(`Server responded with ${qe.status} ${qe.statusText}.  Retrying after ${it}ms delay...`), yield Hl(it), it *= 2;
                                    const ft = yield qe.text();
                                    qe.ok ? yt(null, ft) : yt(new Error(`${qe.status} ${qe.statusText}: ${ft}`))
                                } catch (dt) {
                                    dt instanceof Error && yt(dt)
                                }
                            });
                            return function(Je, yt) {
                                return Ne.apply(this, arguments)
                            }
                        }(), {})
                    }(l, k, B, se, fe, Pe), this._rpcRequest = function Pp(g) {
                        return (l, d) => new Promise((p, _) => {
                            g.request(l, d, (k, B) => {
                                k ? _(k) : p(B)
                            })
                        })
                    }(this._rpcClient), this._rpcBatchRequest = function Op(g) {
                        return l => new Promise((d, p) => {
                            0 === l.length && d([]);
                            const _ = l.map(k => g.request(k.methodName, k.args));
                            g.request(_, (k, B) => {
                                k ? p(k) : d(B)
                            })
                        })
                    }(this._rpcClient), this._rpcWebSocket = new W_(this._rpcWsEndpoint, {
                        autoconnect: !1,
                        max_reconnects: 1 / 0
                    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
                }
                get commitment() {
                    return this._commitment
                }
                get rpcEndpoint() {
                    return this._rpcEndpoint
                }
                getBalanceAndContext(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgs([l.toBase58()], _, void 0, k), fe = $t(yield p._rpcRequest("getBalance", B), us(ct()));
                        if ("error" in fe) throw new wn(fe.error, `failed to get balance for ${l.toBase58()}`);
                        return fe.result
                    })()
                }
                getBalance(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        return yield p.getBalanceAndContext(l, d).then(_ => _.value).catch(_ => {
                            throw new Error("failed to get balance of account " + l.toBase58() + ": " + _)
                        })
                    })()
                }
                getBlockTime(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const _ = $t(yield d._rpcRequest("getBlockTime", [l]), Li(fn(ct())));
                        if ("error" in _) throw new wn(_.error, `failed to get block time for slot ${l}`);
                        return _.result
                    })()
                }
                getMinimumLedgerSlot() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("minimumLedgerSlot", []), Li(ct()));
                        if ("error" in p) throw new wn(p.error, "failed to get minimum ledger slot");
                        return p.result
                    })()
                }
                getFirstAvailableBlock() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getFirstAvailableBlock", []), Qh);
                        if ("error" in p) throw new wn(p.error, "failed to get first available block");
                        return p.result
                    })()
                }
                getSupply(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        let p = {};
                        p = "string" == typeof l ? {
                            commitment: l
                        } : l ? { ...l,
                            commitment: l && l.commitment || d.commitment
                        } : {
                            commitment: d.commitment
                        };
                        const k = $t(yield d._rpcRequest("getSupply", [p]), Z1);
                        if ("error" in k) throw new wn(k.error, "failed to get supply");
                        return k.result
                    })()
                }
                getTokenSupply(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgs([l.toBase58()], d),
                            B = $t(yield p._rpcRequest("getTokenSupply", _), us(Q_));
                        if ("error" in B) throw new wn(B.error, "failed to get token supply");
                        return B.result
                    })()
                }
                getTokenAccountBalance(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgs([l.toBase58()], d),
                            B = $t(yield p._rpcRequest("getTokenAccountBalance", _), us(Q_));
                        if ("error" in B) throw new wn(B.error, "failed to get token account balance");
                        return B.result
                    })()
                }
                getTokenAccountsByOwner(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: k,
                            config: B
                        } = Qr(p);
                        let se = [l.toBase58()];
                        se.push("mint" in d ? {
                            mint: d.mint.toBase58()
                        } : {
                            programId: d.programId.toBase58()
                        });
                        const fe = _._buildArgs(se, k, "base64", B),
                            Ne = $t(yield _._rpcRequest("getTokenAccountsByOwner", fe), II);
                        if ("error" in Ne) throw new wn(Ne.error, `failed to get token accounts owned by account ${l.toBase58()}`);
                        return Ne.result
                    })()
                }
                getParsedTokenAccountsByOwner(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        let k = [l.toBase58()];
                        k.push("mint" in d ? {
                            mint: d.mint.toBase58()
                        } : {
                            programId: d.programId.toBase58()
                        });
                        const B = _._buildArgs(k, p, "jsonParsed"),
                            fe = $t(yield _._rpcRequest("getTokenAccountsByOwner", B), Y1);
                        if ("error" in fe) throw new wn(fe.error, `failed to get token accounts owned by account ${l.toBase58()}`);
                        return fe.result
                    })()
                }
                getLargestAccounts(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const p = { ...l,
                                commitment: l && l.commitment || d.commitment
                            },
                            _ = p.filter || p.commitment ? [p] : [],
                            B = $t(yield d._rpcRequest("getLargestAccounts", _), PI);
                        if ("error" in B) throw new wn(B.error, "failed to get largest accounts");
                        return B.result
                    })()
                }
                getTokenLargestAccounts(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgs([l.toBase58()], d),
                            B = $t(yield p._rpcRequest("getTokenLargestAccounts", _), Rg);
                        if ("error" in B) throw new wn(B.error, "failed to get token largest accounts");
                        return B.result
                    })()
                }
                getAccountInfoAndContext(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgs([l.toBase58()], _, "base64", k), fe = $t(yield p._rpcRequest("getAccountInfo", B), us(fn(Rp)));
                        if ("error" in fe) throw new wn(fe.error, `failed to get info about account ${l.toBase58()}`);
                        return fe.result
                    })()
                }
                getParsedAccountInfo(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgs([l.toBase58()], _, "jsonParsed", k), fe = $t(yield p._rpcRequest("getAccountInfo", B), us(fn(Fg)));
                        if ("error" in fe) throw new wn(fe.error, `failed to get info about account ${l.toBase58()}`);
                        return fe.result
                    })()
                }
                getAccountInfo(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        try {
                            return (yield p.getAccountInfoAndContext(l, d)).value
                        } catch (_) {
                            throw new Error("failed to get info about account " + l.toBase58() + ": " + _)
                        }
                    })()
                }
                getMultipleParsedAccounts(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = l.map(Ne => Ne.toBase58()), se = p._buildArgs([B], _, "jsonParsed", k), Pe = $t(yield p._rpcRequest("getMultipleAccounts", se), us(dn(fn(Fg))));
                        if ("error" in Pe) throw new wn(Pe.error, `failed to get info for accounts ${B}`);
                        return Pe.result
                    })()
                }
                getMultipleAccountsInfoAndContext(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = l.map(Ne => Ne.toBase58()), se = p._buildArgs([B], _, "base64", k), Pe = $t(yield p._rpcRequest("getMultipleAccounts", se), us(dn(fn(Rp))));
                        if ("error" in Pe) throw new wn(Pe.error, `failed to get info for accounts ${B}`);
                        return Pe.result
                    })()
                }
                getMultipleAccountsInfo(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        return (yield p.getMultipleAccountsInfoAndContext(l, d)).value
                    })()
                }
                getStakeActivation(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: k,
                            config: B
                        } = Qr(d), se = _._buildArgs([l.toBase58()], k, void 0, { ...B,
                            epoch: p ? ? B ? .epoch
                        }), Pe = $t(yield _._rpcRequest("getStakeActivation", se), Li(Vg));
                        if ("error" in Pe) throw new wn(Pe.error, `failed to get Stake Activation ${l.toBase58()}`);
                        return Pe.result
                    })()
                }
                getProgramAccounts(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), {
                            encoding: B,
                            ...se
                        } = k || {}, fe = p._buildArgs([l.toBase58()], _, B || "base64", se), Pe = yield p._rpcRequest("getProgramAccounts", fe), Ne = dn(Ng), Je = $t(Pe, !0 === se.withContext ? us(Ne) : Li(Ne));
                        if ("error" in Je) throw new wn(Je.error, `failed to get accounts owned by program ${l.toBase58()}`);
                        return Je.result
                    })()
                }
                getParsedProgramAccounts(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgs([l.toBase58()], _, "jsonParsed", k), fe = $t(yield p._rpcRequest("getProgramAccounts", B), Li(dn(ef)));
                        if ("error" in fe) throw new wn(fe.error, `failed to get accounts owned by program ${l.toBase58()}`);
                        return fe.result
                    })()
                }
                confirmTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        let _, k;
                        if ("string" == typeof l) _ = l;
                        else {
                            const B = l;
                            if (B.abortSignal ? .aborted) return Promise.reject(B.abortSignal.reason);
                            _ = B.signature
                        }
                        try {
                            k = ps().decode(_)
                        } catch {
                            throw new Error("signature must be base58 encoded: " + _)
                        }
                        return Tr(64 === k.length, "signature has invalid length"), "string" == typeof l ? yield p.confirmTransactionUsingLegacyTimeoutStrategy({
                            commitment: d || p.commitment,
                            signature: _
                        }): "lastValidBlockHeight" in l ? yield p.confirmTransactionUsingBlockHeightExceedanceStrategy({
                            commitment: d || p.commitment,
                            strategy: l
                        }): yield p.confirmTransactionUsingDurableNonceStrategy({
                            commitment: d || p.commitment,
                            strategy: l
                        })
                    })()
                }
                getCancellationPromise(l) {
                    return new Promise((d, p) => {
                        null != l && (l.aborted ? p(l.reason) : l.addEventListener("abort", () => {
                            p(l.reason)
                        }))
                    })
                }
                getTransactionConfirmationPromise({
                    commitment: l,
                    signature: d
                }) {
                    var p = this;
                    let _, k, B = !1;
                    return {
                        abortConfirmation: () => {
                            k && (k(), k = void 0), null != _ && (this.removeSignatureListener(_), _ = void 0)
                        },
                        confirmationPromise: new Promise((Pe, Ne) => {
                            try {
                                _ = this.onSignature(d, (yt, bt) => {
                                    _ = void 0, Pe({
                                        __type: al.PROCESSED,
                                        response: {
                                            context: bt,
                                            value: yt
                                        }
                                    })
                                }, l);
                                const Je = new Promise(yt => {
                                    null == _ ? yt() : k = this._onSubscriptionStateChange(_, bt => {
                                        "subscribed" === bt && yt()
                                    })
                                });
                                (0, K.Z)(function*() {
                                    if (yield Je, B) return;
                                    const yt = yield p.getSignatureStatus(d);
                                    if (B || null == yt) return;
                                    const {
                                        context: bt,
                                        value: dt
                                    } = yt;
                                    if (null != dt)
                                        if (dt ? .err) Ne(dt.err);
                                        else {
                                            switch (l) {
                                                case "confirmed":
                                                case "single":
                                                case "singleGossip":
                                                    if ("processed" === dt.confirmationStatus) return;
                                                    break;
                                                case "finalized":
                                                case "max":
                                                case "root":
                                                    if ("processed" === dt.confirmationStatus || "confirmed" === dt.confirmationStatus) return
                                            }
                                            B = !0, Pe({
                                                __type: al.PROCESSED,
                                                response: {
                                                    context: bt,
                                                    value: dt
                                                }
                                            })
                                        }
                                })()
                            } catch (Je) {
                                Ne(Je)
                            }
                        })
                    }
                }
                confirmTransactionUsingBlockHeightExceedanceStrategy({
                    commitment: l,
                    strategy: {
                        abortSignal: d,
                        lastValidBlockHeight: p,
                        signature: _
                    }
                }) {
                    var k = this;
                    return (0, K.Z)(function*() {
                        let B = !1;
                        const se = new Promise(yt => {
                                const bt = function() {
                                    var dt = (0, K.Z)(function*() {
                                        try {
                                            return yield k.getBlockHeight(l)
                                        } catch {
                                            return -1
                                        }
                                    });
                                    return function() {
                                        return dt.apply(this, arguments)
                                    }
                                }();
                                (0, K.Z)(function*() {
                                    let dt = yield bt();
                                    if (!B) {
                                        for (; dt <= p;)
                                            if (yield Hl(1e3), B || (dt = yield bt(), B)) return;
                                        yt({
                                            __type: al.BLOCKHEIGHT_EXCEEDED
                                        })
                                    }
                                })()
                            }),
                            {
                                abortConfirmation: fe,
                                confirmationPromise: Pe
                            } = k.getTransactionConfirmationPromise({
                                commitment: l,
                                signature: _
                            }),
                            Ne = k.getCancellationPromise(d);
                        let Je;
                        try {
                            const yt = yield Promise.race([Ne, Pe, se]);
                            if (yt.__type !== al.PROCESSED) throw new Eg(_);
                            Je = yt.response
                        } finally {
                            B = !0, fe()
                        }
                        return Je
                    })()
                }
                confirmTransactionUsingDurableNonceStrategy({
                    commitment: l,
                    strategy: {
                        abortSignal: d,
                        minContextSlot: p,
                        nonceAccountPubkey: _,
                        nonceValue: k,
                        signature: B
                    }
                }) {
                    var se = this;
                    return (0, K.Z)(function*() {
                        let fe = !1;
                        const Pe = new Promise(dt => {
                                let qe = k,
                                    it = null;
                                const ft = function() {
                                    var Pt = (0, K.Z)(function*() {
                                        try {
                                            const {
                                                context: Bt,
                                                value: pn
                                            } = yield se.getNonceAndContext(_, {
                                                commitment: l,
                                                minContextSlot: p
                                            });
                                            return it = Bt.slot, pn ? .nonce
                                        } catch {
                                            return qe
                                        }
                                    });
                                    return function() {
                                        return Pt.apply(this, arguments)
                                    }
                                }();
                                (0, K.Z)(function*() {
                                    if (qe = yield ft(), !fe)
                                        for (;;) {
                                            if (k !== qe) return void dt({
                                                __type: al.NONCE_INVALID,
                                                slotInWhichNonceDidAdvance: it
                                            });
                                            if (yield Hl(2e3), fe || (qe = yield ft(), fe)) return
                                        }
                                })()
                            }),
                            {
                                abortConfirmation: Ne,
                                confirmationPromise: Je
                            } = se.getTransactionConfirmationPromise({
                                commitment: l,
                                signature: B
                            }),
                            yt = se.getCancellationPromise(d);
                        let bt;
                        try {
                            const dt = yield Promise.race([yt, Je, Pe]);
                            if (dt.__type === al.PROCESSED) bt = dt.response;
                            else {
                                let qe;
                                for (;;) {
                                    const it = yield se.getSignatureStatus(B);
                                    if (null == it) break;
                                    if (!(it.context.slot < (dt.slotInWhichNonceDidAdvance ? ? p))) {
                                        qe = it;
                                        break
                                    }
                                    yield Hl(400)
                                }
                                if (!qe ? .value) throw new Gh(B); {
                                    const it = l || "finalized",
                                        {
                                            confirmationStatus: ft
                                        } = qe.value;
                                    switch (it) {
                                        case "processed":
                                        case "recent":
                                            if ("processed" !== ft && "confirmed" !== ft && "finalized" !== ft) throw new Gh(B);
                                            break;
                                        case "confirmed":
                                        case "single":
                                        case "singleGossip":
                                            if ("confirmed" !== ft && "finalized" !== ft) throw new Gh(B);
                                            break;
                                        case "finalized":
                                        case "max":
                                        case "root":
                                            if ("finalized" !== ft) throw new Gh(B)
                                    }
                                    bt = {
                                        context: qe.context,
                                        value: {
                                            err: qe.value.err
                                        }
                                    }
                                }
                            }
                        } finally {
                            fe = !0, Ne()
                        }
                        return bt
                    })()
                }
                confirmTransactionUsingLegacyTimeoutStrategy({
                    commitment: l,
                    signature: d
                }) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        let _;
                        const k = new Promise(Pe => {
                                let Ne = p._confirmTransactionInitialTimeout || 6e4;
                                switch (l) {
                                    case "processed":
                                    case "recent":
                                    case "single":
                                    case "confirmed":
                                    case "singleGossip":
                                        Ne = p._confirmTransactionInitialTimeout || 3e4
                                }
                                _ = setTimeout(() => Pe({
                                    __type: al.TIMED_OUT,
                                    timeoutMs: Ne
                                }), Ne)
                            }),
                            {
                                abortConfirmation: B,
                                confirmationPromise: se
                            } = p.getTransactionConfirmationPromise({
                                commitment: l,
                                signature: d
                            });
                        let fe;
                        try {
                            const Pe = yield Promise.race([se, k]);
                            if (Pe.__type !== al.PROCESSED) throw new Wh(d, Pe.timeoutMs / 1e3);
                            fe = Pe.response
                        } finally {
                            clearTimeout(_), B()
                        }
                        return fe
                    })()
                }
                getClusterNodes() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getClusterNodes", []), Li(dn(Hg)));
                        if ("error" in p) throw new wn(p.error, "failed to get cluster nodes");
                        return p.result
                    })()
                }
                getVoteAccounts(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const p = d._buildArgs([], l),
                            k = $t(yield d._rpcRequest("getVoteAccounts", p), iv);
                        if ("error" in k) throw new wn(k.error, "failed to get vote accounts");
                        return k.result
                    })()
                }
                getSlot(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, void 0, _), se = $t(yield d._rpcRequest("getSlot", k), Li(ct()));
                        if ("error" in se) throw new wn(se.error, "failed to get slot");
                        return se.result
                    })()
                }
                getSlotLeader(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, void 0, _), se = $t(yield d._rpcRequest("getSlotLeader", k), Li(Jt()));
                        if ("error" in se) throw new wn(se.error, "failed to get slot leader");
                        return se.result
                    })()
                }
                getSlotLeaders(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = [l, d],
                            B = $t(yield p._rpcRequest("getSlotLeaders", _), Li(dn(gs)));
                        if ("error" in B) throw new wn(B.error, "failed to get slot leaders");
                        return B.result
                    })()
                }
                getSignatureStatus(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            context: _,
                            value: k
                        } = yield p.getSignatureStatuses([l], d);
                        return Tr(1 === k.length), {
                            context: _,
                            value: k[0]
                        }
                    })()
                }
                getSignatureStatuses(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = [l];
                        d && _.push(d);
                        const B = $t(yield p._rpcRequest("getSignatureStatuses", _), ov);
                        if ("error" in B) throw new wn(B.error, "failed to get signature status");
                        return B.result
                    })()
                }
                getTransactionCount(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, void 0, _), se = $t(yield d._rpcRequest("getTransactionCount", k), Li(ct()));
                        if ("error" in se) throw new wn(se.error, "failed to get transaction count");
                        return se.result
                    })()
                }
                getTotalSupply(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        return (yield d.getSupply({
                            commitment: l,
                            excludeNonCirculatingAccountsList: !0
                        })).value.total
                    })()
                }
                getInflationGovernor(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const p = d._buildArgs([], l),
                            k = $t(yield d._rpcRequest("getInflationGovernor", p), Lp);
                        if ("error" in k) throw new wn(k.error, "failed to get inflation");
                        return k.result
                    })()
                }
                getInflationReward(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: k,
                            config: B
                        } = Qr(p), se = _._buildArgs([l.map(Ne => Ne.toBase58())], k, void 0, { ...B,
                            epoch: d ? ? B ? .epoch
                        }), Pe = $t(yield _._rpcRequest("getInflationReward", se), j1);
                        if ("error" in Pe) throw new wn(Pe.error, "failed to get inflation reward");
                        return Pe.result
                    })()
                }
                getInflationRate() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getInflationRate", []), Lg);
                        if ("error" in p) throw new wn(p.error, "failed to get inflation rate");
                        return p.result
                    })()
                }
                getEpochInfo(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, void 0, _), se = $t(yield d._rpcRequest("getEpochInfo", k), X_);
                        if ("error" in se) throw new wn(se.error, "failed to get epoch info");
                        return se.result
                    })()
                }
                getEpochSchedule() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getEpochSchedule", []), q1);
                        if ("error" in p) throw new wn(p.error, "failed to get epoch schedule");
                        const _ = p.result;
                        return new $_(_.slotsPerEpoch, _.leaderScheduleSlotOffset, _.warmup, _.firstNormalEpoch, _.firstNormalSlot)
                    })()
                }
                getLeaderSchedule() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getLeaderSchedule", []), Ld);
                        if ("error" in p) throw new wn(p.error, "failed to get leader schedule");
                        return p.result
                    })()
                }
                getMinimumBalanceForRentExemption(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgs([l], d),
                            B = $t(yield p._rpcRequest("getMinimumBalanceForRentExemption", _), J1);
                        return "error" in B ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : B.result
                    })()
                }
                getRecentBlockhashAndContext(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const p = d._buildArgs([], l),
                            k = $t(yield d._rpcRequest("getRecentBlockhash", p), BI);
                        if ("error" in k) throw new wn(k.error, "failed to get recent blockhash");
                        return k.result
                    })()
                }
                getRecentPerformanceSamples(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const _ = $t(yield d._rpcRequest("getRecentPerformanceSamples", l ? [l] : []), rC);
                        if ("error" in _) throw new wn(_.error, "failed to get recent performance samples");
                        return _.result
                    })()
                }
                getFeeCalculatorForBlockhash(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgs([l], d),
                            B = $t(yield p._rpcRequest("getFeeCalculatorForBlockhash", _), Ws);
                        if ("error" in B) throw new wn(B.error, "failed to get fee calculator");
                        const {
                            context: se,
                            value: fe
                        } = B.result;
                        return {
                            context: se,
                            value: null !== fe ? fe.feeCalculator : null
                        }
                    })()
                }
                getFeeForMessage(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = Oi(l.serialize()).toString("base64"),
                            k = p._buildArgs([_], d),
                            se = $t(yield p._rpcRequest("getFeeForMessage", k), us(fn(ct())));
                        if ("error" in se) throw new wn(se.error, "failed to get fee for message");
                        if (null === se.result) throw new Error("invalid blockhash");
                        return se.result
                    })()
                }
                getRecentPrioritizationFees(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const p = l ? .lockedWritableAccounts ? .map(se => se.toBase58()),
                            _ = p ? .length ? [p] : [],
                            B = $t(yield d._rpcRequest("getRecentPrioritizationFees", _), Y_);
                        if ("error" in B) throw new wn(B.error, "failed to get recent prioritization fees");
                        return B.result
                    })()
                }
                getRecentBlockhash(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        try {
                            return (yield d.getRecentBlockhashAndContext(l)).value
                        } catch (p) {
                            throw new Error("failed to get recent blockhash: " + p)
                        }
                    })()
                }
                getLatestBlockhash(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        try {
                            return (yield d.getLatestBlockhashAndContext(l)).value
                        } catch (p) {
                            throw new Error("failed to get recent blockhash: " + p)
                        }
                    })()
                }
                getLatestBlockhashAndContext(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, void 0, _), se = $t(yield d._rpcRequest("getLatestBlockhash", k), NI);
                        if ("error" in se) throw new wn(se.error, "failed to get latest blockhash");
                        return se.result
                    })()
                }
                isBlockhashValid(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgs([l], _, void 0, k), fe = $t(yield p._rpcRequest("isBlockhashValid", B), Ud);
                        if ("error" in fe) throw new wn(fe.error, "failed to determine if the blockhash `" + l + "`is valid");
                        return fe.result
                    })()
                }
                getVersion() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getVersion", []), Li(Z_));
                        if ("error" in p) throw new wn(p.error, "failed to get version");
                        return p.result
                    })()
                }
                getGenesisHash() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        const p = $t(yield l._rpcRequest("getGenesisHash", []), Li(Jt()));
                        if ("error" in p) throw new wn(p.error, "failed to get genesis hash");
                        return p.result
                    })()
                }
                getBlock(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgsAtLeastConfirmed([l], _, void 0, k), se = yield p._rpcRequest("getBlock", B);
                        try {
                            switch (k ? .transactionDetails) {
                                case "accounts":
                                    {
                                        const fe = $t(se, jg);
                                        if ("error" in fe) throw fe.error;
                                        return fe.result
                                    }
                                case "none":
                                    {
                                        const fe = $t(se, uv);
                                        if ("error" in fe) throw fe.error;
                                        return fe.result
                                    }
                                default:
                                    {
                                        const fe = $t(se, Fd);
                                        if ("error" in fe) throw fe.error;
                                        const {
                                            result: Pe
                                        } = fe;
                                        return Pe ? { ...Pe,
                                            transactions: Pe.transactions.map(({
                                                transaction: Ne,
                                                meta: Je,
                                                version: yt
                                            }) => ({
                                                meta: Je,
                                                transaction: { ...Ne,
                                                    message: Yh(yt, Ne.message)
                                                },
                                                version: yt
                                            }))
                                        } : null
                                    }
                            }
                        } catch (fe) {
                            throw new wn(fe, "failed to get confirmed block")
                        }
                    })()
                }
                getParsedBlock(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgsAtLeastConfirmed([l], _, "jsonParsed", k), se = yield p._rpcRequest("getBlock", B);
                        try {
                            switch (k ? .transactionDetails) {
                                case "accounts":
                                    {
                                        const fe = $t(se, LI);
                                        if ("error" in fe) throw fe.error;
                                        return fe.result
                                    }
                                case "none":
                                    {
                                        const fe = $t(se, tC);
                                        if ("error" in fe) throw fe.error;
                                        return fe.result
                                    }
                                default:
                                    {
                                        const fe = $t(se, Vd);
                                        if ("error" in fe) throw fe.error;
                                        return fe.result
                                    }
                            }
                        } catch (fe) {
                            throw new wn(fe, "failed to get block")
                        }
                    })()
                }
                getBlockProduction(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        let p, _;
                        if ("string" == typeof l) _ = l;
                        else if (l) {
                            const {
                                commitment: fe,
                                ...Pe
                            } = l;
                            _ = fe, p = Pe
                        }
                        const k = d._buildArgs([], _, "base64", p),
                            se = $t(yield d._rpcRequest("getBlockProduction", k), $l);
                        if ("error" in se) throw new wn(se.error, "failed to get block production information");
                        return se.result
                    })()
                }
                getTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgsAtLeastConfirmed([l], _, void 0, k), fe = $t(yield p._rpcRequest("getTransaction", B), dv);
                        if ("error" in fe) throw new wn(fe.error, "failed to get transaction");
                        const Pe = fe.result;
                        return Pe && { ...Pe,
                            transaction: { ...Pe.transaction,
                                message: Yh(Pe.version, Pe.transaction.message)
                            }
                        }
                    })()
                }
                getParsedTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = p._buildArgsAtLeastConfirmed([l], _, "jsonParsed", k), fe = $t(yield p._rpcRequest("getTransaction", B), Wg);
                        if ("error" in fe) throw new wn(fe.error, "failed to get transaction");
                        return fe.result
                    })()
                }
                getParsedTransactions(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = l.map(Pe => ({
                            methodName: "getTransaction",
                            args: p._buildArgsAtLeastConfirmed([Pe], _, "jsonParsed", k)
                        }));
                        return (yield p._rpcBatchRequest(B)).map(Pe => {
                            const Ne = $t(Pe, Wg);
                            if ("error" in Ne) throw new wn(Ne.error, "failed to get transactions");
                            return Ne.result
                        })
                    })()
                }
                getTransactions(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: _,
                            config: k
                        } = Qr(d), B = l.map(Pe => ({
                            methodName: "getTransaction",
                            args: p._buildArgsAtLeastConfirmed([Pe], _, void 0, k)
                        }));
                        return (yield p._rpcBatchRequest(B)).map(Pe => {
                            const Ne = $t(Pe, dv);
                            if ("error" in Ne) throw new wn(Ne.error, "failed to get transactions");
                            const Je = Ne.result;
                            return Je && { ...Je,
                                transaction: { ...Je.transaction,
                                    message: Yh(Je.version, Je.transaction.message)
                                }
                            }
                        })
                    })()
                }
                getConfirmedBlock(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgsAtLeastConfirmed([l], d),
                            B = $t(yield p._rpcRequest("getConfirmedBlock", _), RI);
                        if ("error" in B) throw new wn(B.error, "failed to get confirmed block");
                        const se = B.result;
                        if (!se) throw new Error("Confirmed block " + l + " not found");
                        const fe = { ...se,
                            transactions: se.transactions.map(({
                                transaction: Pe,
                                meta: Ne
                            }) => {
                                const Je = new lc(Pe.message);
                                return {
                                    meta: Ne,
                                    transaction: { ...Pe,
                                        message: Je
                                    }
                                }
                            })
                        };
                        return { ...fe,
                            transactions: fe.transactions.map(({
                                transaction: Pe,
                                meta: Ne
                            }) => ({
                                meta: Ne,
                                transaction: Fi.populate(Pe.message, Pe.signatures)
                            }))
                        }
                    })()
                }
                getBlocks(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const k = _._buildArgsAtLeastConfirmed(void 0 !== d ? [l, d] : [l], p),
                            se = $t(yield _._rpcRequest("getBlocks", k), Li(dn(ct())));
                        if ("error" in se) throw new wn(se.error, "failed to get blocks");
                        return se.result
                    })()
                }
                getBlockSignatures(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgsAtLeastConfirmed([l], d, void 0, {
                                transactionDetails: "signatures",
                                rewards: !1
                            }),
                            B = $t(yield p._rpcRequest("getBlock", _), nC);
                        if ("error" in B) throw new wn(B.error, "failed to get block");
                        const se = B.result;
                        if (!se) throw new Error("Block " + l + " not found");
                        return se
                    })()
                }
                getConfirmedBlockSignatures(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgsAtLeastConfirmed([l], d, void 0, {
                                transactionDetails: "signatures",
                                rewards: !1
                            }),
                            B = $t(yield p._rpcRequest("getConfirmedBlock", _), nC);
                        if ("error" in B) throw new wn(B.error, "failed to get confirmed block");
                        const se = B.result;
                        if (!se) throw new Error("Confirmed block " + l + " not found");
                        return se
                    })()
                }
                getConfirmedTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgsAtLeastConfirmed([l], d),
                            B = $t(yield p._rpcRequest("getConfirmedTransaction", _), dv);
                        if ("error" in B) throw new wn(B.error, "failed to get transaction");
                        const se = B.result;
                        if (!se) return se;
                        const fe = new lc(se.transaction.message),
                            Pe = se.transaction.signatures;
                        return { ...se,
                            transaction: Fi.populate(fe, Pe)
                        }
                    })()
                }
                getParsedConfirmedTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._buildArgsAtLeastConfirmed([l], d, "jsonParsed"),
                            B = $t(yield p._rpcRequest("getConfirmedTransaction", _), Wg);
                        if ("error" in B) throw new wn(B.error, "failed to get confirmed transaction");
                        return B.result
                    })()
                }
                getParsedConfirmedTransactions(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = l.map(se => ({
                            methodName: "getConfirmedTransaction",
                            args: p._buildArgsAtLeastConfirmed([se], d, "jsonParsed")
                        }));
                        return (yield p._rpcBatchRequest(_)).map(se => {
                            const fe = $t(se, Wg);
                            if ("error" in fe) throw new wn(fe.error, "failed to get confirmed transactions");
                            return fe.result
                        })
                    })()
                }
                getConfirmedSignaturesForAddress(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        let k = {},
                            B = yield _.getFirstAvailableBlock();
                        for (; !("until" in k || (d--, d <= 0 || d < B));) try {
                            const Pe = yield _.getConfirmedBlockSignatures(d, "finalized");
                            Pe.signatures.length > 0 && (k.until = Pe.signatures[Pe.signatures.length - 1].toString())
                        } catch (Pe) {
                            if (Pe instanceof Error && Pe.message.includes("skipped")) continue;
                            throw Pe
                        }
                        let se = yield _.getSlot("finalized");
                        for (; !("before" in k || (p++, p > se));) try {
                            const Pe = yield _.getConfirmedBlockSignatures(p);
                            Pe.signatures.length > 0 && (k.before = Pe.signatures[Pe.signatures.length - 1].toString())
                        } catch (Pe) {
                            if (Pe instanceof Error && Pe.message.includes("skipped")) continue;
                            throw Pe
                        }
                        return (yield _.getConfirmedSignaturesForAddress2(l, k)).map(Pe => Pe.signature)
                    })()
                }
                getConfirmedSignaturesForAddress2(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const k = _._buildArgsAtLeastConfirmed([l.toBase58()], p, void 0, d),
                            se = $t(yield _._rpcRequest("getConfirmedSignaturesForAddress2", k), Bp);
                        if ("error" in se) throw new wn(se.error, "failed to get confirmed signatures for address");
                        return se.result
                    })()
                }
                getSignaturesForAddress(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        const k = _._buildArgsAtLeastConfirmed([l.toBase58()], p, void 0, d),
                            se = $t(yield _._rpcRequest("getSignaturesForAddress", k), OI);
                        if ("error" in se) throw new wn(se.error, "failed to get signatures for address");
                        return se.result
                    })()
                }
                getAddressLookupTable(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            context: _,
                            value: k
                        } = yield p.getAccountInfoAndContext(l, d);
                        let B = null;
                        return null !== k && (B = new Og({
                            key: l,
                            state: Og.deserialize(k.data)
                        })), {
                            context: _,
                            value: B
                        }
                    })()
                }
                getNonceAndContext(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const {
                            context: _,
                            value: k
                        } = yield p.getAccountInfoAndContext(l, d);
                        let B = null;
                        return null !== k && (B = Dp.fromAccountData(k.data)), {
                            context: _,
                            value: B
                        }
                    })()
                }
                getNonce(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        return yield p.getNonceAndContext(l, d).then(_ => _.value).catch(_ => {
                            throw new Error("failed to get nonce for account " + l.toBase58() + ": " + _)
                        })
                    })()
                }
                requestAirdrop(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const k = $t(yield p._rpcRequest("requestAirdrop", [l.toBase58(), d]), sC);
                        if ("error" in k) throw new wn(k.error, `airdrop to ${l.toBase58()} failed`);
                        return k.result
                    })()
                }
                _blockhashWithExpiryBlockHeight(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        if (!l) {
                            for (; d._pollingBlockhash;) yield Hl(100);
                            const _ = Date.now() - d._blockhashInfo.lastFetch >= Mp;
                            if (null !== d._blockhashInfo.latestBlockhash && !_) return d._blockhashInfo.latestBlockhash
                        }
                        return yield d._pollNewBlockhash()
                    })()
                }
                _pollNewBlockhash() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        l._pollingBlockhash = !0;
                        try {
                            const d = Date.now(),
                                p = l._blockhashInfo.latestBlockhash,
                                _ = p ? p.blockhash : null;
                            for (let k = 0; k < 50; k++) {
                                const B = yield l.getLatestBlockhash("finalized");
                                if (_ !== B.blockhash) return l._blockhashInfo = {
                                    latestBlockhash: B,
                                    lastFetch: Date.now(),
                                    transactionSignatures: [],
                                    simulatedSignatures: []
                                }, B;
                                yield Hl(200)
                            }
                            throw new Error(`Unable to obtain a new blockhash after ${Date.now()-d}ms`)
                        } finally {
                            l._pollingBlockhash = !1
                        }
                    })()
                }
                getStakeMinimumDelegation(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        const {
                            commitment: p,
                            config: _
                        } = Qr(l), k = d._buildArgs([], p, "base64", _), se = $t(yield d._rpcRequest("getStakeMinimumDelegation", k), us(ct()));
                        if ("error" in se) throw new wn(se.error, "failed to get stake minimum delegation");
                        return se.result
                    })()
                }
                simulateTransaction(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        if ("message" in l) {
                            const it = l.serialize(),
                                ft = q.Buffer.from(it).toString("base64");
                            if (Array.isArray(d) || void 0 !== p) throw new Error("Invalid arguments");
                            const Pt = d || {};
                            Pt.encoding = "base64", "commitment" in Pt || (Pt.commitment = _.commitment);
                            const Bt = [ft, Pt],
                                rn = $t(yield _._rpcRequest("simulateTransaction", Bt), Xh);
                            if ("error" in rn) throw new Error("failed to simulate transaction: " + rn.error.message);
                            return rn.result
                        }
                        let k;
                        if (l instanceof Fi) {
                            let qe = l;
                            k = new Fi, k.feePayer = qe.feePayer, k.instructions = l.instructions, k.nonceInfo = qe.nonceInfo, k.signatures = qe.signatures
                        } else k = Fi.populate(l), k._message = k._json = void 0;
                        if (void 0 !== d && !Array.isArray(d)) throw new Error("Invalid arguments");
                        const B = d;
                        if (k.nonceInfo && B) k.sign(...B);
                        else {
                            let qe = _._disableBlockhashCaching;
                            for (;;) {
                                const it = yield _._blockhashWithExpiryBlockHeight(qe);
                                if (k.lastValidBlockHeight = it.lastValidBlockHeight, k.recentBlockhash = it.blockhash, !B) break;
                                if (k.sign(...B), !k.signature) throw new Error("!signature");
                                const ft = k.signature.toString("base64");
                                if (!_._blockhashInfo.simulatedSignatures.includes(ft) && !_._blockhashInfo.transactionSignatures.includes(ft)) {
                                    _._blockhashInfo.simulatedSignatures.push(ft);
                                    break
                                }
                                qe = !0
                            }
                        }
                        const se = k._compile(),
                            fe = se.serialize(),
                            Ne = k._serialize(fe).toString("base64"),
                            Je = {
                                encoding: "base64",
                                commitment: _.commitment
                            };
                        if (p) {
                            const qe = (Array.isArray(p) ? p : se.nonProgramIds()).map(it => it.toBase58());
                            Je.accounts = {
                                encoding: "base64",
                                addresses: qe
                            }
                        }
                        B && (Je.sigVerify = !0);
                        const yt = [Ne, Je],
                            dt = $t(yield _._rpcRequest("simulateTransaction", yt), Xh);
                        if ("error" in dt) {
                            let qe;
                            if ("data" in dt.error && (qe = dt.error.data.logs, qe && Array.isArray(qe))) {
                                const it = "\n    ",
                                    ft = it + qe.join(it);
                                console.error(dt.error.message, ft)
                            }
                            throw new z_("failed to simulate transaction: " + dt.error.message, qe)
                        }
                        return dt.result
                    })()
                }
                sendTransaction(l, d, p) {
                    var _ = this;
                    return (0, K.Z)(function*() {
                        if ("version" in l) {
                            if (d && Array.isArray(d)) throw new Error("Invalid arguments");
                            const se = l.serialize();
                            return yield _.sendRawTransaction(se, d)
                        }
                        if (void 0 === d || !Array.isArray(d)) throw new Error("Invalid arguments");
                        const k = d;
                        if (l.nonceInfo) l.sign(...k);
                        else {
                            let se = _._disableBlockhashCaching;
                            for (;;) {
                                const fe = yield _._blockhashWithExpiryBlockHeight(se);
                                if (l.lastValidBlockHeight = fe.lastValidBlockHeight, l.recentBlockhash = fe.blockhash, l.sign(...k), !l.signature) throw new Error("!signature");
                                const Pe = l.signature.toString("base64");
                                if (!_._blockhashInfo.transactionSignatures.includes(Pe)) {
                                    _._blockhashInfo.transactionSignatures.push(Pe);
                                    break
                                }
                                se = !0
                            }
                        }
                        const B = l.serialize();
                        return yield _.sendRawTransaction(B, p)
                    })()
                }
                sendRawTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = Oi(l).toString("base64");
                        return yield p.sendEncodedTransaction(_, d)
                    })()
                }
                sendEncodedTransaction(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = {
                                encoding: "base64"
                            },
                            k = d && d.skipPreflight,
                            B = !0 === k ? "processed" : d && d.preflightCommitment || p.commitment;
                        d && null != d.maxRetries && (_.maxRetries = d.maxRetries), d && null != d.minContextSlot && (_.minContextSlot = d.minContextSlot), k && (_.skipPreflight = k), B && (_.preflightCommitment = B);
                        const se = [l, _],
                            Pe = $t(yield p._rpcRequest("sendTransaction", se), rf);
                        if ("error" in Pe) {
                            let Ne;
                            throw "data" in Pe.error && (Ne = Pe.error.data.logs), new z_("failed to send transaction: " + Pe.error.message, Ne)
                        }
                        return Pe.result
                    })()
                }
                _wsOnOpen() {
                    var l = this;
                    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
                        (0, K.Z)(function*() {
                            try {
                                yield l._rpcWebSocket.notify("ping")
                            } catch {}
                        })()
                    }, 5e3), this._updateSubscriptions()
                }
                _wsOnError(l) {
                    this._rpcWebSocketConnected = !1, console.error("ws error:", l.message)
                }
                _wsOnClose(l) {
                    this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), 1e3 !== l ? (this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([d, p]) => {
                        this._setSubscription(d, { ...p,
                            state: "pending"
                        })
                    })) : this._updateSubscriptions()
                }
                _setSubscription(l, d) {
                    const p = this._subscriptionsByHash[l] ? .state;
                    if (this._subscriptionsByHash[l] = d, p !== d.state) {
                        const _ = this._subscriptionStateChangeCallbacksByHash[l];
                        _ && _.forEach(k => {
                            try {
                                k(d.state)
                            } catch {}
                        })
                    }
                }
                _onSubscriptionStateChange(l, d) {
                    const p = this._subscriptionHashByClientSubscriptionId[l];
                    if (null == p) return () => {};
                    const _ = this._subscriptionStateChangeCallbacksByHash[p] || = new Set;
                    return _.add(d), () => {
                        _.delete(d), 0 === _.size && delete this._subscriptionStateChangeCallbacksByHash[p]
                    }
                }
                _updateSubscriptions() {
                    var l = this;
                    return (0, K.Z)(function*() {
                        if (0 === Object.keys(l._subscriptionsByHash).length) return void(l._rpcWebSocketConnected && (l._rpcWebSocketConnected = !1, l._rpcWebSocketIdleTimeout = setTimeout(() => {
                            l._rpcWebSocketIdleTimeout = null;
                            try {
                                l._rpcWebSocket.close()
                            } catch (_) {
                                _ instanceof Error && console.log(`Error when closing socket connection: ${_.message}`)
                            }
                        }, 500)));
                        if (null !== l._rpcWebSocketIdleTimeout && (clearTimeout(l._rpcWebSocketIdleTimeout), l._rpcWebSocketIdleTimeout = null, l._rpcWebSocketConnected = !0), !l._rpcWebSocketConnected) return void l._rpcWebSocket.connect();
                        const d = l._rpcWebSocketGeneration,
                            p = () => d === l._rpcWebSocketGeneration;
                        yield Promise.all(Object.keys(l._subscriptionsByHash).map(function() {
                            var _ = (0, K.Z)(function*(k) {
                                const B = l._subscriptionsByHash[k];
                                if (void 0 !== B) switch (B.state) {
                                    case "pending":
                                    case "unsubscribed":
                                        if (0 === B.callbacks.size) return delete l._subscriptionsByHash[k], "unsubscribed" === B.state && delete l._subscriptionCallbacksByServerSubscriptionId[B.serverSubscriptionId], void(yield l._updateSubscriptions());
                                        yield(0, K.Z)(function*() {
                                            const {
                                                args: se,
                                                method: fe
                                            } = B;
                                            try {
                                                l._setSubscription(k, { ...B,
                                                    state: "subscribing"
                                                });
                                                const Pe = yield l._rpcWebSocket.call(fe, se);
                                                l._setSubscription(k, { ...B,
                                                    serverSubscriptionId: Pe,
                                                    state: "subscribed"
                                                }), l._subscriptionCallbacksByServerSubscriptionId[Pe] = B.callbacks, yield l._updateSubscriptions()
                                            } catch (Pe) {
                                                if (Pe instanceof Error && console.error(`${fe} error for argument`, se, Pe.message), !p()) return;
                                                l._setSubscription(k, { ...B,
                                                    state: "pending"
                                                }), yield l._updateSubscriptions()
                                            }
                                        })();
                                        break;
                                    case "subscribed":
                                        0 === B.callbacks.size && (yield(0, K.Z)(function*() {
                                            const {
                                                serverSubscriptionId: se,
                                                unsubscribeMethod: fe
                                            } = B;
                                            if (l._subscriptionsAutoDisposedByRpc.has(se)) l._subscriptionsAutoDisposedByRpc.delete(se);
                                            else {
                                                l._setSubscription(k, { ...B,
                                                    state: "unsubscribing"
                                                }), l._setSubscription(k, { ...B,
                                                    state: "unsubscribing"
                                                });
                                                try {
                                                    yield l._rpcWebSocket.call(fe, [se])
                                                } catch (Pe) {
                                                    if (Pe instanceof Error && console.error(`${fe} error:`, Pe.message), !p()) return;
                                                    return l._setSubscription(k, { ...B,
                                                        state: "subscribed"
                                                    }), void(yield l._updateSubscriptions())
                                                }
                                            }
                                            l._setSubscription(k, { ...B,
                                                state: "unsubscribed"
                                            }), yield l._updateSubscriptions()
                                        })())
                                }
                            });
                            return function(k) {
                                return _.apply(this, arguments)
                            }
                        }()))
                    })()
                }
                _handleServerNotification(l, d) {
                    const p = this._subscriptionCallbacksByServerSubscriptionId[l];
                    void 0 !== p && p.forEach(_ => {
                        try {
                            _(...d)
                        } catch (k) {
                            console.error(k)
                        }
                    })
                }
                _wsOnAccountNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, J_);
                    this._handleServerNotification(p, [d.value, d.context])
                }
                _makeSubscription(l, d) {
                    var p = this;
                    const _ = this._nextClientSubscriptionId++,
                        k = Pd([l.method, d]),
                        B = this._subscriptionsByHash[k];
                    return void 0 === B ? this._subscriptionsByHash[k] = { ...l,
                        args: d,
                        callbacks: new Set([l.callback]),
                        state: "pending"
                    } : B.callbacks.add(l.callback), this._subscriptionHashByClientSubscriptionId[_] = k, this._subscriptionDisposeFunctionsByClientSubscriptionId[_] = (0, K.Z)(function*() {
                        delete p._subscriptionDisposeFunctionsByClientSubscriptionId[_], delete p._subscriptionHashByClientSubscriptionId[_];
                        const se = p._subscriptionsByHash[k];
                        Tr(void 0 !== se, `Could not find a \`Subscription\` when tearing down client subscription #${_}`), se.callbacks.delete(l.callback), yield p._updateSubscriptions()
                    }), this._updateSubscriptions(), _
                }
                onAccountChange(l, d, p) {
                    const _ = this._buildArgs([l.toBase58()], p || this._commitment || "finalized", "base64");
                    return this._makeSubscription({
                        callback: d,
                        method: "accountSubscribe",
                        unsubscribeMethod: "accountUnsubscribe"
                    }, _)
                }
                removeAccountChangeListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "account change")
                    })()
                }
                _wsOnProgramAccountNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, X1);
                    this._handleServerNotification(p, [{
                        accountId: d.value.pubkey,
                        accountInfo: d.value.account
                    }, d.context])
                }
                onProgramAccountChange(l, d, p, _) {
                    const k = this._buildArgs([l.toBase58()], p || this._commitment || "finalized", "base64", _ ? {
                        filters: _
                    } : void 0);
                    return this._makeSubscription({
                        callback: d,
                        method: "programSubscribe",
                        unsubscribeMethod: "programUnsubscribe"
                    }, k)
                }
                removeProgramAccountChangeListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "program account change")
                    })()
                }
                onLogs(l, d, p) {
                    const _ = this._buildArgs(["object" == typeof l ? {
                        mentions: [l.toString()]
                    } : l], p || this._commitment || "finalized");
                    return this._makeSubscription({
                        callback: d,
                        method: "logsSubscribe",
                        unsubscribeMethod: "logsUnsubscribe"
                    }, _)
                }
                removeOnLogsListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "logs")
                    })()
                }
                _wsOnLogsNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, $a);
                    this._handleServerNotification(p, [d.value, d.context])
                }
                _wsOnSlotNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, Q1);
                    this._handleServerNotification(p, [d])
                }
                onSlotChange(l) {
                    return this._makeSubscription({
                        callback: l,
                        method: "slotSubscribe",
                        unsubscribeMethod: "slotUnsubscribe"
                    }, [])
                }
                removeSlotChangeListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "slot change")
                    })()
                }
                _wsOnSlotUpdatesNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, Ug);
                    this._handleServerNotification(p, [d])
                }
                onSlotUpdate(l) {
                    return this._makeSubscription({
                        callback: l,
                        method: "slotsUpdatesSubscribe",
                        unsubscribeMethod: "slotsUpdatesUnsubscribe"
                    }, [])
                }
                removeSlotUpdateListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "slot update")
                    })()
                }
                _unsubscribeClientSubscription(l, d) {
                    var p = this;
                    return (0, K.Z)(function*() {
                        const _ = p._subscriptionDisposeFunctionsByClientSubscriptionId[l];
                        _ ? yield _(): console.warn(`Ignored unsubscribe request because an active subscription with id \`${l}\` for '${d}' events could not be found.`)
                    })()
                }
                _buildArgs(l, d, p, _) {
                    const k = d || this._commitment;
                    if (k || p || _) {
                        let B = {};
                        p && (B.encoding = p), k && (B.commitment = k), _ && (B = Object.assign(B, _)), l.push(B)
                    }
                    return l
                }
                _buildArgsAtLeastConfirmed(l, d, p, _) {
                    const k = d || this._commitment;
                    if (k && !["confirmed", "finalized"].includes(k)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
                    return this._buildArgs(l, d, p, _)
                }
                _wsOnSignatureNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, tv);
                    "receivedSignature" !== d.value && this._subscriptionsAutoDisposedByRpc.add(p), this._handleServerNotification(p, "receivedSignature" === d.value ? [{
                        type: "received"
                    }, d.context] : [{
                        type: "status",
                        result: d.value
                    }, d.context])
                }
                onSignature(l, d, p) {
                    const _ = this._buildArgs([l], p || this._commitment || "finalized"),
                        k = this._makeSubscription({
                            callback: (B, se) => {
                                if ("status" === B.type) {
                                    d(B.result, se);
                                    try {
                                        this.removeSignatureListener(k)
                                    } catch {}
                                }
                            },
                            method: "signatureSubscribe",
                            unsubscribeMethod: "signatureUnsubscribe"
                        }, _);
                    return k
                }
                onSignatureWithOptions(l, d, p) {
                    const {
                        commitment: _,
                        ...k
                    } = { ...p,
                        commitment: p && p.commitment || this._commitment || "finalized"
                    }, B = this._buildArgs([l], _, void 0, k), se = this._makeSubscription({
                        callback: (fe, Pe) => {
                            d(fe, Pe);
                            try {
                                this.removeSignatureListener(se)
                            } catch {}
                        },
                        method: "signatureSubscribe",
                        unsubscribeMethod: "signatureUnsubscribe"
                    }, B);
                    return se
                }
                removeSignatureListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "signature result")
                    })()
                }
                _wsOnRootNotification(l) {
                    const {
                        result: d,
                        subscription: p
                    } = $t(l, Fp);
                    this._handleServerNotification(p, [d])
                }
                onRootChange(l) {
                    return this._makeSubscription({
                        callback: l,
                        method: "rootSubscribe",
                        unsubscribeMethod: "rootUnsubscribe"
                    }, [])
                }
                removeRootChangeListener(l) {
                    var d = this;
                    return (0, K.Z)(function*() {
                        yield d._unsubscribeClientSubscription(l, "root change")
                    })()
                }
            }
            class ul {
                constructor(l) {
                    this._keypair = void 0, this._keypair = l ? ? Cg()
                }
                static generate() {
                    return new ul(Cg())
                }
                static fromSecretKey(l, d) {
                    if (64 !== l.byteLength) throw new Error("bad secret key size");
                    const p = l.slice(32, 64);
                    if (!d || !d.skipValidation) {
                        const _ = l.slice(0, 32),
                            k = Dd(_);
                        for (let B = 0; B < 32; B++)
                            if (p[B] !== k[B]) throw new Error("provided secretKey is invalid")
                    }
                    return new ul({
                        publicKey: p,
                        secretKey: l
                    })
                }
                static fromSeed(l) {
                    const d = Dd(l),
                        p = new Uint8Array(64);
                    return p.set(l), p.set(d, 32), new ul({
                        publicKey: d,
                        secretKey: p
                    })
                }
                get publicKey() {
                    return new ln(this._keypair.publicKey)
                }
                get secretKey() {
                    return new Uint8Array(this._keypair.secretKey)
                }
            }
            const va = Object.freeze({
                CreateLookupTable: {
                    index: 0,
                    layout: He.n_([He.Jq("instruction"), Au("recentSlot"), He.u8("bumpSeed")])
                },
                FreezeLookupTable: {
                    index: 1,
                    layout: He.n_([He.Jq("instruction")])
                },
                ExtendLookupTable: {
                    index: 2,
                    layout: He.n_([He.Jq("instruction"), Au(), He.A9(er(), He.cv(He.Jq(), -8), "addresses")])
                },
                DeactivateLookupTable: {
                    index: 3,
                    layout: He.n_([He.Jq("instruction")])
                },
                CloseLookupTable: {
                    index: 4,
                    layout: He.n_([He.Jq("instruction")])
                }
            });
            class aC {
                constructor() {}
                static decodeInstructionType(l) {
                    this.checkProgramId(l.programId);
                    const p = He.Jq("instruction").decode(l.data);
                    let _;
                    for (const [k, B] of Object.entries(va))
                        if (B.index == p) {
                            _ = k;
                            break
                        }
                    if (!_) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
                    return _
                }
                static decodeCreateLookupTable(l) {
                    this.checkProgramId(l.programId), this.checkKeysLength(l.keys, 4);
                    const {
                        recentSlot: d
                    } = Dr(va.CreateLookupTable, l.data);
                    return {
                        authority: l.keys[1].pubkey,
                        payer: l.keys[2].pubkey,
                        recentSlot: Number(d)
                    }
                }
                static decodeExtendLookupTable(l) {
                    if (this.checkProgramId(l.programId), l.keys.length < 2) throw new Error(`invalid instruction; found ${l.keys.length} keys, expected at least 2`);
                    const {
                        addresses: d
                    } = Dr(va.ExtendLookupTable, l.data);
                    return {
                        lookupTable: l.keys[0].pubkey,
                        authority: l.keys[1].pubkey,
                        payer: l.keys.length > 2 ? l.keys[2].pubkey : void 0,
                        addresses: d.map(p => new ln(p))
                    }
                }
                static decodeCloseLookupTable(l) {
                    return this.checkProgramId(l.programId), this.checkKeysLength(l.keys, 3), {
                        lookupTable: l.keys[0].pubkey,
                        authority: l.keys[1].pubkey,
                        recipient: l.keys[2].pubkey
                    }
                }
                static decodeFreezeLookupTable(l) {
                    return this.checkProgramId(l.programId), this.checkKeysLength(l.keys, 2), {
                        lookupTable: l.keys[0].pubkey,
                        authority: l.keys[1].pubkey
                    }
                }
                static decodeDeactivateLookupTable(l) {
                    return this.checkProgramId(l.programId), this.checkKeysLength(l.keys, 2), {
                        lookupTable: l.keys[0].pubkey,
                        authority: l.keys[1].pubkey
                    }
                }
                static checkProgramId(l) {
                    if (!l.equals(fv.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program")
                }
                static checkKeysLength(l, d) {
                    if (l.length < d) throw new Error(`invalid instruction; found ${l.length} keys, expected at least ${d}`)
                }
            }
            class fv {
                constructor() {}
                static createLookupTable(l) {
                    const [d, p] = ln.findProgramAddressSync([l.authority.toBuffer(), (0, La.k$)(BigInt(l.recentSlot), 8)], this.programId), k = ar(va.CreateLookupTable, {
                        recentSlot: BigInt(l.recentSlot),
                        bumpSeed: p
                    });
                    return [new Hr({
                        programId: this.programId,
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authority,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: l.payer,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: ro.programId,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        data: k
                    }), d]
                }
                static freezeLookupTable(l) {
                    const p = ar(va.FreezeLookupTable);
                    return new Hr({
                        programId: this.programId,
                        keys: [{
                            pubkey: l.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authority,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        data: p
                    })
                }
                static extendLookupTable(l) {
                    const p = ar(va.ExtendLookupTable, {
                            addresses: l.addresses.map(k => k.toBytes())
                        }),
                        _ = [{
                            pubkey: l.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return l.payer && _.push({
                        pubkey: l.payer,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: ro.programId,
                        isSigner: !1,
                        isWritable: !1
                    }), new Hr({
                        programId: this.programId,
                        keys: _,
                        data: p
                    })
                }
                static deactivateLookupTable(l) {
                    const p = ar(va.DeactivateLookupTable);
                    return new Hr({
                        programId: this.programId,
                        keys: [{
                            pubkey: l.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authority,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        data: p
                    })
                }
                static closeLookupTable(l) {
                    const p = ar(va.CloseLookupTable);
                    return new Hr({
                        programId: this.programId,
                        keys: [{
                            pubkey: l.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: l.authority,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: l.recipient,
                            isSigner: !1,
                            isWritable: !0
                        }],
                        data: p
                    })
                }
            }
            fv.programId = new ln("AddressLookupTab1e1111111111111111111111111");
            class cC {
                constructor() {}
                static decodeInstructionType(l) {
                    this.checkProgramId(l.programId);
                    const p = He.u8("instruction").decode(l.data);
                    let _;
                    for (const [k, B] of Object.entries(dl))
                        if (B.index == p) {
                            _ = k;
                            break
                        }
                    if (!_) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
                    return _
                }
                static decodeRequestUnits(l) {
                    this.checkProgramId(l.programId);
                    const {
                        units: d,
                        additionalFee: p
                    } = Dr(dl.RequestUnits, l.data);
                    return {
                        units: d,
                        additionalFee: p
                    }
                }
                static decodeRequestHeapFrame(l) {
                    this.checkProgramId(l.programId);
                    const {
                        bytes: d
                    } = Dr(dl.RequestHeapFrame, l.data);
                    return {
                        bytes: d
                    }
                }
                static decodeSetComputeUnitLimit(l) {
                    this.checkProgramId(l.programId);
                    const {
                        units: d
                    } = Dr(dl.SetComputeUnitLimit, l.data);
                    return {
                        units: d
                    }
                }
                static decodeSetComputeUnitPrice(l) {
                    this.checkProgramId(l.programId);
                    const {
                        microLamports: d
                    } = Dr(dl.SetComputeUnitPrice, l.data);
                    return {
                        microLamports: d
                    }
                }
                static checkProgramId(l) {
                    if (!l.equals($o.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
                }
            }
            const dl = Object.freeze({
                RequestUnits: {
                    index: 0,
                    layout: He.n_([He.u8("instruction"), He.Jq("units"), He.Jq("additionalFee")])
                },
                RequestHeapFrame: {
                    index: 1,
                    layout: He.n_([He.u8("instruction"), He.Jq("bytes")])
                },
                SetComputeUnitLimit: {
                    index: 2,
                    layout: He.n_([He.u8("instruction"), He.Jq("units")])
                },
                SetComputeUnitPrice: {
                    index: 3,
                    layout: He.n_([He.u8("instruction"), Au("microLamports")])
                }
            });
            class $o {
                constructor() {}
                static requestUnits(l) {
                    const p = ar(dl.RequestUnits, l);
                    return new Hr({
                        keys: [],
                        programId: this.programId,
                        data: p
                    })
                }
                static requestHeapFrame(l) {
                    const p = ar(dl.RequestHeapFrame, l);
                    return new Hr({
                        keys: [],
                        programId: this.programId,
                        data: p
                    })
                }
                static setComputeUnitLimit(l) {
                    const p = ar(dl.SetComputeUnitLimit, l);
                    return new Hr({
                        keys: [],
                        programId: this.programId,
                        data: p
                    })
                }
                static setComputeUnitPrice(l) {
                    const p = ar(dl.SetComputeUnitPrice, {
                        microLamports: BigInt(l.microLamports)
                    });
                    return new Hr({
                        keys: [],
                        programId: this.programId,
                        data: p
                    })
                }
            }
            $o.programId = new ln("ComputeBudget111111111111111111111111111111");
            const Gg = He.n_([He.u8("numSignatures"), He.u8("padding"), He.KB("signatureOffset"), He.KB("signatureInstructionIndex"), He.KB("publicKeyOffset"), He.KB("publicKeyInstructionIndex"), He.KB("messageDataOffset"), He.KB("messageDataSize"), He.KB("messageInstructionIndex")]);
            class Up {
                constructor() {}
                static createInstructionWithPublicKey(l) {
                    const {
                        publicKey: d,
                        message: p,
                        signature: _,
                        instructionIndex: k
                    } = l;
                    Tr(32 === d.length, `Public Key must be 32 bytes but received ${d.length} bytes`), Tr(64 === _.length, `Signature must be 64 bytes but received ${_.length} bytes`);
                    const B = Gg.span,
                        se = B + d.length,
                        fe = se + _.length,
                        Ne = q.Buffer.alloc(fe + p.length),
                        Je = k ? ? 65535;
                    return Gg.encode({
                        numSignatures: 1,
                        padding: 0,
                        signatureOffset: se,
                        signatureInstructionIndex: Je,
                        publicKeyOffset: B,
                        publicKeyInstructionIndex: Je,
                        messageDataOffset: fe,
                        messageDataSize: p.length,
                        messageInstructionIndex: Je
                    }, Ne), Ne.fill(d, B), Ne.fill(_, se), Ne.fill(p, fe), new Hr({
                        keys: [],
                        programId: Up.programId,
                        data: Ne
                    })
                }
                static createInstructionWithPrivateKey(l) {
                    const {
                        privateKey: d,
                        message: p,
                        instructionIndex: _
                    } = l;
                    Tr(64 === d.length, `Private key must be 64 bytes but received ${d.length} bytes`);
                    try {
                        const k = ul.fromSecretKey(d),
                            B = k.publicKey.toBytes(),
                            se = zh(p, k.secretKey);
                        return this.createInstructionWithPublicKey({
                            publicKey: B,
                            message: p,
                            signature: se,
                            instructionIndex: _
                        })
                    } catch (k) {
                        throw new Error(`Error creating instruction; ${k}`)
                    }
                }
            }
            Up.programId = new ln("Ed25519SigVerify111111111111111111111111111");
            const dC = ol.getPublicKey,
                $d = He.n_([He.u8("numSignatures"), He.KB("signatureOffset"), He.u8("signatureInstructionIndex"), He.KB("ethAddressOffset"), He.u8("ethAddressInstructionIndex"), He.KB("messageDataOffset"), He.KB("messageDataSize"), He.u8("messageInstructionIndex"), He.Ik(20, "ethAddress"), He.Ik(64, "signature"), He.u8("recoveryId")]);
            class zd {
                constructor() {}
                static publicKeyToEthAddress(l) {
                    Tr(64 === l.length, `Public key must be 64 bytes but received ${l.length} bytes`);
                    try {
                        return q.Buffer.from(ma(Oi(l))).slice(-20)
                    } catch (d) {
                        throw new Error(`Error constructing Ethereum address: ${d}`)
                    }
                }
                static createInstructionWithPublicKey(l) {
                    const {
                        publicKey: d,
                        message: p,
                        signature: _,
                        recoveryId: k,
                        instructionIndex: B
                    } = l;
                    return zd.createInstructionWithEthAddress({
                        ethAddress: zd.publicKeyToEthAddress(d),
                        message: p,
                        signature: _,
                        recoveryId: k,
                        instructionIndex: B
                    })
                }
                static createInstructionWithEthAddress(l) {
                    const {
                        ethAddress: d,
                        message: p,
                        signature: _,
                        recoveryId: k,
                        instructionIndex: B = 0
                    } = l;
                    let se;
                    se = "string" == typeof d ? d.startsWith("0x") ? q.Buffer.from(d.substr(2), "hex") : q.Buffer.from(d, "hex") : d, Tr(20 === se.length, `Address must be 20 bytes but received ${se.length} bytes`);
                    const Ne = 12 + se.length,
                        Je = Ne + _.length + 1,
                        bt = q.Buffer.alloc($d.span + p.length);
                    return $d.encode({
                        numSignatures: 1,
                        signatureOffset: Ne,
                        signatureInstructionIndex: B,
                        ethAddressOffset: 12,
                        ethAddressInstructionIndex: B,
                        messageDataOffset: Je,
                        messageDataSize: p.length,
                        messageInstructionIndex: B,
                        signature: Oi(_),
                        ethAddress: Oi(se),
                        recoveryId: k
                    }, bt), bt.fill(Oi(p), $d.span), new Hr({
                        keys: [],
                        programId: zd.programId,
                        data: bt
                    })
                }
                static createInstructionWithPrivateKey(l) {
                    const {
                        privateKey: d,
                        message: p,
                        instructionIndex: _
                    } = l;
                    Tr(32 === d.length, `Private key must be 32 bytes but received ${d.length} bytes`);
                    try {
                        const k = Oi(d),
                            B = dC(k, !1).slice(1),
                            se = q.Buffer.from(ma(Oi(p))),
                            [fe, Pe] = ((g, l) => {
                                const d = ol.sign(g, l);
                                return [d.toCompactRawBytes(), d.recovery]
                            })(se, k);
                        return this.createInstructionWithPublicKey({
                            publicKey: B,
                            message: p,
                            signature: fe,
                            recoveryId: Pe,
                            instructionIndex: _
                        })
                    } catch (k) {
                        throw new Error(`Error creating instruction; ${k}`)
                    }
                }
            }
            zd.programId = new ln("KeccakSecp256k11111111111111111111111111111");
            const gv = new ln("StakeConfig11111111111111111111111111111111");
            class jd {
                constructor(l, d) {
                    this.staker = void 0, this.withdrawer = void 0, this.staker = l, this.withdrawer = d
                }
            }
            class sf {
                constructor(l, d, p) {
                    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = l, this.epoch = d, this.custodian = p
                }
            }
            sf.default = new sf(0, 0, ln.default);
            class yv {
                constructor() {}
                static decodeInstructionType(l) {
                    this.checkProgramId(l.programId);
                    const p = He.Jq("instruction").decode(l.data);
                    let _;
                    for (const [k, B] of Object.entries(Os))
                        if (B.index == p) {
                            _ = k;
                            break
                        }
                    if (!_) throw new Error("Instruction type incorrect; not a StakeInstruction");
                    return _
                }
                static decodeInitialize(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        authorized: d,
                        lockup: p
                    } = Dr(Os.Initialize, l.data);
                    return {
                        stakePubkey: l.keys[0].pubkey,
                        authorized: new jd(new ln(d.staker), new ln(d.withdrawer)),
                        lockup: new sf(p.unixTimestamp, p.epoch, new ln(p.custodian))
                    }
                }
                static decodeDelegate(l) {
                    return this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 6), Dr(Os.Delegate, l.data), {
                        stakePubkey: l.keys[0].pubkey,
                        votePubkey: l.keys[1].pubkey,
                        authorizedPubkey: l.keys[5].pubkey
                    }
                }
                static decodeAuthorize(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        newAuthorized: d,
                        stakeAuthorizationType: p
                    } = Dr(Os.Authorize, l.data), _ = {
                        stakePubkey: l.keys[0].pubkey,
                        authorizedPubkey: l.keys[2].pubkey,
                        newAuthorizedPubkey: new ln(d),
                        stakeAuthorizationType: {
                            index: p
                        }
                    };
                    return l.keys.length > 3 && (_.custodianPubkey = l.keys[3].pubkey), _
                }
                static decodeAuthorizeWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 2);
                    const {
                        newAuthorized: d,
                        stakeAuthorizationType: p,
                        authoritySeed: _,
                        authorityOwner: k
                    } = Dr(Os.AuthorizeWithSeed, l.data), B = {
                        stakePubkey: l.keys[0].pubkey,
                        authorityBase: l.keys[1].pubkey,
                        authoritySeed: _,
                        authorityOwner: new ln(k),
                        newAuthorizedPubkey: new ln(d),
                        stakeAuthorizationType: {
                            index: p
                        }
                    };
                    return l.keys.length > 3 && (B.custodianPubkey = l.keys[3].pubkey), B
                }
                static decodeSplit(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        lamports: d
                    } = Dr(Os.Split, l.data);
                    return {
                        stakePubkey: l.keys[0].pubkey,
                        splitStakePubkey: l.keys[1].pubkey,
                        authorizedPubkey: l.keys[2].pubkey,
                        lamports: d
                    }
                }
                static decodeMerge(l) {
                    return this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3), Dr(Os.Merge, l.data), {
                        stakePubkey: l.keys[0].pubkey,
                        sourceStakePubKey: l.keys[1].pubkey,
                        authorizedPubkey: l.keys[4].pubkey
                    }
                }
                static decodeWithdraw(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 5);
                    const {
                        lamports: d
                    } = Dr(Os.Withdraw, l.data), p = {
                        stakePubkey: l.keys[0].pubkey,
                        toPubkey: l.keys[1].pubkey,
                        authorizedPubkey: l.keys[4].pubkey,
                        lamports: d
                    };
                    return l.keys.length > 5 && (p.custodianPubkey = l.keys[5].pubkey), p
                }
                static decodeDeactivate(l) {
                    return this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3), Dr(Os.Deactivate, l.data), {
                        stakePubkey: l.keys[0].pubkey,
                        authorizedPubkey: l.keys[2].pubkey
                    }
                }
                static checkProgramId(l) {
                    if (!l.equals(af.programId)) throw new Error("invalid instruction; programId is not StakeProgram")
                }
                static checkKeyLength(l, d) {
                    if (l.length < d) throw new Error(`invalid instruction; found ${l.length} keys, expected at least ${d}`)
                }
            }
            const Os = Object.freeze({
                    Initialize: {
                        index: 0,
                        layout: He.n_([He.Jq("instruction"), ((g = "authorized") => He.n_([er("staker"), er("withdrawer")], g))(), ((g = "lockup") => He.n_([He.gM("unixTimestamp"), He.gM("epoch"), er("custodian")], g))()])
                    },
                    Authorize: {
                        index: 1,
                        layout: He.n_([He.Jq("instruction"), er("newAuthorized"), He.Jq("stakeAuthorizationType")])
                    },
                    Delegate: {
                        index: 2,
                        layout: He.n_([He.Jq("instruction")])
                    },
                    Split: {
                        index: 3,
                        layout: He.n_([He.Jq("instruction"), He.gM("lamports")])
                    },
                    Withdraw: {
                        index: 4,
                        layout: He.n_([He.Jq("instruction"), He.gM("lamports")])
                    },
                    Deactivate: {
                        index: 5,
                        layout: He.n_([He.Jq("instruction")])
                    },
                    Merge: {
                        index: 7,
                        layout: He.n_([He.Jq("instruction")])
                    },
                    AuthorizeWithSeed: {
                        index: 8,
                        layout: He.n_([He.Jq("instruction"), er("newAuthorized"), He.Jq("stakeAuthorizationType"), Fl("authoritySeed"), er("authorityOwner")])
                    }
                }),
                Hp = Object.freeze({
                    Staker: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class af {
                constructor() {}
                static initialize(l) {
                    const {
                        stakePubkey: d,
                        authorized: p,
                        lockup: _
                    } = l, k = _ || sf.default, se = ar(Os.Initialize, {
                        authorized: {
                            staker: Oi(p.staker.toBuffer()),
                            withdrawer: Oi(p.withdrawer.toBuffer())
                        },
                        lockup: {
                            unixTimestamp: k.unixTimestamp,
                            epoch: k.epoch,
                            custodian: Oi(k.custodian.toBuffer())
                        }
                    });
                    return new Hr({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: Md,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: se
                    })
                }
                static createAccountWithSeed(l) {
                    const d = new Fi;
                    d.add(ro.createAccountWithSeed({
                        fromPubkey: l.fromPubkey,
                        newAccountPubkey: l.stakePubkey,
                        basePubkey: l.basePubkey,
                        seed: l.seed,
                        lamports: l.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: p,
                        authorized: _,
                        lockup: k
                    } = l;
                    return d.add(this.initialize({
                        stakePubkey: p,
                        authorized: _,
                        lockup: k
                    }))
                }
                static createAccount(l) {
                    const d = new Fi;
                    d.add(ro.createAccount({
                        fromPubkey: l.fromPubkey,
                        newAccountPubkey: l.stakePubkey,
                        lamports: l.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: p,
                        authorized: _,
                        lockup: k
                    } = l;
                    return d.add(this.initialize({
                        stakePubkey: p,
                        authorized: _,
                        lockup: k
                    }))
                }
                static delegate(l) {
                    const {
                        stakePubkey: d,
                        authorizedPubkey: p,
                        votePubkey: _
                    } = l, B = ar(Os.Delegate);
                    return (new Fi).add({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: _,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Bc,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Kh,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: gv,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: p,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: B
                    })
                }
                static authorize(l) {
                    const {
                        stakePubkey: d,
                        authorizedPubkey: p,
                        newAuthorizedPubkey: _,
                        stakeAuthorizationType: k,
                        custodianPubkey: B
                    } = l, fe = ar(Os.Authorize, {
                        newAuthorized: Oi(_.toBuffer()),
                        stakeAuthorizationType: k.index
                    }), Pe = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Bc,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return B && Pe.push({
                        pubkey: B,
                        isSigner: !0,
                        isWritable: !1
                    }), (new Fi).add({
                        keys: Pe,
                        programId: this.programId,
                        data: fe
                    })
                }
                static authorizeWithSeed(l) {
                    const {
                        stakePubkey: d,
                        authorityBase: p,
                        authoritySeed: _,
                        authorityOwner: k,
                        newAuthorizedPubkey: B,
                        stakeAuthorizationType: se,
                        custodianPubkey: fe
                    } = l, Ne = ar(Os.AuthorizeWithSeed, {
                        newAuthorized: Oi(B.toBuffer()),
                        stakeAuthorizationType: se.index,
                        authoritySeed: _,
                        authorityOwner: Oi(k.toBuffer())
                    }), Je = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: Bc,
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return fe && Je.push({
                        pubkey: fe,
                        isSigner: !0,
                        isWritable: !1
                    }), (new Fi).add({
                        keys: Je,
                        programId: this.programId,
                        data: Ne
                    })
                }
                static splitInstruction(l) {
                    const {
                        stakePubkey: d,
                        authorizedPubkey: p,
                        splitStakePubkey: _,
                        lamports: k
                    } = l, se = ar(Os.Split, {
                        lamports: k
                    });
                    return new Hr({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: _,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: p,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: se
                    })
                }
                static split(l, d) {
                    const p = new Fi;
                    return p.add(ro.createAccount({
                        fromPubkey: l.authorizedPubkey,
                        newAccountPubkey: l.splitStakePubkey,
                        lamports: d,
                        space: this.space,
                        programId: this.programId
                    })), p.add(this.splitInstruction(l))
                }
                static splitWithSeed(l, d) {
                    const {
                        stakePubkey: p,
                        authorizedPubkey: _,
                        splitStakePubkey: k,
                        basePubkey: B,
                        seed: se,
                        lamports: fe
                    } = l, Pe = new Fi;
                    return Pe.add(ro.allocate({
                        accountPubkey: k,
                        basePubkey: B,
                        seed: se,
                        space: this.space,
                        programId: this.programId
                    })), d && d > 0 && Pe.add(ro.transfer({
                        fromPubkey: l.authorizedPubkey,
                        toPubkey: k,
                        lamports: d
                    })), Pe.add(this.splitInstruction({
                        stakePubkey: p,
                        authorizedPubkey: _,
                        splitStakePubkey: k,
                        lamports: fe
                    }))
                }
                static merge(l) {
                    const {
                        stakePubkey: d,
                        sourceStakePubKey: p,
                        authorizedPubkey: _
                    } = l, B = ar(Os.Merge);
                    return (new Fi).add({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: p,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: Bc,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Kh,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: _,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: B
                    })
                }
                static withdraw(l) {
                    const {
                        stakePubkey: d,
                        authorizedPubkey: p,
                        toPubkey: _,
                        lamports: k,
                        custodianPubkey: B
                    } = l, fe = ar(Os.Withdraw, {
                        lamports: k
                    }), Pe = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: _,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Bc,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: Kh,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return B && Pe.push({
                        pubkey: B,
                        isSigner: !0,
                        isWritable: !1
                    }), (new Fi).add({
                        keys: Pe,
                        programId: this.programId,
                        data: fe
                    })
                }
                static deactivate(l) {
                    const {
                        stakePubkey: d,
                        authorizedPubkey: p
                    } = l, k = ar(Os.Deactivate);
                    return (new Fi).add({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: Bc,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: p,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: k
                    })
                }
            }
            af.programId = new ln("Stake11111111111111111111111111111111111111"), af.space = 200;
            class _v {
                constructor(l, d, p, _) {
                    this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = l, this.authorizedVoter = d, this.authorizedWithdrawer = p, this.commission = _
                }
            }
            class hC {
                constructor() {}
                static decodeInstructionType(l) {
                    this.checkProgramId(l.programId);
                    const p = He.Jq("instruction").decode(l.data);
                    let _;
                    for (const [k, B] of Object.entries(zo))
                        if (B.index == p) {
                            _ = k;
                            break
                        }
                    if (!_) throw new Error("Instruction type incorrect; not a VoteInstruction");
                    return _
                }
                static decodeInitializeAccount(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 4);
                    const {
                        voteInit: d
                    } = Dr(zo.InitializeAccount, l.data);
                    return {
                        votePubkey: l.keys[0].pubkey,
                        nodePubkey: l.keys[3].pubkey,
                        voteInit: new _v(new ln(d.nodePubkey), new ln(d.authorizedVoter), new ln(d.authorizedWithdrawer), d.commission)
                    }
                }
                static decodeAuthorize(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        newAuthorized: d,
                        voteAuthorizationType: p
                    } = Dr(zo.Authorize, l.data);
                    return {
                        votePubkey: l.keys[0].pubkey,
                        authorizedPubkey: l.keys[2].pubkey,
                        newAuthorizedPubkey: new ln(d),
                        voteAuthorizationType: {
                            index: p
                        }
                    }
                }
                static decodeAuthorizeWithSeed(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: d,
                            currentAuthorityDerivedKeySeed: p,
                            newAuthorized: _,
                            voteAuthorizationType: k
                        }
                    } = Dr(zo.AuthorizeWithSeed, l.data);
                    return {
                        currentAuthorityDerivedKeyBasePubkey: l.keys[2].pubkey,
                        currentAuthorityDerivedKeyOwnerPubkey: new ln(d),
                        currentAuthorityDerivedKeySeed: p,
                        newAuthorizedPubkey: new ln(_),
                        voteAuthorizationType: {
                            index: k
                        },
                        votePubkey: l.keys[0].pubkey
                    }
                }
                static decodeWithdraw(l) {
                    this.checkProgramId(l.programId), this.checkKeyLength(l.keys, 3);
                    const {
                        lamports: d
                    } = Dr(zo.Withdraw, l.data);
                    return {
                        votePubkey: l.keys[0].pubkey,
                        authorizedWithdrawerPubkey: l.keys[2].pubkey,
                        lamports: d,
                        toPubkey: l.keys[1].pubkey
                    }
                }
                static checkProgramId(l) {
                    if (!l.equals(Wd.programId)) throw new Error("invalid instruction; programId is not VoteProgram")
                }
                static checkKeyLength(l, d) {
                    if (l.length < d) throw new Error(`invalid instruction; found ${l.length} keys, expected at least ${d}`)
                }
            }
            const zo = Object.freeze({
                    InitializeAccount: {
                        index: 0,
                        layout: He.n_([He.Jq("instruction"), ((g = "voteInit") => He.n_([er("nodePubkey"), er("authorizedVoter"), er("authorizedWithdrawer"), He.u8("commission")], g))()])
                    },
                    Authorize: {
                        index: 1,
                        layout: He.n_([He.Jq("instruction"), er("newAuthorized"), He.Jq("voteAuthorizationType")])
                    },
                    Withdraw: {
                        index: 3,
                        layout: He.n_([He.Jq("instruction"), He.gM("lamports")])
                    },
                    UpdateValidatorIdentity: {
                        index: 4,
                        layout: He.n_([He.Jq("instruction")])
                    },
                    AuthorizeWithSeed: {
                        index: 10,
                        layout: He.n_([He.Jq("instruction"), ((g = "voteAuthorizeWithSeedArgs") => He.n_([He.Jq("voteAuthorizationType"), er("currentAuthorityDerivedKeyOwnerPubkey"), Fl("currentAuthorityDerivedKeySeed"), er("newAuthorized")], g))()])
                    }
                }),
                cf = Object.freeze({
                    Voter: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class Wd {
                constructor() {}
                static initializeAccount(l) {
                    const {
                        votePubkey: d,
                        nodePubkey: p,
                        voteInit: _
                    } = l, B = ar(zo.InitializeAccount, {
                        voteInit: {
                            nodePubkey: Oi(_.nodePubkey.toBuffer()),
                            authorizedVoter: Oi(_.authorizedVoter.toBuffer()),
                            authorizedWithdrawer: Oi(_.authorizedWithdrawer.toBuffer()),
                            commission: _.commission
                        }
                    });
                    return new Hr({
                        keys: [{
                            pubkey: d,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: Md,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Bc,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: p,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: B
                    })
                }
                static createAccount(l) {
                    const d = new Fi;
                    return d.add(ro.createAccount({
                        fromPubkey: l.fromPubkey,
                        newAccountPubkey: l.votePubkey,
                        lamports: l.lamports,
                        space: this.space,
                        programId: this.programId
                    })), d.add(this.initializeAccount({
                        votePubkey: l.votePubkey,
                        nodePubkey: l.voteInit.nodePubkey,
                        voteInit: l.voteInit
                    }))
                }
                static authorize(l) {
                    const {
                        votePubkey: d,
                        authorizedPubkey: p,
                        newAuthorizedPubkey: _,
                        voteAuthorizationType: k
                    } = l, se = ar(zo.Authorize, {
                        newAuthorized: Oi(_.toBuffer()),
                        voteAuthorizationType: k.index
                    }), fe = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Bc,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new Fi).add({
                        keys: fe,
                        programId: this.programId,
                        data: se
                    })
                }
                static authorizeWithSeed(l) {
                    const {
                        currentAuthorityDerivedKeyBasePubkey: d,
                        currentAuthorityDerivedKeyOwnerPubkey: p,
                        currentAuthorityDerivedKeySeed: _,
                        newAuthorizedPubkey: k,
                        voteAuthorizationType: B,
                        votePubkey: se
                    } = l, Pe = ar(zo.AuthorizeWithSeed, {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: Oi(p.toBuffer()),
                            currentAuthorityDerivedKeySeed: _,
                            newAuthorized: Oi(k.toBuffer()),
                            voteAuthorizationType: B.index
                        }
                    }), Ne = [{
                        pubkey: se,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: Bc,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: d,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new Fi).add({
                        keys: Ne,
                        programId: this.programId,
                        data: Pe
                    })
                }
                static withdraw(l) {
                    const {
                        votePubkey: d,
                        authorizedWithdrawerPubkey: p,
                        lamports: _,
                        toPubkey: k
                    } = l, se = ar(zo.Withdraw, {
                        lamports: _
                    }), fe = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: k,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new Fi).add({
                        keys: fe,
                        programId: this.programId,
                        data: se
                    })
                }
                static safeWithdraw(l, d, p) {
                    if (l.lamports > d - p) throw new Error("Withdraw will leave vote account with insufficient funds.");
                    return Wd.withdraw(l)
                }
                static updateValidatorIdentity(l) {
                    const {
                        votePubkey: d,
                        authorizedWithdrawerPubkey: p,
                        nodePubkey: _
                    } = l, B = ar(zo.UpdateValidatorIdentity), se = [{
                        pubkey: d,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: _,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: p,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new Fi).add({
                        keys: se,
                        programId: this.programId,
                        data: B
                    })
                }
            }
            Wd.programId = new ln("Vote111111111111111111111111111111111111111"), Wd.space = 3762;
            const fC = new ln("Va1idator1nfo111111111111111111111111111111"),
                vv = Ot({
                    name: Jt(),
                    website: Yn(Jt()),
                    details: Yn(Jt()),
                    keybaseUsername: Yn(Jt())
                });
            class Zg {
                constructor(l, d) {
                    this.key = void 0, this.info = void 0, this.key = l, this.info = d
                }
                static fromConfigData(l) {
                    let d = [...l];
                    if (2 !== Fo(d)) return null;
                    const _ = [];
                    for (let k = 0; k < 2; k++) {
                        const B = new ln(Jo(d, 0, ac)),
                            se = 1 === cc(d);
                        _.push({
                            publicKey: B,
                            isSigner: se
                        })
                    }
                    if (_[0].publicKey.equals(fC) && _[1].isSigner) {
                        const k = Fl().decode(q.Buffer.from(d)),
                            B = JSON.parse(k);
                        return bu(B, vv), new Zg(_[1].publicKey, B)
                    }
                    return null
                }
            }
            const FI = new ln("Vote111111111111111111111111111111111111111"),
                pC = He.n_([er("nodePubkey"), er("authorizedWithdrawer"), He.u8("commission"), He._O(), He.A9(He.n_([He._O("slot"), He.Jq("confirmationCount")]), He.cv(He.Jq(), -8), "votes"), He.u8("rootSlotValid"), He._O("rootSlot"), He._O(), He.A9(He.n_([He._O("epoch"), er("authorizedVoter")]), He.cv(He.Jq(), -8), "authorizedVoters"), He.n_([He.A9(He.n_([er("authorizedPubkey"), He._O("epochOfLastAuthorizedSwitch"), He._O("targetEpoch")]), 32, "buf"), He._O("idx"), He.u8("isEmpty")], "priorVoters"), He._O(), He.A9(He.n_([He._O("epoch"), He._O("credits"), He._O("prevCredits")]), He.cv(He.Jq(), -8), "epochCredits"), He.n_([He._O("slot"), He._O("timestamp")], "lastTimestamp")]);
            class Yg {
                constructor(l) {
                    this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = l.nodePubkey, this.authorizedWithdrawer = l.authorizedWithdrawer, this.commission = l.commission, this.rootSlot = l.rootSlot, this.votes = l.votes, this.authorizedVoters = l.authorizedVoters, this.priorVoters = l.priorVoters, this.epochCredits = l.epochCredits, this.lastTimestamp = l.lastTimestamp
                }
                static fromAccountData(l) {
                    const p = pC.decode(Oi(l), 4);
                    let _ = p.rootSlot;
                    return p.rootSlotValid || (_ = null), new Yg({
                        nodePubkey: new ln(p.nodePubkey),
                        authorizedWithdrawer: new ln(p.authorizedWithdrawer),
                        commission: p.commission,
                        votes: p.votes,
                        rootSlot: _,
                        authorizedVoters: p.authorizedVoters.map(mC),
                        priorVoters: bv(p.priorVoters),
                        epochCredits: p.epochCredits,
                        lastTimestamp: p.lastTimestamp
                    })
                }
            }

            function mC({
                authorizedVoter: g,
                epoch: l
            }) {
                return {
                    epoch: l,
                    authorizedVoter: new ln(g)
                }
            }

            function lf({
                authorizedPubkey: g,
                epochOfLastAuthorizedSwitch: l,
                targetEpoch: d
            }) {
                return {
                    authorizedPubkey: new ln(g),
                    epochOfLastAuthorizedSwitch: l,
                    targetEpoch: d
                }
            }

            function bv({
                buf: g,
                idx: l,
                isEmpty: d
            }) {
                return d ? [] : [...g.slice(l + 1).map(lf), ...g.slice(0, l).map(lf)]
            }
            const wv = {
                http: {
                    devnet: "http://api.devnet.solana.com",
                    testnet: "http://api.testnet.solana.com",
                    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
                },
                https: {
                    devnet: "https://api.devnet.solana.com",
                    testnet: "https://api.testnet.solana.com",
                    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
                }
            };

            function xv(g, l) {
                const d = !1 === l ? "http" : "https";
                if (!g) return wv[d].devnet;
                const p = wv[d][g];
                if (!p) throw new Error(`Unknown ${d} cluster: ${g}`);
                return p
            }

            function VI(g, l, d, p) {
                return $p.apply(this, arguments)
            }

            function $p() {
                return ($p = (0, K.Z)(function*(g, l, d, p) {
                    let _, k;
                    d && Object.prototype.hasOwnProperty.call(d, "lastValidBlockHeight") || d && Object.prototype.hasOwnProperty.call(d, "nonceValue") ? (_ = d, k = p) : k = d;
                    const B = k && {
                            skipPreflight: k.skipPreflight,
                            preflightCommitment: k.preflightCommitment || k.commitment,
                            minContextSlot: k.minContextSlot
                        },
                        se = yield g.sendRawTransaction(l, B), fe = k && k.commitment, Ne = (yield g.confirmTransaction(_ || se, fe)).value;
                    if (Ne.err) throw new Error(`Raw transaction ${se} failed (${JSON.stringify(Ne)})`);
                    return se
                })).apply(this, arguments)
            }
            const UI = 1e9
        },
        99546: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            var F = T(98052);

            function j(v, M, U) {
                return void 0 === M && (M = new Uint8Array(2)), void 0 === U && (U = 0), M[U + 0] = v >>> 8, M[U + 1] = v >>> 0, M
            }

            function C(v, M, U) {
                return void 0 === M && (M = new Uint8Array(2)), void 0 === U && (U = 0), M[U + 0] = v >>> 0, M[U + 1] = v >>> 8, M
            }

            function z(v, M) {
                return void 0 === M && (M = 0), v[M] << 24 | v[M + 1] << 16 | v[M + 2] << 8 | v[M + 3]
            }

            function H(v, M) {
                return void 0 === M && (M = 0), (v[M] << 24 | v[M + 1] << 16 | v[M + 2] << 8 | v[M + 3]) >>> 0
            }

            function Y(v, M) {
                return void 0 === M && (M = 0), v[M + 3] << 24 | v[M + 2] << 16 | v[M + 1] << 8 | v[M]
            }

            function Z(v, M) {
                return void 0 === M && (M = 0), (v[M + 3] << 24 | v[M + 2] << 16 | v[M + 1] << 8 | v[M]) >>> 0
            }

            function le(v, M, U) {
                return void 0 === M && (M = new Uint8Array(4)), void 0 === U && (U = 0), M[U + 0] = v >>> 24, M[U + 1] = v >>> 16, M[U + 2] = v >>> 8, M[U + 3] = v >>> 0, M
            }

            function re(v, M, U) {
                return void 0 === M && (M = new Uint8Array(4)), void 0 === U && (U = 0), M[U + 0] = v >>> 0, M[U + 1] = v >>> 8, M[U + 2] = v >>> 16, M[U + 3] = v >>> 24, M
            }

            function we(v, M, U) {
                return void 0 === M && (M = new Uint8Array(8)), void 0 === U && (U = 0), le(v / 4294967296 >>> 0, M, U), le(v >>> 0, M, U + 4), M
            }

            function ve(v, M, U) {
                return void 0 === M && (M = new Uint8Array(8)), void 0 === U && (U = 0), re(v >>> 0, M, U), re(v / 4294967296 >>> 0, M, U + 4), M
            }
            I.readInt16BE = function K(v, M) {
                return void 0 === M && (M = 0), (v[M + 0] << 8 | v[M + 1]) << 16 >> 16
            }, I.readUint16BE = function q(v, M) {
                return void 0 === M && (M = 0), (v[M + 0] << 8 | v[M + 1]) >>> 0
            }, I.readInt16LE = function ne(v, M) {
                return void 0 === M && (M = 0), (v[M + 1] << 8 | v[M]) << 16 >> 16
            }, I.readUint16LE = function S(v, M) {
                return void 0 === M && (M = 0), (v[M + 1] << 8 | v[M]) >>> 0
            }, I.writeUint16BE = j, I.writeInt16BE = j, I.writeUint16LE = C, I.writeInt16LE = C, I.readInt32BE = z, I.readUint32BE = H, I.readInt32LE = Y, I.readUint32LE = Z, I.writeUint32BE = le, I.writeInt32BE = le, I.writeUint32LE = re, I.writeInt32LE = re, I.readInt64BE = function de(v, M) {
                void 0 === M && (M = 0);
                var U = z(v, M),
                    G = z(v, M + 4);
                return 4294967296 * U + G - 4294967296 * (G >> 31)
            }, I.readUint64BE = function Se(v, M) {
                return void 0 === M && (M = 0), 4294967296 * H(v, M) + H(v, M + 4)
            }, I.readInt64LE = function me(v, M) {
                void 0 === M && (M = 0);
                var U = Y(v, M);
                return 4294967296 * Y(v, M + 4) + U - 4294967296 * (U >> 31)
            }, I.readUint64LE = function Ce(v, M) {
                void 0 === M && (M = 0);
                var U = Z(v, M);
                return 4294967296 * Z(v, M + 4) + U
            }, I.writeUint64BE = we, I.writeInt64BE = we, I.writeUint64LE = ve, I.writeInt64LE = ve, I.readUintBE = function De(v, M, U) {
                if (void 0 === U && (U = 0), v % 8 != 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
                if (v / 8 > M.length - U) throw new Error("readUintBE: array is too short for the given bitLength");
                for (var G = 0, y = 1, E = v / 8 + U - 1; E >= U; E--) G += M[E] * y, y *= 256;
                return G
            }, I.readUintLE = function ae(v, M, U) {
                if (void 0 === U && (U = 0), v % 8 != 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
                if (v / 8 > M.length - U) throw new Error("readUintLE: array is too short for the given bitLength");
                for (var G = 0, y = 1, E = U; E < U + v / 8; E++) G += M[E] * y, y *= 256;
                return G
            }, I.writeUintBE = function Me(v, M, U, G) {
                if (void 0 === U && (U = new Uint8Array(v / 8)), void 0 === G && (G = 0), v % 8 != 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
                if (!F.isSafeInteger(M)) throw new Error("writeUintBE value must be an integer");
                for (var y = 1, E = v / 8 + G - 1; E >= G; E--) U[E] = M / y & 255, y *= 256;
                return U
            }, I.writeUintLE = function Le(v, M, U, G) {
                if (void 0 === U && (U = new Uint8Array(v / 8)), void 0 === G && (G = 0), v % 8 != 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
                if (!F.isSafeInteger(M)) throw new Error("writeUintLE value must be an integer");
                for (var y = 1, E = G; E < G + v / 8; E++) U[E] = M / y & 255, y *= 256;
                return U
            }, I.readFloat32BE = function L(v, M) {
                return void 0 === M && (M = 0), new DataView(v.buffer, v.byteOffset, v.byteLength).getFloat32(M)
            }, I.readFloat32LE = function ue(v, M) {
                return void 0 === M && (M = 0), new DataView(v.buffer, v.byteOffset, v.byteLength).getFloat32(M, !0)
            }, I.readFloat64BE = function Te(v, M) {
                return void 0 === M && (M = 0), new DataView(v.buffer, v.byteOffset, v.byteLength).getFloat64(M)
            }, I.readFloat64LE = function xe(v, M) {
                return void 0 === M && (M = 0), new DataView(v.buffer, v.byteOffset, v.byteLength).getFloat64(M, !0)
            }, I.writeFloat32BE = function Ae(v, M, U) {
                return void 0 === M && (M = new Uint8Array(4)), void 0 === U && (U = 0), new DataView(M.buffer, M.byteOffset, M.byteLength).setFloat32(U, v), M
            }, I.writeFloat32LE = function Ie(v, M, U) {
                return void 0 === M && (M = new Uint8Array(4)), void 0 === U && (U = 0), new DataView(M.buffer, M.byteOffset, M.byteLength).setFloat32(U, v, !0), M
            }, I.writeFloat64BE = function $(v, M, U) {
                return void 0 === M && (M = new Uint8Array(8)), void 0 === U && (U = 0), new DataView(M.buffer, M.byteOffset, M.byteLength).setFloat64(U, v), M
            }, I.writeFloat64LE = function f(v, M, U) {
                return void 0 === M && (M = new Uint8Array(8)), void 0 === U && (U = 0), new DataView(M.buffer, M.byteOffset, M.byteLength).setFloat64(U, v, !0), M
            }
        },
        6814: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            var F = T(99546),
                K = T(43403),
                q = 20;

            function ne(z, H, Y) {
                for (var Z = 1634760805, le = 857760878, re = 2036477234, de = 1797285236, Se = Y[3] << 24 | Y[2] << 16 | Y[1] << 8 | Y[0], me = Y[7] << 24 | Y[6] << 16 | Y[5] << 8 | Y[4], Ce = Y[11] << 24 | Y[10] << 16 | Y[9] << 8 | Y[8], we = Y[15] << 24 | Y[14] << 16 | Y[13] << 8 | Y[12], ve = Y[19] << 24 | Y[18] << 16 | Y[17] << 8 | Y[16], De = Y[23] << 24 | Y[22] << 16 | Y[21] << 8 | Y[20], ae = Y[27] << 24 | Y[26] << 16 | Y[25] << 8 | Y[24], Me = Y[31] << 24 | Y[30] << 16 | Y[29] << 8 | Y[28], Le = H[3] << 24 | H[2] << 16 | H[1] << 8 | H[0], L = H[7] << 24 | H[6] << 16 | H[5] << 8 | H[4], ue = H[11] << 24 | H[10] << 16 | H[9] << 8 | H[8], Te = H[15] << 24 | H[14] << 16 | H[13] << 8 | H[12], xe = Z, Ae = le, Ie = re, $ = de, f = Se, v = me, M = Ce, U = we, G = ve, y = De, E = ae, A = Me, b = Le, N = L, R = ue, Q = Te, Ee = 0; Ee < q; Ee += 2) f = (f ^= G = G + (b = (b ^= xe = xe + f | 0) >>> 16 | b << 16) | 0) >>> 20 | f << 12, v = (v ^= y = y + (N = (N ^= Ae = Ae + v | 0) >>> 16 | N << 16) | 0) >>> 20 | v << 12, M = (M ^= E = E + (R = (R ^= Ie = Ie + M | 0) >>> 16 | R << 16) | 0) >>> 20 | M << 12, U = (U ^= A = A + (Q = (Q ^= $ = $ + U | 0) >>> 16 | Q << 16) | 0) >>> 20 | U << 12, M = (M ^= E = E + (R = (R ^= Ie = Ie + M | 0) >>> 24 | R << 8) | 0) >>> 25 | M << 7, U = (U ^= A = A + (Q = (Q ^= $ = $ + U | 0) >>> 24 | Q << 8) | 0) >>> 25 | U << 7, v = (v ^= y = y + (N = (N ^= Ae = Ae + v | 0) >>> 24 | N << 8) | 0) >>> 25 | v << 7, f = (f ^= G = G + (b = (b ^= xe = xe + f | 0) >>> 24 | b << 8) | 0) >>> 25 | f << 7, v = (v ^= E = E + (Q = (Q ^= xe = xe + v | 0) >>> 16 | Q << 16) | 0) >>> 20 | v << 12, M = (M ^= A = A + (b = (b ^= Ae = Ae + M | 0) >>> 16 | b << 16) | 0) >>> 20 | M << 12, U = (U ^= G = G + (N = (N ^= Ie = Ie + U | 0) >>> 16 | N << 16) | 0) >>> 20 | U << 12, f = (f ^= y = y + (R = (R ^= $ = $ + f | 0) >>> 16 | R << 16) | 0) >>> 20 | f << 12, U = (U ^= G = G + (N = (N ^= Ie = Ie + U | 0) >>> 24 | N << 8) | 0) >>> 25 | U << 7, f = (f ^= y = y + (R = (R ^= $ = $ + f | 0) >>> 24 | R << 8) | 0) >>> 25 | f << 7, M = (M ^= A = A + (b = (b ^= Ae = Ae + M | 0) >>> 24 | b << 8) | 0) >>> 25 | M << 7, v = (v ^= E = E + (Q = (Q ^= xe = xe + v | 0) >>> 24 | Q << 8) | 0) >>> 25 | v << 7;
                F.writeUint32LE(xe + Z | 0, z, 0), F.writeUint32LE(Ae + le | 0, z, 4), F.writeUint32LE(Ie + re | 0, z, 8), F.writeUint32LE($ + de | 0, z, 12), F.writeUint32LE(f + Se | 0, z, 16), F.writeUint32LE(v + me | 0, z, 20), F.writeUint32LE(M + Ce | 0, z, 24), F.writeUint32LE(U + we | 0, z, 28), F.writeUint32LE(G + ve | 0, z, 32), F.writeUint32LE(y + De | 0, z, 36), F.writeUint32LE(E + ae | 0, z, 40), F.writeUint32LE(A + Me | 0, z, 44), F.writeUint32LE(b + Le | 0, z, 48), F.writeUint32LE(N + L | 0, z, 52), F.writeUint32LE(R + ue | 0, z, 56), F.writeUint32LE(Q + Te | 0, z, 60)
            }

            function S(z, H, Y, Z, le) {
                if (void 0 === le && (le = 0), 32 !== z.length) throw new Error("ChaCha: key size must be 32 bytes");
                if (Z.length < Y.length) throw new Error("ChaCha: destination is shorter than source");
                var re, de;
                if (0 === le) {
                    if (8 !== H.length && 12 !== H.length) throw new Error("ChaCha nonce must be 8 or 12 bytes");
                    (re = new Uint8Array(16)).set(H, de = re.length - H.length)
                } else {
                    if (16 !== H.length) throw new Error("ChaCha nonce with counter must be 16 bytes");
                    re = H, de = le
                }
                for (var Se = new Uint8Array(64), me = 0; me < Y.length; me += 64) {
                    ne(Se, re, z);
                    for (var Ce = me; Ce < me + 64 && Ce < Y.length; Ce++) Z[Ce] = Y[Ce] ^ Se[Ce - me];
                    C(re, 0, de)
                }
                return K.wipe(Se), 0 === le && K.wipe(re), Z
            }

            function C(z, H, Y) {
                for (var Z = 1; Y--;) z[H] = 255 & (Z = Z + (255 & z[H]) | 0), Z >>>= 8, H++;
                if (Z > 0) throw new Error("ChaCha: counter overflow")
            }
            I.streamXOR = S, I.stream = function j(z, H, Y, Z) {
                return void 0 === Z && (Z = 0), K.wipe(Y), S(z, H, Y, Y, Z)
            }
        },
        79026: (et, I, T) => {
            "use strict";
            var K = T(6814),
                q = T(50826),
                ne = T(43403),
                S = T(99546),
                j = T(97456);
            I.Cv = 32, I.WH = 12, I.pg = 16;
            var C = new Uint8Array(16),
                z = function() {
                    function H(Y) {
                        if (this.nonceLength = I.WH, this.tagLength = I.pg, Y.length !== I.Cv) throw new Error("ChaCha20Poly1305 needs 32-byte key");
                        this._key = new Uint8Array(Y)
                    }
                    return H.prototype.seal = function(Y, Z, le, re) {
                        if (Y.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                        var de = new Uint8Array(16);
                        de.set(Y, de.length - Y.length);
                        var Se = new Uint8Array(32);
                        K.stream(this._key, de, Se, 4);
                        var Ce, me = Z.length + this.tagLength;
                        if (re) {
                            if (re.length !== me) throw new Error("ChaCha20Poly1305: incorrect destination length");
                            Ce = re
                        } else Ce = new Uint8Array(me);
                        return K.streamXOR(this._key, de, Z, Ce, 4), this._authenticate(Ce.subarray(Ce.length - this.tagLength, Ce.length), Se, Ce.subarray(0, Ce.length - this.tagLength), le), ne.wipe(de), Ce
                    }, H.prototype.open = function(Y, Z, le, re) {
                        if (Y.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                        if (Z.length < this.tagLength) return null;
                        var de = new Uint8Array(16);
                        de.set(Y, de.length - Y.length);
                        var Se = new Uint8Array(32);
                        K.stream(this._key, de, Se, 4);
                        var me = new Uint8Array(this.tagLength);
                        if (this._authenticate(me, Se, Z.subarray(0, Z.length - this.tagLength), le), !j.equal(me, Z.subarray(Z.length - this.tagLength, Z.length))) return null;
                        var we, Ce = Z.length - this.tagLength;
                        if (re) {
                            if (re.length !== Ce) throw new Error("ChaCha20Poly1305: incorrect destination length");
                            we = re
                        } else we = new Uint8Array(Ce);
                        return K.streamXOR(this._key, de, Z.subarray(0, Z.length - this.tagLength), we, 4), ne.wipe(de), we
                    }, H.prototype.clean = function() {
                        return ne.wipe(this._key), this
                    }, H.prototype._authenticate = function(Y, Z, le, re) {
                        var de = new q.Poly1305(Z);
                        re && (de.update(re), re.length % 16 > 0 && de.update(C.subarray(re.length % 16))), de.update(le), le.length % 16 > 0 && de.update(C.subarray(le.length % 16));
                        var Se = new Uint8Array(8);
                        re && S.writeUint64LE(re.length, Se), de.update(Se), S.writeUint64LE(le.length, Se), de.update(Se);
                        for (var me = de.digest(), Ce = 0; Ce < me.length; Ce++) Y[Ce] = me[Ce];
                        de.clean(), ne.wipe(me), ne.wipe(Se)
                    }, H
                }();
            I.OK = z
        },
        97456: (et, I) => {
            "use strict";

            function K(ne, S) {
                if (ne.length !== S.length) return 0;
                for (var j = 0, C = 0; C < ne.length; C++) j |= ne[C] ^ S[C];
                return 1 & j - 1 >>> 8
            }
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.select = function T(ne, S, j) {
                return ~(ne - 1) & S | ne - 1 & j
            }, I.lessOrEqual = function F(ne, S) {
                return (0 | ne) - (0 | S) - 1 >>> 31 & 1
            }, I.compare = K, I.equal = function q(ne, S) {
                return 0 !== ne.length && 0 !== S.length && 0 !== K(ne, S)
            }
        },
        30970: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.isSerializableHash = function T(F) {
                return typeof F.saveState < "u" && typeof F.restoreState < "u" && typeof F.cleanSavedState < "u"
            }
        },
        81028: (et, I, T) => {
            "use strict";
            var K = T(98347),
                q = T(43403),
                ne = function() {
                    function S(j, C, z, H) {
                        void 0 === z && (z = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = j, this._info = H;
                        var Y = K.hmac(this._hash, z, C);
                        this._hmac = new K.HMAC(j, Y), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
                    }
                    return S.prototype._fillBuffer = function() {
                        this._counter[0]++;
                        var j = this._counter[0];
                        if (0 === j) throw new Error("hkdf: cannot expand more");
                        this._hmac.reset(), j > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
                    }, S.prototype.expand = function(j) {
                        for (var C = new Uint8Array(j), z = 0; z < C.length; z++) this._bufpos === this._buffer.length && this._fillBuffer(), C[z] = this._buffer[this._bufpos++];
                        return C
                    }, S.prototype.clean = function() {
                        this._hmac.clean(), q.wipe(this._buffer), q.wipe(this._counter), this._bufpos = 0
                    }, S
                }();
            I.t = ne
        },
        98347: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            var F = T(30970),
                K = T(97456),
                q = T(43403),
                ne = function() {
                    function j(C, z) {
                        this._finished = !1, this._inner = new C, this._outer = new C, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
                        var H = new Uint8Array(this.blockSize);
                        z.length > this.blockSize ? this._inner.update(z).finish(H).clean() : H.set(z);
                        for (var Y = 0; Y < H.length; Y++) H[Y] ^= 54;
                        for (this._inner.update(H), Y = 0; Y < H.length; Y++) H[Y] ^= 106;
                        this._outer.update(H), F.isSerializableHash(this._inner) && F.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), q.wipe(H)
                    }
                    return j.prototype.reset = function() {
                        if (!F.isSerializableHash(this._inner) || !F.isSerializableHash(this._outer)) throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
                        return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, j.prototype.clean = function() {
                        F.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), F.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
                    }, j.prototype.update = function(C) {
                        return this._inner.update(C), this
                    }, j.prototype.finish = function(C) {
                        return this._finished ? (this._outer.finish(C), this) : (this._inner.finish(C), this._outer.update(C.subarray(0, this.digestLength)).finish(C), this._finished = !0, this)
                    }, j.prototype.digest = function() {
                        var C = new Uint8Array(this.digestLength);
                        return this.finish(C), C
                    }, j.prototype.saveState = function() {
                        if (!F.isSerializableHash(this._inner)) throw new Error("hmac: can't saveState() because hash doesn't implement it");
                        return this._inner.saveState()
                    }, j.prototype.restoreState = function(C) {
                        if (!F.isSerializableHash(this._inner) || !F.isSerializableHash(this._outer)) throw new Error("hmac: can't restoreState() because hash doesn't implement it");
                        return this._inner.restoreState(C), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, j.prototype.cleanSavedState = function(C) {
                        if (!F.isSerializableHash(this._inner)) throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
                        this._inner.cleanSavedState(C)
                    }, j
                }();
            I.HMAC = ne, I.hmac = function S(j, C, z) {
                var H = new ne(j, C);
                H.update(z);
                var Y = H.digest();
                return H.clean(), Y
            }, I.equal = K.equal
        },
        98052: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.mul = Math.imul || function T(j, C) {
                var H = 65535 & j,
                    Z = 65535 & C;
                return H * Z + ((j >>> 16 & 65535) * Z + H * (C >>> 16 & 65535) << 16 >>> 0) | 0
            }, I.add = function F(j, C) {
                return j + C | 0
            }, I.sub = function K(j, C) {
                return j - C | 0
            }, I.rotl = function q(j, C) {
                return j << C | j >>> 32 - C
            }, I.rotr = function ne(j, C) {
                return j << 32 - C | j >>> C
            }, I.isInteger = Number.isInteger || function S(j) {
                return "number" == typeof j && isFinite(j) && Math.floor(j) === j
            }, I.MAX_SAFE_INTEGER = 9007199254740991, I.isSafeInteger = function(j) {
                return I.isInteger(j) && j >= -I.MAX_SAFE_INTEGER && j <= I.MAX_SAFE_INTEGER
            }
        },
        50826: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            var F = T(97456),
                K = T(43403);
            I.DIGEST_LENGTH = 16;
            var q = function() {
                function j(C) {
                    this.digestLength = I.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
                    var z = C[0] | C[1] << 8;
                    this._r[0] = 8191 & z;
                    var H = C[2] | C[3] << 8;
                    this._r[1] = 8191 & (z >>> 13 | H << 3);
                    var Y = C[4] | C[5] << 8;
                    this._r[2] = 7939 & (H >>> 10 | Y << 6);
                    var Z = C[6] | C[7] << 8;
                    this._r[3] = 8191 & (Y >>> 7 | Z << 9);
                    var le = C[8] | C[9] << 8;
                    this._r[4] = 255 & (Z >>> 4 | le << 12), this._r[5] = le >>> 1 & 8190;
                    var re = C[10] | C[11] << 8;
                    this._r[6] = 8191 & (le >>> 14 | re << 2);
                    var de = C[12] | C[13] << 8;
                    this._r[7] = 8065 & (re >>> 11 | de << 5);
                    var Se = C[14] | C[15] << 8;
                    this._r[8] = 8191 & (de >>> 8 | Se << 8), this._r[9] = Se >>> 5 & 127, this._pad[0] = C[16] | C[17] << 8, this._pad[1] = C[18] | C[19] << 8, this._pad[2] = C[20] | C[21] << 8, this._pad[3] = C[22] | C[23] << 8, this._pad[4] = C[24] | C[25] << 8, this._pad[5] = C[26] | C[27] << 8, this._pad[6] = C[28] | C[29] << 8, this._pad[7] = C[30] | C[31] << 8
                }
                return j.prototype._blocks = function(C, z, H) {
                    for (var Y = this._fin ? 0 : 2048, Z = this._h[0], le = this._h[1], re = this._h[2], de = this._h[3], Se = this._h[4], me = this._h[5], Ce = this._h[6], we = this._h[7], ve = this._h[8], De = this._h[9], ae = this._r[0], Me = this._r[1], Le = this._r[2], L = this._r[3], ue = this._r[4], Te = this._r[5], xe = this._r[6], Ae = this._r[7], Ie = this._r[8], $ = this._r[9]; H >= 16;) {
                        var f = C[z + 0] | C[z + 1] << 8,
                            v = C[z + 2] | C[z + 3] << 8,
                            M = C[z + 4] | C[z + 5] << 8,
                            U = C[z + 6] | C[z + 7] << 8,
                            G = C[z + 8] | C[z + 9] << 8,
                            y = C[z + 10] | C[z + 11] << 8,
                            E = C[z + 12] | C[z + 13] << 8,
                            A = C[z + 14] | C[z + 15] << 8,
                            b = 0,
                            N = b;
                        N += (Z += 8191 & f) * ae, N += (le += 8191 & (f >>> 13 | v << 3)) * (5 * $), N += (re += 8191 & (v >>> 10 | M << 6)) * (5 * Ie), N += (de += 8191 & (M >>> 7 | U << 9)) * (5 * Ae), b = (N += (Se += 8191 & (U >>> 4 | G << 12)) * (5 * xe)) >>> 13, N &= 8191, N += (me += G >>> 1 & 8191) * (5 * Te), N += (Ce += 8191 & (G >>> 14 | y << 2)) * (5 * ue), N += (we += 8191 & (y >>> 11 | E << 5)) * (5 * L), N += (ve += 8191 & (E >>> 8 | A << 8)) * (5 * Le);
                        var R = b += (N += (De += A >>> 5 | Y) * (5 * Me)) >>> 13;
                        R += Z * Me, R += le * ae, R += re * (5 * $), R += de * (5 * Ie), b = (R += Se * (5 * Ae)) >>> 13, R &= 8191, R += me * (5 * xe), R += Ce * (5 * Te), R += we * (5 * ue), R += ve * (5 * L), b += (R += De * (5 * Le)) >>> 13, R &= 8191;
                        var Q = b;
                        Q += Z * Le, Q += le * Me, Q += re * ae, Q += de * (5 * $), b = (Q += Se * (5 * Ie)) >>> 13, Q &= 8191, Q += me * (5 * Ae), Q += Ce * (5 * xe), Q += we * (5 * Te), Q += ve * (5 * ue);
                        var Ee = b += (Q += De * (5 * L)) >>> 13;
                        Ee += Z * L, Ee += le * Le, Ee += re * Me, Ee += de * ae, b = (Ee += Se * (5 * $)) >>> 13, Ee &= 8191, Ee += me * (5 * Ie), Ee += Ce * (5 * Ae), Ee += we * (5 * xe), Ee += ve * (5 * Te);
                        var Fe = b += (Ee += De * (5 * ue)) >>> 13;
                        Fe += Z * ue, Fe += le * L, Fe += re * Le, Fe += de * Me, b = (Fe += Se * ae) >>> 13, Fe &= 8191, Fe += me * (5 * $), Fe += Ce * (5 * Ie), Fe += we * (5 * Ae), Fe += ve * (5 * xe);
                        var Ge = b += (Fe += De * (5 * Te)) >>> 13;
                        Ge += Z * Te, Ge += le * ue, Ge += re * L, Ge += de * Le, b = (Ge += Se * Me) >>> 13, Ge &= 8191, Ge += me * ae, Ge += Ce * (5 * $), Ge += we * (5 * Ie), Ge += ve * (5 * Ae);
                        var wt = b += (Ge += De * (5 * xe)) >>> 13;
                        wt += Z * xe, wt += le * Te, wt += re * ue, wt += de * L, b = (wt += Se * Le) >>> 13, wt &= 8191, wt += me * Me, wt += Ce * ae, wt += we * (5 * $), wt += ve * (5 * Ie);
                        var Vt = b += (wt += De * (5 * Ae)) >>> 13;
                        Vt += Z * Ae, Vt += le * xe, Vt += re * Te, Vt += de * ue, b = (Vt += Se * L) >>> 13, Vt &= 8191, Vt += me * Le, Vt += Ce * Me, Vt += we * ae, Vt += ve * (5 * $);
                        var Mt = b += (Vt += De * (5 * Ie)) >>> 13;
                        Mt += Z * Ie, Mt += le * Ae, Mt += re * xe, Mt += de * Te, b = (Mt += Se * ue) >>> 13, Mt &= 8191, Mt += me * L, Mt += Ce * Le, Mt += we * Me, Mt += ve * ae;
                        var sn = b += (Mt += De * (5 * $)) >>> 13;
                        sn += Z * $, sn += le * Ie, sn += re * Ae, sn += de * xe, b = (sn += Se * Te) >>> 13, sn &= 8191, sn += me * ue, sn += Ce * L, sn += we * Le, sn += ve * Me, Z = N = 8191 & (b = (b = ((b += (sn += De * ae) >>> 13) << 2) + b | 0) + (N &= 8191) | 0), le = R += b >>>= 13, re = Q &= 8191, de = Ee &= 8191, Se = Fe &= 8191, me = Ge &= 8191, Ce = wt &= 8191, we = Vt &= 8191, ve = Mt &= 8191, De = sn &= 8191, z += 16, H -= 16
                    }
                    this._h[0] = Z, this._h[1] = le, this._h[2] = re, this._h[3] = de, this._h[4] = Se, this._h[5] = me, this._h[6] = Ce, this._h[7] = we, this._h[8] = ve, this._h[9] = De
                }, j.prototype.finish = function(C, z) {
                    void 0 === z && (z = 0);
                    var Y, Z, le, re, H = new Uint16Array(10);
                    if (this._leftover) {
                        for (re = this._leftover, this._buffer[re++] = 1; re < 16; re++) this._buffer[re] = 0;
                        this._fin = 1, this._blocks(this._buffer, 0, 16)
                    }
                    for (Y = this._h[1] >>> 13, this._h[1] &= 8191, re = 2; re < 10; re++) this._h[re] += Y, Y = this._h[re] >>> 13, this._h[re] &= 8191;
                    for (this._h[0] += 5 * Y, Y = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += Y, Y = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += Y, H[0] = this._h[0] + 5, Y = H[0] >>> 13, H[0] &= 8191, re = 1; re < 10; re++) H[re] = this._h[re] + Y, Y = H[re] >>> 13, H[re] &= 8191;
                    for (H[9] -= 8192, Z = (1 ^ Y) - 1, re = 0; re < 10; re++) H[re] &= Z;
                    for (Z = ~Z, re = 0; re < 10; re++) this._h[re] = this._h[re] & Z | H[re];
                    for (this._h[0] = 65535 & (this._h[0] | this._h[1] << 13), this._h[1] = 65535 & (this._h[1] >>> 3 | this._h[2] << 10), this._h[2] = 65535 & (this._h[2] >>> 6 | this._h[3] << 7), this._h[3] = 65535 & (this._h[3] >>> 9 | this._h[4] << 4), this._h[4] = 65535 & (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14), this._h[5] = 65535 & (this._h[6] >>> 2 | this._h[7] << 11), this._h[6] = 65535 & (this._h[7] >>> 5 | this._h[8] << 8), this._h[7] = 65535 & (this._h[8] >>> 8 | this._h[9] << 5), this._h[0] = 65535 & (le = this._h[0] + this._pad[0]), re = 1; re < 8; re++) this._h[re] = 65535 & (le = (this._h[re] + this._pad[re] | 0) + (le >>> 16) | 0);
                    return C[z + 0] = this._h[0] >>> 0, C[z + 1] = this._h[0] >>> 8, C[z + 2] = this._h[1] >>> 0, C[z + 3] = this._h[1] >>> 8, C[z + 4] = this._h[2] >>> 0, C[z + 5] = this._h[2] >>> 8, C[z + 6] = this._h[3] >>> 0, C[z + 7] = this._h[3] >>> 8, C[z + 8] = this._h[4] >>> 0, C[z + 9] = this._h[4] >>> 8, C[z + 10] = this._h[5] >>> 0, C[z + 11] = this._h[5] >>> 8, C[z + 12] = this._h[6] >>> 0, C[z + 13] = this._h[6] >>> 8, C[z + 14] = this._h[7] >>> 0, C[z + 15] = this._h[7] >>> 8, this._finished = !0, this
                }, j.prototype.update = function(C) {
                    var Y, z = 0,
                        H = C.length;
                    if (this._leftover) {
                        (Y = 16 - this._leftover) > H && (Y = H);
                        for (var Z = 0; Z < Y; Z++) this._buffer[this._leftover + Z] = C[z + Z];
                        if (H -= Y, z += Y, this._leftover += Y, this._leftover < 16) return this;
                        this._blocks(this._buffer, 0, 16), this._leftover = 0
                    }
                    if (H >= 16 && (this._blocks(C, z, Y = H - H % 16), z += Y, H -= Y), H) {
                        for (Z = 0; Z < H; Z++) this._buffer[this._leftover + Z] = C[z + Z];
                        this._leftover += H
                    }
                    return this
                }, j.prototype.digest = function() {
                    if (this._finished) throw new Error("Poly1305 was finished");
                    var C = new Uint8Array(16);
                    return this.finish(C), C
                }, j.prototype.clean = function() {
                    return K.wipe(this._buffer), K.wipe(this._r), K.wipe(this._h), K.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
                }, j
            }();
            I.Poly1305 = q, I.oneTimeAuth = function ne(j, C) {
                var z = new q(j);
                z.update(C);
                var H = z.digest();
                return z.clean(), H
            }, I.equal = function S(j, C) {
                return j.length === I.DIGEST_LENGTH && C.length === I.DIGEST_LENGTH && F.equal(j, C)
            }
        },
        25465: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.randomStringForEntropy = I.randomString = I.randomUint32 = I.randomBytes = I.defaultRandomSource = void 0;
            const F = T(71297),
                K = T(99546),
                q = T(43403);

            function ne(H, Y = I.defaultRandomSource) {
                return Y.randomBytes(H)
            }
            I.defaultRandomSource = new F.SystemRandomSource, I.randomBytes = ne, I.randomUint32 = function S(H = I.defaultRandomSource) {
                const Y = ne(4, H),
                    Z = (0, K.readUint32LE)(Y);
                return (0, q.wipe)(Y), Z
            };
            const j = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

            function C(H, Y = j, Z = I.defaultRandomSource) {
                if (Y.length < 2) throw new Error("randomString charset is too short");
                if (Y.length > 256) throw new Error("randomString charset is too long");
                let le = "";
                const re = Y.length,
                    de = 256 - 256 % re;
                for (; H > 0;) {
                    const Se = ne(Math.ceil(256 * H / de), Z);
                    for (let me = 0; me < Se.length && H > 0; me++) {
                        const Ce = Se[me];
                        Ce < de && (le += Y.charAt(Ce % re), H--)
                    }(0, q.wipe)(Se)
                }
                return le
            }
            I.randomString = C, I.randomStringForEntropy = function z(H, Y = j, Z = I.defaultRandomSource) {
                return C(Math.ceil(H / (Math.log(Y.length) / Math.LN2)), Y, Z)
            }
        },
        23158: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.BrowserRandomSource = void 0, I.BrowserRandomSource = class F {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1;
                    const q = typeof self < "u" ? self.crypto || self.msCrypto : null;
                    q && void 0 !== q.getRandomValues && (this._crypto = q, this.isAvailable = !0, this.isInstantiated = !0)
                }
                randomBytes(q) {
                    if (!this.isAvailable || !this._crypto) throw new Error("Browser random byte generator is not available.");
                    const ne = new Uint8Array(q);
                    for (let S = 0; S < ne.length; S += 65536) this._crypto.getRandomValues(ne.subarray(S, S + Math.min(ne.length - S, 65536)));
                    return ne
                }
            }
        },
        65481: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.NodeRandomSource = void 0;
            const F = T(43403);
            I.NodeRandomSource = class K {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1; {
                        const ne = T(35883);
                        ne && ne.randomBytes && (this._crypto = ne, this.isAvailable = !0, this.isInstantiated = !0)
                    }
                }
                randomBytes(ne) {
                    if (!this.isAvailable || !this._crypto) throw new Error("Node.js random byte generator is not available.");
                    let S = this._crypto.randomBytes(ne);
                    if (S.length !== ne) throw new Error("NodeRandomSource: got fewer bytes than requested");
                    const j = new Uint8Array(ne);
                    for (let C = 0; C < j.length; C++) j[C] = S[C];
                    return (0, F.wipe)(S), j
                }
            }
        },
        71297: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.SystemRandomSource = void 0;
            const F = T(23158),
                K = T(65481);
            I.SystemRandomSource = class q {
                constructor() {
                    return this.isAvailable = !1, this.name = "", this._source = new F.BrowserRandomSource, this._source.isAvailable ? (this.isAvailable = !0, void(this.name = "Browser")) : (this._source = new K.NodeRandomSource, this._source.isAvailable ? (this.isAvailable = !0, void(this.name = "Node")) : void 0)
                }
                randomBytes(S) {
                    if (!this.isAvailable) throw new Error("System random byte generator is not available.");
                    return this._source.randomBytes(S)
                }
            }
        },
        31033: (et, I, T) => {
            "use strict";
            var K = T(99546),
                q = T(43403);
            I.k = 32, I.cn = 64;
            var ne = function() {
                function z() {
                    this.digestLength = I.k, this.blockSize = I.cn, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return z.prototype._initState = function() {
                    this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
                }, z.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, z.prototype.clean = function() {
                    q.wipe(this._buffer), q.wipe(this._temp), this.reset()
                }, z.prototype.update = function(H, Y) {
                    if (void 0 === Y && (Y = H.length), this._finished) throw new Error("SHA256: can't update because hash was finished.");
                    var Z = 0;
                    if (this._bytesHashed += Y, this._bufferLength > 0) {
                        for (; this._bufferLength < this.blockSize && Y > 0;) this._buffer[this._bufferLength++] = H[Z++], Y--;
                        this._bufferLength === this.blockSize && (j(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (Y >= this.blockSize && (Z = j(this._temp, this._state, H, Z, Y), Y %= this.blockSize); Y > 0;) this._buffer[this._bufferLength++] = H[Z++], Y--;
                    return this
                }, z.prototype.finish = function(H) {
                    if (!this._finished) {
                        var Y = this._bytesHashed,
                            Z = this._bufferLength,
                            le = Y / 536870912 | 0,
                            re = Y << 3,
                            de = Y % 64 < 56 ? 64 : 128;
                        this._buffer[Z] = 128;
                        for (var Se = Z + 1; Se < de - 8; Se++) this._buffer[Se] = 0;
                        K.writeUint32BE(le, this._buffer, de - 8), K.writeUint32BE(re, this._buffer, de - 4), j(this._temp, this._state, this._buffer, 0, de), this._finished = !0
                    }
                    for (Se = 0; Se < this.digestLength / 4; Se++) K.writeUint32BE(this._state[Se], H, 4 * Se);
                    return this
                }, z.prototype.digest = function() {
                    var H = new Uint8Array(this.digestLength);
                    return this.finish(H), H
                }, z.prototype.saveState = function() {
                    if (this._finished) throw new Error("SHA256: cannot save finished state");
                    return {
                        state: new Int32Array(this._state),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, z.prototype.restoreState = function(H) {
                    return this._state.set(H.state), this._bufferLength = H.bufferLength, H.buffer && this._buffer.set(H.buffer), this._bytesHashed = H.bytesHashed, this._finished = !1, this
                }, z.prototype.cleanSavedState = function(H) {
                    q.wipe(H.state), H.buffer && q.wipe(H.buffer), H.bufferLength = 0, H.bytesHashed = 0
                }, z
            }();
            I.mE = ne;
            var S = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

            function j(z, H, Y, Z, le) {
                for (; le >= 64;) {
                    for (var re = H[0], de = H[1], Se = H[2], me = H[3], Ce = H[4], we = H[5], ve = H[6], De = H[7], ae = 0; ae < 16; ae++) z[ae] = K.readUint32BE(Y, Z + 4 * ae);
                    for (ae = 16; ae < 64; ae++) {
                        var Le = z[ae - 2];
                        z[ae] = ((L = (Le >>> 17 | Le << 15) ^ (Le >>> 19 | Le << 13) ^ Le >>> 10) + z[ae - 7] | 0) + ((ue = ((Le = z[ae - 15]) >>> 7 | Le << 25) ^ (Le >>> 18 | Le << 14) ^ Le >>> 3) + z[ae - 16] | 0)
                    }
                    for (ae = 0; ae < 64; ae++) {
                        var L = (((Ce >>> 6 | Ce << 26) ^ (Ce >>> 11 | Ce << 21) ^ (Ce >>> 25 | Ce << 7)) + (Ce & we ^ ~Ce & ve) | 0) + (De + (S[ae] + z[ae] | 0) | 0) | 0,
                            ue = ((re >>> 2 | re << 30) ^ (re >>> 13 | re << 19) ^ (re >>> 22 | re << 10)) + (re & de ^ re & Se ^ de & Se) | 0;
                        De = ve, ve = we, we = Ce, Ce = me + L | 0, me = Se, Se = de, de = re, re = L + ue | 0
                    }
                    H[0] += re, H[1] += de, H[2] += Se, H[3] += me, H[4] += Ce, H[5] += we, H[6] += ve, H[7] += De, Z += 64, le -= 64
                }
                return Z
            }
            I.vp = function C(z) {
                var H = new ne;
                H.update(z);
                var Y = H.digest();
                return H.clean(), Y
            }
        },
        43403: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.wipe = function T(F) {
                for (var K = 0; K < F.length; K++) F[K] = 0;
                return F
            }
        },
        28467: (et, I, T) => {
            "use strict";
            I.gi = I.Au = I.KS = I.kz = void 0;
            const K = T(25465),
                q = T(43403);

            function ne(ae) {
                const Me = new Float64Array(16);
                if (ae)
                    for (let Le = 0; Le < ae.length; Le++) Me[Le] = ae[Le];
                return Me
            }
            I.kz = 32, I.KS = 32;
            const S = new Uint8Array(32);
            S[0] = 9;
            const j = ne([56129, 1]);

            function C(ae) {
                let Me = 1;
                for (let Le = 0; Le < 16; Le++) {
                    let L = ae[Le] + Me + 65535;
                    Me = Math.floor(L / 65536), ae[Le] = L - 65536 * Me
                }
                ae[0] += Me - 1 + 37 * (Me - 1)
            }

            function z(ae, Me, Le) {
                const L = ~(Le - 1);
                for (let ue = 0; ue < 16; ue++) {
                    const Te = L & (ae[ue] ^ Me[ue]);
                    ae[ue] ^= Te, Me[ue] ^= Te
                }
            }

            function Z(ae, Me, Le) {
                for (let L = 0; L < 16; L++) ae[L] = Me[L] + Le[L]
            }

            function le(ae, Me, Le) {
                for (let L = 0; L < 16; L++) ae[L] = Me[L] - Le[L]
            }

            function re(ae, Me, Le) {
                let L, ue, Te = 0,
                    xe = 0,
                    Ae = 0,
                    Ie = 0,
                    $ = 0,
                    f = 0,
                    v = 0,
                    M = 0,
                    U = 0,
                    G = 0,
                    y = 0,
                    E = 0,
                    A = 0,
                    b = 0,
                    N = 0,
                    R = 0,
                    Q = 0,
                    Ee = 0,
                    Fe = 0,
                    Ge = 0,
                    wt = 0,
                    Vt = 0,
                    Mt = 0,
                    sn = 0,
                    ei = 0,
                    ai = 0,
                    jn = 0,
                    An = 0,
                    ui = 0,
                    Mi = 0,
                    ji = 0,
                    Wn = Le[0],
                    kn = Le[1],
                    Bi = Le[2],
                    ci = Le[3],
                    en = Le[4],
                    Ii = Le[5],
                    pe = Le[6],
                    O = Le[7],
                    W = Le[8],
                    ke = Le[9],
                    je = Le[10],
                    Qe = Le[11],
                    st = Le[12],
                    tn = Le[13],
                    Kn = Le[14],
                    mn = Le[15];
                L = Me[0], Te += L * Wn, xe += L * kn, Ae += L * Bi, Ie += L * ci, $ += L * en, f += L * Ii, v += L * pe, M += L * O, U += L * W, G += L * ke, y += L * je, E += L * Qe, A += L * st, b += L * tn, N += L * Kn, R += L * mn, L = Me[1], xe += L * Wn, Ae += L * kn, Ie += L * Bi, $ += L * ci, f += L * en, v += L * Ii, M += L * pe, U += L * O, G += L * W, y += L * ke, E += L * je, A += L * Qe, b += L * st, N += L * tn, R += L * Kn, Q += L * mn, L = Me[2], Ae += L * Wn, Ie += L * kn, $ += L * Bi, f += L * ci, v += L * en, M += L * Ii, U += L * pe, G += L * O, y += L * W, E += L * ke, A += L * je, b += L * Qe, N += L * st, R += L * tn, Q += L * Kn, Ee += L * mn, L = Me[3], Ie += L * Wn, $ += L * kn, f += L * Bi, v += L * ci, M += L * en, U += L * Ii, G += L * pe, y += L * O, E += L * W, A += L * ke, b += L * je, N += L * Qe, R += L * st, Q += L * tn, Ee += L * Kn, Fe += L * mn, L = Me[4], $ += L * Wn, f += L * kn, v += L * Bi, M += L * ci, U += L * en, G += L * Ii, y += L * pe, E += L * O, A += L * W, b += L * ke, N += L * je, R += L * Qe, Q += L * st, Ee += L * tn, Fe += L * Kn, Ge += L * mn, L = Me[5], f += L * Wn, v += L * kn, M += L * Bi, U += L * ci, G += L * en, y += L * Ii, E += L * pe, A += L * O, b += L * W, N += L * ke, R += L * je, Q += L * Qe, Ee += L * st, Fe += L * tn, Ge += L * Kn, wt += L * mn, L = Me[6], v += L * Wn, M += L * kn, U += L * Bi, G += L * ci, y += L * en, E += L * Ii, A += L * pe, b += L * O, N += L * W, R += L * ke, Q += L * je, Ee += L * Qe, Fe += L * st, Ge += L * tn, wt += L * Kn, Vt += L * mn, L = Me[7], M += L * Wn, U += L * kn, G += L * Bi, y += L * ci, E += L * en, A += L * Ii, b += L * pe, N += L * O, R += L * W, Q += L * ke, Ee += L * je, Fe += L * Qe, Ge += L * st, wt += L * tn, Vt += L * Kn, Mt += L * mn, L = Me[8], U += L * Wn, G += L * kn, y += L * Bi, E += L * ci, A += L * en, b += L * Ii, N += L * pe, R += L * O, Q += L * W, Ee += L * ke, Fe += L * je, Ge += L * Qe, wt += L * st, Vt += L * tn, Mt += L * Kn, sn += L * mn, L = Me[9], G += L * Wn, y += L * kn, E += L * Bi, A += L * ci, b += L * en, N += L * Ii, R += L * pe, Q += L * O, Ee += L * W, Fe += L * ke, Ge += L * je, wt += L * Qe, Vt += L * st, Mt += L * tn, sn += L * Kn, ei += L * mn, L = Me[10], y += L * Wn, E += L * kn, A += L * Bi, b += L * ci, N += L * en, R += L * Ii, Q += L * pe, Ee += L * O, Fe += L * W, Ge += L * ke, wt += L * je, Vt += L * Qe, Mt += L * st, sn += L * tn, ei += L * Kn, ai += L * mn, L = Me[11], E += L * Wn, A += L * kn, b += L * Bi, N += L * ci, R += L * en, Q += L * Ii, Ee += L * pe, Fe += L * O, Ge += L * W, wt += L * ke, Vt += L * je, Mt += L * Qe, sn += L * st, ei += L * tn, ai += L * Kn, jn += L * mn, L = Me[12], A += L * Wn, b += L * kn, N += L * Bi, R += L * ci, Q += L * en, Ee += L * Ii, Fe += L * pe, Ge += L * O, wt += L * W, Vt += L * ke, Mt += L * je, sn += L * Qe, ei += L * st, ai += L * tn, jn += L * Kn, An += L * mn, L = Me[13], b += L * Wn, N += L * kn, R += L * Bi, Q += L * ci, Ee += L * en, Fe += L * Ii, Ge += L * pe, wt += L * O, Vt += L * W, Mt += L * ke, sn += L * je, ei += L * Qe, ai += L * st, jn += L * tn, An += L * Kn, ui += L * mn, L = Me[14], N += L * Wn, R += L * kn, Q += L * Bi, Ee += L * ci, Fe += L * en, Ge += L * Ii, wt += L * pe, Vt += L * O, Mt += L * W, sn += L * ke, ei += L * je, ai += L * Qe, jn += L * st, An += L * tn, ui += L * Kn, Mi += L * mn, L = Me[15], R += L * Wn, Q += L * kn, Ee += L * Bi, Fe += L * ci, Ge += L * en, wt += L * Ii, Vt += L * pe, Mt += L * O, sn += L * W, ei += L * ke, ai += L * je, jn += L * Qe, An += L * st, ui += L * tn, Mi += L * Kn, ji += L * mn, Te += 38 * Q, xe += 38 * Ee, Ae += 38 * Fe, Ie += 38 * Ge, $ += 38 * wt, f += 38 * Vt, v += 38 * Mt, M += 38 * sn, U += 38 * ei, G += 38 * ai, y += 38 * jn, E += 38 * An, A += 38 * ui, b += 38 * Mi, N += 38 * ji, ue = 1, L = Te + ue + 65535, ue = Math.floor(L / 65536), Te = L - 65536 * ue, L = xe + ue + 65535, ue = Math.floor(L / 65536), xe = L - 65536 * ue, L = Ae + ue + 65535, ue = Math.floor(L / 65536), Ae = L - 65536 * ue, L = Ie + ue + 65535, ue = Math.floor(L / 65536), Ie = L - 65536 * ue, L = $ + ue + 65535, ue = Math.floor(L / 65536), $ = L - 65536 * ue, L = f + ue + 65535, ue = Math.floor(L / 65536), f = L - 65536 * ue, L = v + ue + 65535, ue = Math.floor(L / 65536), v = L - 65536 * ue, L = M + ue + 65535, ue = Math.floor(L / 65536), M = L - 65536 * ue, L = U + ue + 65535, ue = Math.floor(L / 65536), U = L - 65536 * ue, L = G + ue + 65535, ue = Math.floor(L / 65536), G = L - 65536 * ue, L = y + ue + 65535, ue = Math.floor(L / 65536), y = L - 65536 * ue, L = E + ue + 65535, ue = Math.floor(L / 65536), E = L - 65536 * ue, L = A + ue + 65535, ue = Math.floor(L / 65536), A = L - 65536 * ue, L = b + ue + 65535, ue = Math.floor(L / 65536), b = L - 65536 * ue, L = N + ue + 65535, ue = Math.floor(L / 65536), N = L - 65536 * ue, L = R + ue + 65535, ue = Math.floor(L / 65536), R = L - 65536 * ue, Te += ue - 1 + 37 * (ue - 1), ue = 1, L = Te + ue + 65535, ue = Math.floor(L / 65536), Te = L - 65536 * ue, L = xe + ue + 65535, ue = Math.floor(L / 65536), xe = L - 65536 * ue, L = Ae + ue + 65535, ue = Math.floor(L / 65536), Ae = L - 65536 * ue, L = Ie + ue + 65535, ue = Math.floor(L / 65536), Ie = L - 65536 * ue, L = $ + ue + 65535, ue = Math.floor(L / 65536), $ = L - 65536 * ue, L = f + ue + 65535, ue = Math.floor(L / 65536), f = L - 65536 * ue, L = v + ue + 65535, ue = Math.floor(L / 65536), v = L - 65536 * ue, L = M + ue + 65535, ue = Math.floor(L / 65536), M = L - 65536 * ue, L = U + ue + 65535, ue = Math.floor(L / 65536), U = L - 65536 * ue, L = G + ue + 65535, ue = Math.floor(L / 65536), G = L - 65536 * ue, L = y + ue + 65535, ue = Math.floor(L / 65536), y = L - 65536 * ue, L = E + ue + 65535, ue = Math.floor(L / 65536), E = L - 65536 * ue, L = A + ue + 65535, ue = Math.floor(L / 65536), A = L - 65536 * ue, L = b + ue + 65535, ue = Math.floor(L / 65536), b = L - 65536 * ue, L = N + ue + 65535, ue = Math.floor(L / 65536), N = L - 65536 * ue, L = R + ue + 65535, ue = Math.floor(L / 65536), R = L - 65536 * ue, Te += ue - 1 + 37 * (ue - 1), ae[0] = Te, ae[1] = xe, ae[2] = Ae, ae[3] = Ie, ae[4] = $, ae[5] = f, ae[6] = v, ae[7] = M, ae[8] = U, ae[9] = G, ae[10] = y, ae[11] = E, ae[12] = A, ae[13] = b, ae[14] = N, ae[15] = R
            }

            function de(ae, Me) {
                re(ae, Me, Me)
            }

            function me(ae, Me) {
                const Le = new Uint8Array(32),
                    L = new Float64Array(80),
                    ue = ne(),
                    Te = ne(),
                    xe = ne(),
                    Ae = ne(),
                    Ie = ne(),
                    $ = ne();
                for (let U = 0; U < 31; U++) Le[U] = ae[U];
                Le[31] = 127 & ae[31] | 64, Le[0] &= 248,
                    function Y(ae, Me) {
                        for (let Le = 0; Le < 16; Le++) ae[Le] = Me[2 * Le] + (Me[2 * Le + 1] << 8);
                        ae[15] &= 32767
                    }(L, Me);
                for (let U = 0; U < 16; U++) Te[U] = L[U];
                ue[0] = Ae[0] = 1;
                for (let U = 254; U >= 0; --U) {
                    const G = Le[U >>> 3] >>> (7 & U) & 1;
                    z(ue, Te, G), z(xe, Ae, G), Z(Ie, ue, xe), le(ue, ue, xe), Z(xe, Te, Ae), le(Te, Te, Ae), de(Ae, Ie), de($, ue), re(ue, xe, ue), re(xe, Te, Ie), Z(Ie, ue, xe), le(ue, ue, xe), de(Te, ue), le(xe, Ae, $), re(ue, xe, j), Z(ue, ue, Ae), re(xe, xe, ue), re(ue, Ae, $), re(Ae, Te, L), de(Te, Ie), z(ue, Te, G), z(xe, Ae, G)
                }
                for (let U = 0; U < 16; U++) L[U + 16] = ue[U], L[U + 32] = xe[U], L[U + 48] = Te[U], L[U + 64] = Ae[U];
                const f = L.subarray(32),
                    v = L.subarray(16);
                (function Se(ae, Me) {
                    const Le = ne();
                    for (let L = 0; L < 16; L++) Le[L] = Me[L];
                    for (let L = 253; L >= 0; L--) de(Le, Le), 2 !== L && 4 !== L && re(Le, Le, Me);
                    for (let L = 0; L < 16; L++) ae[L] = Le[L]
                })(f, f), re(v, v, f);
                const M = new Uint8Array(32);
                return function H(ae, Me) {
                    const Le = ne(),
                        L = ne();
                    for (let ue = 0; ue < 16; ue++) L[ue] = Me[ue];
                    C(L), C(L), C(L);
                    for (let ue = 0; ue < 2; ue++) {
                        Le[0] = L[0] - 65517;
                        for (let xe = 1; xe < 15; xe++) Le[xe] = L[xe] - 65535 - (Le[xe - 1] >> 16 & 1), Le[xe - 1] &= 65535;
                        Le[15] = L[15] - 32767 - (Le[14] >> 16 & 1);
                        const Te = Le[15] >> 16 & 1;
                        Le[14] &= 65535, z(L, Le, 1 - Te)
                    }
                    for (let ue = 0; ue < 16; ue++) ae[2 * ue] = 255 & L[ue], ae[2 * ue + 1] = L[ue] >> 8
                }(M, v), M
            }

            function Ce(ae) {
                return me(ae, S)
            }
            I.Au = function ve(ae) {
                const Me = (0, K.randomBytes)(32, ae),
                    Le = function we(ae) {
                        if (ae.length !== I.KS) throw new Error(`x25519: seed must be ${I.KS} bytes`);
                        const Me = new Uint8Array(ae);
                        return {
                            publicKey: Ce(Me),
                            secretKey: Me
                        }
                    }(Me);
                return (0, q.wipe)(Me), Le
            }, I.gi = function De(ae, Me, Le = !1) {
                if (ae.length !== I.kz) throw new Error("X25519: incorrect secret key length");
                if (Me.length !== I.kz) throw new Error("X25519: incorrect public key length");
                const L = me(ae, Me);
                if (Le) {
                    let ue = 0;
                    for (let Te = 0; Te < L.length; Te++) ue |= L[Te];
                    if (0 === ue) throw new Error("X25519: invalid shared key")
                }
                return L
            }
        },
        6380: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            const F = T(30004);
            F.__exportStar(T(42996), I), F.__exportStar(T(46836), I)
        },
        42996: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.ONE_THOUSAND = I.ONE_HUNDRED = void 0, I.ONE_HUNDRED = 100, I.ONE_THOUSAND = 1e3
        },
        46836: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.ONE_YEAR = I.FOUR_WEEKS = I.THREE_WEEKS = I.TWO_WEEKS = I.ONE_WEEK = I.THIRTY_DAYS = I.SEVEN_DAYS = I.FIVE_DAYS = I.THREE_DAYS = I.ONE_DAY = I.TWENTY_FOUR_HOURS = I.TWELVE_HOURS = I.SIX_HOURS = I.THREE_HOURS = I.ONE_HOUR = I.SIXTY_MINUTES = I.THIRTY_MINUTES = I.TEN_MINUTES = I.FIVE_MINUTES = I.ONE_MINUTE = I.SIXTY_SECONDS = I.THIRTY_SECONDS = I.TEN_SECONDS = I.FIVE_SECONDS = I.ONE_SECOND = void 0, I.ONE_SECOND = 1, I.FIVE_SECONDS = 5, I.TEN_SECONDS = 10, I.THIRTY_SECONDS = 30, I.SIXTY_SECONDS = 60, I.ONE_MINUTE = I.SIXTY_SECONDS, I.FIVE_MINUTES = 5 * I.ONE_MINUTE, I.TEN_MINUTES = 10 * I.ONE_MINUTE, I.THIRTY_MINUTES = 30 * I.ONE_MINUTE, I.SIXTY_MINUTES = 60 * I.ONE_MINUTE, I.ONE_HOUR = I.SIXTY_MINUTES, I.THREE_HOURS = 3 * I.ONE_HOUR, I.SIX_HOURS = 6 * I.ONE_HOUR, I.TWELVE_HOURS = 12 * I.ONE_HOUR, I.TWENTY_FOUR_HOURS = 24 * I.ONE_HOUR, I.ONE_DAY = I.TWENTY_FOUR_HOURS, I.THREE_DAYS = 3 * I.ONE_DAY, I.FIVE_DAYS = 5 * I.ONE_DAY, I.SEVEN_DAYS = 7 * I.ONE_DAY, I.THIRTY_DAYS = 30 * I.ONE_DAY, I.ONE_WEEK = I.SEVEN_DAYS, I.TWO_WEEKS = 2 * I.ONE_WEEK, I.THREE_WEEKS = 3 * I.ONE_WEEK, I.FOUR_WEEKS = 4 * I.ONE_WEEK, I.ONE_YEAR = 365 * I.ONE_DAY
        },
        35409: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            const F = T(30004);
            F.__exportStar(T(53429), I), F.__exportStar(T(75882), I), F.__exportStar(T(48066), I), F.__exportStar(T(6380), I)
        },
        48066: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), T(30004).__exportStar(T(88148), I)
        },
        88148: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.IWatch = void 0, I.IWatch = class T {}
        },
        49976: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.fromMiliseconds = I.toMiliseconds = void 0;
            const F = T(6380);
            I.toMiliseconds = function K(ne) {
                return ne * F.ONE_THOUSAND
            }, I.fromMiliseconds = function q(ne) {
                return Math.floor(ne / F.ONE_THOUSAND)
            }
        },
        52373: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.delay = void 0, I.delay = function T(F) {
                return new Promise(K => {
                    setTimeout(() => {
                        K(!0)
                    }, F)
                })
            }
        },
        53429: (et, I, T) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            });
            const F = T(30004);
            F.__exportStar(T(52373), I), F.__exportStar(T(49976), I)
        },
        75882: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.Watch = void 0;
            class T {
                constructor() {
                    this.timestamps = new Map
                }
                start(K) {
                    if (this.timestamps.has(K)) throw new Error(`Watch already started for label: ${K}`);
                    this.timestamps.set(K, {
                        started: Date.now()
                    })
                }
                stop(K) {
                    const q = this.get(K);
                    if (typeof q.elapsed < "u") throw new Error(`Watch already stopped for label: ${K}`);
                    const ne = Date.now() - q.started;
                    this.timestamps.set(K, {
                        started: q.started,
                        elapsed: ne
                    })
                }
                get(K) {
                    const q = this.timestamps.get(K);
                    if (typeof q > "u") throw new Error(`No timestamp found for label: ${K}`);
                    return q
                }
                elapsed(K) {
                    const q = this.get(K);
                    return q.elapsed || Date.now() - q.started
                }
            }
            I.Watch = T, I.default = T
        },
        13304: (et, I, T) => {
            "use strict";
            T.d(I, {
                AW: () => _n,
                O6: () => lo,
                rV: () => yi,
                gn: () => ot,
                H1: () => _u,
                hF: () => el,
                WG: () => at,
                pe: () => St,
                m$: () => gn,
                vB: () => Nn,
                HI: () => pt,
                E0: () => kt,
                Gq: () => lt,
                $0: () => yu,
                Z4: () => kc,
                Bv: () => Lo,
                Au: () => Ti,
                jd: () => Ji,
                gu: () => O,
                D: () => xr,
                X_: () => da,
                bW: () => ks,
                Z7: () => $t,
                cO: () => rc,
                _H: () => Zo,
                fc: () => ns,
                D6: () => zs,
                Hh: () => _r,
                Ym: () => Si,
                rj: () => qn,
                jU: () => Ir,
                gp: () => sc,
                rF: () => Ot,
                Bw: () => Kt,
                UG: () => ua,
                Gg: () => _i,
                xW: () => Pl,
                b$: () => Qs,
                Ih: () => gd,
                h1: () => Oh,
                Q8: () => ti,
                o8: () => xs,
                qt: () => pa,
                Dd: () => yd,
                $t: () => Oc,
                nf: () => Nh,
                Q0: () => fn,
                in: () => Pr,
                p8: () => bd,
                sI: () => Rl,
                al: () => Jt,
                L5: () => ls,
                EJ: () => ct,
                Z2: () => Bh,
                PM: () => to,
                hH: () => Yn,
                ON: () => Fh,
                n: () => Rh,
                JT: () => vd,
                M_: () => Vn,
                jv: () => Ba,
                KC: () => un,
                eG: () => Fn,
                fK: () => Is,
                IP: () => Cr,
                DQ: () => ui,
                iP: () => Ye,
                M: () => Pc,
                he: () => eo,
                uw: () => Yi,
                Ll: () => Ut,
                EN: () => or
            });
            var F = T(15861),
                K = T(79026),
                q = T(81028),
                ne = T(25465),
                S = T(31033),
                j = T(28467),
                C = T(3544),
                z = function(X, be, Ue) {
                    if (Ue || 2 === arguments.length)
                        for (var Wt, rt = 0, At = be.length; rt < At; rt++)(Wt || !(rt in be)) && (Wt || (Wt = Array.prototype.slice.call(be, 0, rt)), Wt[rt] = be[rt]);
                    return X.concat(Wt || Array.prototype.slice.call(be))
                },
                H = function X(be, Ue, rt) {
                    this.name = be, this.version = Ue, this.os = rt, this.type = "browser"
                },
                Y = function X(be) {
                    this.version = be, this.type = "node", this.name = "node", this.os = process.platform
                },
                Z = function X(be, Ue, rt, At) {
                    this.name = be, this.version = Ue, this.os = rt, this.bot = At, this.type = "bot-device"
                },
                le = function X() {
                    this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
                },
                re = function X() {
                    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
                },
                Se = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
                me = 3,
                Ce = [
                    ["aol", /AOLShield\/([0-9\._]+)/],
                    ["edge", /Edge\/([0-9\._]+)/],
                    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
                    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
                    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
                    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
                    ["silk", /\bSilk\/([0-9._-]+)\b/],
                    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
                    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
                    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
                    ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
                    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
                    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
                    ["fxios", /FxiOS\/([0-9\.]+)/],
                    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
                    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
                    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
                    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
                    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
                    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
                    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
                    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
                    ["ie", /MSIE\s(7\.0)/],
                    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
                    ["android", /Android\s([0-9\.]+)/],
                    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
                    ["safari", /Version\/([0-9\._]+).*Safari/],
                    ["facebook", /FB[AS]V\/([0-9\.]+)/],
                    ["instagram", /Instagram\s([0-9\.]+)/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
                    ["curl", /^curl\/([0-9\.]+)$/],
                    ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]
                ],
                we = [
                    ["iOS", /iP(hone|od|ad)/],
                    ["Android OS", /Android/],
                    ["BlackBerry OS", /BlackBerry|BB10/],
                    ["Windows Mobile", /IEMobile/],
                    ["Amazon OS", /Kindle/],
                    ["Windows 3.11", /Win16/],
                    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                    ["Windows 98", /(Windows 98)|(Win98)/],
                    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                    ["Windows Server 2003", /(Windows NT 5.2)/],
                    ["Windows Vista", /(Windows NT 6.0)/],
                    ["Windows 7", /(Windows NT 6.1)/],
                    ["Windows 8", /(Windows NT 6.2)/],
                    ["Windows 8.1", /(Windows NT 6.3)/],
                    ["Windows 10", /(Windows NT 10.0)/],
                    ["Windows ME", /Windows ME/],
                    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                    ["Open BSD", /OpenBSD/],
                    ["Sun OS", /SunOS/],
                    ["Chrome OS", /CrOS/],
                    ["Linux", /(Linux)|(X11)/],
                    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                    ["QNX", /QNX/],
                    ["BeOS", /BeOS/],
                    ["OS/2", /OS\/2/]
                ];

            function Me(X) {
                var be = function De(X) {
                    return "" !== X && Ce.reduce(function(be, Ue) {
                        var rt = Ue[0];
                        if (be) return be;
                        var Wt = Ue[1].exec(X);
                        return !!Wt && [rt, Wt]
                    }, !1)
                }(X);
                if (!be) return null;
                var Ue = be[0],
                    rt = be[1];
                if ("searchbot" === Ue) return new le;
                var At = rt[1] && rt[1].split(".").join("_").split("_").slice(0, 3);
                At ? At.length < me && (At = z(z([], At, !0), function ue(X) {
                    for (var be = [], Ue = 0; Ue < X; Ue++) be.push("0");
                    return be
                }(me - At.length), !0)) : At = [];
                var Wt = At.join("."),
                    Ct = function Le(X) {
                        for (var be = 0, Ue = we.length; be < Ue; be++) {
                            var rt = we[be],
                                At = rt[0];
                            if (rt[1].exec(X)) return At
                        }
                        return null
                    }(X),
                    bn = Se.exec(X);
                return bn && bn[1] ? new Z(Ue, Wt, Ct, bn[1]) : new H(Ue, Wt, Ct)
            }
            var Te = T(35409),
                xe = T(20439),
                Ae = T(66534),
                Ie = T(98808);
            const jn = {
                    waku: {
                        publish: "waku_publish",
                        batchPublish: "waku_batchPublish",
                        subscribe: "waku_subscribe",
                        batchSubscribe: "waku_batchSubscribe",
                        subscription: "waku_subscription",
                        unsubscribe: "waku_unsubscribe",
                        batchUnsubscribe: "waku_batchUnsubscribe",
                        batchFetchMessages: "waku_batchFetchMessages"
                    },
                    irn: {
                        publish: "irn_publish",
                        batchPublish: "irn_batchPublish",
                        subscribe: "irn_subscribe",
                        batchSubscribe: "irn_batchSubscribe",
                        subscription: "irn_subscription",
                        unsubscribe: "irn_unsubscribe",
                        batchUnsubscribe: "irn_batchUnsubscribe",
                        batchFetchMessages: "irn_batchFetchMessages"
                    },
                    iridium: {
                        publish: "iridium_publish",
                        batchPublish: "iridium_batchPublish",
                        subscribe: "iridium_subscribe",
                        batchSubscribe: "iridium_batchSubscribe",
                        subscription: "iridium_subscription",
                        unsubscribe: "iridium_unsubscribe",
                        batchUnsubscribe: "iridium_batchUnsubscribe",
                        batchFetchMessages: "iridium_batchFetchMessages"
                    }
                },
                An = ":";

            function ui(X) {
                const [be, Ue] = X.split(An);
                return {
                    namespace: be,
                    reference: Ue
                }
            }

            function O(X, be = []) {
                const Ue = [];
                return Object.keys(X).forEach(rt => {
                    be.length && !be.includes(rt) || Ue.push(...X[rt].accounts)
                }), Ue
            }

            function je(X, be) {
                return X.includes(":") ? [X] : be.chains || []
            }
            const $n = "base10",
                _n = "base16",
                Sn = "base64pad",
                pi = "utf8",
                ca = 0,
                yi = 1,
                hr = 0,
                qo = 1,
                yr = 12,
                Rn = 32;

            function Ti() {
                const X = j.Au();
                return {
                    privateKey: (0, C.BB)(X.secretKey, _n),
                    publicKey: (0, C.BB)(X.publicKey, _n)
                }
            }

            function Ji() {
                const X = (0, ne.randomBytes)(Rn);
                return (0, C.BB)(X, _n)
            }

            function gn(X, be) {
                const Ue = j.gi((0, C.mL)(X, _n), (0, C.mL)(be, _n), !0),
                    rt = new q.t(S.mE, Ue).expand(Rn);
                return (0, C.BB)(rt, _n)
            }

            function Si(X) {
                const be = (0, S.vp)((0, C.mL)(X, _n));
                return (0, C.BB)(be, _n)
            }

            function qn(X) {
                const be = (0, S.vp)((0, C.mL)(X, pi));
                return (0, C.BB)(be, _n)
            }

            function at(X) {
                return Number((0, C.BB)(X, $n))
            }

            function pt(X) {
                const be = function Ve(X) {
                    return (0, C.mL)(`${X}`, $n)
                }(typeof X.type < "u" ? X.type : ca);
                if (at(be) === yi && typeof X.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
                const Ue = typeof X.senderPublicKey < "u" ? (0, C.mL)(X.senderPublicKey, _n) : void 0,
                    rt = typeof X.iv < "u" ? (0, C.mL)(X.iv, _n) : (0, ne.randomBytes)(yr);
                return function Bn(X) {
                    if (at(X.type) === yi) {
                        if (typeof X.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
                        return (0, C.BB)((0, C.zo)([X.type, X.senderPublicKey, X.iv, X.sealed]), Sn)
                    }
                    return (0, C.BB)((0, C.zo)([X.type, X.iv, X.sealed]), Sn)
                }({
                    type: be,
                    sealed: new K.OK((0, C.mL)(X.symKey, _n)).seal(rt, (0, C.mL)(X.message, pi)),
                    iv: rt,
                    senderPublicKey: Ue
                })
            }

            function St(X) {
                const be = new K.OK((0, C.mL)(X.symKey, _n)),
                    {
                        sealed: Ue,
                        iv: rt
                    } = Nn(X.encoded),
                    At = be.open(rt, Ue);
                if (null === At) throw new Error("Failed to decrypt");
                return (0, C.BB)(At, pi)
            }

            function Nn(X) {
                const be = (0, C.mL)(X, Sn),
                    Ue = be.slice(hr, qo),
                    rt = qo;
                if (at(Ue) === yi) {
                    const bn = rt + Rn,
                        vi = bn + yr,
                        ni = be.slice(rt, bn),
                        fr = be.slice(bn, vi);
                    return {
                        type: Ue,
                        sealed: be.slice(vi),
                        iv: fr,
                        senderPublicKey: ni
                    }
                }
                const At = rt + yr,
                    Wt = be.slice(rt, At);
                return {
                    type: Ue,
                    sealed: be.slice(At),
                    iv: Wt
                }
            }

            function Ut(X, be) {
                const Ue = Nn(X);
                return or({
                    type: at(Ue.type),
                    senderPublicKey: typeof Ue.senderPublicKey < "u" ? (0, C.BB)(Ue.senderPublicKey, _n) : void 0,
                    receiverPublicKey: be ? .receiverPublicKey
                })
            }

            function or(X) {
                const be = X ? .type || ca;
                if (be === yi) {
                    if (typeof X ? .senderPublicKey > "u") throw new Error("missing sender public key");
                    if (typeof X ? .receiverPublicKey > "u") throw new Error("missing receiver public key")
                }
                return {
                    type: be,
                    senderPublicKey: X ? .senderPublicKey,
                    receiverPublicKey: X ? .receiverPublicKey
                }
            }

            function ti(X) {
                return X.type === yi && "string" == typeof X.senderPublicKey && "string" == typeof X.receiverPublicKey
            }
            var qi = Object.defineProperty,
                Xs = Object.getOwnPropertySymbols,
                Xn = Object.prototype.hasOwnProperty,
                an = Object.prototype.propertyIsEnumerable,
                As = (X, be, Ue) => be in X ? qi(X, be, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Ue
                }) : X[be] = Ue,
                wo = (X, be) => {
                    for (var Ue in be || (be = {})) Xn.call(be, Ue) && As(X, Ue, be[Ue]);
                    if (Xs)
                        for (var Ue of Xs(be)) an.call(be, Ue) && As(X, Ue, be[Ue]);
                    return X
                };
            const Dc = "ReactNative",
                Wr = {
                    reactNative: "react-native",
                    node: "node",
                    browser: "browser",
                    unknown: "unknown"
                },
                la = "js";

            function ua() {
                return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
            }

            function Qs() {
                return !(0, xe.getDocument)() && !!(0, xe.getNavigator)() && navigator.product === Dc
            }

            function Ir() {
                return !ua() && !!(0, xe.getNavigator)() && !!(0, xe.getDocument)()
            }

            function ao() {
                return Qs() ? Wr.reactNative : ua() ? Wr.node : Ir() ? Wr.browser : Wr.unknown
            }

            function da() {
                var X;
                try {
                    return Qs() && typeof global < "u" && typeof(null == global ? void 0 : global.Application) < "u" ? null == (X = global.Application) ? void 0 : X.applicationId : void 0
                } catch {
                    return
                }
            }

            function xr() {
                return (0, Ae.D)() || {
                    name: "",
                    description: "",
                    url: "",
                    icons: [""]
                }
            }

            function ic(X, be, Ue) {
                const rt = function Zi() {
                        if (ao() === Wr.reactNative && typeof global < "u" && typeof(null == global ? void 0 : global.Platform) < "u") {
                            const {
                                OS: Ue,
                                Version: rt
                            } = global.Platform;
                            return [Ue, rt].join("-")
                        }
                        const X = function ve(X) {
                            return X ? Me(X) : typeof document > "u" && typeof navigator < "u" && "ReactNative" === navigator.product ? new re : typeof navigator < "u" ? Me(navigator.userAgent) : function L() {
                                return typeof process < "u" && process.version ? new Y(process.version.slice(1)) : null
                            }()
                        }();
                        if (null === X) return "unknown";
                        const be = X.os ? X.os.replace(" ", "").toLowerCase() : "unknown";
                        return "browser" === X.type ? [be, X.name, X.version].join("-") : [be, X.version].join("-")
                    }(),
                    At = function hd() {
                        var X;
                        const be = ao();
                        return be === Wr.browser ? [be, (null == (X = (0, xe.getLocation)()) ? void 0 : X.host) || "unknown"].join(":") : be
                    }();
                return [
                    [X, be].join("-"), [la, Ue].join("-"), rt, At
                ].join("/")
            }

            function yu({
                protocol: X,
                version: be,
                relayUrl: Ue,
                sdkVersion: rt,
                auth: At,
                projectId: Wt,
                useOnCloseEvent: Ct,
                bundleId: bn
            }) {
                const vi = Ue.split("?"),
                    ni = ic(X, be, rt),
                    ii = function nc(X, be) {
                        let Ue = Ie.parse(X);
                        return Ue = wo(wo({}, Ue), be), Ie.stringify(Ue)
                    }(vi[1] || "", {
                        auth: At,
                        ua: ni,
                        projectId: Wt,
                        useOnCloseEvent: Ct || void 0,
                        origin: bn || void 0
                    });
                return vi[0] + "?" + ii
            }

            function Mn(X, be) {
                return X.filter(Ue => be.includes(Ue)).length === X.length
            }

            function un(X) {
                return Object.fromEntries(X.entries())
            }

            function Cr(X) {
                return new Map(Object.entries(X))
            }

            function _u(X = Te.FIVE_MINUTES, be) {
                const Ue = (0, Te.toMiliseconds)(X || Te.FIVE_MINUTES);
                let rt, At, Wt;
                return {
                    resolve: Ct => {
                        Wt && rt && (clearTimeout(Wt), rt(Ct))
                    },
                    reject: Ct => {
                        Wt && At && (clearTimeout(Wt), At(Ct))
                    },
                    done: () => new Promise((Ct, bn) => {
                        Wt = setTimeout(() => {
                            bn(new Error(be))
                        }, Ue), rt = Ct, At = bn
                    })
                }
            }

            function el(X, be, Ue) {
                return new Promise(function() {
                    var rt = (0, F.Z)(function*(At, Wt) {
                        const Ct = setTimeout(() => Wt(new Error(Ue)), be);
                        try {
                            At(yield X)
                        } catch (bn) {
                            Wt(bn)
                        }
                        clearTimeout(Ct)
                    });
                    return function(At, Wt) {
                        return rt.apply(this, arguments)
                    }
                }())
            }

            function md(X, be) {
                if ("string" == typeof be && be.startsWith(`${X}:`)) return be;
                if ("topic" === X.toLowerCase()) {
                    if ("string" != typeof be) throw new Error('Value must be "string" for expirer target type: topic');
                    return `topic:${be}`
                }
                if ("id" === X.toLowerCase()) {
                    if ("number" != typeof be) throw new Error('Value must be "number" for expirer target type: id');
                    return `id:${be}`
                }
                throw new Error(`Unknown expirer target type: ${X}`)
            }

            function kc(X) {
                return md("topic", X)
            }

            function lt(X) {
                return md("id", X)
            }

            function Ye(X) {
                const [be, Ue] = X.split(":"), rt = {
                    id: void 0,
                    topic: void 0
                };
                if ("topic" === be && "string" == typeof Ue) rt.topic = Ue;
                else {
                    if ("id" !== be || !Number.isInteger(Number(Ue))) throw new Error(`Invalid target, expected id:number or topic:string, got ${be}:${Ue}`);
                    rt.id = Number(Ue)
                }
                return rt
            }

            function ot(X, be) {
                return (0, Te.fromMiliseconds)((be || Date.now()) + (0, Te.toMiliseconds)(X))
            }

            function Kt(X) {
                return Date.now() >= (0, Te.toMiliseconds)(X)
            }

            function kt(X, be) {
                return `${X}${be?`:${be}`:""}`
            }

            function Fn(X = [], be = []) {
                return [...new Set([...X, ...be])]
            }

            function _r(X) {
                return Ei.apply(this, arguments)
            }

            function Ei() {
                return (Ei = (0, F.Z)(function*({
                    id: X,
                    topic: be,
                    wcDeepLink: Ue
                }) {
                    try {
                        if (!Ue) return;
                        let At = ("string" == typeof Ue ? JSON.parse(Ue) : Ue) ? .href;
                        if ("string" != typeof At) return;
                        At.endsWith("/") && (At = At.slice(0, -1));
                        const Wt = `${At}/wc?requestId=${X}&sessionTopic=${be}`,
                            Ct = ao();
                        Ct === Wr.browser ? Wt.startsWith("https://") ? window.open(Wt, "_blank", "noreferrer noopener") : window.open(Wt, "_self", "noreferrer noopener") : Ct === Wr.reactNative && typeof(null == global ? void 0 : global.Linking) < "u" && (yield global.Linking.openURL(Wt))
                    } catch (rt) {
                        console.error(rt)
                    }
                })).apply(this, arguments)
            }

            function ks(X, be) {
                return ha.apply(this, arguments)
            }

            function ha() {
                return (ha = (0, F.Z)(function*(X, be) {
                    try {
                        return (yield X.getItem(be)) || (Ir() ? localStorage.getItem(be) : void 0)
                    } catch (Ue) {
                        console.error(Ue)
                    }
                })).apply(this, arguments)
            }
            const Di = "irn";

            function Zo(X) {
                return X ? .relay || {
                    protocol: Di
                }
            }

            function rc(X) {
                const be = jn[X];
                if (typeof be > "u") throw new Error(`Relay Protocol not supported: ${X}`);
                return be
            }
            var nn = Object.defineProperty,
                Wi = Object.getOwnPropertySymbols,
                as = Object.prototype.hasOwnProperty,
                Yo = Object.prototype.propertyIsEnumerable,
                cs = (X, be, Ue) => be in X ? nn(X, be, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Ue
                }) : X[be] = Ue,
                co = (X, be) => {
                    for (var Ue in be || (be = {})) as.call(be, Ue) && cs(X, Ue, be[Ue]);
                    if (Wi)
                        for (var Ue of Wi(be)) Yo.call(be, Ue) && cs(X, Ue, be[Ue]);
                    return X
                };

            function Ms(X, be = "-") {
                const Ue = {},
                    rt = "relay" + be;
                return Object.keys(X).forEach(At => {
                    if (At.startsWith(rt)) {
                        const Wt = At.replace(rt, "");
                        Ue[Wt] = X[At]
                    }
                }), Ue
            }

            function eo(X) {
                const be = (X = (X = X.includes("wc://") ? X.replace("wc://", "") : X).includes("wc:") ? X.replace("wc:", "") : X).indexOf(":"),
                    Ue = -1 !== X.indexOf("?") ? X.indexOf("?") : void 0,
                    rt = X.substring(0, be),
                    At = X.substring(be + 1, Ue).split("@"),
                    Wt = typeof Ue < "u" ? X.substring(Ue) : "",
                    Ct = Ie.parse(Wt);
                return {
                    protocol: rt,
                    topic: Gr(At[0]),
                    version: parseInt(At[1], 10),
                    symKey: Ct.symKey,
                    relay: Ms(Ct)
                }
            }

            function Gr(X) {
                return X.startsWith("//") ? X.substring(2) : X
            }

            function Lo(X) {
                return `${X.protocol}:${X.topic}@${X.version}?` + Ie.stringify(co({
                    symKey: X.symKey
                }, function Oa(X, be = "-") {
                    const rt = {};
                    return Object.keys(X).forEach(At => {
                        X[At] && (rt["relay" + be + At] = X[At])
                    }), rt
                }(X.relay)))
            }
            var fa = Object.defineProperty,
                $s = Object.defineProperties,
                Ml = Object.getOwnPropertyDescriptors,
                Mc = Object.getOwnPropertySymbols,
                ps = Object.prototype.hasOwnProperty,
                vu = Object.prototype.propertyIsEnumerable,
                Il = (X, be, Ue) => be in X ? fa(X, be, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Ue
                }) : X[be] = Ue,
                He = (X, be) => {
                    for (var Ue in be || (be = {})) ps.call(be, Ue) && Il(X, Ue, be[Ue]);
                    if (Mc)
                        for (var Ue of Mc(be)) vu.call(be, Ue) && Il(X, Ue, be[Ue]);
                    return X
                },
                La = (X, be) => $s(X, Ml(be));

            function Ic(X) {
                const be = [];
                return X.forEach(Ue => {
                    const [rt, At] = Ue.split(":");
                    be.push(`${rt}:${At}`)
                }), be
            }

            function ns(X, be) {
                const Ue = Pr(X, be);
                if (Ue) throw new Error(Ue.message);
                const rt = {};
                for (const [At, Wt] of Object.entries(X)) rt[At] = {
                    methods: Wt.methods,
                    events: Wt.events,
                    chains: Wt.accounts.map(Ct => `${Ct.split(":")[0]}:${Ct.split(":")[1]}`)
                };
                return rt
            }

            function sc(X) {
                return X.includes(":")
            }

            function Pc(X) {
                return sc(X) ? X.split(":")[0] : X
            }

            function Is(X) {
                var be, Ue, rt;
                const At = {};
                if (!ls(X)) return At;
                for (const [Wt, Ct] of Object.entries(X)) {
                    const bn = sc(Wt) ? [Wt] : Ct.chains,
                        vi = Ct.methods || [],
                        ni = Ct.events || [],
                        fr = Pc(Wt);
                    At[fr] = La(He({}, At[fr]), {
                        chains: Fn(bn, null == (be = At[fr]) ? void 0 : be.chains),
                        methods: Fn(vi, null == (Ue = At[fr]) ? void 0 : Ue.methods),
                        events: Fn(ni, null == (rt = At[fr]) ? void 0 : rt.events)
                    })
                }
                return At
            }
            const is = {
                    INVALID_METHOD: {
                        message: "Invalid method.",
                        code: 1001
                    },
                    INVALID_EVENT: {
                        message: "Invalid event.",
                        code: 1002
                    },
                    INVALID_UPDATE_REQUEST: {
                        message: "Invalid update request.",
                        code: 1003
                    },
                    INVALID_EXTEND_REQUEST: {
                        message: "Invalid extend request.",
                        code: 1004
                    },
                    INVALID_SESSION_SETTLE_REQUEST: {
                        message: "Invalid session settle request.",
                        code: 1005
                    },
                    UNAUTHORIZED_METHOD: {
                        message: "Unauthorized method.",
                        code: 3001
                    },
                    UNAUTHORIZED_EVENT: {
                        message: "Unauthorized event.",
                        code: 3002
                    },
                    UNAUTHORIZED_UPDATE_REQUEST: {
                        message: "Unauthorized update request.",
                        code: 3003
                    },
                    UNAUTHORIZED_EXTEND_REQUEST: {
                        message: "Unauthorized extend request.",
                        code: 3004
                    },
                    USER_REJECTED: {
                        message: "User rejected.",
                        code: 5e3
                    },
                    USER_REJECTED_CHAINS: {
                        message: "User rejected chains.",
                        code: 5001
                    },
                    USER_REJECTED_METHODS: {
                        message: "User rejected methods.",
                        code: 5002
                    },
                    USER_REJECTED_EVENTS: {
                        message: "User rejected events.",
                        code: 5003
                    },
                    UNSUPPORTED_CHAINS: {
                        message: "Unsupported chains.",
                        code: 5100
                    },
                    UNSUPPORTED_METHODS: {
                        message: "Unsupported methods.",
                        code: 5101
                    },
                    UNSUPPORTED_EVENTS: {
                        message: "Unsupported events.",
                        code: 5102
                    },
                    UNSUPPORTED_ACCOUNTS: {
                        message: "Unsupported accounts.",
                        code: 5103
                    },
                    UNSUPPORTED_NAMESPACE_KEY: {
                        message: "Unsupported namespace key.",
                        code: 5104
                    },
                    USER_DISCONNECTED: {
                        message: "User disconnected.",
                        code: 6e3
                    },
                    SESSION_SETTLEMENT_FAILED: {
                        message: "Session settlement failed.",
                        code: 7e3
                    },
                    WC_METHOD_UNSUPPORTED: {
                        message: "Unsupported wc_ method.",
                        code: 10001
                    }
                },
                bu = {
                    NOT_INITIALIZED: {
                        message: "Not initialized.",
                        code: 1
                    },
                    NO_MATCHING_KEY: {
                        message: "No matching key.",
                        code: 2
                    },
                    RESTORE_WILL_OVERRIDE: {
                        message: "Restore will override.",
                        code: 3
                    },
                    RESUBSCRIBED: {
                        message: "Resubscribed.",
                        code: 4
                    },
                    MISSING_OR_INVALID: {
                        message: "Missing or invalid.",
                        code: 5
                    },
                    EXPIRED: {
                        message: "Expired.",
                        code: 6
                    },
                    UNKNOWN_TYPE: {
                        message: "Unknown type.",
                        code: 7
                    },
                    MISMATCHED_TOPIC: {
                        message: "Mismatched topic.",
                        code: 8
                    },
                    NON_CONFORMING_NAMESPACES: {
                        message: "Non conforming namespaces.",
                        code: 9
                    }
                };

            function $t(X, be) {
                const {
                    message: Ue,
                    code: rt
                } = bu[X];
                return {
                    message: be ? `${Ue} ${be}` : Ue,
                    code: rt
                }
            }

            function zs(X, be) {
                const {
                    message: Ue,
                    code: rt
                } = is[X];
                return {
                    message: be ? `${Ue} ${be}` : Ue,
                    code: rt
                }
            }

            function pa(X, be) {
                return !!Array.isArray(X) && (!(typeof be < "u" && X.length) || X.every(be))
            }

            function ls(X) {
                return Object.getPrototypeOf(X) === Object.prototype && Object.keys(X).length
            }

            function xs(X) {
                return typeof X > "u"
            }

            function Vn(X, be) {
                return !(!be || !xs(X)) || "string" == typeof X && !!X.trim().length
            }

            function tl(X, be) {
                return !(!be || !xs(X)) || "number" == typeof X && !isNaN(X)
            }

            function gd(X, be) {
                const {
                    requiredNamespaces: Ue
                } = be, rt = Object.keys(X.namespaces), At = Object.keys(Ue);
                let Wt = !0;
                return !!Mn(At, rt) && (rt.forEach(Ct => {
                    const {
                        accounts: bn,
                        methods: vi,
                        events: ni
                    } = X.namespaces[Ct], fr = Ic(bn), ii = Ue[Ct];
                    Mn(je(Ct, ii), fr) && Mn(ii.methods, vi) && Mn(ii.events, ni) || (Wt = !1)
                }), Wt)
            }

            function nl(X) {
                return !(!Vn(X, !1) || !X.includes(":")) && 2 === X.split(":").length
            }

            function Ba(X) {
                if (Vn(X, !1)) try {
                    return typeof new URL(X) < "u"
                } catch {
                    return !1
                }
                return !1
            }

            function Pl(X) {
                var be;
                return null == (be = X ? .proposer) ? void 0 : be.publicKey
            }

            function Oh(X) {
                return X ? .topic
            }

            function yd(X, be) {
                let Ue = null;
                return Vn(X ? .publicKey, !1) || (Ue = $t("MISSING_OR_INVALID", `${be} controller public key should be a string`)), Ue
            }

            function dn(X) {
                let be = !0;
                return pa(X) ? X.length && (be = X.every(Ue => Vn(Ue, !1))) : be = !1, be
            }

            function Lh(X, be) {
                let Ue = null;
                return Object.values(X).forEach(rt => {
                    if (Ue) return;
                    const At = function Ll(X, be) {
                        let Ue = null;
                        return dn(X ? .methods) ? dn(X ? .events) || (Ue = zs("UNSUPPORTED_EVENTS", `${be}, events should be an array of strings or empty array for no events`)) : Ue = zs("UNSUPPORTED_METHODS", `${be}, methods should be an array of strings or empty array for no methods`), Ue
                    }(rt, `${be}, namespace`);
                    At && (Ue = At)
                }), Ue
            }

            function Rh(X, be, Ue) {
                let rt = null;
                if (X && ls(X)) {
                    const At = Lh(X, be);
                    At && (rt = At);
                    const Wt = function _d(X, be, Ue) {
                        let rt = null;
                        return Object.entries(X).forEach(([At, Wt]) => {
                            if (rt) return;
                            const Ct = function Bo(X, be, Ue) {
                                let rt = null;
                                return pa(be) && be.length ? be.forEach(At => {
                                    rt || nl(At) || (rt = zs("UNSUPPORTED_CHAINS", `${Ue}, chain ${At} should be a string and conform to "namespace:chainId" format`))
                                }) : nl(X) || (rt = zs("UNSUPPORTED_CHAINS", `${Ue}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), rt
                            }(At, je(At, Wt), `${be} ${Ue}`);
                            Ct && (rt = Ct)
                        }), rt
                    }(X, be, Ue);
                    Wt && (rt = Wt)
                } else rt = $t("MISSING_OR_INVALID", `${be}, ${Ue} should be an object with data`);
                return rt
            }

            function Pr(X, be) {
                let Ue = null;
                if (X && ls(X)) {
                    const rt = Lh(X, be);
                    rt && (Ue = rt);
                    const At = function Ol(X, be) {
                        let Ue = null;
                        return Object.values(X).forEach(rt => {
                            if (Ue) return;
                            const At = function il(X, be) {
                                let Ue = null;
                                return pa(X) ? X.forEach(rt => {
                                    Ue || function Ph(X) {
                                        if (Vn(X, !1) && X.includes(":")) {
                                            const be = X.split(":");
                                            if (3 === be.length) return !!be[2] && nl(be[0] + ":" + be[1])
                                        }
                                        return !1
                                    }(rt) || (Ue = zs("UNSUPPORTED_ACCOUNTS", `${be}, account ${rt} should be a string and conform to "namespace:chainId:address" format`))
                                }) : Ue = zs("UNSUPPORTED_ACCOUNTS", `${be}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Ue
                            }(rt ? .accounts, `${be} namespace`);
                            At && (Ue = At)
                        }), Ue
                    }(X, be);
                    At && (Ue = At)
                } else Ue = $t("MISSING_OR_INVALID", `${be}, namespaces should be an object with data`);
                return Ue
            }

            function Bh(X) {
                return Vn(X.protocol, !0)
            }

            function to(X, be) {
                let Ue = !1;
                return be && !X ? Ue = !0 : X && pa(X) && X.length && X.forEach(rt => {
                    Ue = Bh(rt)
                }), Ue
            }

            function fn(X) {
                return "number" == typeof X
            }

            function ct(X) {
                return typeof X < "u" && null !== typeof X
            }

            function Oc(X) {
                return !!(X && "object" == typeof X && X.code && tl(X.code, !1) && X.message && Vn(X.message, !1))
            }

            function Yn(X) {
                return !(xs(X) || !Vn(X.method, !1))
            }

            function vd(X) {
                return !(xs(X) || xs(X.result) && xs(X.error) || !tl(X.id, !1) || !Vn(X.jsonrpc, !1))
            }

            function Nh(X) {
                return !(xs(X) || !Vn(X.name, !1))
            }

            function bd(X, be) {
                return !(!nl(be) || ! function Ra(X) {
                    const be = [];
                    return Object.values(X).forEach(Ue => {
                        be.push(...Ic(Ue.accounts))
                    }), be
                }(X).includes(be))
            }

            function Jt(X, be, Ue) {
                return !!Vn(Ue, !1) && function Ro(X, be) {
                    const Ue = [];
                    return Object.values(X).forEach(rt => {
                        Ic(rt.accounts).includes(be) && Ue.push(...rt.methods)
                    }), Ue
                }(X, be).includes(Ue)
            }

            function Rl(X, be, Ue) {
                return !!Vn(Ue, !1) && function _t(X, be) {
                    const Ue = [];
                    return Object.values(X).forEach(rt => {
                        Ic(rt.accounts).includes(be) && Ue.push(...rt.events)
                    }), Ue
                }(X, be).includes(Ue)
            }

            function Ot(X, be, Ue) {
                let rt = null;
                const At = function xn(X) {
                        const be = {};
                        return Object.keys(X).forEach(Ue => {
                            var rt;
                            Ue.includes(":") ? be[Ue] = X[Ue] : null == (rt = X[Ue].chains) || rt.forEach(At => {
                                be[At] = {
                                    methods: X[Ue].methods,
                                    events: X[Ue].events
                                }
                            })
                        }), be
                    }(X),
                    Wt = function Fa(X) {
                        const be = {};
                        return Object.keys(X).forEach(Ue => {
                            Ue.includes(":") ? be[Ue] = X[Ue] : Ic(X[Ue].accounts) ? .forEach(At => {
                                be[At] = {
                                    accounts: X[Ue].accounts.filter(Wt => Wt.includes(`${At}:`)),
                                    methods: X[Ue].methods,
                                    events: X[Ue].events
                                }
                            })
                        }), be
                    }(be),
                    Ct = Object.keys(At),
                    bn = Object.keys(Wt),
                    vi = Na(Object.keys(X)),
                    ni = Na(Object.keys(be)),
                    fr = vi.filter(ii => !ni.includes(ii));
                return fr.length && (rt = $t("NON_CONFORMING_NAMESPACES", `${Ue} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${fr.toString()}\n      Received: ${Object.keys(be).toString()}`)), Mn(Ct, bn) || (rt = $t("NON_CONFORMING_NAMESPACES", `${Ue} namespaces chains don't satisfy required namespaces.\n      Required: ${Ct.toString()}\n      Approved: ${bn.toString()}`)), Object.keys(be).forEach(ii => {
                    if (!ii.includes(":") || rt) return;
                    const no = Ic(be[ii].accounts);
                    no.includes(ii) || (rt = $t("NON_CONFORMING_NAMESPACES", `${Ue} namespaces accounts don't satisfy namespace accounts for ${ii}\n        Required: ${ii}\n        Approved: ${no.toString()}`))
                }), Ct.forEach(ii => {
                    rt || (Mn(At[ii].methods, Wt[ii].methods) ? Mn(At[ii].events, Wt[ii].events) || (rt = $t("NON_CONFORMING_NAMESPACES", `${Ue} namespaces events don't satisfy namespace events for ${ii}`)) : rt = $t("NON_CONFORMING_NAMESPACES", `${Ue} namespaces methods don't satisfy namespace methods for ${ii}`))
                }), rt
            }

            function Na(X) {
                return [...new Set(X.map(be => be.includes(":") ? be.split(":")[0] : be))]
            }

            function Fh(X, be) {
                return tl(X, !1) && X <= be.max && X >= be.min
            }

            function _i() {
                const X = ao();
                return new Promise(be => {
                    switch (X) {
                        case Wr.browser:
                            be(function fp() {
                                return Ir() && navigator ? .onLine
                            }());
                            break;
                        case Wr.reactNative:
                            be(function Vh() {
                                return Un.apply(this, arguments)
                            }());
                            break;
                        default:
                            be(!0)
                    }
                })
            }

            function Un() {
                return (Un = (0, F.Z)(function*() {
                    return !(Qs() && typeof global < "u" && null != global && global.NetInfo) || (yield null == global ? void 0 : global.NetInfo.fetch()) ? .isConnected
                })).apply(this, arguments)
            }

            function Yi(X) {
                switch (ao()) {
                    case Wr.browser:
                        ! function Kr(X) {
                            !Qs() && Ir() && (window.addEventListener("online", () => X(!0)), window.addEventListener("offline", () => X(!1)))
                        }(X);
                        break;
                    case Wr.reactNative:
                        ! function js(X) {
                            Qs() && typeof global < "u" && null != global && global.NetInfo && global ? .NetInfo.addEventListener(be => X(be ? .isConnected))
                        }(X)
                }
            }
            const Va = {};
            class lo {
                static get(be) {
                    return Va[be]
                }
                static set(be, Ue) {
                    Va[be] = Ue
                }
                static delete(be) {
                    delete Va[be]
                }
            }
        },
        98808: (et, I, T) => {
            "use strict";
            const F = T(8385),
                K = T(34989),
                q = T(36144),
                ne = T(80220),
                j = Symbol("encodeFragmentIdentifier");

            function H(we) {
                if ("string" != typeof we || 1 !== we.length) throw new TypeError("arrayFormatSeparator must be single character string")
            }

            function Y(we, ve) {
                return ve.encode ? ve.strict ? F(we) : encodeURIComponent(we) : we
            }

            function Z(we, ve) {
                return ve.decode ? K(we) : we
            }

            function le(we) {
                return Array.isArray(we) ? we.sort() : "object" == typeof we ? le(Object.keys(we)).sort((ve, De) => Number(ve) - Number(De)).map(ve => we[ve]) : we
            }

            function re(we) {
                const ve = we.indexOf("#");
                return -1 !== ve && (we = we.slice(0, ve)), we
            }

            function Se(we) {
                const ve = (we = re(we)).indexOf("?");
                return -1 === ve ? "" : we.slice(ve + 1)
            }

            function me(we, ve) {
                return ve.parseNumbers && !Number.isNaN(Number(we)) && "string" == typeof we && "" !== we.trim() ? we = Number(we) : ve.parseBooleans && null !== we && ("true" === we.toLowerCase() || "false" === we.toLowerCase()) && (we = "true" === we.toLowerCase()), we
            }

            function Ce(we, ve) {
                H((ve = Object.assign({
                    decode: !0,
                    sort: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ",",
                    parseNumbers: !1,
                    parseBooleans: !1
                }, ve)).arrayFormatSeparator);
                const De = function z(we) {
                        let ve;
                        switch (we.arrayFormat) {
                            case "index":
                                return (De, ae, Me) => {
                                    ve = /\[(\d*)\]$/.exec(De), De = De.replace(/\[\d*\]$/, ""), ve ? (void 0 === Me[De] && (Me[De] = {}), Me[De][ve[1]] = ae) : Me[De] = ae
                                };
                            case "bracket":
                                return (De, ae, Me) => {
                                    ve = /(\[\])$/.exec(De), Me[De = De.replace(/\[\]$/, "")] = ve ? void 0 !== Me[De] ? [].concat(Me[De], ae) : [ae] : ae
                                };
                            case "colon-list-separator":
                                return (De, ae, Me) => {
                                    ve = /(:list)$/.exec(De), Me[De = De.replace(/:list$/, "")] = ve ? void 0 !== Me[De] ? [].concat(Me[De], ae) : [ae] : ae
                                };
                            case "comma":
                            case "separator":
                                return (De, ae, Me) => {
                                    const Le = "string" == typeof ae && ae.includes(we.arrayFormatSeparator),
                                        L = "string" == typeof ae && !Le && Z(ae, we).includes(we.arrayFormatSeparator);
                                    ae = L ? Z(ae, we) : ae;
                                    const ue = Le || L ? ae.split(we.arrayFormatSeparator).map(Te => Z(Te, we)) : null === ae ? ae : Z(ae, we);
                                    Me[De] = ue
                                };
                            case "bracket-separator":
                                return (De, ae, Me) => {
                                    const Le = /(\[\])$/.test(De);
                                    if (De = De.replace(/\[\]$/, ""), !Le) return void(Me[De] = ae && Z(ae, we));
                                    const L = null === ae ? [] : ae.split(we.arrayFormatSeparator).map(ue => Z(ue, we));
                                    Me[De] = void 0 !== Me[De] ? [].concat(Me[De], L) : L
                                };
                            default:
                                return (De, ae, Me) => {
                                    Me[De] = void 0 !== Me[De] ? [].concat(Me[De], ae) : ae
                                }
                        }
                    }(ve),
                    ae = Object.create(null);
                if ("string" != typeof we || !(we = we.trim().replace(/^[?#&]/, ""))) return ae;
                for (const Me of we.split("&")) {
                    if ("" === Me) continue;
                    let [Le, L] = q(ve.decode ? Me.replace(/\+/g, " ") : Me, "=");
                    L = void 0 === L ? null : ["comma", "separator", "bracket-separator"].includes(ve.arrayFormat) ? L : Z(L, ve), De(Z(Le, ve), L, ae)
                }
                for (const Me of Object.keys(ae)) {
                    const Le = ae[Me];
                    if ("object" == typeof Le && null !== Le)
                        for (const L of Object.keys(Le)) Le[L] = me(Le[L], ve);
                    else ae[Me] = me(Le, ve)
                }
                return !1 === ve.sort ? ae : (!0 === ve.sort ? Object.keys(ae).sort() : Object.keys(ae).sort(ve.sort)).reduce((Me, Le) => {
                    const L = ae[Le];
                    return Me[Le] = L && "object" == typeof L && !Array.isArray(L) ? le(L) : L, Me
                }, Object.create(null))
            }
            I.extract = Se, I.parse = Ce, I.stringify = (we, ve) => {
                if (!we) return "";
                H((ve = Object.assign({
                    encode: !0,
                    strict: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ","
                }, ve)).arrayFormatSeparator);
                const De = L => ve.skipNull && (we => null == we)(we[L]) || ve.skipEmptyString && "" === we[L],
                    ae = function C(we) {
                        switch (we.arrayFormat) {
                            case "index":
                                return ve => (De, ae) => {
                                    const Me = De.length;
                                    return void 0 === ae || we.skipNull && null === ae || we.skipEmptyString && "" === ae ? De : null === ae ? [...De, [Y(ve, we), "[", Me, "]"].join("")] : [...De, [Y(ve, we), "[", Y(Me, we), "]=", Y(ae, we)].join("")]
                                };
                            case "bracket":
                                return ve => (De, ae) => void 0 === ae || we.skipNull && null === ae || we.skipEmptyString && "" === ae ? De : null === ae ? [...De, [Y(ve, we), "[]"].join("")] : [...De, [Y(ve, we), "[]=", Y(ae, we)].join("")];
                            case "colon-list-separator":
                                return ve => (De, ae) => void 0 === ae || we.skipNull && null === ae || we.skipEmptyString && "" === ae ? De : null === ae ? [...De, [Y(ve, we), ":list="].join("")] : [...De, [Y(ve, we), ":list=", Y(ae, we)].join("")];
                            case "comma":
                            case "separator":
                            case "bracket-separator":
                                {
                                    const ve = "bracket-separator" === we.arrayFormat ? "[]=" : "=";
                                    return De => (ae, Me) => void 0 === Me || we.skipNull && null === Me || we.skipEmptyString && "" === Me ? ae : (Me = null === Me ? "" : Me, 0 === ae.length ? [
                                        [Y(De, we), ve, Y(Me, we)].join("")
                                    ] : [
                                        [ae, Y(Me, we)].join(we.arrayFormatSeparator)
                                    ])
                                }
                            default:
                                return ve => (De, ae) => void 0 === ae || we.skipNull && null === ae || we.skipEmptyString && "" === ae ? De : null === ae ? [...De, Y(ve, we)] : [...De, [Y(ve, we), "=", Y(ae, we)].join("")]
                        }
                    }(ve),
                    Me = {};
                for (const L of Object.keys(we)) De(L) || (Me[L] = we[L]);
                const Le = Object.keys(Me);
                return !1 !== ve.sort && Le.sort(ve.sort), Le.map(L => {
                    const ue = we[L];
                    return void 0 === ue ? "" : null === ue ? Y(L, ve) : Array.isArray(ue) ? 0 === ue.length && "bracket-separator" === ve.arrayFormat ? Y(L, ve) + "[]" : ue.reduce(ae(L), []).join("&") : Y(L, ve) + "=" + Y(ue, ve)
                }).filter(L => L.length > 0).join("&")
            }, I.parseUrl = (we, ve) => {
                ve = Object.assign({
                    decode: !0
                }, ve);
                const [De, ae] = q(we, "#");
                return Object.assign({
                    url: De.split("?")[0] || "",
                    query: Ce(Se(we), ve)
                }, ve && ve.parseFragmentIdentifier && ae ? {
                    fragmentIdentifier: Z(ae, ve)
                } : {})
            }, I.stringifyUrl = (we, ve) => {
                ve = Object.assign({
                    encode: !0,
                    strict: !0,
                    [j]: !0
                }, ve);
                const De = re(we.url).split("?")[0] || "",
                    ae = I.extract(we.url),
                    Me = I.parse(ae, {
                        sort: !1
                    }),
                    Le = Object.assign(Me, we.query);
                let L = I.stringify(Le, ve);
                L && (L = `?${L}`);
                let ue = function de(we) {
                    let ve = "";
                    const De = we.indexOf("#");
                    return -1 !== De && (ve = we.slice(De)), ve
                }(we.url);
                return we.fragmentIdentifier && (ue = `#${ve[j]?Y(we.fragmentIdentifier,ve):we.fragmentIdentifier}`), `${De}${L}${ue}`
            }, I.pick = (we, ve, De) => {
                De = Object.assign({
                    parseFragmentIdentifier: !0,
                    [j]: !1
                }, De);
                const {
                    url: ae,
                    query: Me,
                    fragmentIdentifier: Le
                } = I.parseUrl(we, De);
                return I.stringifyUrl({
                    url: ae,
                    query: ne(Me, ve),
                    fragmentIdentifier: Le
                }, De)
            }, I.exclude = (we, ve, De) => {
                const ae = Array.isArray(ve) ? Me => !ve.includes(Me) : (Me, Le) => !ve(Me, Le);
                return I.pick(we, ae, De)
            }
        },
        20439: (et, I) => {
            "use strict";

            function T(le) {
                let re;
                return typeof window < "u" && typeof window[le] < "u" && (re = window[le]), re
            }

            function F(le) {
                const re = T(le);
                if (!re) throw new Error(`${le} is not defined in Window`);
                return re
            }
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.getLocalStorage = I.getLocalStorageOrThrow = I.getCrypto = I.getCryptoOrThrow = I.getLocation = I.getLocationOrThrow = I.getNavigator = I.getNavigatorOrThrow = I.getDocument = I.getDocumentOrThrow = I.getFromWindowOrThrow = I.getFromWindow = void 0, I.getFromWindow = T, I.getFromWindowOrThrow = F, I.getDocumentOrThrow = function K() {
                return F("document")
            }, I.getDocument = function q() {
                return T("document")
            }, I.getNavigatorOrThrow = function ne() {
                return F("navigator")
            }, I.getNavigator = function S() {
                return T("navigator")
            }, I.getLocationOrThrow = function j() {
                return F("location")
            }, I.getLocation = function C() {
                return T("location")
            }, I.getCryptoOrThrow = function z() {
                return F("crypto")
            }, I.getCrypto = function H() {
                return T("crypto")
            }, I.getLocalStorageOrThrow = function Y() {
                return F("localStorage")
            }, I.getLocalStorage = function Z() {
                return T("localStorage")
            }
        },
        66534: (et, I, T) => {
            "use strict";
            I.D = void 0;
            const K = T(20439);
            I.D = function q() {
                let ne, S;
                try {
                    ne = K.getDocumentOrThrow(), S = K.getLocationOrThrow()
                } catch {
                    return null
                }

                function C(...Se) {
                    const me = ne.getElementsByTagName("meta");
                    for (let Ce = 0; Ce < me.length; Ce++) {
                        const we = me[Ce],
                            ve = ["itemprop", "property", "name"].map(De => we.getAttribute(De)).filter(De => !!De && Se.includes(De));
                        if (ve.length && ve) {
                            const De = we.getAttribute("content");
                            if (De) return De
                        }
                    }
                    return ""
                }
                const Y = function z() {
                    let Se = C("name", "og:site_name", "og:title", "twitter:title");
                    return Se || (Se = ne.title), Se
                }();
                return {
                    description: function H() {
                        return C("description", "og:description", "twitter:description", "keywords")
                    }(),
                    url: S.origin,
                    icons: function j() {
                        const Se = ne.getElementsByTagName("link"),
                            me = [];
                        for (let Ce = 0; Ce < Se.length; Ce++) {
                            const we = Se[Ce],
                                ve = we.getAttribute("rel");
                            if (ve && ve.toLowerCase().indexOf("icon") > -1) {
                                const De = we.getAttribute("href");
                                if (De)
                                    if (-1 === De.toLowerCase().indexOf("https:") && -1 === De.toLowerCase().indexOf("http:") && 0 !== De.indexOf("//")) {
                                        let ae = S.protocol + "//" + S.host;
                                        if (0 === De.indexOf("/")) ae += De;
                                        else {
                                            const Me = S.pathname.split("/");
                                            Me.pop(), ae += Me.join("/") + "/" + De
                                        }
                                        me.push(ae)
                                    } else 0 === De.indexOf("//") ? me.push(S.protocol + De) : me.push(De)
                            }
                        }
                        return me
                    }(),
                    name: Y
                }
            }
        },
        53703: (et, I, T) => {
            "use strict";
            const F = T(94713);
            et.exports = class q {
                constructor(S) {
                    this.options = S, this.iframe = document.createElement("iframe"), this.widgetWindow = null, this.widget_layout_mode = "Modal", this.await_data = !1, this.onMessage = j => {
                        var C, z, H, Y, Z, le, re, de, Se, me, Ce, we;
                        if (j.source === this.widgetWindow && "object" == typeof j.data) switch (j.data.type) {
                            case "loaded":
                                this.sendEvent("extra", this.options.extra), null === (z = null === (C = this.options.listeners) || void 0 === C ? void 0 : C[j.data.type]) || void 0 === z || z.call(C);
                                break;
                            case "payment-status":
                                null === (Y = null === (H = this.options.listeners) || void 0 === H ? void 0 : H[j.data.type]) || void 0 === Y || Y.call(H, j.data.data);
                                break;
                            case "position":
                                null === (le = null === (Z = this.options.listeners) || void 0 === Z ? void 0 : Z[j.data.type]) || void 0 === le || le.call(Z, j.data.data);
                                break;
                            case "rate-update":
                                null === (de = null === (re = this.options.listeners) || void 0 === re ? void 0 : re[j.data.type]) || void 0 === de || de.call(re, j.data.data);
                                break;
                            case "close":
                                document.body.removeChild(this.iframe), document.body.style.overflow = "", this.unListenWidget(), null === (me = null === (Se = this.options.listeners) || void 0 === Se ? void 0 : Se[j.data.type]) || void 0 === me || me.call(Se);
                                break;
                            case "error":
                                null === (we = null === (Ce = this.options.listeners) || void 0 === Ce ? void 0 : Ce[j.data.type]) || void 0 === we || we.call(Ce, j.data.data)
                        }
                    }, this.validateOptions(S), this.options.origin || (this.options.origin = "https://widget.wert.io"), this.options.extra && (this.await_data = !0)
                }
                open() {
                    this.iframe.style.border = "none", this.iframe.style.width = "100%", this.iframe.style.height = "100%", this.iframe.style.bottom = "0", this.iframe.style.right = "0", this.iframe.style.position = "fixed", this.iframe.style.zIndex = "10000", document.body.style.overflow = "hidden", this.iframe.setAttribute("src", this.getEmbedUrl()), this.iframe.setAttribute("allow", "camera *; microphone *"), this.iframe.setAttribute("sandbox", "allow-scripts allow-forms allow-popups allow-same-origin"), document.body.appendChild(this.iframe), this.widgetWindow = this.iframe.contentWindow, this.listenWidget()
                }
                addEventListeners(S) {
                    this.options.listeners = Object.assign(Object.assign({}, this.options.listeners), S)
                }
                removeEventListeners(S) {
                    var j, C;
                    if (typeof S > "u") delete this.options.listeners;
                    else if ("string" == typeof S) null === (j = this.options.listeners) || void 0 === j || delete j[S];
                    else
                        for (const z of S) null === (C = this.options.listeners) || void 0 === C || delete C[z]
                }
                updateTheme(S) {
                    !S || !Object.keys(S).length || this.sendEvent("theme", S)
                }
                validateOptions(S) {
                    var j, C, z, H;
                    if (!S.partner_id) throw Error("Please provide a partner_id in order for the widget to work correctly");
                    S.container_id && console.error("container_id is no longer supported"), !(null === (C = null === (j = S.extra) || void 0 === j ? void 0 : j.item_info) || void 0 === C) && C.name && S.extra.item_info.name.length > 40 && console.error("Max length of the extra.item_info.name value is 40 characters"), null !== (H = null === (z = S.extra) || void 0 === z ? void 0 : z.item_info) && void 0 !== H && H.category && S.extra.item_info.category.length > 40 && console.error("Max length of the extra.item_info.category value is 40 characters")
                }
                listenWidget() {
                    window.addEventListener("message", this.onMessage), this.checkIntervalId = window.setInterval(() => {
                        this.widgetWindow && !this.widgetWindow.closed || this.unListenWidget()
                    }, 200)
                }
                unListenWidget() {
                    this.checkIntervalId && (clearInterval(this.checkIntervalId), this.checkIntervalId = void 0, window.removeEventListener("message", this.onMessage))
                }
                sendEvent(S, j) {
                    var C;
                    j && (null === (C = this.widgetWindow) || void 0 === C || C.postMessage({
                        data: j,
                        type: S
                    }, this.options.origin))
                }
                getEmbedCode() {
                    const C = "<\/script>";
                    return `<script type="text/javascript" src="https://javascript.wert.io/wert-${F.version}.js">` + C + '\n<script type="text/javascript">\n' + `const wertWidget = new WertWidget(${JSON.stringify(this.options,null,2)});\nwertWidget.open();\n` + C
                }
                getEmbedUrl() {
                    const S = this.getParametersString();
                    return `${this.options.origin}/${this.options.partner_id}/widget${S}`
                }
                getParametersString() {
                    return Object.entries(Object.assign(Object.assign(Object.assign({}, this.options), {
                        widget_layout_mode: this.widget_layout_mode
                    }), this.await_data && {
                        await_data: this.await_data
                    })).reduce((S, [j, C]) => void 0 === C || "object" == typeof C || ["origin", "partner_id"].includes(j) ? S : S + (S.length ? "&" : "?") + j + "=" + encodeURIComponent(C), "")
                }
            }
        },
        95026: (et, I, T) => {
            "use strict";
            var F = T(843).Buffer;
            et.exports = function K(q) {
                if (q.length >= 255) throw new TypeError("Alphabet too long");
                for (var ne = new Uint8Array(256), S = 0; S < ne.length; S++) ne[S] = 255;
                for (var j = 0; j < q.length; j++) {
                    var C = q.charAt(j),
                        z = C.charCodeAt(0);
                    if (255 !== ne[z]) throw new TypeError(C + " is ambiguous");
                    ne[z] = j
                }
                var H = q.length,
                    Y = q.charAt(0),
                    Z = Math.log(H) / Math.log(256),
                    le = Math.log(256) / Math.log(H);

                function de(me) {
                    if ("string" != typeof me) throw new TypeError("Expected String");
                    if (0 === me.length) return F.alloc(0);
                    for (var Ce = 0, we = 0, ve = 0; me[Ce] === Y;) we++, Ce++;
                    for (var De = (me.length - Ce) * Z + 1 >>> 0, ae = new Uint8Array(De); me[Ce];) {
                        var Me = ne[me.charCodeAt(Ce)];
                        if (255 === Me) return;
                        for (var Le = 0, L = De - 1;
                            (0 !== Me || Le < ve) && -1 !== L; L--, Le++) ae[L] = (Me += H * ae[L] >>> 0) % 256 >>> 0, Me = Me / 256 >>> 0;
                        if (0 !== Me) throw new Error("Non-zero carry");
                        ve = Le, Ce++
                    }
                    for (var ue = De - ve; ue !== De && 0 === ae[ue];) ue++;
                    var Te = F.allocUnsafe(we + (De - ue));
                    Te.fill(0, 0, we);
                    for (var xe = we; ue !== De;) Te[xe++] = ae[ue++];
                    return Te
                }
                return {
                    encode: function re(me) {
                        if ((Array.isArray(me) || me instanceof Uint8Array) && (me = F.from(me)), !F.isBuffer(me)) throw new TypeError("Expected Buffer");
                        if (0 === me.length) return "";
                        for (var Ce = 0, we = 0, ve = 0, De = me.length; ve !== De && 0 === me[ve];) ve++, Ce++;
                        for (var ae = (De - ve) * le + 1 >>> 0, Me = new Uint8Array(ae); ve !== De;) {
                            for (var Le = me[ve], L = 0, ue = ae - 1;
                                (0 !== Le || L < we) && -1 !== ue; ue--, L++) Me[ue] = (Le += 256 * Me[ue] >>> 0) % H >>> 0, Le = Le / H >>> 0;
                            if (0 !== Le) throw new Error("Non-zero carry");
                            we = L, ve++
                        }
                        for (var Te = ae - we; Te !== ae && 0 === Me[Te];) Te++;
                        for (var xe = Y.repeat(Ce); Te < ae; ++Te) xe += q.charAt(Me[Te]);
                        return xe
                    },
                    decodeUnsafe: de,
                    decode: function Se(me) {
                        var Ce = de(me);
                        if (Ce) return Ce;
                        throw new Error("Non-base" + H + " character")
                    }
                }
            }
        },
        9919: (et, I) => {
            "use strict";
            I.byteLength = function C(re) {
                var de = j(re),
                    me = de[1];
                return 3 * (de[0] + me) / 4 - me
            }, I.toByteArray = function H(re) {
                var de, ae, Se = j(re),
                    me = Se[0],
                    Ce = Se[1],
                    we = new K(function z(re, de, Se) {
                        return 3 * (de + Se) / 4 - Se
                    }(0, me, Ce)),
                    ve = 0,
                    De = Ce > 0 ? me - 4 : me;
                for (ae = 0; ae < De; ae += 4) de = F[re.charCodeAt(ae)] << 18 | F[re.charCodeAt(ae + 1)] << 12 | F[re.charCodeAt(ae + 2)] << 6 | F[re.charCodeAt(ae + 3)], we[ve++] = de >> 16 & 255, we[ve++] = de >> 8 & 255, we[ve++] = 255 & de;
                return 2 === Ce && (de = F[re.charCodeAt(ae)] << 2 | F[re.charCodeAt(ae + 1)] >> 4, we[ve++] = 255 & de), 1 === Ce && (de = F[re.charCodeAt(ae)] << 10 | F[re.charCodeAt(ae + 1)] << 4 | F[re.charCodeAt(ae + 2)] >> 2, we[ve++] = de >> 8 & 255, we[ve++] = 255 & de), we
            }, I.fromByteArray = function le(re) {
                for (var de, Se = re.length, me = Se % 3, Ce = [], ve = 0, De = Se - me; ve < De; ve += 16383) Ce.push(Z(re, ve, ve + 16383 > De ? De : ve + 16383));
                return 1 === me ? Ce.push(T[(de = re[Se - 1]) >> 2] + T[de << 4 & 63] + "==") : 2 === me && Ce.push(T[(de = (re[Se - 2] << 8) + re[Se - 1]) >> 10] + T[de >> 4 & 63] + T[de << 2 & 63] + "="), Ce.join("")
            };
            for (var T = [], F = [], K = typeof Uint8Array < "u" ? Uint8Array : Array, q = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ne = 0; ne < 64; ++ne) T[ne] = q[ne], F[q.charCodeAt(ne)] = ne;

            function j(re) {
                var de = re.length;
                if (de % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var Se = re.indexOf("=");
                return -1 === Se && (Se = de), [Se, Se === de ? 0 : 4 - Se % 4]
            }

            function Y(re) {
                return T[re >> 18 & 63] + T[re >> 12 & 63] + T[re >> 6 & 63] + T[63 & re]
            }

            function Z(re, de, Se) {
                for (var Ce = [], we = de; we < Se; we += 3) Ce.push(Y((re[we] << 16 & 16711680) + (re[we + 1] << 8 & 65280) + (255 & re[we + 2])));
                return Ce.join("")
            }
            F["-".charCodeAt(0)] = 62, F["_".charCodeAt(0)] = 63
        },
        49347: (et, I) => {
            "use strict";
            I.oU = function K(j) {
                {
                    const C = Buffer.from(j);
                    C.reverse();
                    const z = C.toString("hex");
                    return 0 === z.length ? BigInt(0) : BigInt(`0x${z}`)
                }
            }, I.k$ = function ne(j, C) {
                {
                    const z = j.toString(16),
                        H = Buffer.from(z.padStart(2 * C, "0").slice(0, 2 * C), "hex");
                    return H.reverse(), H
                }
            }
        },
        62662: function(et, I, T) {
            ! function(F, K) {
                "use strict";

                function q($, f) {
                    if (!$) throw new Error(f || "Assertion failed")
                }

                function ne($, f) {
                    $.super_ = f;
                    var v = function() {};
                    v.prototype = f.prototype, $.prototype = new v, $.prototype.constructor = $
                }

                function S($, f, v) {
                    if (S.isBN($)) return $;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== $ && (("le" === f || "be" === f) && (v = f, f = 10), this._init($ || 0, f || 10, v || "be"))
                }
                var j;
                "object" == typeof F ? F.exports = S : K.BN = S, S.BN = S, S.wordSize = 26;
                try {
                    j = typeof window < "u" && typeof window.Buffer < "u" ? window.Buffer : T(46601).Buffer
                } catch {}

                function C($, f) {
                    var v = $.charCodeAt(f);
                    return v >= 48 && v <= 57 ? v - 48 : v >= 65 && v <= 70 ? v - 55 : v >= 97 && v <= 102 ? v - 87 : void q(!1, "Invalid character in " + $)
                }

                function z($, f, v) {
                    var M = C($, v);
                    return v - 1 >= f && (M |= C($, v - 1) << 4), M
                }

                function H($, f, v, M) {
                    for (var U = 0, G = 0, y = Math.min($.length, v), E = f; E < y; E++) {
                        var A = $.charCodeAt(E) - 48;
                        U *= M, G = A >= 49 ? A - 49 + 10 : A >= 17 ? A - 17 + 10 : A, q(A >= 0 && G < M, "Invalid character"), U += G
                    }
                    return U
                }

                function Y($, f) {
                    $.words = f.words, $.length = f.length, $.negative = f.negative, $.red = f.red
                }
                if (S.isBN = function(f) {
                        return f instanceof S || null !== f && "object" == typeof f && f.constructor.wordSize === S.wordSize && Array.isArray(f.words)
                    }, S.max = function(f, v) {
                        return f.cmp(v) > 0 ? f : v
                    }, S.min = function(f, v) {
                        return f.cmp(v) < 0 ? f : v
                    }, S.prototype._init = function(f, v, M) {
                        if ("number" == typeof f) return this._initNumber(f, v, M);
                        if ("object" == typeof f) return this._initArray(f, v, M);
                        "hex" === v && (v = 16), q(v === (0 | v) && v >= 2 && v <= 36);
                        var U = 0;
                        "-" === (f = f.toString().replace(/\s+/g, ""))[0] && (U++, this.negative = 1), U < f.length && (16 === v ? this._parseHex(f, U, M) : (this._parseBase(f, v, U), "le" === M && this._initArray(this.toArray(), v, M)))
                    }, S.prototype._initNumber = function(f, v, M) {
                        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [67108863 & f], this.length = 1) : f < 4503599627370496 ? (this.words = [67108863 & f, f / 67108864 & 67108863], this.length = 2) : (q(f < 9007199254740992), this.words = [67108863 & f, f / 67108864 & 67108863, 1], this.length = 3), "le" === M && this._initArray(this.toArray(), v, M)
                    }, S.prototype._initArray = function(f, v, M) {
                        if (q("number" == typeof f.length), f.length <= 0) return this.words = [0], this.length = 1, this;
                        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
                        for (var U = 0; U < this.length; U++) this.words[U] = 0;
                        var G, y, E = 0;
                        if ("be" === M)
                            for (U = f.length - 1, G = 0; U >= 0; U -= 3) this.words[G] |= (y = f[U] | f[U - 1] << 8 | f[U - 2] << 16) << E & 67108863, this.words[G + 1] = y >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, G++);
                        else if ("le" === M)
                            for (U = 0, G = 0; U < f.length; U += 3) this.words[G] |= (y = f[U] | f[U + 1] << 8 | f[U + 2] << 16) << E & 67108863, this.words[G + 1] = y >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, G++);
                        return this._strip()
                    }, S.prototype._parseHex = function(f, v, M) {
                        this.length = Math.ceil((f.length - v) / 6), this.words = new Array(this.length);
                        for (var U = 0; U < this.length; U++) this.words[U] = 0;
                        var E, G = 0,
                            y = 0;
                        if ("be" === M)
                            for (U = f.length - 1; U >= v; U -= 2) E = z(f, v, U) << G, this.words[y] |= 67108863 & E, G >= 18 ? (G -= 18, this.words[y += 1] |= E >>> 26) : G += 8;
                        else
                            for (U = (f.length - v) % 2 == 0 ? v + 1 : v; U < f.length; U += 2) E = z(f, v, U) << G, this.words[y] |= 67108863 & E, G >= 18 ? (G -= 18, this.words[y += 1] |= E >>> 26) : G += 8;
                        this._strip()
                    }, S.prototype._parseBase = function(f, v, M) {
                        this.words = [0], this.length = 1;
                        for (var U = 0, G = 1; G <= 67108863; G *= v) U++;
                        U--, G = G / v | 0;
                        for (var y = f.length - M, E = y % U, A = Math.min(y, y - E) + M, b = 0, N = M; N < A; N += U) b = H(f, N, N + U, v), this.imuln(G), this.words[0] + b < 67108864 ? this.words[0] += b : this._iaddn(b);
                        if (0 !== E) {
                            var R = 1;
                            for (b = H(f, N, f.length, v), N = 0; N < E; N++) R *= v;
                            this.imuln(R), this.words[0] + b < 67108864 ? this.words[0] += b : this._iaddn(b)
                        }
                        this._strip()
                    }, S.prototype.copy = function(f) {
                        f.words = new Array(this.length);
                        for (var v = 0; v < this.length; v++) f.words[v] = this.words[v];
                        f.length = this.length, f.negative = this.negative, f.red = this.red
                    }, S.prototype._move = function(f) {
                        Y(f, this)
                    }, S.prototype.clone = function() {
                        var f = new S(null);
                        return this.copy(f), f
                    }, S.prototype._expand = function(f) {
                        for (; this.length < f;) this.words[this.length++] = 0;
                        return this
                    }, S.prototype._strip = function() {
                        for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
                        return this._normSign()
                    }, S.prototype._normSign = function() {
                        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                    }, typeof Symbol < "u" && "function" == typeof Symbol.for) try {
                    S.prototype[Symbol.for("nodejs.util.inspect.custom")] = Z
                } catch {
                    S.prototype.inspect = Z
                } else S.prototype.inspect = Z;

                function Z() {
                    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                }
                var le = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                    re = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                    de = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

                function Ce($, f, v) {
                    v.negative = f.negative ^ $.negative;
                    var M = $.length + f.length | 0;
                    v.length = M, M = M - 1 | 0;
                    var U = 0 | $.words[0],
                        G = 0 | f.words[0],
                        y = U * G,
                        A = y / 67108864 | 0;
                    v.words[0] = 67108863 & y;
                    for (var b = 1; b < M; b++) {
                        for (var N = A >>> 26, R = 67108863 & A, Q = Math.min(b, f.length - 1), Ee = Math.max(0, b - $.length + 1); Ee <= Q; Ee++) N += (y = (U = 0 | $.words[b - Ee | 0]) * (G = 0 | f.words[Ee]) + R) / 67108864 | 0, R = 67108863 & y;
                        v.words[b] = 0 | R, A = 0 | N
                    }
                    return 0 !== A ? v.words[b] = 0 | A : v.length--, v._strip()
                }
                S.prototype.toString = function(f, v) {
                    var M;
                    if (v = 0 | v || 1, 16 === (f = f || 10) || "hex" === f) {
                        M = "";
                        for (var U = 0, G = 0, y = 0; y < this.length; y++) {
                            var E = this.words[y],
                                A = (16777215 & (E << U | G)).toString(16);
                            G = E >>> 24 - U & 16777215, (U += 2) >= 26 && (U -= 26, y--), M = 0 !== G || y !== this.length - 1 ? le[6 - A.length] + A + M : A + M
                        }
                        for (0 !== G && (M = G.toString(16) + M); M.length % v != 0;) M = "0" + M;
                        return 0 !== this.negative && (M = "-" + M), M
                    }
                    if (f === (0 | f) && f >= 2 && f <= 36) {
                        var b = re[f],
                            N = de[f];
                        M = "";
                        var R = this.clone();
                        for (R.negative = 0; !R.isZero();) {
                            var Q = R.modrn(N).toString(f);
                            M = (R = R.idivn(N)).isZero() ? Q + M : le[b - Q.length] + Q + M
                        }
                        for (this.isZero() && (M = "0" + M); M.length % v != 0;) M = "0" + M;
                        return 0 !== this.negative && (M = "-" + M), M
                    }
                    q(!1, "Base should be between 2 and 36")
                }, S.prototype.toNumber = function() {
                    var f = this.words[0];
                    return 2 === this.length ? f += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? f += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && q(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -f : f
                }, S.prototype.toJSON = function() {
                    return this.toString(16, 2)
                }, j && (S.prototype.toBuffer = function(f, v) {
                    return this.toArrayLike(j, f, v)
                }), S.prototype.toArray = function(f, v) {
                    return this.toArrayLike(Array, f, v)
                }, S.prototype.toArrayLike = function(f, v, M) {
                    this._strip();
                    var U = this.byteLength(),
                        G = M || Math.max(1, U);
                    q(U <= G, "byte array longer than desired length"), q(G > 0, "Requested array length <= 0");
                    var y = function(f, v) {
                        return f.allocUnsafe ? f.allocUnsafe(v) : new f(v)
                    }(f, G);
                    return this["_toArrayLike" + ("le" === v ? "LE" : "BE")](y, U), y
                }, S.prototype._toArrayLikeLE = function(f, v) {
                    for (var M = 0, U = 0, G = 0, y = 0; G < this.length; G++) {
                        var E = this.words[G] << y | U;
                        f[M++] = 255 & E, M < f.length && (f[M++] = E >> 8 & 255), M < f.length && (f[M++] = E >> 16 & 255), 6 === y ? (M < f.length && (f[M++] = E >> 24 & 255), U = 0, y = 0) : (U = E >>> 24, y += 2)
                    }
                    if (M < f.length)
                        for (f[M++] = U; M < f.length;) f[M++] = 0
                }, S.prototype._toArrayLikeBE = function(f, v) {
                    for (var M = f.length - 1, U = 0, G = 0, y = 0; G < this.length; G++) {
                        var E = this.words[G] << y | U;
                        f[M--] = 255 & E, M >= 0 && (f[M--] = E >> 8 & 255), M >= 0 && (f[M--] = E >> 16 & 255), 6 === y ? (M >= 0 && (f[M--] = E >> 24 & 255), U = 0, y = 0) : (U = E >>> 24, y += 2)
                    }
                    if (M >= 0)
                        for (f[M--] = U; M >= 0;) f[M--] = 0
                }, S.prototype._countBits = Math.clz32 ? function(f) {
                    return 32 - Math.clz32(f)
                } : function(f) {
                    var v = f,
                        M = 0;
                    return v >= 4096 && (M += 13, v >>>= 13), v >= 64 && (M += 7, v >>>= 7), v >= 8 && (M += 4, v >>>= 4), v >= 2 && (M += 2, v >>>= 2), M + v
                }, S.prototype._zeroBits = function(f) {
                    if (0 === f) return 26;
                    var v = f,
                        M = 0;
                    return 8191 & v || (M += 13, v >>>= 13), 127 & v || (M += 7, v >>>= 7), 15 & v || (M += 4, v >>>= 4), 3 & v || (M += 2, v >>>= 2), 1 & v || M++, M
                }, S.prototype.bitLength = function() {
                    var v = this._countBits(this.words[this.length - 1]);
                    return 26 * (this.length - 1) + v
                }, S.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for (var f = 0, v = 0; v < this.length; v++) {
                        var M = this._zeroBits(this.words[v]);
                        if (f += M, 26 !== M) break
                    }
                    return f
                }, S.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8)
                }, S.prototype.toTwos = function(f) {
                    return 0 !== this.negative ? this.abs().inotn(f).iaddn(1) : this.clone()
                }, S.prototype.fromTwos = function(f) {
                    return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone()
                }, S.prototype.isNeg = function() {
                    return 0 !== this.negative
                }, S.prototype.neg = function() {
                    return this.clone().ineg()
                }, S.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this
                }, S.prototype.iuor = function(f) {
                    for (; this.length < f.length;) this.words[this.length++] = 0;
                    for (var v = 0; v < f.length; v++) this.words[v] = this.words[v] | f.words[v];
                    return this._strip()
                }, S.prototype.ior = function(f) {
                    return q(0 == (this.negative | f.negative)), this.iuor(f)
                }, S.prototype.or = function(f) {
                    return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this)
                }, S.prototype.uor = function(f) {
                    return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this)
                }, S.prototype.iuand = function(f) {
                    var v;
                    v = this.length > f.length ? f : this;
                    for (var M = 0; M < v.length; M++) this.words[M] = this.words[M] & f.words[M];
                    return this.length = v.length, this._strip()
                }, S.prototype.iand = function(f) {
                    return q(0 == (this.negative | f.negative)), this.iuand(f)
                }, S.prototype.and = function(f) {
                    return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this)
                }, S.prototype.uand = function(f) {
                    return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this)
                }, S.prototype.iuxor = function(f) {
                    var v, M;
                    this.length > f.length ? (v = this, M = f) : (v = f, M = this);
                    for (var U = 0; U < M.length; U++) this.words[U] = v.words[U] ^ M.words[U];
                    if (this !== v)
                        for (; U < v.length; U++) this.words[U] = v.words[U];
                    return this.length = v.length, this._strip()
                }, S.prototype.ixor = function(f) {
                    return q(0 == (this.negative | f.negative)), this.iuxor(f)
                }, S.prototype.xor = function(f) {
                    return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this)
                }, S.prototype.uxor = function(f) {
                    return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this)
                }, S.prototype.inotn = function(f) {
                    q("number" == typeof f && f >= 0);
                    var v = 0 | Math.ceil(f / 26),
                        M = f % 26;
                    this._expand(v), M > 0 && v--;
                    for (var U = 0; U < v; U++) this.words[U] = 67108863 & ~this.words[U];
                    return M > 0 && (this.words[U] = ~this.words[U] & 67108863 >> 26 - M), this._strip()
                }, S.prototype.notn = function(f) {
                    return this.clone().inotn(f)
                }, S.prototype.setn = function(f, v) {
                    q("number" == typeof f && f >= 0);
                    var M = f / 26 | 0,
                        U = f % 26;
                    return this._expand(M + 1), this.words[M] = v ? this.words[M] | 1 << U : this.words[M] & ~(1 << U), this._strip()
                }, S.prototype.iadd = function(f) {
                    var v, M, U;
                    if (0 !== this.negative && 0 === f.negative) return this.negative = 0, v = this.isub(f), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== f.negative) return f.negative = 0, v = this.isub(f), f.negative = 1, v._normSign();
                    this.length > f.length ? (M = this, U = f) : (M = f, U = this);
                    for (var G = 0, y = 0; y < U.length; y++) this.words[y] = 67108863 & (v = (0 | M.words[y]) + (0 | U.words[y]) + G), G = v >>> 26;
                    for (; 0 !== G && y < M.length; y++) this.words[y] = 67108863 & (v = (0 | M.words[y]) + G), G = v >>> 26;
                    if (this.length = M.length, 0 !== G) this.words[this.length] = G, this.length++;
                    else if (M !== this)
                        for (; y < M.length; y++) this.words[y] = M.words[y];
                    return this
                }, S.prototype.add = function(f) {
                    var v;
                    return 0 !== f.negative && 0 === this.negative ? (f.negative = 0, v = this.sub(f), f.negative ^= 1, v) : 0 === f.negative && 0 !== this.negative ? (this.negative = 0, v = f.sub(this), this.negative = 1, v) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this)
                }, S.prototype.isub = function(f) {
                    if (0 !== f.negative) {
                        f.negative = 0;
                        var v = this.iadd(f);
                        return f.negative = 1, v._normSign()
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
                    var U, G, M = this.cmp(f);
                    if (0 === M) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    M > 0 ? (U = this, G = f) : (U = f, G = this);
                    for (var y = 0, E = 0; E < G.length; E++) y = (v = (0 | U.words[E]) - (0 | G.words[E]) + y) >> 26, this.words[E] = 67108863 & v;
                    for (; 0 !== y && E < U.length; E++) y = (v = (0 | U.words[E]) + y) >> 26, this.words[E] = 67108863 & v;
                    if (0 === y && E < U.length && U !== this)
                        for (; E < U.length; E++) this.words[E] = U.words[E];
                    return this.length = Math.max(this.length, E), U !== this && (this.negative = 1), this._strip()
                }, S.prototype.sub = function(f) {
                    return this.clone().isub(f)
                };
                var we = function(f, v, M) {
                    var A, b, N, U = f.words,
                        G = v.words,
                        y = M.words,
                        E = 0,
                        R = 0 | U[0],
                        Q = 8191 & R,
                        Ee = R >>> 13,
                        Fe = 0 | U[1],
                        Ge = 8191 & Fe,
                        wt = Fe >>> 13,
                        Vt = 0 | U[2],
                        Mt = 8191 & Vt,
                        sn = Vt >>> 13,
                        ei = 0 | U[3],
                        ai = 8191 & ei,
                        jn = ei >>> 13,
                        An = 0 | U[4],
                        ui = 8191 & An,
                        Mi = An >>> 13,
                        ji = 0 | U[5],
                        Wn = 8191 & ji,
                        kn = ji >>> 13,
                        Bi = 0 | U[6],
                        ci = 8191 & Bi,
                        en = Bi >>> 13,
                        Ii = 0 | U[7],
                        pe = 8191 & Ii,
                        O = Ii >>> 13,
                        W = 0 | U[8],
                        ke = 8191 & W,
                        je = W >>> 13,
                        Qe = 0 | U[9],
                        st = 8191 & Qe,
                        tn = Qe >>> 13,
                        Kn = 0 | G[0],
                        mn = 8191 & Kn,
                        $n = Kn >>> 13,
                        _n = 0 | G[1],
                        Sn = 8191 & _n,
                        pi = _n >>> 13,
                        ca = 0 | G[2],
                        yi = 8191 & ca,
                        hr = ca >>> 13,
                        qo = 0 | G[3],
                        yr = 8191 & qo,
                        Rn = qo >>> 13,
                        Ti = 0 | G[4],
                        Ji = 8191 & Ti,
                        gn = Ti >>> 13,
                        Si = 0 | G[5],
                        qn = 8191 & Si,
                        Ve = Si >>> 13,
                        at = 0 | G[6],
                        pt = 8191 & at,
                        St = at >>> 13,
                        Bn = 0 | G[7],
                        Nn = 8191 & Bn,
                        Ut = Bn >>> 13,
                        or = 0 | G[8],
                        ti = 8191 & or,
                        qi = or >>> 13,
                        Xs = 0 | G[9],
                        Xn = 8191 & Xs,
                        an = Xs >>> 13;
                    M.negative = f.negative ^ v.negative, M.length = 19;
                    var As = (E + (A = Math.imul(Q, mn)) | 0) + ((8191 & (b = (b = Math.imul(Q, $n)) + Math.imul(Ee, mn) | 0)) << 13) | 0;
                    E = ((N = Math.imul(Ee, $n)) + (b >>> 13) | 0) + (As >>> 26) | 0, As &= 67108863, A = Math.imul(Ge, mn), b = (b = Math.imul(Ge, $n)) + Math.imul(wt, mn) | 0, N = Math.imul(wt, $n);
                    var wo = (E + (A = A + Math.imul(Q, Sn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, pi) | 0) + Math.imul(Ee, Sn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, pi) | 0) + (b >>> 13) | 0) + (wo >>> 26) | 0, wo &= 67108863, A = Math.imul(Mt, mn), b = (b = Math.imul(Mt, $n)) + Math.imul(sn, mn) | 0, N = Math.imul(sn, $n), A = A + Math.imul(Ge, Sn) | 0, b = (b = b + Math.imul(Ge, pi) | 0) + Math.imul(wt, Sn) | 0, N = N + Math.imul(wt, pi) | 0;
                    var Dc = (E + (A = A + Math.imul(Q, yi) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, hr) | 0) + Math.imul(Ee, yi) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, hr) | 0) + (b >>> 13) | 0) + (Dc >>> 26) | 0, Dc &= 67108863, A = Math.imul(ai, mn), b = (b = Math.imul(ai, $n)) + Math.imul(jn, mn) | 0, N = Math.imul(jn, $n), A = A + Math.imul(Mt, Sn) | 0, b = (b = b + Math.imul(Mt, pi) | 0) + Math.imul(sn, Sn) | 0, N = N + Math.imul(sn, pi) | 0, A = A + Math.imul(Ge, yi) | 0, b = (b = b + Math.imul(Ge, hr) | 0) + Math.imul(wt, yi) | 0, N = N + Math.imul(wt, hr) | 0;
                    var Wr = (E + (A = A + Math.imul(Q, yr) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, Rn) | 0) + Math.imul(Ee, yr) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, Rn) | 0) + (b >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, A = Math.imul(ui, mn), b = (b = Math.imul(ui, $n)) + Math.imul(Mi, mn) | 0, N = Math.imul(Mi, $n), A = A + Math.imul(ai, Sn) | 0, b = (b = b + Math.imul(ai, pi) | 0) + Math.imul(jn, Sn) | 0, N = N + Math.imul(jn, pi) | 0, A = A + Math.imul(Mt, yi) | 0, b = (b = b + Math.imul(Mt, hr) | 0) + Math.imul(sn, yi) | 0, N = N + Math.imul(sn, hr) | 0, A = A + Math.imul(Ge, yr) | 0, b = (b = b + Math.imul(Ge, Rn) | 0) + Math.imul(wt, yr) | 0, N = N + Math.imul(wt, Rn) | 0;
                    var mt = (E + (A = A + Math.imul(Q, Ji) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, gn) | 0) + Math.imul(Ee, Ji) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, gn) | 0) + (b >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, A = Math.imul(Wn, mn), b = (b = Math.imul(Wn, $n)) + Math.imul(kn, mn) | 0, N = Math.imul(kn, $n), A = A + Math.imul(ui, Sn) | 0, b = (b = b + Math.imul(ui, pi) | 0) + Math.imul(Mi, Sn) | 0, N = N + Math.imul(Mi, pi) | 0, A = A + Math.imul(ai, yi) | 0, b = (b = b + Math.imul(ai, hr) | 0) + Math.imul(jn, yi) | 0, N = N + Math.imul(jn, hr) | 0, A = A + Math.imul(Mt, yr) | 0, b = (b = b + Math.imul(Mt, Rn) | 0) + Math.imul(sn, yr) | 0, N = N + Math.imul(sn, Rn) | 0, A = A + Math.imul(Ge, Ji) | 0, b = (b = b + Math.imul(Ge, gn) | 0) + Math.imul(wt, Ji) | 0, N = N + Math.imul(wt, gn) | 0;
                    var xo = (E + (A = A + Math.imul(Q, qn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, Ve) | 0) + Math.imul(Ee, qn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, Ve) | 0) + (b >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, A = Math.imul(ci, mn), b = (b = Math.imul(ci, $n)) + Math.imul(en, mn) | 0, N = Math.imul(en, $n), A = A + Math.imul(Wn, Sn) | 0, b = (b = b + Math.imul(Wn, pi) | 0) + Math.imul(kn, Sn) | 0, N = N + Math.imul(kn, pi) | 0, A = A + Math.imul(ui, yi) | 0, b = (b = b + Math.imul(ui, hr) | 0) + Math.imul(Mi, yi) | 0, N = N + Math.imul(Mi, hr) | 0, A = A + Math.imul(ai, yr) | 0, b = (b = b + Math.imul(ai, Rn) | 0) + Math.imul(jn, yr) | 0, N = N + Math.imul(jn, Rn) | 0, A = A + Math.imul(Mt, Ji) | 0, b = (b = b + Math.imul(Mt, gn) | 0) + Math.imul(sn, Ji) | 0, N = N + Math.imul(sn, gn) | 0, A = A + Math.imul(Ge, qn) | 0, b = (b = b + Math.imul(Ge, Ve) | 0) + Math.imul(wt, qn) | 0, N = N + Math.imul(wt, Ve) | 0;
                    var Zn = (E + (A = A + Math.imul(Q, pt) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, St) | 0) + Math.imul(Ee, pt) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, St) | 0) + (b >>> 13) | 0) + (Zn >>> 26) | 0, Zn &= 67108863, A = Math.imul(pe, mn), b = (b = Math.imul(pe, $n)) + Math.imul(O, mn) | 0, N = Math.imul(O, $n), A = A + Math.imul(ci, Sn) | 0, b = (b = b + Math.imul(ci, pi) | 0) + Math.imul(en, Sn) | 0, N = N + Math.imul(en, pi) | 0, A = A + Math.imul(Wn, yi) | 0, b = (b = b + Math.imul(Wn, hr) | 0) + Math.imul(kn, yi) | 0, N = N + Math.imul(kn, hr) | 0, A = A + Math.imul(ui, yr) | 0, b = (b = b + Math.imul(ui, Rn) | 0) + Math.imul(Mi, yr) | 0, N = N + Math.imul(Mi, Rn) | 0, A = A + Math.imul(ai, Ji) | 0, b = (b = b + Math.imul(ai, gn) | 0) + Math.imul(jn, Ji) | 0, N = N + Math.imul(jn, gn) | 0, A = A + Math.imul(Mt, qn) | 0, b = (b = b + Math.imul(Mt, Ve) | 0) + Math.imul(sn, qn) | 0, N = N + Math.imul(sn, Ve) | 0, A = A + Math.imul(Ge, pt) | 0, b = (b = b + Math.imul(Ge, St) | 0) + Math.imul(wt, pt) | 0, N = N + Math.imul(wt, St) | 0;
                    var di = (E + (A = A + Math.imul(Q, Nn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, Ut) | 0) + Math.imul(Ee, Nn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, Ut) | 0) + (b >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, A = Math.imul(ke, mn), b = (b = Math.imul(ke, $n)) + Math.imul(je, mn) | 0, N = Math.imul(je, $n), A = A + Math.imul(pe, Sn) | 0, b = (b = b + Math.imul(pe, pi) | 0) + Math.imul(O, Sn) | 0, N = N + Math.imul(O, pi) | 0, A = A + Math.imul(ci, yi) | 0, b = (b = b + Math.imul(ci, hr) | 0) + Math.imul(en, yi) | 0, N = N + Math.imul(en, hr) | 0, A = A + Math.imul(Wn, yr) | 0, b = (b = b + Math.imul(Wn, Rn) | 0) + Math.imul(kn, yr) | 0, N = N + Math.imul(kn, Rn) | 0, A = A + Math.imul(ui, Ji) | 0, b = (b = b + Math.imul(ui, gn) | 0) + Math.imul(Mi, Ji) | 0, N = N + Math.imul(Mi, gn) | 0, A = A + Math.imul(ai, qn) | 0, b = (b = b + Math.imul(ai, Ve) | 0) + Math.imul(jn, qn) | 0, N = N + Math.imul(jn, Ve) | 0, A = A + Math.imul(Mt, pt) | 0, b = (b = b + Math.imul(Mt, St) | 0) + Math.imul(sn, pt) | 0, N = N + Math.imul(sn, St) | 0, A = A + Math.imul(Ge, Nn) | 0, b = (b = b + Math.imul(Ge, Ut) | 0) + Math.imul(wt, Nn) | 0, N = N + Math.imul(wt, Ut) | 0;
                    var Nr = (E + (A = A + Math.imul(Q, ti) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, qi) | 0) + Math.imul(Ee, ti) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, qi) | 0) + (b >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, A = Math.imul(st, mn), b = (b = Math.imul(st, $n)) + Math.imul(tn, mn) | 0, N = Math.imul(tn, $n), A = A + Math.imul(ke, Sn) | 0, b = (b = b + Math.imul(ke, pi) | 0) + Math.imul(je, Sn) | 0, N = N + Math.imul(je, pi) | 0, A = A + Math.imul(pe, yi) | 0, b = (b = b + Math.imul(pe, hr) | 0) + Math.imul(O, yi) | 0, N = N + Math.imul(O, hr) | 0, A = A + Math.imul(ci, yr) | 0, b = (b = b + Math.imul(ci, Rn) | 0) + Math.imul(en, yr) | 0, N = N + Math.imul(en, Rn) | 0, A = A + Math.imul(Wn, Ji) | 0, b = (b = b + Math.imul(Wn, gn) | 0) + Math.imul(kn, Ji) | 0, N = N + Math.imul(kn, gn) | 0, A = A + Math.imul(ui, qn) | 0, b = (b = b + Math.imul(ui, Ve) | 0) + Math.imul(Mi, qn) | 0, N = N + Math.imul(Mi, Ve) | 0, A = A + Math.imul(ai, pt) | 0, b = (b = b + Math.imul(ai, St) | 0) + Math.imul(jn, pt) | 0, N = N + Math.imul(jn, St) | 0, A = A + Math.imul(Mt, Nn) | 0, b = (b = b + Math.imul(Mt, Ut) | 0) + Math.imul(sn, Nn) | 0, N = N + Math.imul(sn, Ut) | 0, A = A + Math.imul(Ge, ti) | 0, b = (b = b + Math.imul(Ge, qi) | 0) + Math.imul(wt, ti) | 0, N = N + Math.imul(wt, qi) | 0;
                    var la = (E + (A = A + Math.imul(Q, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Q, an) | 0) + Math.imul(Ee, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Ee, an) | 0) + (b >>> 13) | 0) + (la >>> 26) | 0, la &= 67108863, A = Math.imul(st, Sn), b = (b = Math.imul(st, pi)) + Math.imul(tn, Sn) | 0, N = Math.imul(tn, pi), A = A + Math.imul(ke, yi) | 0, b = (b = b + Math.imul(ke, hr) | 0) + Math.imul(je, yi) | 0, N = N + Math.imul(je, hr) | 0, A = A + Math.imul(pe, yr) | 0, b = (b = b + Math.imul(pe, Rn) | 0) + Math.imul(O, yr) | 0, N = N + Math.imul(O, Rn) | 0, A = A + Math.imul(ci, Ji) | 0, b = (b = b + Math.imul(ci, gn) | 0) + Math.imul(en, Ji) | 0, N = N + Math.imul(en, gn) | 0, A = A + Math.imul(Wn, qn) | 0, b = (b = b + Math.imul(Wn, Ve) | 0) + Math.imul(kn, qn) | 0, N = N + Math.imul(kn, Ve) | 0, A = A + Math.imul(ui, pt) | 0, b = (b = b + Math.imul(ui, St) | 0) + Math.imul(Mi, pt) | 0, N = N + Math.imul(Mi, St) | 0, A = A + Math.imul(ai, Nn) | 0, b = (b = b + Math.imul(ai, Ut) | 0) + Math.imul(jn, Nn) | 0, N = N + Math.imul(jn, Ut) | 0, A = A + Math.imul(Mt, ti) | 0, b = (b = b + Math.imul(Mt, qi) | 0) + Math.imul(sn, ti) | 0, N = N + Math.imul(sn, qi) | 0;
                    var ua = (E + (A = A + Math.imul(Ge, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Ge, an) | 0) + Math.imul(wt, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(wt, an) | 0) + (b >>> 13) | 0) + (ua >>> 26) | 0, ua &= 67108863, A = Math.imul(st, yi), b = (b = Math.imul(st, hr)) + Math.imul(tn, yi) | 0, N = Math.imul(tn, hr), A = A + Math.imul(ke, yr) | 0, b = (b = b + Math.imul(ke, Rn) | 0) + Math.imul(je, yr) | 0, N = N + Math.imul(je, Rn) | 0, A = A + Math.imul(pe, Ji) | 0, b = (b = b + Math.imul(pe, gn) | 0) + Math.imul(O, Ji) | 0, N = N + Math.imul(O, gn) | 0, A = A + Math.imul(ci, qn) | 0, b = (b = b + Math.imul(ci, Ve) | 0) + Math.imul(en, qn) | 0, N = N + Math.imul(en, Ve) | 0, A = A + Math.imul(Wn, pt) | 0, b = (b = b + Math.imul(Wn, St) | 0) + Math.imul(kn, pt) | 0, N = N + Math.imul(kn, St) | 0, A = A + Math.imul(ui, Nn) | 0, b = (b = b + Math.imul(ui, Ut) | 0) + Math.imul(Mi, Nn) | 0, N = N + Math.imul(Mi, Ut) | 0, A = A + Math.imul(ai, ti) | 0, b = (b = b + Math.imul(ai, qi) | 0) + Math.imul(jn, ti) | 0, N = N + Math.imul(jn, qi) | 0;
                    var Qs = (E + (A = A + Math.imul(Mt, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Mt, an) | 0) + Math.imul(sn, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(sn, an) | 0) + (b >>> 13) | 0) + (Qs >>> 26) | 0, Qs &= 67108863, A = Math.imul(st, yr), b = (b = Math.imul(st, Rn)) + Math.imul(tn, yr) | 0, N = Math.imul(tn, Rn), A = A + Math.imul(ke, Ji) | 0, b = (b = b + Math.imul(ke, gn) | 0) + Math.imul(je, Ji) | 0, N = N + Math.imul(je, gn) | 0, A = A + Math.imul(pe, qn) | 0, b = (b = b + Math.imul(pe, Ve) | 0) + Math.imul(O, qn) | 0, N = N + Math.imul(O, Ve) | 0, A = A + Math.imul(ci, pt) | 0, b = (b = b + Math.imul(ci, St) | 0) + Math.imul(en, pt) | 0, N = N + Math.imul(en, St) | 0, A = A + Math.imul(Wn, Nn) | 0, b = (b = b + Math.imul(Wn, Ut) | 0) + Math.imul(kn, Nn) | 0, N = N + Math.imul(kn, Ut) | 0, A = A + Math.imul(ui, ti) | 0, b = (b = b + Math.imul(ui, qi) | 0) + Math.imul(Mi, ti) | 0, N = N + Math.imul(Mi, qi) | 0;
                    var Ir = (E + (A = A + Math.imul(ai, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(ai, an) | 0) + Math.imul(jn, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(jn, an) | 0) + (b >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, A = Math.imul(st, Ji), b = (b = Math.imul(st, gn)) + Math.imul(tn, Ji) | 0, N = Math.imul(tn, gn), A = A + Math.imul(ke, qn) | 0, b = (b = b + Math.imul(ke, Ve) | 0) + Math.imul(je, qn) | 0, N = N + Math.imul(je, Ve) | 0, A = A + Math.imul(pe, pt) | 0, b = (b = b + Math.imul(pe, St) | 0) + Math.imul(O, pt) | 0, N = N + Math.imul(O, St) | 0, A = A + Math.imul(ci, Nn) | 0, b = (b = b + Math.imul(ci, Ut) | 0) + Math.imul(en, Nn) | 0, N = N + Math.imul(en, Ut) | 0, A = A + Math.imul(Wn, ti) | 0, b = (b = b + Math.imul(Wn, qi) | 0) + Math.imul(kn, ti) | 0, N = N + Math.imul(kn, qi) | 0;
                    var ao = (E + (A = A + Math.imul(ui, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(ui, an) | 0) + Math.imul(Mi, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(Mi, an) | 0) + (b >>> 13) | 0) + (ao >>> 26) | 0, ao &= 67108863, A = Math.imul(st, qn), b = (b = Math.imul(st, Ve)) + Math.imul(tn, qn) | 0, N = Math.imul(tn, Ve), A = A + Math.imul(ke, pt) | 0, b = (b = b + Math.imul(ke, St) | 0) + Math.imul(je, pt) | 0, N = N + Math.imul(je, St) | 0, A = A + Math.imul(pe, Nn) | 0, b = (b = b + Math.imul(pe, Ut) | 0) + Math.imul(O, Nn) | 0, N = N + Math.imul(O, Ut) | 0, A = A + Math.imul(ci, ti) | 0, b = (b = b + Math.imul(ci, qi) | 0) + Math.imul(en, ti) | 0, N = N + Math.imul(en, qi) | 0;
                    var da = (E + (A = A + Math.imul(Wn, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(Wn, an) | 0) + Math.imul(kn, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(kn, an) | 0) + (b >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, A = Math.imul(st, pt), b = (b = Math.imul(st, St)) + Math.imul(tn, pt) | 0, N = Math.imul(tn, St), A = A + Math.imul(ke, Nn) | 0, b = (b = b + Math.imul(ke, Ut) | 0) + Math.imul(je, Nn) | 0, N = N + Math.imul(je, Ut) | 0, A = A + Math.imul(pe, ti) | 0, b = (b = b + Math.imul(pe, qi) | 0) + Math.imul(O, ti) | 0, N = N + Math.imul(O, qi) | 0;
                    var nc = (E + (A = A + Math.imul(ci, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(ci, an) | 0) + Math.imul(en, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(en, an) | 0) + (b >>> 13) | 0) + (nc >>> 26) | 0, nc &= 67108863, A = Math.imul(st, Nn), b = (b = Math.imul(st, Ut)) + Math.imul(tn, Nn) | 0, N = Math.imul(tn, Ut), A = A + Math.imul(ke, ti) | 0, b = (b = b + Math.imul(ke, qi) | 0) + Math.imul(je, ti) | 0, N = N + Math.imul(je, qi) | 0;
                    var xr = (E + (A = A + Math.imul(pe, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(pe, an) | 0) + Math.imul(O, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(O, an) | 0) + (b >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, A = Math.imul(st, ti), b = (b = Math.imul(st, qi)) + Math.imul(tn, ti) | 0, N = Math.imul(tn, qi);
                    var Js = (E + (A = A + Math.imul(ke, Xn) | 0) | 0) + ((8191 & (b = (b = b + Math.imul(ke, an) | 0) + Math.imul(je, Xn) | 0)) << 13) | 0;
                    E = ((N = N + Math.imul(je, an) | 0) + (b >>> 13) | 0) + (Js >>> 26) | 0, Js &= 67108863;
                    var Zi = (E + (A = Math.imul(st, Xn)) | 0) + ((8191 & (b = (b = Math.imul(st, an)) + Math.imul(tn, Xn) | 0)) << 13) | 0;
                    return E = ((N = Math.imul(tn, an)) + (b >>> 13) | 0) + (Zi >>> 26) | 0, Zi &= 67108863, y[0] = As, y[1] = wo, y[2] = Dc, y[3] = Wr, y[4] = mt, y[5] = xo, y[6] = Zn, y[7] = di, y[8] = Nr, y[9] = la, y[10] = ua, y[11] = Qs, y[12] = Ir, y[13] = ao, y[14] = da, y[15] = nc, y[16] = xr, y[17] = Js, y[18] = Zi, 0 !== E && (y[19] = E, M.length++), M
                };

                function ve($, f, v) {
                    v.negative = f.negative ^ $.negative, v.length = $.length + f.length;
                    for (var M = 0, U = 0, G = 0; G < v.length - 1; G++) {
                        var y = U;
                        U = 0;
                        for (var E = 67108863 & M, A = Math.min(G, f.length - 1), b = Math.max(0, G - $.length + 1); b <= A; b++) {
                            var Ee = (0 | $.words[G - b]) * (0 | f.words[b]),
                                Fe = 67108863 & Ee;
                            E = 67108863 & (Fe = Fe + E | 0), U += (y = (y = y + (Ee / 67108864 | 0) | 0) + (Fe >>> 26) | 0) >>> 26, y &= 67108863
                        }
                        v.words[G] = E, M = y, y = U
                    }
                    return 0 !== M ? v.words[G] = M : v.length--, v._strip()
                }

                function De($, f, v) {
                    return ve($, f, v)
                }

                function ae($, f) {
                    this.x = $, this.y = f
                }
                Math.imul || (we = Ce), S.prototype.mulTo = function(f, v) {
                    var U = this.length + f.length;
                    return 10 === this.length && 10 === f.length ? we(this, f, v) : U < 63 ? Ce(this, f, v) : U < 1024 ? ve(this, f, v) : De(this, f, v)
                }, ae.prototype.makeRBT = function(f) {
                    for (var v = new Array(f), M = S.prototype._countBits(f) - 1, U = 0; U < f; U++) v[U] = this.revBin(U, M, f);
                    return v
                }, ae.prototype.revBin = function(f, v, M) {
                    if (0 === f || f === M - 1) return f;
                    for (var U = 0, G = 0; G < v; G++) U |= (1 & f) << v - G - 1, f >>= 1;
                    return U
                }, ae.prototype.permute = function(f, v, M, U, G, y) {
                    for (var E = 0; E < y; E++) U[E] = v[f[E]], G[E] = M[f[E]]
                }, ae.prototype.transform = function(f, v, M, U, G, y) {
                    this.permute(y, f, v, M, U, G);
                    for (var E = 1; E < G; E <<= 1)
                        for (var A = E << 1, b = Math.cos(2 * Math.PI / A), N = Math.sin(2 * Math.PI / A), R = 0; R < G; R += A)
                            for (var Q = b, Ee = N, Fe = 0; Fe < E; Fe++) {
                                var Ge = M[R + Fe],
                                    wt = U[R + Fe],
                                    Vt = M[R + Fe + E],
                                    Mt = U[R + Fe + E],
                                    sn = Q * Vt - Ee * Mt;
                                Mt = Q * Mt + Ee * Vt, M[R + Fe] = Ge + (Vt = sn), U[R + Fe] = wt + Mt, M[R + Fe + E] = Ge - Vt, U[R + Fe + E] = wt - Mt, Fe !== A && (sn = b * Q - N * Ee, Ee = b * Ee + N * Q, Q = sn)
                            }
                }, ae.prototype.guessLen13b = function(f, v) {
                    var M = 1 | Math.max(v, f),
                        U = 1 & M,
                        G = 0;
                    for (M = M / 2 | 0; M; M >>>= 1) G++;
                    return 1 << G + 1 + U
                }, ae.prototype.conjugate = function(f, v, M) {
                    if (!(M <= 1))
                        for (var U = 0; U < M / 2; U++) {
                            var G = f[U];
                            f[U] = f[M - U - 1], f[M - U - 1] = G, G = v[U], v[U] = -v[M - U - 1], v[M - U - 1] = -G
                        }
                }, ae.prototype.normalize13b = function(f, v) {
                    for (var M = 0, U = 0; U < v / 2; U++) {
                        var G = 8192 * Math.round(f[2 * U + 1] / v) + Math.round(f[2 * U] / v) + M;
                        f[U] = 67108863 & G, M = G < 67108864 ? 0 : G / 67108864 | 0
                    }
                    return f
                }, ae.prototype.convert13b = function(f, v, M, U) {
                    for (var G = 0, y = 0; y < v; y++) M[2 * y] = 8191 & (G += 0 | f[y]), M[2 * y + 1] = 8191 & (G >>>= 13), G >>>= 13;
                    for (y = 2 * v; y < U; ++y) M[y] = 0;
                    q(0 === G), q(0 == (-8192 & G))
                }, ae.prototype.stub = function(f) {
                    for (var v = new Array(f), M = 0; M < f; M++) v[M] = 0;
                    return v
                }, ae.prototype.mulp = function(f, v, M) {
                    var U = 2 * this.guessLen13b(f.length, v.length),
                        G = this.makeRBT(U),
                        y = this.stub(U),
                        E = new Array(U),
                        A = new Array(U),
                        b = new Array(U),
                        N = new Array(U),
                        R = new Array(U),
                        Q = new Array(U),
                        Ee = M.words;
                    Ee.length = U, this.convert13b(f.words, f.length, E, U), this.convert13b(v.words, v.length, N, U), this.transform(E, y, A, b, U, G), this.transform(N, y, R, Q, U, G);
                    for (var Fe = 0; Fe < U; Fe++) {
                        var Ge = A[Fe] * R[Fe] - b[Fe] * Q[Fe];
                        b[Fe] = A[Fe] * Q[Fe] + b[Fe] * R[Fe], A[Fe] = Ge
                    }
                    return this.conjugate(A, b, U), this.transform(A, b, Ee, y, U, G), this.conjugate(Ee, y, U), this.normalize13b(Ee, U), M.negative = f.negative ^ v.negative, M.length = f.length + v.length, M._strip()
                }, S.prototype.mul = function(f) {
                    var v = new S(null);
                    return v.words = new Array(this.length + f.length), this.mulTo(f, v)
                }, S.prototype.mulf = function(f) {
                    var v = new S(null);
                    return v.words = new Array(this.length + f.length), De(this, f, v)
                }, S.prototype.imul = function(f) {
                    return this.clone().mulTo(f, this)
                }, S.prototype.imuln = function(f) {
                    var v = f < 0;
                    v && (f = -f), q("number" == typeof f), q(f < 67108864);
                    for (var M = 0, U = 0; U < this.length; U++) {
                        var G = (0 | this.words[U]) * f,
                            y = (67108863 & G) + (67108863 & M);
                        M >>= 26, M += G / 67108864 | 0, M += y >>> 26, this.words[U] = 67108863 & y
                    }
                    return 0 !== M && (this.words[U] = M, this.length++), v ? this.ineg() : this
                }, S.prototype.muln = function(f) {
                    return this.clone().imuln(f)
                }, S.prototype.sqr = function() {
                    return this.mul(this)
                }, S.prototype.isqr = function() {
                    return this.imul(this.clone())
                }, S.prototype.pow = function(f) {
                    var v = function me($) {
                        for (var f = new Array($.bitLength()), v = 0; v < f.length; v++) f[v] = $.words[v / 26 | 0] >>> v % 26 & 1;
                        return f
                    }(f);
                    if (0 === v.length) return new S(1);
                    for (var M = this, U = 0; U < v.length && 0 === v[U]; U++, M = M.sqr());
                    if (++U < v.length)
                        for (var G = M.sqr(); U < v.length; U++, G = G.sqr()) 0 !== v[U] && (M = M.mul(G));
                    return M
                }, S.prototype.iushln = function(f) {
                    q("number" == typeof f && f >= 0);
                    var G, v = f % 26,
                        M = (f - v) / 26,
                        U = 67108863 >>> 26 - v << 26 - v;
                    if (0 !== v) {
                        var y = 0;
                        for (G = 0; G < this.length; G++) {
                            var E = this.words[G] & U;
                            this.words[G] = (0 | this.words[G]) - E << v | y, y = E >>> 26 - v
                        }
                        y && (this.words[G] = y, this.length++)
                    }
                    if (0 !== M) {
                        for (G = this.length - 1; G >= 0; G--) this.words[G + M] = this.words[G];
                        for (G = 0; G < M; G++) this.words[G] = 0;
                        this.length += M
                    }
                    return this._strip()
                }, S.prototype.ishln = function(f) {
                    return q(0 === this.negative), this.iushln(f)
                }, S.prototype.iushrn = function(f, v, M) {
                    var U;
                    q("number" == typeof f && f >= 0), U = v ? (v - v % 26) / 26 : 0;
                    var G = f % 26,
                        y = Math.min((f - G) / 26, this.length),
                        E = 67108863 ^ 67108863 >>> G << G,
                        A = M;
                    if (U -= y, U = Math.max(0, U), A) {
                        for (var b = 0; b < y; b++) A.words[b] = this.words[b];
                        A.length = y
                    }
                    if (0 !== y)
                        if (this.length > y)
                            for (this.length -= y, b = 0; b < this.length; b++) this.words[b] = this.words[b + y];
                        else this.words[0] = 0, this.length = 1;
                    var N = 0;
                    for (b = this.length - 1; b >= 0 && (0 !== N || b >= U); b--) {
                        var R = 0 | this.words[b];
                        this.words[b] = N << 26 - G | R >>> G, N = R & E
                    }
                    return A && 0 !== N && (A.words[A.length++] = N), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
                }, S.prototype.ishrn = function(f, v, M) {
                    return q(0 === this.negative), this.iushrn(f, v, M)
                }, S.prototype.shln = function(f) {
                    return this.clone().ishln(f)
                }, S.prototype.ushln = function(f) {
                    return this.clone().iushln(f)
                }, S.prototype.shrn = function(f) {
                    return this.clone().ishrn(f)
                }, S.prototype.ushrn = function(f) {
                    return this.clone().iushrn(f)
                }, S.prototype.testn = function(f) {
                    q("number" == typeof f && f >= 0);
                    var v = f % 26,
                        M = (f - v) / 26;
                    return !(this.length <= M || !(this.words[M] & 1 << v))
                }, S.prototype.imaskn = function(f) {
                    q("number" == typeof f && f >= 0);
                    var v = f % 26,
                        M = (f - v) / 26;
                    return q(0 === this.negative, "imaskn works only with positive numbers"), this.length <= M ? this : (0 !== v && M++, this.length = Math.min(M, this.length), 0 !== v && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> v << v), this._strip())
                }, S.prototype.maskn = function(f) {
                    return this.clone().imaskn(f)
                }, S.prototype.iaddn = function(f) {
                    return q("number" == typeof f), q(f < 67108864), f < 0 ? this.isubn(-f) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= f ? (this.words[0] = f - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f)
                }, S.prototype._iaddn = function(f) {
                    this.words[0] += f;
                    for (var v = 0; v < this.length && this.words[v] >= 67108864; v++) this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
                    return this.length = Math.max(this.length, v + 1), this
                }, S.prototype.isubn = function(f) {
                    if (q("number" == typeof f), q(f < 67108864), f < 0) return this.iaddn(-f);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(f), this.negative = 1, this;
                    if (this.words[0] -= f, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else
                        for (var v = 0; v < this.length && this.words[v] < 0; v++) this.words[v] += 67108864, this.words[v + 1] -= 1;
                    return this._strip()
                }, S.prototype.addn = function(f) {
                    return this.clone().iaddn(f)
                }, S.prototype.subn = function(f) {
                    return this.clone().isubn(f)
                }, S.prototype.iabs = function() {
                    return this.negative = 0, this
                }, S.prototype.abs = function() {
                    return this.clone().iabs()
                }, S.prototype._ishlnsubmul = function(f, v, M) {
                    var G;
                    this._expand(f.length + M);
                    var y, E = 0;
                    for (G = 0; G < f.length; G++) {
                        y = (0 | this.words[G + M]) + E;
                        var A = (0 | f.words[G]) * v;
                        E = ((y -= 67108863 & A) >> 26) - (A / 67108864 | 0), this.words[G + M] = 67108863 & y
                    }
                    for (; G < this.length - M; G++) E = (y = (0 | this.words[G + M]) + E) >> 26, this.words[G + M] = 67108863 & y;
                    if (0 === E) return this._strip();
                    for (q(-1 === E), E = 0, G = 0; G < this.length; G++) E = (y = -(0 | this.words[G]) + E) >> 26, this.words[G] = 67108863 & y;
                    return this.negative = 1, this._strip()
                }, S.prototype._wordDiv = function(f, v) {
                    var M, U = this.clone(),
                        G = f,
                        y = 0 | G.words[G.length - 1];
                    0 != (M = 26 - this._countBits(y)) && (G = G.ushln(M), U.iushln(M), y = 0 | G.words[G.length - 1]);
                    var b, A = U.length - G.length;
                    if ("mod" !== v) {
                        (b = new S(null)).length = A + 1, b.words = new Array(b.length);
                        for (var N = 0; N < b.length; N++) b.words[N] = 0
                    }
                    var R = U.clone()._ishlnsubmul(G, 1, A);
                    0 === R.negative && (U = R, b && (b.words[A] = 1));
                    for (var Q = A - 1; Q >= 0; Q--) {
                        var Ee = 67108864 * (0 | U.words[G.length + Q]) + (0 | U.words[G.length + Q - 1]);
                        for (Ee = Math.min(Ee / y | 0, 67108863), U._ishlnsubmul(G, Ee, Q); 0 !== U.negative;) Ee--, U.negative = 0, U._ishlnsubmul(G, 1, Q), U.isZero() || (U.negative ^= 1);
                        b && (b.words[Q] = Ee)
                    }
                    return b && b._strip(), U._strip(), "div" !== v && 0 !== M && U.iushrn(M), {
                        div: b || null,
                        mod: U
                    }
                }, S.prototype.divmod = function(f, v, M) {
                    return q(!f.isZero()), this.isZero() ? {
                        div: new S(0),
                        mod: new S(0)
                    } : 0 !== this.negative && 0 === f.negative ? (y = this.neg().divmod(f, v), "mod" !== v && (U = y.div.neg()), "div" !== v && (G = y.mod.neg(), M && 0 !== G.negative && G.iadd(f)), {
                        div: U,
                        mod: G
                    }) : 0 === this.negative && 0 !== f.negative ? (y = this.divmod(f.neg(), v), "mod" !== v && (U = y.div.neg()), {
                        div: U,
                        mod: y.mod
                    }) : this.negative & f.negative ? (y = this.neg().divmod(f.neg(), v), "div" !== v && (G = y.mod.neg(), M && 0 !== G.negative && G.isub(f)), {
                        div: y.div,
                        mod: G
                    }) : f.length > this.length || this.cmp(f) < 0 ? {
                        div: new S(0),
                        mod: this
                    } : 1 === f.length ? "div" === v ? {
                        div: this.divn(f.words[0]),
                        mod: null
                    } : "mod" === v ? {
                        div: null,
                        mod: new S(this.modrn(f.words[0]))
                    } : {
                        div: this.divn(f.words[0]),
                        mod: new S(this.modrn(f.words[0]))
                    } : this._wordDiv(f, v);
                    var U, G, y
                }, S.prototype.div = function(f) {
                    return this.divmod(f, "div", !1).div
                }, S.prototype.mod = function(f) {
                    return this.divmod(f, "mod", !1).mod
                }, S.prototype.umod = function(f) {
                    return this.divmod(f, "mod", !0).mod
                }, S.prototype.divRound = function(f) {
                    var v = this.divmod(f);
                    if (v.mod.isZero()) return v.div;
                    var M = 0 !== v.div.negative ? v.mod.isub(f) : v.mod,
                        U = f.ushrn(1),
                        G = f.andln(1),
                        y = M.cmp(U);
                    return y < 0 || 1 === G && 0 === y ? v.div : 0 !== v.div.negative ? v.div.isubn(1) : v.div.iaddn(1)
                }, S.prototype.modrn = function(f) {
                    var v = f < 0;
                    v && (f = -f), q(f <= 67108863);
                    for (var M = (1 << 26) % f, U = 0, G = this.length - 1; G >= 0; G--) U = (M * U + (0 | this.words[G])) % f;
                    return v ? -U : U
                }, S.prototype.modn = function(f) {
                    return this.modrn(f)
                }, S.prototype.idivn = function(f) {
                    var v = f < 0;
                    v && (f = -f), q(f <= 67108863);
                    for (var M = 0, U = this.length - 1; U >= 0; U--) {
                        var G = (0 | this.words[U]) + 67108864 * M;
                        this.words[U] = G / f | 0, M = G % f
                    }
                    return this._strip(), v ? this.ineg() : this
                }, S.prototype.divn = function(f) {
                    return this.clone().idivn(f)
                }, S.prototype.egcd = function(f) {
                    q(0 === f.negative), q(!f.isZero());
                    var v = this,
                        M = f.clone();
                    v = 0 !== v.negative ? v.umod(f) : v.clone();
                    for (var U = new S(1), G = new S(0), y = new S(0), E = new S(1), A = 0; v.isEven() && M.isEven();) v.iushrn(1), M.iushrn(1), ++A;
                    for (var b = M.clone(), N = v.clone(); !v.isZero();) {
                        for (var R = 0, Q = 1; !(v.words[0] & Q) && R < 26; ++R, Q <<= 1);
                        if (R > 0)
                            for (v.iushrn(R); R-- > 0;)(U.isOdd() || G.isOdd()) && (U.iadd(b), G.isub(N)), U.iushrn(1), G.iushrn(1);
                        for (var Ee = 0, Fe = 1; !(M.words[0] & Fe) && Ee < 26; ++Ee, Fe <<= 1);
                        if (Ee > 0)
                            for (M.iushrn(Ee); Ee-- > 0;)(y.isOdd() || E.isOdd()) && (y.iadd(b), E.isub(N)), y.iushrn(1), E.iushrn(1);
                        v.cmp(M) >= 0 ? (v.isub(M), U.isub(y), G.isub(E)) : (M.isub(v), y.isub(U), E.isub(G))
                    }
                    return {
                        a: y,
                        b: E,
                        gcd: M.iushln(A)
                    }
                }, S.prototype._invmp = function(f) {
                    q(0 === f.negative), q(!f.isZero());
                    var R, v = this,
                        M = f.clone();
                    v = 0 !== v.negative ? v.umod(f) : v.clone();
                    for (var U = new S(1), G = new S(0), y = M.clone(); v.cmpn(1) > 0 && M.cmpn(1) > 0;) {
                        for (var E = 0, A = 1; !(v.words[0] & A) && E < 26; ++E, A <<= 1);
                        if (E > 0)
                            for (v.iushrn(E); E-- > 0;) U.isOdd() && U.iadd(y), U.iushrn(1);
                        for (var b = 0, N = 1; !(M.words[0] & N) && b < 26; ++b, N <<= 1);
                        if (b > 0)
                            for (M.iushrn(b); b-- > 0;) G.isOdd() && G.iadd(y), G.iushrn(1);
                        v.cmp(M) >= 0 ? (v.isub(M), U.isub(G)) : (M.isub(v), G.isub(U))
                    }
                    return (R = 0 === v.cmpn(1) ? U : G).cmpn(0) < 0 && R.iadd(f), R
                }, S.prototype.gcd = function(f) {
                    if (this.isZero()) return f.abs();
                    if (f.isZero()) return this.abs();
                    var v = this.clone(),
                        M = f.clone();
                    v.negative = 0, M.negative = 0;
                    for (var U = 0; v.isEven() && M.isEven(); U++) v.iushrn(1), M.iushrn(1);
                    for (;;) {
                        for (; v.isEven();) v.iushrn(1);
                        for (; M.isEven();) M.iushrn(1);
                        var G = v.cmp(M);
                        if (G < 0) {
                            var y = v;
                            v = M, M = y
                        } else if (0 === G || 0 === M.cmpn(1)) break;
                        v.isub(M)
                    }
                    return M.iushln(U)
                }, S.prototype.invm = function(f) {
                    return this.egcd(f).a.umod(f)
                }, S.prototype.isEven = function() {
                    return 0 == (1 & this.words[0])
                }, S.prototype.isOdd = function() {
                    return 1 == (1 & this.words[0])
                }, S.prototype.andln = function(f) {
                    return this.words[0] & f
                }, S.prototype.bincn = function(f) {
                    q("number" == typeof f);
                    var v = f % 26,
                        M = (f - v) / 26,
                        U = 1 << v;
                    if (this.length <= M) return this._expand(M + 1), this.words[M] |= U, this;
                    for (var G = U, y = M; 0 !== G && y < this.length; y++) {
                        var E = 0 | this.words[y];
                        G = (E += G) >>> 26, this.words[y] = E &= 67108863
                    }
                    return 0 !== G && (this.words[y] = G, this.length++), this
                }, S.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0]
                }, S.prototype.cmpn = function(f) {
                    var M, v = f < 0;
                    if (0 !== this.negative && !v) return -1;
                    if (0 === this.negative && v) return 1;
                    if (this._strip(), this.length > 1) M = 1;
                    else {
                        v && (f = -f), q(f <= 67108863, "Number is too big");
                        var U = 0 | this.words[0];
                        M = U === f ? 0 : U < f ? -1 : 1
                    }
                    return 0 !== this.negative ? 0 | -M : M
                }, S.prototype.cmp = function(f) {
                    if (0 !== this.negative && 0 === f.negative) return -1;
                    if (0 === this.negative && 0 !== f.negative) return 1;
                    var v = this.ucmp(f);
                    return 0 !== this.negative ? 0 | -v : v
                }, S.prototype.ucmp = function(f) {
                    if (this.length > f.length) return 1;
                    if (this.length < f.length) return -1;
                    for (var v = 0, M = this.length - 1; M >= 0; M--) {
                        var U = 0 | this.words[M],
                            G = 0 | f.words[M];
                        if (U !== G) {
                            U < G ? v = -1 : U > G && (v = 1);
                            break
                        }
                    }
                    return v
                }, S.prototype.gtn = function(f) {
                    return 1 === this.cmpn(f)
                }, S.prototype.gt = function(f) {
                    return 1 === this.cmp(f)
                }, S.prototype.gten = function(f) {
                    return this.cmpn(f) >= 0
                }, S.prototype.gte = function(f) {
                    return this.cmp(f) >= 0
                }, S.prototype.ltn = function(f) {
                    return -1 === this.cmpn(f)
                }, S.prototype.lt = function(f) {
                    return -1 === this.cmp(f)
                }, S.prototype.lten = function(f) {
                    return this.cmpn(f) <= 0
                }, S.prototype.lte = function(f) {
                    return this.cmp(f) <= 0
                }, S.prototype.eqn = function(f) {
                    return 0 === this.cmpn(f)
                }, S.prototype.eq = function(f) {
                    return 0 === this.cmp(f)
                }, S.red = function(f) {
                    return new Ae(f)
                }, S.prototype.toRed = function(f) {
                    return q(!this.red, "Already a number in reduction context"), q(0 === this.negative, "red works only with positives"), f.convertTo(this)._forceRed(f)
                }, S.prototype.fromRed = function() {
                    return q(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                }, S.prototype._forceRed = function(f) {
                    return this.red = f, this
                }, S.prototype.forceRed = function(f) {
                    return q(!this.red, "Already a number in reduction context"), this._forceRed(f)
                }, S.prototype.redAdd = function(f) {
                    return q(this.red, "redAdd works only with red numbers"), this.red.add(this, f)
                }, S.prototype.redIAdd = function(f) {
                    return q(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f)
                }, S.prototype.redSub = function(f) {
                    return q(this.red, "redSub works only with red numbers"), this.red.sub(this, f)
                }, S.prototype.redISub = function(f) {
                    return q(this.red, "redISub works only with red numbers"), this.red.isub(this, f)
                }, S.prototype.redShl = function(f) {
                    return q(this.red, "redShl works only with red numbers"), this.red.shl(this, f)
                }, S.prototype.redMul = function(f) {
                    return q(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f)
                }, S.prototype.redIMul = function(f) {
                    return q(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f)
                }, S.prototype.redSqr = function() {
                    return q(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                }, S.prototype.redISqr = function() {
                    return q(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                }, S.prototype.redSqrt = function() {
                    return q(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                }, S.prototype.redInvm = function() {
                    return q(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                }, S.prototype.redNeg = function() {
                    return q(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                }, S.prototype.redPow = function(f) {
                    return q(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f)
                };
                var Me = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };

                function Le($, f) {
                    this.name = $, this.p = new S(f, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                }

                function L() {
                    Le.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                }

                function ue() {
                    Le.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                }

                function Te() {
                    Le.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                }

                function xe() {
                    Le.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                }

                function Ae($) {
                    if ("string" == typeof $) {
                        var f = S._prime($);
                        this.m = f.p, this.prime = f
                    } else q($.gtn(1), "modulus must be greater than 1"), this.m = $, this.prime = null
                }

                function Ie($) {
                    Ae.call(this, $), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                }
                Le.prototype._tmp = function() {
                    var f = new S(null);
                    return f.words = new Array(Math.ceil(this.n / 13)), f
                }, Le.prototype.ireduce = function(f) {
                    var M, v = f;
                    do {
                        this.split(v, this.tmp), M = (v = (v = this.imulK(v)).iadd(this.tmp)).bitLength()
                    } while (M > this.n);
                    var U = M < this.n ? -1 : v.ucmp(this.p);
                    return 0 === U ? (v.words[0] = 0, v.length = 1) : U > 0 ? v.isub(this.p) : void 0 !== v.strip ? v.strip() : v._strip(), v
                }, Le.prototype.split = function(f, v) {
                    f.iushrn(this.n, 0, v)
                }, Le.prototype.imulK = function(f) {
                    return f.imul(this.k)
                }, ne(L, Le), L.prototype.split = function(f, v) {
                    for (var M = 4194303, U = Math.min(f.length, 9), G = 0; G < U; G++) v.words[G] = f.words[G];
                    if (v.length = U, f.length <= 9) return f.words[0] = 0, void(f.length = 1);
                    var y = f.words[9];
                    for (v.words[v.length++] = y & M, G = 10; G < f.length; G++) {
                        var E = 0 | f.words[G];
                        f.words[G - 10] = (E & M) << 4 | y >>> 22, y = E
                    }
                    f.words[G - 10] = y >>>= 22, f.length -= 0 === y && f.length > 10 ? 10 : 9
                }, L.prototype.imulK = function(f) {
                    f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
                    for (var v = 0, M = 0; M < f.length; M++) {
                        var U = 0 | f.words[M];
                        f.words[M] = 67108863 & (v += 977 * U), v = 64 * U + (v / 67108864 | 0)
                    }
                    return 0 === f.words[f.length - 1] && (f.length--, 0 === f.words[f.length - 1] && f.length--), f
                }, ne(ue, Le), ne(Te, Le), ne(xe, Le), xe.prototype.imulK = function(f) {
                    for (var v = 0, M = 0; M < f.length; M++) {
                        var U = 19 * (0 | f.words[M]) + v,
                            G = 67108863 & U;
                        U >>>= 26, f.words[M] = G, v = U
                    }
                    return 0 !== v && (f.words[f.length++] = v), f
                }, S._prime = function(f) {
                    if (Me[f]) return Me[f];
                    var v;
                    if ("k256" === f) v = new L;
                    else if ("p224" === f) v = new ue;
                    else if ("p192" === f) v = new Te;
                    else {
                        if ("p25519" !== f) throw new Error("Unknown prime " + f);
                        v = new xe
                    }
                    return Me[f] = v, v
                }, Ae.prototype._verify1 = function(f) {
                    q(0 === f.negative, "red works only with positives"), q(f.red, "red works only with red numbers")
                }, Ae.prototype._verify2 = function(f, v) {
                    q(0 == (f.negative | v.negative), "red works only with positives"), q(f.red && f.red === v.red, "red works only with red numbers")
                }, Ae.prototype.imod = function(f) {
                    return this.prime ? this.prime.ireduce(f)._forceRed(this) : (Y(f, f.umod(this.m)._forceRed(this)), f)
                }, Ae.prototype.neg = function(f) {
                    return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this)
                }, Ae.prototype.add = function(f, v) {
                    this._verify2(f, v);
                    var M = f.add(v);
                    return M.cmp(this.m) >= 0 && M.isub(this.m), M._forceRed(this)
                }, Ae.prototype.iadd = function(f, v) {
                    this._verify2(f, v);
                    var M = f.iadd(v);
                    return M.cmp(this.m) >= 0 && M.isub(this.m), M
                }, Ae.prototype.sub = function(f, v) {
                    this._verify2(f, v);
                    var M = f.sub(v);
                    return M.cmpn(0) < 0 && M.iadd(this.m), M._forceRed(this)
                }, Ae.prototype.isub = function(f, v) {
                    this._verify2(f, v);
                    var M = f.isub(v);
                    return M.cmpn(0) < 0 && M.iadd(this.m), M
                }, Ae.prototype.shl = function(f, v) {
                    return this._verify1(f), this.imod(f.ushln(v))
                }, Ae.prototype.imul = function(f, v) {
                    return this._verify2(f, v), this.imod(f.imul(v))
                }, Ae.prototype.mul = function(f, v) {
                    return this._verify2(f, v), this.imod(f.mul(v))
                }, Ae.prototype.isqr = function(f) {
                    return this.imul(f, f.clone())
                }, Ae.prototype.sqr = function(f) {
                    return this.mul(f, f)
                }, Ae.prototype.sqrt = function(f) {
                    if (f.isZero()) return f.clone();
                    var v = this.m.andln(3);
                    if (q(v % 2 == 1), 3 === v) {
                        var M = this.m.add(new S(1)).iushrn(2);
                        return this.pow(f, M)
                    }
                    for (var U = this.m.subn(1), G = 0; !U.isZero() && 0 === U.andln(1);) G++, U.iushrn(1);
                    q(!U.isZero());
                    var y = new S(1).toRed(this),
                        E = y.redNeg(),
                        A = this.m.subn(1).iushrn(1),
                        b = this.m.bitLength();
                    for (b = new S(2 * b * b).toRed(this); 0 !== this.pow(b, A).cmp(E);) b.redIAdd(E);
                    for (var N = this.pow(b, U), R = this.pow(f, U.addn(1).iushrn(1)), Q = this.pow(f, U), Ee = G; 0 !== Q.cmp(y);) {
                        for (var Fe = Q, Ge = 0; 0 !== Fe.cmp(y); Ge++) Fe = Fe.redSqr();
                        q(Ge < Ee);
                        var wt = this.pow(N, new S(1).iushln(Ee - Ge - 1));
                        R = R.redMul(wt), N = wt.redSqr(), Q = Q.redMul(N), Ee = Ge
                    }
                    return R
                }, Ae.prototype.invm = function(f) {
                    var v = f._invmp(this.m);
                    return 0 !== v.negative ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v)
                }, Ae.prototype.pow = function(f, v) {
                    if (v.isZero()) return new S(1).toRed(this);
                    if (0 === v.cmpn(1)) return f.clone();
                    var U = new Array(16);
                    U[0] = new S(1).toRed(this), U[1] = f;
                    for (var G = 2; G < U.length; G++) U[G] = this.mul(U[G - 1], f);
                    var y = U[0],
                        E = 0,
                        A = 0,
                        b = v.bitLength() % 26;
                    for (0 === b && (b = 26), G = v.length - 1; G >= 0; G--) {
                        for (var N = v.words[G], R = b - 1; R >= 0; R--) {
                            var Q = N >> R & 1;
                            y !== U[0] && (y = this.sqr(y)), 0 !== Q || 0 !== E ? (E <<= 1, E |= Q, (4 == ++A || 0 === G && 0 === R) && (y = this.mul(y, U[E]), A = 0, E = 0)) : A = 0
                        }
                        b = 26
                    }
                    return y
                }, Ae.prototype.convertTo = function(f) {
                    var v = f.umod(this.m);
                    return v === f ? v.clone() : v
                }, Ae.prototype.convertFrom = function(f) {
                    var v = f.clone();
                    return v.red = null, v
                }, S.mont = function(f) {
                    return new Ie(f)
                }, ne(Ie, Ae), Ie.prototype.convertTo = function(f) {
                    return this.imod(f.ushln(this.shift))
                }, Ie.prototype.convertFrom = function(f) {
                    var v = this.imod(f.mul(this.rinv));
                    return v.red = null, v
                }, Ie.prototype.imul = function(f, v) {
                    if (f.isZero() || v.isZero()) return f.words[0] = 0, f.length = 1, f;
                    var M = f.imul(v),
                        U = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                        G = M.isub(U).iushrn(this.shift),
                        y = G;
                    return G.cmp(this.m) >= 0 ? y = G.isub(this.m) : G.cmpn(0) < 0 && (y = G.iadd(this.m)), y._forceRed(this)
                }, Ie.prototype.mul = function(f, v) {
                    if (f.isZero() || v.isZero()) return new S(0)._forceRed(this);
                    var M = f.mul(v),
                        U = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                        G = M.isub(U).iushrn(this.shift),
                        y = G;
                    return G.cmp(this.m) >= 0 ? y = G.isub(this.m) : G.cmpn(0) < 0 && (y = G.iadd(this.m)), y._forceRed(this)
                }, Ie.prototype.invm = function(f) {
                    return this.imod(f._invmp(this.m).mul(this.r2))._forceRed(this)
                }
            }(et = T.nmd(et), this)
        },
        84946: function(et, I, T) {
            "use strict";
            var F = this && this.__createBinding || (Object.create ? function(Te, xe, Ae, Ie) {
                    void 0 === Ie && (Ie = Ae), Object.defineProperty(Te, Ie, {
                        enumerable: !0,
                        get: function() {
                            return xe[Ae]
                        }
                    })
                } : function(Te, xe, Ae, Ie) {
                    void 0 === Ie && (Ie = Ae), Te[Ie] = xe[Ae]
                }),
                K = this && this.__setModuleDefault || (Object.create ? function(Te, xe) {
                    Object.defineProperty(Te, "default", {
                        enumerable: !0,
                        value: xe
                    })
                } : function(Te, xe) {
                    Te.default = xe
                }),
                q = this && this.__decorate || function(Te, xe, Ae, Ie) {
                    var v, $ = arguments.length,
                        f = $ < 3 ? xe : null === Ie ? Ie = Object.getOwnPropertyDescriptor(xe, Ae) : Ie;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) f = Reflect.decorate(Te, xe, Ae, Ie);
                    else
                        for (var M = Te.length - 1; M >= 0; M--)(v = Te[M]) && (f = ($ < 3 ? v(f) : $ > 3 ? v(xe, Ae, f) : v(xe, Ae)) || f);
                    return $ > 3 && f && Object.defineProperty(xe, Ae, f), f
                },
                ne = this && this.__importStar || function(Te) {
                    if (Te && Te.__esModule) return Te;
                    var xe = {};
                    if (null != Te)
                        for (var Ae in Te) "default" !== Ae && Object.hasOwnProperty.call(Te, Ae) && F(xe, Te, Ae);
                    return K(xe, Te), xe
                },
                S = this && this.__importDefault || function(Te) {
                    return Te && Te.__esModule ? Te : {
                        default: Te
                    }
                };
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.deserializeUnchecked = I.deserialize = I.serialize = I.BinaryReader = I.BinaryWriter = I.BorshError = I.baseDecode = I.baseEncode = void 0;
            const j = S(T(62662)),
                C = S(T(71109)),
                z = ne(T(88138)),
                Y = new("function" != typeof TextDecoder ? z.TextDecoder : TextDecoder)("utf-8", {
                    fatal: !0
                });
            I.baseEncode = function Z(Te) {
                return "string" == typeof Te && (Te = Buffer.from(Te, "utf8")), C.default.encode(Buffer.from(Te))
            }, I.baseDecode = function le(Te) {
                return Buffer.from(C.default.decode(Te))
            };
            class de extends Error {
                constructor(xe) {
                    super(xe), this.fieldPath = [], this.originalMessage = xe
                }
                addToFieldPath(xe) {
                    this.fieldPath.splice(0, 0, xe), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
                }
            }
            I.BorshError = de;
            class Se {
                constructor() {
                    this.buf = Buffer.alloc(1024), this.length = 0
                }
                maybeResize() {
                    this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(1024)]))
                }
                writeU8(xe) {
                    this.maybeResize(), this.buf.writeUInt8(xe, this.length), this.length += 1
                }
                writeU16(xe) {
                    this.maybeResize(), this.buf.writeUInt16LE(xe, this.length), this.length += 2
                }
                writeU32(xe) {
                    this.maybeResize(), this.buf.writeUInt32LE(xe, this.length), this.length += 4
                }
                writeU64(xe) {
                    this.maybeResize(), this.writeBuffer(Buffer.from(new j.default(xe).toArray("le", 8)))
                }
                writeU128(xe) {
                    this.maybeResize(), this.writeBuffer(Buffer.from(new j.default(xe).toArray("le", 16)))
                }
                writeU256(xe) {
                    this.maybeResize(), this.writeBuffer(Buffer.from(new j.default(xe).toArray("le", 32)))
                }
                writeU512(xe) {
                    this.maybeResize(), this.writeBuffer(Buffer.from(new j.default(xe).toArray("le", 64)))
                }
                writeBuffer(xe) {
                    this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), xe, Buffer.alloc(1024)]), this.length += xe.length
                }
                writeString(xe) {
                    this.maybeResize();
                    const Ae = Buffer.from(xe, "utf8");
                    this.writeU32(Ae.length), this.writeBuffer(Ae)
                }
                writeFixedArray(xe) {
                    this.writeBuffer(Buffer.from(xe))
                }
                writeArray(xe, Ae) {
                    this.maybeResize(), this.writeU32(xe.length);
                    for (const Ie of xe) this.maybeResize(), Ae(Ie)
                }
                toArray() {
                    return this.buf.subarray(0, this.length)
                }
            }

            function me(Te, xe, Ae) {
                const Ie = Ae.value;
                Ae.value = function(...$) {
                    try {
                        return Ie.apply(this, $)
                    } catch (f) {
                        if (f instanceof RangeError && ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(f.code) >= 0) throw new de("Reached the end of buffer when deserializing");
                        throw f
                    }
                }
            }
            I.BinaryWriter = Se;
            class Ce {
                constructor(xe) {
                    this.buf = xe, this.offset = 0
                }
                readU8() {
                    const xe = this.buf.readUInt8(this.offset);
                    return this.offset += 1, xe
                }
                readU16() {
                    const xe = this.buf.readUInt16LE(this.offset);
                    return this.offset += 2, xe
                }
                readU32() {
                    const xe = this.buf.readUInt32LE(this.offset);
                    return this.offset += 4, xe
                }
                readU64() {
                    const xe = this.readBuffer(8);
                    return new j.default(xe, "le")
                }
                readU128() {
                    const xe = this.readBuffer(16);
                    return new j.default(xe, "le")
                }
                readU256() {
                    const xe = this.readBuffer(32);
                    return new j.default(xe, "le")
                }
                readU512() {
                    const xe = this.readBuffer(64);
                    return new j.default(xe, "le")
                }
                readBuffer(xe) {
                    if (this.offset + xe > this.buf.length) throw new de(`Expected buffer length ${xe} isn't within bounds`);
                    const Ae = this.buf.slice(this.offset, this.offset + xe);
                    return this.offset += xe, Ae
                }
                readString() {
                    const xe = this.readU32(),
                        Ae = this.readBuffer(xe);
                    try {
                        return Y.decode(Ae)
                    } catch (Ie) {
                        throw new de(`Error decoding UTF-8 string: ${Ie}`)
                    }
                }
                readFixedArray(xe) {
                    return new Uint8Array(this.readBuffer(xe))
                }
                readArray(xe) {
                    const Ae = this.readU32(),
                        Ie = Array();
                    for (let $ = 0; $ < Ae; ++$) Ie.push(xe());
                    return Ie
                }
            }

            function we(Te) {
                return Te.charAt(0).toUpperCase() + Te.slice(1)
            }

            function ve(Te, xe, Ae, Ie, $) {
                try {
                    if ("string" == typeof Ie) $[`write${we(Ie)}`](Ae);
                    else if (Ie instanceof Array)
                        if ("number" == typeof Ie[0]) {
                            if (Ae.length !== Ie[0]) throw new de(`Expecting byte array of length ${Ie[0]}, but got ${Ae.length} bytes`);
                            $.writeFixedArray(Ae)
                        } else if (2 === Ie.length && "number" == typeof Ie[1]) {
                        if (Ae.length !== Ie[1]) throw new de(`Expecting byte array of length ${Ie[1]}, but got ${Ae.length} bytes`);
                        for (let f = 0; f < Ie[1]; f++) ve(Te, null, Ae[f], Ie[0], $)
                    } else $.writeArray(Ae, f => {
                        ve(Te, xe, f, Ie[0], $)
                    });
                    else if (void 0 !== Ie.kind) switch (Ie.kind) {
                        case "option":
                            null == Ae ? $.writeU8(0) : ($.writeU8(1), ve(Te, xe, Ae, Ie.type, $));
                            break;
                        case "map":
                            $.writeU32(Ae.size), Ae.forEach((f, v) => {
                                ve(Te, xe, v, Ie.key, $), ve(Te, xe, f, Ie.value, $)
                            });
                            break;
                        default:
                            throw new de(`FieldType ${Ie} unrecognized`)
                    } else De(Te, Ae, $)
                } catch (f) {
                    throw f instanceof de && f.addToFieldPath(xe), f
                }
            }

            function De(Te, xe, Ae) {
                if ("function" == typeof xe.borshSerialize) return void xe.borshSerialize(Ae);
                const Ie = Te.get(xe.constructor);
                if (!Ie) throw new de(`Class ${xe.constructor.name} is missing in schema`);
                if ("struct" === Ie.kind) Ie.fields.map(([$, f]) => {
                    ve(Te, $, xe[$], f, Ae)
                });
                else {
                    if ("enum" !== Ie.kind) throw new de(`Unexpected schema kind: ${Ie.kind} for ${xe.constructor.name}`); {
                        const $ = xe[Ie.field];
                        for (let f = 0; f < Ie.values.length; ++f) {
                            const [v, M] = Ie.values[f];
                            if (v === $) {
                                Ae.writeU8(f), ve(Te, v, xe[v], M, Ae);
                                break
                            }
                        }
                    }
                }
            }

            function Me(Te, xe, Ae, Ie) {
                try {
                    if ("string" == typeof Ae) return Ie[`read${we(Ae)}`]();
                    if (Ae instanceof Array) {
                        if ("number" == typeof Ae[0]) return Ie.readFixedArray(Ae[0]);
                        if ("number" == typeof Ae[1]) {
                            const $ = [];
                            for (let f = 0; f < Ae[1]; f++) $.push(Me(Te, null, Ae[0], Ie));
                            return $
                        }
                        return Ie.readArray(() => Me(Te, xe, Ae[0], Ie))
                    }
                    if ("option" === Ae.kind) return Ie.readU8() ? Me(Te, xe, Ae.type, Ie) : void 0;
                    if ("map" === Ae.kind) {
                        let $ = new Map;
                        const f = Ie.readU32();
                        for (let v = 0; v < f; v++) {
                            const M = Me(Te, xe, Ae.key, Ie),
                                U = Me(Te, xe, Ae.value, Ie);
                            $.set(M, U)
                        }
                        return $
                    }
                    return Le(Te, Ae, Ie)
                } catch ($) {
                    throw $ instanceof de && $.addToFieldPath(xe), $
                }
            }

            function Le(Te, xe, Ae) {
                if ("function" == typeof xe.borshDeserialize) return xe.borshDeserialize(Ae);
                const Ie = Te.get(xe);
                if (!Ie) throw new de(`Class ${xe.name} is missing in schema`);
                if ("struct" === Ie.kind) {
                    const $ = {};
                    for (const [f, v] of Te.get(xe).fields) $[f] = Me(Te, f, v, Ae);
                    return new xe($)
                }
                if ("enum" === Ie.kind) {
                    const $ = Ae.readU8();
                    if ($ >= Ie.values.length) throw new de(`Enum index: ${$} is out of range`);
                    const [f, v] = Ie.values[$];
                    return new xe({
                        [f]: Me(Te, f, v, Ae)
                    })
                }
                throw new de(`Unexpected schema kind: ${Ie.kind} for ${xe.constructor.name}`)
            }
            q([me], Ce.prototype, "readU8", null), q([me], Ce.prototype, "readU16", null), q([me], Ce.prototype, "readU32", null), q([me], Ce.prototype, "readU64", null), q([me], Ce.prototype, "readU128", null), q([me], Ce.prototype, "readU256", null), q([me], Ce.prototype, "readU512", null), q([me], Ce.prototype, "readString", null), q([me], Ce.prototype, "readFixedArray", null), q([me], Ce.prototype, "readArray", null), I.BinaryReader = Ce, I.serialize = function ae(Te, xe, Ae = Se) {
                const Ie = new Ae;
                return De(Te, xe, Ie), Ie.toArray()
            }, I.deserialize = function L(Te, xe, Ae, Ie = Ce) {
                const $ = new Ie(Ae),
                    f = Le(Te, xe, $);
                if ($.offset < Ae.length) throw new de(`Unexpected ${Ae.length-$.offset} bytes after deserialized data`);
                return f
            }, I.deserializeUnchecked = function ue(Te, xe, Ae, Ie = Ce) {
                return Le(Te, xe, new Ie(Ae))
            }
        },
        71109: (et, I, T) => {
            var F = T(95026);
            et.exports = F("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
        },
        45815: (et, I) => {
            "use strict";
            class T {
                constructor(y, E) {
                    if (!Number.isInteger(y)) throw new TypeError("span must be an integer");
                    this.span = y, this.property = E
                }
                makeDestinationObject() {
                    return {}
                }
                decode(y, E) {
                    throw new Error("Layout is abstract")
                }
                encode(y, E, A) {
                    throw new Error("Layout is abstract")
                }
                getSpan(y, E) {
                    if (0 > this.span) throw new RangeError("indeterminate span");
                    return this.span
                }
                replicate(y) {
                    const E = Object.create(this.constructor.prototype);
                    return Object.assign(E, this), E.property = y, E
                }
                fromArray(y) {}
            }

            function F(G, y) {
                return y.property ? G + "[" + y.property + "]" : G
            }
            I.Layout = T, I.nameWithProperty = F, I.bindConstructorLayout = function K(G, y) {
                if ("function" != typeof G) throw new TypeError("Class must be constructor");
                if (G.hasOwnProperty("layout_")) throw new Error("Class is already bound to a layout");
                if (!(y && y instanceof T)) throw new TypeError("layout must be a Layout");
                if (y.hasOwnProperty("boundConstructor_")) throw new Error("layout is already bound to a constructor");
                G.layout_ = y, y.boundConstructor_ = G, y.makeDestinationObject = () => new G, Object.defineProperty(G.prototype, "encode", {
                    value: function(E, A) {
                        return y.encode(this, E, A)
                    },
                    writable: !0
                }), Object.defineProperty(G, "decode", {
                    value: function(E, A) {
                        return y.decode(E, A)
                    },
                    writable: !0
                })
            };
            class q extends T {
                isCount() {
                    throw new Error("ExternalLayout is abstract")
                }
            }
            class ne extends q {
                constructor(y, E) {
                    if (void 0 === y && (y = 1), !Number.isInteger(y) || 0 >= y) throw new TypeError("elementSpan must be a (positive) integer");
                    super(-1, E), this.elementSpan = y
                }
                isCount() {
                    return !0
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), Math.floor((y.length - E) / this.elementSpan)
                }
                encode(y, E, A) {
                    return 0
                }
            }
            class S extends q {
                constructor(y, E, A) {
                    if (!(y instanceof T)) throw new TypeError("layout must be a Layout");
                    if (void 0 === E) E = 0;
                    else if (!Number.isInteger(E)) throw new TypeError("offset must be integer or undefined");
                    super(y.span, A || y.property), this.layout = y, this.offset = E
                }
                isCount() {
                    return this.layout instanceof j || this.layout instanceof C
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), this.layout.decode(y, E + this.offset)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), this.layout.encode(y, E, A + this.offset)
                }
            }
            class j extends T {
                constructor(y, E) {
                    if (super(y, E), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readUIntLE(E, this.span)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeUIntLE(y, A, this.span), this.span
                }
            }
            class C extends T {
                constructor(y, E) {
                    if (super(y, E), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readUIntBE(E, this.span)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeUIntBE(y, A, this.span), this.span
                }
            }
            class z extends T {
                constructor(y, E) {
                    if (super(y, E), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readIntLE(E, this.span)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeIntLE(y, A, this.span), this.span
                }
            }
            class H extends T {
                constructor(y, E) {
                    if (super(y, E), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readIntBE(E, this.span)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeIntBE(y, A, this.span), this.span
                }
            }
            const Y = Math.pow(2, 32);

            function Z(G) {
                const y = Math.floor(G / Y);
                return {
                    hi32: y,
                    lo32: G - y * Y
                }
            }

            function le(G, y) {
                return G * Y + y
            }
            class re extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    void 0 === E && (E = 0);
                    const A = y.readUInt32LE(E);
                    return le(y.readUInt32LE(E + 4), A)
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = Z(y);
                    return E.writeUInt32LE(b.lo32, A), E.writeUInt32LE(b.hi32, A + 4), 8
                }
            }
            class de extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), le(y.readUInt32BE(E), y.readUInt32BE(E + 4))
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = Z(y);
                    return E.writeUInt32BE(b.hi32, A), E.writeUInt32BE(b.lo32, A + 4), 8
                }
            }
            class Se extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    void 0 === E && (E = 0);
                    const A = y.readUInt32LE(E);
                    return le(y.readInt32LE(E + 4), A)
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = Z(y);
                    return E.writeUInt32LE(b.lo32, A), E.writeInt32LE(b.hi32, A + 4), 8
                }
            }
            class me extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), le(y.readInt32BE(E), y.readUInt32BE(E + 4))
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = Z(y);
                    return E.writeInt32BE(b.hi32, A), E.writeUInt32BE(b.lo32, A + 4), 8
                }
            }
            class Ce extends T {
                constructor(y) {
                    super(4, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readFloatLE(E)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeFloatLE(y, A), 4
                }
            }
            class we extends T {
                constructor(y) {
                    super(4, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readFloatBE(E)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeFloatBE(y, A), 4
                }
            }
            class ve extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readDoubleLE(E)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeDoubleLE(y, A), 8
                }
            }
            class De extends T {
                constructor(y) {
                    super(8, y)
                }
                decode(y, E) {
                    return void 0 === E && (E = 0), y.readDoubleBE(E)
                }
                encode(y, E, A) {
                    return void 0 === A && (A = 0), E.writeDoubleBE(y, A), 8
                }
            }
            class ae extends T {
                constructor(y, E, A) {
                    if (!(y instanceof T)) throw new TypeError("elementLayout must be a Layout");
                    if (!(E instanceof q && E.isCount() || Number.isInteger(E) && 0 <= E)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                    let b = -1;
                    !(E instanceof q) && 0 < y.span && (b = E * y.span), super(b, A), this.elementLayout = y, this.count = E
                }
                getSpan(y, E) {
                    if (0 <= this.span) return this.span;
                    void 0 === E && (E = 0);
                    let A = 0,
                        b = this.count;
                    if (b instanceof q && (b = b.decode(y, E)), 0 < this.elementLayout.span) A = b * this.elementLayout.span;
                    else {
                        let N = 0;
                        for (; N < b;) A += this.elementLayout.getSpan(y, E + A), ++N
                    }
                    return A
                }
                decode(y, E) {
                    void 0 === E && (E = 0);
                    const A = [];
                    let b = 0,
                        N = this.count;
                    for (N instanceof q && (N = N.decode(y, E)); b < N;) A.push(this.elementLayout.decode(y, E)), E += this.elementLayout.getSpan(y, E), b += 1;
                    return A
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = this.elementLayout,
                        N = y.reduce((R, Q) => R + b.encode(Q, E, A + R), 0);
                    return this.count instanceof q && this.count.encode(y.length, E, A), N
                }
            }
            class Me extends T {
                constructor(y, E, A) {
                    if (!Array.isArray(y) || !y.reduce((N, R) => N && R instanceof T, !0)) throw new TypeError("fields must be array of Layout instances");
                    "boolean" == typeof E && void 0 === A && (A = E, E = void 0);
                    for (const N of y)
                        if (0 > N.span && void 0 === N.property) throw new Error("fields cannot contain unnamed variable-length layout");
                    let b = -1;
                    try {
                        b = y.reduce((N, R) => N + R.getSpan(), 0)
                    } catch {}
                    super(b, E), this.fields = y, this.decodePrefixes = !!A
                }
                getSpan(y, E) {
                    if (0 <= this.span) return this.span;
                    void 0 === E && (E = 0);
                    let A = 0;
                    try {
                        A = this.fields.reduce((b, N) => {
                            const R = N.getSpan(y, E);
                            return E += R, b + R
                        }, 0)
                    } catch {
                        throw new RangeError("indeterminate span")
                    }
                    return A
                }
                decode(y, E) {
                    void 0 === E && (E = 0);
                    const A = this.makeDestinationObject();
                    for (const b of this.fields)
                        if (void 0 !== b.property && (A[b.property] = b.decode(y, E)), E += b.getSpan(y, E), this.decodePrefixes && y.length === E) break;
                    return A
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = A;
                    let N = 0,
                        R = 0;
                    for (const Q of this.fields) {
                        let Ee = Q.span;
                        if (R = 0 < Ee ? Ee : 0, void 0 !== Q.property) {
                            const Fe = y[Q.property];
                            void 0 !== Fe && (R = Q.encode(Fe, E, A), 0 > Ee && (Ee = Q.getSpan(E, A)))
                        }
                        N = A, A += Ee
                    }
                    return N + R - b
                }
                fromArray(y) {
                    const E = this.makeDestinationObject();
                    for (const A of this.fields) void 0 !== A.property && 0 < y.length && (E[A.property] = y.shift());
                    return E
                }
                layoutFor(y) {
                    if ("string" != typeof y) throw new TypeError("property must be string");
                    for (const E of this.fields)
                        if (E.property === y) return E
                }
                offsetOf(y) {
                    if ("string" != typeof y) throw new TypeError("property must be string");
                    let E = 0;
                    for (const A of this.fields) {
                        if (A.property === y) return E;
                        0 > A.span ? E = -1 : 0 <= E && (E += A.span)
                    }
                }
            }
            class Le {
                constructor(y) {
                    this.property = y
                }
                decode() {
                    throw new Error("UnionDiscriminator is abstract")
                }
                encode() {
                    throw new Error("UnionDiscriminator is abstract")
                }
            }
            class L extends Le {
                constructor(y, E) {
                    if (!(y instanceof q && y.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                    super(E || y.property || "variant"), this.layout = y
                }
                decode(y, E) {
                    return this.layout.decode(y, E)
                }
                encode(y, E, A) {
                    return this.layout.encode(y, E, A)
                }
            }
            class ue extends T {
                constructor(y, E, A) {
                    const b = y instanceof j || y instanceof C;
                    if (b) y = new L(new S(y));
                    else if (y instanceof q && y.isCount()) y = new L(y);
                    else if (!(y instanceof Le)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                    if (void 0 === E && (E = null), !(null === E || E instanceof T)) throw new TypeError("defaultLayout must be null or a Layout");
                    if (null !== E) {
                        if (0 > E.span) throw new Error("defaultLayout must have constant span");
                        void 0 === E.property && (E = E.replicate("content"))
                    }
                    let N = -1;
                    E && (N = E.span, 0 <= N && b && (N += y.layout.span)), super(N, A), this.discriminator = y, this.usesPrefixDiscriminator = b, this.defaultLayout = E, this.registry = {};
                    let R = this.defaultGetSourceVariant.bind(this);
                    this.getSourceVariant = function(Q) {
                        return R(Q)
                    }, this.configGetSourceVariant = function(Q) {
                        R = Q.bind(this)
                    }
                }
                getSpan(y, E) {
                    if (0 <= this.span) return this.span;
                    void 0 === E && (E = 0);
                    const A = this.getVariant(y, E);
                    if (!A) throw new Error("unable to determine span for unrecognized variant");
                    return A.getSpan(y, E)
                }
                defaultGetSourceVariant(y) {
                    if (y.hasOwnProperty(this.discriminator.property)) {
                        if (this.defaultLayout && y.hasOwnProperty(this.defaultLayout.property)) return;
                        const E = this.registry[y[this.discriminator.property]];
                        if (E && (!E.layout || y.hasOwnProperty(E.property))) return E
                    } else
                        for (const E in this.registry) {
                            const A = this.registry[E];
                            if (y.hasOwnProperty(A.property)) return A
                        }
                    throw new Error("unable to infer src variant")
                }
                decode(y, E) {
                    let A;
                    void 0 === E && (E = 0);
                    const b = this.discriminator,
                        N = b.decode(y, E);
                    let R = this.registry[N];
                    if (void 0 === R) {
                        let Q = 0;
                        R = this.defaultLayout, this.usesPrefixDiscriminator && (Q = b.layout.span), A = this.makeDestinationObject(), A[b.property] = N, A[R.property] = this.defaultLayout.decode(y, E + Q)
                    } else A = R.decode(y, E);
                    return A
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = this.getSourceVariant(y);
                    if (void 0 === b) {
                        const N = this.discriminator,
                            R = this.defaultLayout;
                        let Q = 0;
                        return this.usesPrefixDiscriminator && (Q = N.layout.span), N.encode(y[N.property], E, A), Q + R.encode(y[R.property], E, A + Q)
                    }
                    return b.encode(y, E, A)
                }
                addVariant(y, E, A) {
                    const b = new Te(this, y, E, A);
                    return this.registry[y] = b, b
                }
                getVariant(y, E) {
                    let A = y;
                    return Buffer.isBuffer(y) && (void 0 === E && (E = 0), A = this.discriminator.decode(y, E)), this.registry[A]
                }
            }
            class Te extends T {
                constructor(y, E, A, b) {
                    if (!(y instanceof ue)) throw new TypeError("union must be a Union");
                    if (!Number.isInteger(E) || 0 > E) throw new TypeError("variant must be a (non-negative) integer");
                    if ("string" == typeof A && void 0 === b && (b = A, A = null), A) {
                        if (!(A instanceof T)) throw new TypeError("layout must be a Layout");
                        if (null !== y.defaultLayout && 0 <= A.span && A.span > y.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                        if ("string" != typeof b) throw new TypeError("variant must have a String property")
                    }
                    let N = y.span;
                    0 > y.span && (N = A ? A.span : 0, 0 <= N && y.usesPrefixDiscriminator && (N += y.discriminator.layout.span)), super(N, b), this.union = y, this.variant = E, this.layout = A || null
                }
                getSpan(y, E) {
                    if (0 <= this.span) return this.span;
                    void 0 === E && (E = 0);
                    let A = 0;
                    return this.union.usesPrefixDiscriminator && (A = this.union.discriminator.layout.span), A + this.layout.getSpan(y, E + A)
                }
                decode(y, E) {
                    const A = this.makeDestinationObject();
                    if (void 0 === E && (E = 0), this !== this.union.getVariant(y, E)) throw new Error("variant mismatch");
                    let b = 0;
                    return this.union.usesPrefixDiscriminator && (b = this.union.discriminator.layout.span), this.layout ? A[this.property] = this.layout.decode(y, E + b) : this.property ? A[this.property] = !0 : this.union.usesPrefixDiscriminator && (A[this.union.discriminator.property] = this.variant), A
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    let b = 0;
                    if (this.union.usesPrefixDiscriminator && (b = this.union.discriminator.layout.span), this.layout && !y.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                    this.union.discriminator.encode(this.variant, E, A);
                    let N = b;
                    if (this.layout && (this.layout.encode(y[this.property], E, A + b), N += this.layout.getSpan(E, A + b), 0 <= this.union.span && N > this.union.span)) throw new Error("encoded variant overruns containing union");
                    return N
                }
                fromArray(y) {
                    if (this.layout) return this.layout.fromArray(y)
                }
            }

            function xe(G) {
                return 0 > G && (G += 4294967296), G
            }
            class Ae extends T {
                constructor(y, E, A) {
                    if (!(y instanceof j || y instanceof C)) throw new TypeError("word must be a UInt or UIntBE layout");
                    if ("string" == typeof E && void 0 === A && (A = E, E = void 0), 4 < y.span) throw new RangeError("word cannot exceed 32 bits");
                    super(y.span, A), this.word = y, this.msb = !!E, this.fields = [];
                    let b = 0;
                    this._packedSetValue = function(N) {
                        return b = xe(N), this
                    }, this._packedGetValue = function() {
                        return b
                    }
                }
                decode(y, E) {
                    const A = this.makeDestinationObject();
                    void 0 === E && (E = 0);
                    const b = this.word.decode(y, E);
                    this._packedSetValue(b);
                    for (const N of this.fields) void 0 !== N.property && (A[N.property] = N.decode(b));
                    return A
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0);
                    const b = this.word.decode(E, A);
                    this._packedSetValue(b);
                    for (const N of this.fields)
                        if (void 0 !== N.property) {
                            const R = y[N.property];
                            void 0 !== R && N.encode(R)
                        }
                    return this.word.encode(this._packedGetValue(), E, A)
                }
                addField(y, E) {
                    const A = new Ie(this, y, E);
                    return this.fields.push(A), A
                }
                addBoolean(y) {
                    const E = new $(this, y);
                    return this.fields.push(E), E
                }
                fieldFor(y) {
                    if ("string" != typeof y) throw new TypeError("property must be string");
                    for (const E of this.fields)
                        if (E.property === y) return E
                }
            }
            class Ie {
                constructor(y, E, A) {
                    if (!(y instanceof Ae)) throw new TypeError("container must be a BitStructure");
                    if (!Number.isInteger(E) || 0 >= E) throw new TypeError("bits must be positive integer");
                    const b = 8 * y.span,
                        N = y.fields.reduce((R, Q) => R + Q.bits, 0);
                    if (E + N > b) throw new Error("bits too long for span remainder (" + (b - N) + " of " + b + " remain)");
                    this.container = y, this.bits = E, this.valueMask = (1 << E) - 1, 32 === E && (this.valueMask = 4294967295), this.start = N, this.container.msb && (this.start = b - N - E), this.wordMask = xe(this.valueMask << this.start), this.property = A
                }
                decode() {
                    return xe(this.container._packedGetValue() & this.wordMask) >>> this.start
                }
                encode(y) {
                    if (!Number.isInteger(y) || y !== xe(y & this.valueMask)) throw new TypeError(F("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                    const E = this.container._packedGetValue(),
                        A = xe(y << this.start);
                    this.container._packedSetValue(xe(E & ~this.wordMask) | A)
                }
            }
            class $ extends Ie {
                constructor(y, E) {
                    super(y, 1, E)
                }
                decode(y, E) {
                    return !!Ie.prototype.decode.call(this, y, E)
                }
                encode(y) {
                    return "boolean" == typeof y && (y = +y), Ie.prototype.encode.call(this, y)
                }
            }
            class f extends T {
                constructor(y, E) {
                    if (!(y instanceof q && y.isCount() || Number.isInteger(y) && 0 <= y)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                    let A = -1;
                    y instanceof q || (A = y), super(A, E), this.length = y
                }
                getSpan(y, E) {
                    let A = this.span;
                    return 0 > A && (A = this.length.decode(y, E)), A
                }
                decode(y, E) {
                    void 0 === E && (E = 0);
                    let A = this.span;
                    return 0 > A && (A = this.length.decode(y, E)), y.slice(E, E + A)
                }
                encode(y, E, A) {
                    let b = this.length;
                    if (this.length instanceof q && (b = y.length), !Buffer.isBuffer(y) || b !== y.length) throw new TypeError(F("Blob.encode", this) + " requires (length " + b + ") Buffer as src");
                    if (A + b > E.length) throw new RangeError("encoding overruns Buffer");
                    return E.write(y.toString("hex"), A, b, "hex"), this.length instanceof q && this.length.encode(b, E, A), b
                }
            }
            class v extends T {
                constructor(y) {
                    super(-1, y)
                }
                getSpan(y, E) {
                    if (!Buffer.isBuffer(y)) throw new TypeError("b must be a Buffer");
                    void 0 === E && (E = 0);
                    let A = E;
                    for (; A < y.length && 0 !== y[A];) A += 1;
                    return 1 + A - E
                }
                decode(y, E, A) {
                    void 0 === E && (E = 0);
                    let b = this.getSpan(y, E);
                    return y.slice(E, E + b - 1).toString("utf-8")
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0), "string" != typeof y && (y = y.toString());
                    const b = new Buffer(y, "utf8"),
                        N = b.length;
                    if (A + N > E.length) throw new RangeError("encoding overruns Buffer");
                    return b.copy(E, A), E[A + N] = 0, N + 1
                }
            }
            class M extends T {
                constructor(y, E) {
                    if ("string" == typeof y && void 0 === E && (E = y, y = void 0), void 0 === y) y = -1;
                    else if (!Number.isInteger(y)) throw new TypeError("maxSpan must be an integer");
                    super(-1, E), this.maxSpan = y
                }
                getSpan(y, E) {
                    if (!Buffer.isBuffer(y)) throw new TypeError("b must be a Buffer");
                    return void 0 === E && (E = 0), y.length - E
                }
                decode(y, E, A) {
                    void 0 === E && (E = 0);
                    let b = this.getSpan(y, E);
                    if (0 <= this.maxSpan && this.maxSpan < b) throw new RangeError("text length exceeds maxSpan");
                    return y.slice(E, E + b).toString("utf-8")
                }
                encode(y, E, A) {
                    void 0 === A && (A = 0), "string" != typeof y && (y = y.toString());
                    const b = new Buffer(y, "utf8"),
                        N = b.length;
                    if (0 <= this.maxSpan && this.maxSpan < N) throw new RangeError("text length exceeds maxSpan");
                    if (A + N > E.length) throw new RangeError("encoding overruns Buffer");
                    return b.copy(E, A), N
                }
            }
            class U extends T {
                constructor(y, E) {
                    super(0, E), this.value = y
                }
                decode(y, E, A) {
                    return this.value
                }
                encode(y, E, A) {
                    return 0
                }
            }
            I.ExternalLayout = q, I.GreedyCount = ne, I.OffsetLayout = S, I.UInt = j, I.UIntBE = C, I.Int = z, I.IntBE = H, I.Float = Ce, I.FloatBE = we, I.Double = ve, I.DoubleBE = De, I.Sequence = ae, I.Structure = Me, I.UnionDiscriminator = Le, I.UnionLayoutDiscriminator = L, I.Union = ue, I.VariantLayout = Te, I.BitStructure = Ae, I.BitField = Ie, I.Boolean = $, I.Blob = f, I.CString = v, I.UTF8 = M, I.Constant = U, I.greedy = (G, y) => new ne(G, y), I.offset = (G, y, E) => new S(G, y, E), I.u8 = G => new j(1, G), I.u16 = G => new j(2, G), I.u24 = G => new j(3, G), I.u32 = G => new j(4, G), I.u40 = G => new j(5, G), I.u48 = G => new j(6, G), I.nu64 = G => new re(G), I.u16be = G => new C(2, G), I.u24be = G => new C(3, G), I.u32be = G => new C(4, G), I.u40be = G => new C(5, G), I.u48be = G => new C(6, G), I.nu64be = G => new de(G), I.s8 = G => new z(1, G), I.s16 = G => new z(2, G), I.s24 = G => new z(3, G), I.s32 = G => new z(4, G), I.s40 = G => new z(5, G), I.s48 = G => new z(6, G), I.ns64 = G => new Se(G), I.s16be = G => new H(2, G), I.s24be = G => new H(3, G), I.s32be = G => new H(4, G), I.s40be = G => new H(5, G), I.s48be = G => new H(6, G), I.ns64be = G => new me(G), I.f32 = G => new Ce(G), I.f32be = G => new we(G), I.f64 = G => new ve(G), I.f64be = G => new De(G), I.struct = (G, y, E) => new Me(G, y, E), I.bits = (G, y, E) => new Ae(G, y, E), I.seq = (G, y, E) => new ae(G, y, E), I.union = (G, y, E) => new ue(G, y, E), I.unionLayoutDiscriminator = (G, y) => new L(G, y), I.blob = (G, y) => new f(G, y), I.cstr = G => new v(G), I.utf8 = (G, y) => new M(G, y), I.const = (G, y) => new U(G, y)
        },
        39007: (et, I, T) => {
            "use strict";
            const F = T(9919),
                K = T(22601),
                q = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            I.Buffer = C, I.SlowBuffer = function we(pe) {
                return +pe != pe && (pe = 0), C.alloc(+pe)
            }, I.INSPECT_MAX_BYTES = 50;
            const ne = 2147483647;

            function j(pe) {
                if (pe > ne) throw new RangeError('The value "' + pe + '" is invalid for option "size"');
                const O = new Uint8Array(pe);
                return Object.setPrototypeOf(O, C.prototype), O
            }

            function C(pe, O, W) {
                if ("number" == typeof pe) {
                    if ("string" == typeof O) throw new TypeError('The "string" argument must be of type string. Received type number');
                    return Z(pe)
                }
                return z(pe, O, W)
            }

            function z(pe, O, W) {
                if ("string" == typeof pe) return function le(pe, O) {
                    if (("string" != typeof O || "" === O) && (O = "utf8"), !C.isEncoding(O)) throw new TypeError("Unknown encoding: " + O);
                    const W = 0 | ve(pe, O);
                    let ke = j(W);
                    const je = ke.write(pe, O);
                    return je !== W && (ke = ke.slice(0, je)), ke
                }(pe, O);
                if (ArrayBuffer.isView(pe)) return function de(pe) {
                    if (kn(pe, Uint8Array)) {
                        const O = new Uint8Array(pe);
                        return Se(O.buffer, O.byteOffset, O.byteLength)
                    }
                    return re(pe)
                }(pe);
                if (null == pe) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe);
                if (kn(pe, ArrayBuffer) || pe && kn(pe.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (kn(pe, SharedArrayBuffer) || pe && kn(pe.buffer, SharedArrayBuffer))) return Se(pe, O, W);
                if ("number" == typeof pe) throw new TypeError('The "value" argument must not be of type number. Received type number');
                const ke = pe.valueOf && pe.valueOf();
                if (null != ke && ke !== pe) return C.from(ke, O, W);
                const je = function me(pe) {
                    if (C.isBuffer(pe)) {
                        const O = 0 | Ce(pe.length),
                            W = j(O);
                        return 0 === W.length || pe.copy(W, 0, 0, O), W
                    }
                    return void 0 !== pe.length ? "number" != typeof pe.length || Bi(pe.length) ? j(0) : re(pe) : "Buffer" === pe.type && Array.isArray(pe.data) ? re(pe.data) : void 0
                }(pe);
                if (je) return je;
                if (typeof Symbol < "u" && null != Symbol.toPrimitive && "function" == typeof pe[Symbol.toPrimitive]) return C.from(pe[Symbol.toPrimitive]("string"), O, W);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe)
            }

            function H(pe) {
                if ("number" != typeof pe) throw new TypeError('"size" argument must be of type number');
                if (pe < 0) throw new RangeError('The value "' + pe + '" is invalid for option "size"')
            }

            function Z(pe) {
                return H(pe), j(pe < 0 ? 0 : 0 | Ce(pe))
            }

            function re(pe) {
                const O = pe.length < 0 ? 0 : 0 | Ce(pe.length),
                    W = j(O);
                for (let ke = 0; ke < O; ke += 1) W[ke] = 255 & pe[ke];
                return W
            }

            function Se(pe, O, W) {
                if (O < 0 || pe.byteLength < O) throw new RangeError('"offset" is outside of buffer bounds');
                if (pe.byteLength < O + (W || 0)) throw new RangeError('"length" is outside of buffer bounds');
                let ke;
                return ke = void 0 === O && void 0 === W ? new Uint8Array(pe) : void 0 === W ? new Uint8Array(pe, O) : new Uint8Array(pe, O, W), Object.setPrototypeOf(ke, C.prototype), ke
            }

            function Ce(pe) {
                if (pe >= ne) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ne.toString(16) + " bytes");
                return 0 | pe
            }

            function ve(pe, O) {
                if (C.isBuffer(pe)) return pe.length;
                if (ArrayBuffer.isView(pe) || kn(pe, ArrayBuffer)) return pe.byteLength;
                if ("string" != typeof pe) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof pe);
                const W = pe.length,
                    ke = arguments.length > 2 && !0 === arguments[2];
                if (!ke && 0 === W) return 0;
                let je = !1;
                for (;;) switch (O) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return W;
                    case "utf8":
                    case "utf-8":
                        return An(pe).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * W;
                    case "hex":
                        return W >>> 1;
                    case "base64":
                        return ji(pe).length;
                    default:
                        if (je) return ke ? -1 : An(pe).length;
                        O = ("" + O).toLowerCase(), je = !0
                }
            }

            function De(pe, O, W) {
                let ke = !1;
                if ((void 0 === O || O < 0) && (O = 0), O > this.length || ((void 0 === W || W > this.length) && (W = this.length), W <= 0) || (W >>>= 0) <= (O >>>= 0)) return "";
                for (pe || (pe = "utf8");;) switch (pe) {
                    case "hex":
                        return G(this, O, W);
                    case "utf8":
                    case "utf-8":
                        return $(this, O, W);
                    case "ascii":
                        return M(this, O, W);
                    case "latin1":
                    case "binary":
                        return U(this, O, W);
                    case "base64":
                        return Ie(this, O, W);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return y(this, O, W);
                    default:
                        if (ke) throw new TypeError("Unknown encoding: " + pe);
                        pe = (pe + "").toLowerCase(), ke = !0
                }
            }

            function ae(pe, O, W) {
                const ke = pe[O];
                pe[O] = pe[W], pe[W] = ke
            }

            function Me(pe, O, W, ke, je) {
                if (0 === pe.length) return -1;
                if ("string" == typeof W ? (ke = W, W = 0) : W > 2147483647 ? W = 2147483647 : W < -2147483648 && (W = -2147483648), Bi(W = +W) && (W = je ? 0 : pe.length - 1), W < 0 && (W = pe.length + W), W >= pe.length) {
                    if (je) return -1;
                    W = pe.length - 1
                } else if (W < 0) {
                    if (!je) return -1;
                    W = 0
                }
                if ("string" == typeof O && (O = C.from(O, ke)), C.isBuffer(O)) return 0 === O.length ? -1 : Le(pe, O, W, ke, je);
                if ("number" == typeof O) return O &= 255, "function" == typeof Uint8Array.prototype.indexOf ? je ? Uint8Array.prototype.indexOf.call(pe, O, W) : Uint8Array.prototype.lastIndexOf.call(pe, O, W) : Le(pe, [O], W, ke, je);
                throw new TypeError("val must be string, number or Buffer")
            }

            function Le(pe, O, W, ke, je) {
                let mn, Qe = 1,
                    st = pe.length,
                    tn = O.length;
                if (void 0 !== ke && ("ucs2" === (ke = String(ke).toLowerCase()) || "ucs-2" === ke || "utf16le" === ke || "utf-16le" === ke)) {
                    if (pe.length < 2 || O.length < 2) return -1;
                    Qe = 2, st /= 2, tn /= 2, W /= 2
                }

                function Kn($n, _n) {
                    return 1 === Qe ? $n[_n] : $n.readUInt16BE(_n * Qe)
                }
                if (je) {
                    let $n = -1;
                    for (mn = W; mn < st; mn++)
                        if (Kn(pe, mn) === Kn(O, -1 === $n ? 0 : mn - $n)) {
                            if (-1 === $n && ($n = mn), mn - $n + 1 === tn) return $n * Qe
                        } else -1 !== $n && (mn -= mn - $n), $n = -1
                } else
                    for (W + tn > st && (W = st - tn), mn = W; mn >= 0; mn--) {
                        let $n = !0;
                        for (let _n = 0; _n < tn; _n++)
                            if (Kn(pe, mn + _n) !== Kn(O, _n)) {
                                $n = !1;
                                break
                            }
                        if ($n) return mn
                    }
                return -1
            }

            function L(pe, O, W, ke) {
                W = Number(W) || 0;
                const je = pe.length - W;
                ke ? (ke = Number(ke)) > je && (ke = je) : ke = je;
                const Qe = O.length;
                let st;
                for (ke > Qe / 2 && (ke = Qe / 2), st = 0; st < ke; ++st) {
                    const tn = parseInt(O.substr(2 * st, 2), 16);
                    if (Bi(tn)) return st;
                    pe[W + st] = tn
                }
                return st
            }

            function ue(pe, O, W, ke) {
                return Wn(An(O, pe.length - W), pe, W, ke)
            }

            function Te(pe, O, W, ke) {
                return Wn(function ui(pe) {
                    const O = [];
                    for (let W = 0; W < pe.length; ++W) O.push(255 & pe.charCodeAt(W));
                    return O
                }(O), pe, W, ke)
            }

            function xe(pe, O, W, ke) {
                return Wn(ji(O), pe, W, ke)
            }

            function Ae(pe, O, W, ke) {
                return Wn(function Mi(pe, O) {
                    let W, ke, je;
                    const Qe = [];
                    for (let st = 0; st < pe.length && !((O -= 2) < 0); ++st) W = pe.charCodeAt(st), ke = W >> 8, je = W % 256, Qe.push(je), Qe.push(ke);
                    return Qe
                }(O, pe.length - W), pe, W, ke)
            }

            function Ie(pe, O, W) {
                return F.fromByteArray(0 === O && W === pe.length ? pe : pe.slice(O, W))
            }

            function $(pe, O, W) {
                W = Math.min(pe.length, W);
                const ke = [];
                let je = O;
                for (; je < W;) {
                    const Qe = pe[je];
                    let st = null,
                        tn = Qe > 239 ? 4 : Qe > 223 ? 3 : Qe > 191 ? 2 : 1;
                    if (je + tn <= W) {
                        let Kn, mn, $n, _n;
                        switch (tn) {
                            case 1:
                                Qe < 128 && (st = Qe);
                                break;
                            case 2:
                                Kn = pe[je + 1], 128 == (192 & Kn) && (_n = (31 & Qe) << 6 | 63 & Kn, _n > 127 && (st = _n));
                                break;
                            case 3:
                                Kn = pe[je + 1], mn = pe[je + 2], 128 == (192 & Kn) && 128 == (192 & mn) && (_n = (15 & Qe) << 12 | (63 & Kn) << 6 | 63 & mn, _n > 2047 && (_n < 55296 || _n > 57343) && (st = _n));
                                break;
                            case 4:
                                Kn = pe[je + 1], mn = pe[je + 2], $n = pe[je + 3], 128 == (192 & Kn) && 128 == (192 & mn) && 128 == (192 & $n) && (_n = (15 & Qe) << 18 | (63 & Kn) << 12 | (63 & mn) << 6 | 63 & $n, _n > 65535 && _n < 1114112 && (st = _n))
                        }
                    }
                    null === st ? (st = 65533, tn = 1) : st > 65535 && (st -= 65536, ke.push(st >>> 10 & 1023 | 55296), st = 56320 | 1023 & st), ke.push(st), je += tn
                }
                return function v(pe) {
                    const O = pe.length;
                    if (O <= f) return String.fromCharCode.apply(String, pe);
                    let W = "",
                        ke = 0;
                    for (; ke < O;) W += String.fromCharCode.apply(String, pe.slice(ke, ke += f));
                    return W
                }(ke)
            }
            I.kMaxLength = ne, !(C.TYPED_ARRAY_SUPPORT = function S() {
                try {
                    const pe = new Uint8Array(1),
                        O = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(O, Uint8Array.prototype), Object.setPrototypeOf(pe, O), 42 === pe.foo()
                } catch {
                    return !1
                }
            }()) && typeof console < "u" && "function" == typeof console.error && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(C.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (C.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(C.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (C.isBuffer(this)) return this.byteOffset
                }
            }), C.poolSize = 8192, C.from = function(pe, O, W) {
                return z(pe, O, W)
            }, Object.setPrototypeOf(C.prototype, Uint8Array.prototype), Object.setPrototypeOf(C, Uint8Array), C.alloc = function(pe, O, W) {
                return function Y(pe, O, W) {
                    return H(pe), pe <= 0 ? j(pe) : void 0 !== O ? "string" == typeof W ? j(pe).fill(O, W) : j(pe).fill(O) : j(pe)
                }(pe, O, W)
            }, C.allocUnsafe = function(pe) {
                return Z(pe)
            }, C.allocUnsafeSlow = function(pe) {
                return Z(pe)
            }, C.isBuffer = function(O) {
                return null != O && !0 === O._isBuffer && O !== C.prototype
            }, C.compare = function(O, W) {
                if (kn(O, Uint8Array) && (O = C.from(O, O.offset, O.byteLength)), kn(W, Uint8Array) && (W = C.from(W, W.offset, W.byteLength)), !C.isBuffer(O) || !C.isBuffer(W)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (O === W) return 0;
                let ke = O.length,
                    je = W.length;
                for (let Qe = 0, st = Math.min(ke, je); Qe < st; ++Qe)
                    if (O[Qe] !== W[Qe]) {
                        ke = O[Qe], je = W[Qe];
                        break
                    }
                return ke < je ? -1 : je < ke ? 1 : 0
            }, C.isEncoding = function(O) {
                switch (String(O).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, C.concat = function(O, W) {
                if (!Array.isArray(O)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === O.length) return C.alloc(0);
                let ke;
                if (void 0 === W)
                    for (W = 0, ke = 0; ke < O.length; ++ke) W += O[ke].length;
                const je = C.allocUnsafe(W);
                let Qe = 0;
                for (ke = 0; ke < O.length; ++ke) {
                    let st = O[ke];
                    if (kn(st, Uint8Array)) Qe + st.length > je.length ? (C.isBuffer(st) || (st = C.from(st)), st.copy(je, Qe)) : Uint8Array.prototype.set.call(je, st, Qe);
                    else {
                        if (!C.isBuffer(st)) throw new TypeError('"list" argument must be an Array of Buffers');
                        st.copy(je, Qe)
                    }
                    Qe += st.length
                }
                return je
            }, C.byteLength = ve, C.prototype._isBuffer = !0, C.prototype.swap16 = function() {
                const O = this.length;
                if (O % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let W = 0; W < O; W += 2) ae(this, W, W + 1);
                return this
            }, C.prototype.swap32 = function() {
                const O = this.length;
                if (O % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let W = 0; W < O; W += 4) ae(this, W, W + 3), ae(this, W + 1, W + 2);
                return this
            }, C.prototype.swap64 = function() {
                const O = this.length;
                if (O % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let W = 0; W < O; W += 8) ae(this, W, W + 7), ae(this, W + 1, W + 6), ae(this, W + 2, W + 5), ae(this, W + 3, W + 4);
                return this
            }, C.prototype.toLocaleString = C.prototype.toString = function() {
                const O = this.length;
                return 0 === O ? "" : 0 === arguments.length ? $(this, 0, O) : De.apply(this, arguments)
            }, C.prototype.equals = function(O) {
                if (!C.isBuffer(O)) throw new TypeError("Argument must be a Buffer");
                return this === O || 0 === C.compare(this, O)
            }, C.prototype.inspect = function() {
                let O = "";
                const W = I.INSPECT_MAX_BYTES;
                return O = this.toString("hex", 0, W).replace(/(.{2})/g, "$1 ").trim(), this.length > W && (O += " ... "), "<Buffer " + O + ">"
            }, q && (C.prototype[q] = C.prototype.inspect), C.prototype.compare = function(O, W, ke, je, Qe) {
                if (kn(O, Uint8Array) && (O = C.from(O, O.offset, O.byteLength)), !C.isBuffer(O)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof O);
                if (void 0 === W && (W = 0), void 0 === ke && (ke = O ? O.length : 0), void 0 === je && (je = 0), void 0 === Qe && (Qe = this.length), W < 0 || ke > O.length || je < 0 || Qe > this.length) throw new RangeError("out of range index");
                if (je >= Qe && W >= ke) return 0;
                if (je >= Qe) return -1;
                if (W >= ke) return 1;
                if (this === O) return 0;
                let st = (Qe >>>= 0) - (je >>>= 0),
                    tn = (ke >>>= 0) - (W >>>= 0);
                const Kn = Math.min(st, tn),
                    mn = this.slice(je, Qe),
                    $n = O.slice(W, ke);
                for (let _n = 0; _n < Kn; ++_n)
                    if (mn[_n] !== $n[_n]) {
                        st = mn[_n], tn = $n[_n];
                        break
                    }
                return st < tn ? -1 : tn < st ? 1 : 0
            }, C.prototype.includes = function(O, W, ke) {
                return -1 !== this.indexOf(O, W, ke)
            }, C.prototype.indexOf = function(O, W, ke) {
                return Me(this, O, W, ke, !0)
            }, C.prototype.lastIndexOf = function(O, W, ke) {
                return Me(this, O, W, ke, !1)
            }, C.prototype.write = function(O, W, ke, je) {
                if (void 0 === W) je = "utf8", ke = this.length, W = 0;
                else if (void 0 === ke && "string" == typeof W) je = W, ke = this.length, W = 0;
                else {
                    if (!isFinite(W)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    W >>>= 0, isFinite(ke) ? (ke >>>= 0, void 0 === je && (je = "utf8")) : (je = ke, ke = void 0)
                }
                const Qe = this.length - W;
                if ((void 0 === ke || ke > Qe) && (ke = Qe), O.length > 0 && (ke < 0 || W < 0) || W > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                je || (je = "utf8");
                let st = !1;
                for (;;) switch (je) {
                    case "hex":
                        return L(this, O, W, ke);
                    case "utf8":
                    case "utf-8":
                        return ue(this, O, W, ke);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return Te(this, O, W, ke);
                    case "base64":
                        return xe(this, O, W, ke);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return Ae(this, O, W, ke);
                    default:
                        if (st) throw new TypeError("Unknown encoding: " + je);
                        je = ("" + je).toLowerCase(), st = !0
                }
            }, C.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            };
            const f = 4096;

            function M(pe, O, W) {
                let ke = "";
                W = Math.min(pe.length, W);
                for (let je = O; je < W; ++je) ke += String.fromCharCode(127 & pe[je]);
                return ke
            }

            function U(pe, O, W) {
                let ke = "";
                W = Math.min(pe.length, W);
                for (let je = O; je < W; ++je) ke += String.fromCharCode(pe[je]);
                return ke
            }

            function G(pe, O, W) {
                const ke = pe.length;
                (!O || O < 0) && (O = 0), (!W || W < 0 || W > ke) && (W = ke);
                let je = "";
                for (let Qe = O; Qe < W; ++Qe) je += ci[pe[Qe]];
                return je
            }

            function y(pe, O, W) {
                const ke = pe.slice(O, W);
                let je = "";
                for (let Qe = 0; Qe < ke.length - 1; Qe += 2) je += String.fromCharCode(ke[Qe] + 256 * ke[Qe + 1]);
                return je
            }

            function E(pe, O, W) {
                if (pe % 1 != 0 || pe < 0) throw new RangeError("offset is not uint");
                if (pe + O > W) throw new RangeError("Trying to access beyond buffer length")
            }

            function A(pe, O, W, ke, je, Qe) {
                if (!C.isBuffer(pe)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (O > je || O < Qe) throw new RangeError('"value" argument is out of bounds');
                if (W + ke > pe.length) throw new RangeError("Index out of range")
            }

            function b(pe, O, W, ke, je) {
                Mt(O, ke, je, pe, W, 7);
                let Qe = Number(O & BigInt(4294967295));
                pe[W++] = Qe, Qe >>= 8, pe[W++] = Qe, Qe >>= 8, pe[W++] = Qe, Qe >>= 8, pe[W++] = Qe;
                let st = Number(O >> BigInt(32) & BigInt(4294967295));
                return pe[W++] = st, st >>= 8, pe[W++] = st, st >>= 8, pe[W++] = st, st >>= 8, pe[W++] = st, W
            }

            function N(pe, O, W, ke, je) {
                Mt(O, ke, je, pe, W, 7);
                let Qe = Number(O & BigInt(4294967295));
                pe[W + 7] = Qe, Qe >>= 8, pe[W + 6] = Qe, Qe >>= 8, pe[W + 5] = Qe, Qe >>= 8, pe[W + 4] = Qe;
                let st = Number(O >> BigInt(32) & BigInt(4294967295));
                return pe[W + 3] = st, st >>= 8, pe[W + 2] = st, st >>= 8, pe[W + 1] = st, st >>= 8, pe[W] = st, W + 8
            }

            function R(pe, O, W, ke, je, Qe) {
                if (W + ke > pe.length) throw new RangeError("Index out of range");
                if (W < 0) throw new RangeError("Index out of range")
            }

            function Q(pe, O, W, ke, je) {
                return O = +O, W >>>= 0, je || R(pe, 0, W, 4), K.write(pe, O, W, ke, 23, 4), W + 4
            }

            function Ee(pe, O, W, ke, je) {
                return O = +O, W >>>= 0, je || R(pe, 0, W, 8), K.write(pe, O, W, ke, 52, 8), W + 8
            }
            C.prototype.slice = function(O, W) {
                const ke = this.length;
                (O = ~~O) < 0 ? (O += ke) < 0 && (O = 0) : O > ke && (O = ke), (W = void 0 === W ? ke : ~~W) < 0 ? (W += ke) < 0 && (W = 0) : W > ke && (W = ke), W < O && (W = O);
                const je = this.subarray(O, W);
                return Object.setPrototypeOf(je, C.prototype), je
            }, C.prototype.readUintLE = C.prototype.readUIntLE = function(O, W, ke) {
                O >>>= 0, W >>>= 0, ke || E(O, W, this.length);
                let je = this[O],
                    Qe = 1,
                    st = 0;
                for (; ++st < W && (Qe *= 256);) je += this[O + st] * Qe;
                return je
            }, C.prototype.readUintBE = C.prototype.readUIntBE = function(O, W, ke) {
                O >>>= 0, W >>>= 0, ke || E(O, W, this.length);
                let je = this[O + --W],
                    Qe = 1;
                for (; W > 0 && (Qe *= 256);) je += this[O + --W] * Qe;
                return je
            }, C.prototype.readUint8 = C.prototype.readUInt8 = function(O, W) {
                return O >>>= 0, W || E(O, 1, this.length), this[O]
            }, C.prototype.readUint16LE = C.prototype.readUInt16LE = function(O, W) {
                return O >>>= 0, W || E(O, 2, this.length), this[O] | this[O + 1] << 8
            }, C.prototype.readUint16BE = C.prototype.readUInt16BE = function(O, W) {
                return O >>>= 0, W || E(O, 2, this.length), this[O] << 8 | this[O + 1]
            }, C.prototype.readUint32LE = C.prototype.readUInt32LE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), (this[O] | this[O + 1] << 8 | this[O + 2] << 16) + 16777216 * this[O + 3]
            }, C.prototype.readUint32BE = C.prototype.readUInt32BE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), 16777216 * this[O] + (this[O + 1] << 16 | this[O + 2] << 8 | this[O + 3])
            }, C.prototype.readBigUInt64LE = en(function(O) {
                sn(O >>>= 0, "offset");
                const W = this[O],
                    ke = this[O + 7];
                (void 0 === W || void 0 === ke) && ei(O, this.length - 8);
                const je = W + 256 * this[++O] + 65536 * this[++O] + this[++O] * 2 ** 24,
                    Qe = this[++O] + 256 * this[++O] + 65536 * this[++O] + ke * 2 ** 24;
                return BigInt(je) + (BigInt(Qe) << BigInt(32))
            }), C.prototype.readBigUInt64BE = en(function(O) {
                sn(O >>>= 0, "offset");
                const W = this[O],
                    ke = this[O + 7];
                (void 0 === W || void 0 === ke) && ei(O, this.length - 8);
                const je = W * 2 ** 24 + 65536 * this[++O] + 256 * this[++O] + this[++O],
                    Qe = this[++O] * 2 ** 24 + 65536 * this[++O] + 256 * this[++O] + ke;
                return (BigInt(je) << BigInt(32)) + BigInt(Qe)
            }), C.prototype.readIntLE = function(O, W, ke) {
                O >>>= 0, W >>>= 0, ke || E(O, W, this.length);
                let je = this[O],
                    Qe = 1,
                    st = 0;
                for (; ++st < W && (Qe *= 256);) je += this[O + st] * Qe;
                return Qe *= 128, je >= Qe && (je -= Math.pow(2, 8 * W)), je
            }, C.prototype.readIntBE = function(O, W, ke) {
                O >>>= 0, W >>>= 0, ke || E(O, W, this.length);
                let je = W,
                    Qe = 1,
                    st = this[O + --je];
                for (; je > 0 && (Qe *= 256);) st += this[O + --je] * Qe;
                return Qe *= 128, st >= Qe && (st -= Math.pow(2, 8 * W)), st
            }, C.prototype.readInt8 = function(O, W) {
                return O >>>= 0, W || E(O, 1, this.length), 128 & this[O] ? -1 * (255 - this[O] + 1) : this[O]
            }, C.prototype.readInt16LE = function(O, W) {
                O >>>= 0, W || E(O, 2, this.length);
                const ke = this[O] | this[O + 1] << 8;
                return 32768 & ke ? 4294901760 | ke : ke
            }, C.prototype.readInt16BE = function(O, W) {
                O >>>= 0, W || E(O, 2, this.length);
                const ke = this[O + 1] | this[O] << 8;
                return 32768 & ke ? 4294901760 | ke : ke
            }, C.prototype.readInt32LE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), this[O] | this[O + 1] << 8 | this[O + 2] << 16 | this[O + 3] << 24
            }, C.prototype.readInt32BE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), this[O] << 24 | this[O + 1] << 16 | this[O + 2] << 8 | this[O + 3]
            }, C.prototype.readBigInt64LE = en(function(O) {
                sn(O >>>= 0, "offset");
                const W = this[O],
                    ke = this[O + 7];
                return (void 0 === W || void 0 === ke) && ei(O, this.length - 8), (BigInt(this[O + 4] + 256 * this[O + 5] + 65536 * this[O + 6] + (ke << 24)) << BigInt(32)) + BigInt(W + 256 * this[++O] + 65536 * this[++O] + this[++O] * 2 ** 24)
            }), C.prototype.readBigInt64BE = en(function(O) {
                sn(O >>>= 0, "offset");
                const W = this[O],
                    ke = this[O + 7];
                (void 0 === W || void 0 === ke) && ei(O, this.length - 8);
                const je = (W << 24) + 65536 * this[++O] + 256 * this[++O] + this[++O];
                return (BigInt(je) << BigInt(32)) + BigInt(this[++O] * 2 ** 24 + 65536 * this[++O] + 256 * this[++O] + ke)
            }), C.prototype.readFloatLE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), K.read(this, O, !0, 23, 4)
            }, C.prototype.readFloatBE = function(O, W) {
                return O >>>= 0, W || E(O, 4, this.length), K.read(this, O, !1, 23, 4)
            }, C.prototype.readDoubleLE = function(O, W) {
                return O >>>= 0, W || E(O, 8, this.length), K.read(this, O, !0, 52, 8)
            }, C.prototype.readDoubleBE = function(O, W) {
                return O >>>= 0, W || E(O, 8, this.length), K.read(this, O, !1, 52, 8)
            }, C.prototype.writeUintLE = C.prototype.writeUIntLE = function(O, W, ke, je) {
                O = +O, W >>>= 0, ke >>>= 0, je || A(this, O, W, ke, Math.pow(2, 8 * ke) - 1, 0);
                let Qe = 1,
                    st = 0;
                for (this[W] = 255 & O; ++st < ke && (Qe *= 256);) this[W + st] = O / Qe & 255;
                return W + ke
            }, C.prototype.writeUintBE = C.prototype.writeUIntBE = function(O, W, ke, je) {
                O = +O, W >>>= 0, ke >>>= 0, je || A(this, O, W, ke, Math.pow(2, 8 * ke) - 1, 0);
                let Qe = ke - 1,
                    st = 1;
                for (this[W + Qe] = 255 & O; --Qe >= 0 && (st *= 256);) this[W + Qe] = O / st & 255;
                return W + ke
            }, C.prototype.writeUint8 = C.prototype.writeUInt8 = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 1, 255, 0), this[W] = 255 & O, W + 1
            }, C.prototype.writeUint16LE = C.prototype.writeUInt16LE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 2, 65535, 0), this[W] = 255 & O, this[W + 1] = O >>> 8, W + 2
            }, C.prototype.writeUint16BE = C.prototype.writeUInt16BE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 2, 65535, 0), this[W] = O >>> 8, this[W + 1] = 255 & O, W + 2
            }, C.prototype.writeUint32LE = C.prototype.writeUInt32LE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 4, 4294967295, 0), this[W + 3] = O >>> 24, this[W + 2] = O >>> 16, this[W + 1] = O >>> 8, this[W] = 255 & O, W + 4
            }, C.prototype.writeUint32BE = C.prototype.writeUInt32BE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 4, 4294967295, 0), this[W] = O >>> 24, this[W + 1] = O >>> 16, this[W + 2] = O >>> 8, this[W + 3] = 255 & O, W + 4
            }, C.prototype.writeBigUInt64LE = en(function(O, W = 0) {
                return b(this, O, W, BigInt(0), BigInt("0xffffffffffffffff"))
            }), C.prototype.writeBigUInt64BE = en(function(O, W = 0) {
                return N(this, O, W, BigInt(0), BigInt("0xffffffffffffffff"))
            }), C.prototype.writeIntLE = function(O, W, ke, je) {
                if (O = +O, W >>>= 0, !je) {
                    const Kn = Math.pow(2, 8 * ke - 1);
                    A(this, O, W, ke, Kn - 1, -Kn)
                }
                let Qe = 0,
                    st = 1,
                    tn = 0;
                for (this[W] = 255 & O; ++Qe < ke && (st *= 256);) O < 0 && 0 === tn && 0 !== this[W + Qe - 1] && (tn = 1), this[W + Qe] = (O / st >> 0) - tn & 255;
                return W + ke
            }, C.prototype.writeIntBE = function(O, W, ke, je) {
                if (O = +O, W >>>= 0, !je) {
                    const Kn = Math.pow(2, 8 * ke - 1);
                    A(this, O, W, ke, Kn - 1, -Kn)
                }
                let Qe = ke - 1,
                    st = 1,
                    tn = 0;
                for (this[W + Qe] = 255 & O; --Qe >= 0 && (st *= 256);) O < 0 && 0 === tn && 0 !== this[W + Qe + 1] && (tn = 1), this[W + Qe] = (O / st >> 0) - tn & 255;
                return W + ke
            }, C.prototype.writeInt8 = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 1, 127, -128), O < 0 && (O = 255 + O + 1), this[W] = 255 & O, W + 1
            }, C.prototype.writeInt16LE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 2, 32767, -32768), this[W] = 255 & O, this[W + 1] = O >>> 8, W + 2
            }, C.prototype.writeInt16BE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 2, 32767, -32768), this[W] = O >>> 8, this[W + 1] = 255 & O, W + 2
            }, C.prototype.writeInt32LE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 4, 2147483647, -2147483648), this[W] = 255 & O, this[W + 1] = O >>> 8, this[W + 2] = O >>> 16, this[W + 3] = O >>> 24, W + 4
            }, C.prototype.writeInt32BE = function(O, W, ke) {
                return O = +O, W >>>= 0, ke || A(this, O, W, 4, 2147483647, -2147483648), O < 0 && (O = 4294967295 + O + 1), this[W] = O >>> 24, this[W + 1] = O >>> 16, this[W + 2] = O >>> 8, this[W + 3] = 255 & O, W + 4
            }, C.prototype.writeBigInt64LE = en(function(O, W = 0) {
                return b(this, O, W, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), C.prototype.writeBigInt64BE = en(function(O, W = 0) {
                return N(this, O, W, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), C.prototype.writeFloatLE = function(O, W, ke) {
                return Q(this, O, W, !0, ke)
            }, C.prototype.writeFloatBE = function(O, W, ke) {
                return Q(this, O, W, !1, ke)
            }, C.prototype.writeDoubleLE = function(O, W, ke) {
                return Ee(this, O, W, !0, ke)
            }, C.prototype.writeDoubleBE = function(O, W, ke) {
                return Ee(this, O, W, !1, ke)
            }, C.prototype.copy = function(O, W, ke, je) {
                if (!C.isBuffer(O)) throw new TypeError("argument should be a Buffer");
                if (ke || (ke = 0), !je && 0 !== je && (je = this.length), W >= O.length && (W = O.length), W || (W = 0), je > 0 && je < ke && (je = ke), je === ke || 0 === O.length || 0 === this.length) return 0;
                if (W < 0) throw new RangeError("targetStart out of bounds");
                if (ke < 0 || ke >= this.length) throw new RangeError("Index out of range");
                if (je < 0) throw new RangeError("sourceEnd out of bounds");
                je > this.length && (je = this.length), O.length - W < je - ke && (je = O.length - W + ke);
                const Qe = je - ke;
                return this === O && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(W, ke, je) : Uint8Array.prototype.set.call(O, this.subarray(ke, je), W), Qe
            }, C.prototype.fill = function(O, W, ke, je) {
                if ("string" == typeof O) {
                    if ("string" == typeof W ? (je = W, W = 0, ke = this.length) : "string" == typeof ke && (je = ke, ke = this.length), void 0 !== je && "string" != typeof je) throw new TypeError("encoding must be a string");
                    if ("string" == typeof je && !C.isEncoding(je)) throw new TypeError("Unknown encoding: " + je);
                    if (1 === O.length) {
                        const st = O.charCodeAt(0);
                        ("utf8" === je && st < 128 || "latin1" === je) && (O = st)
                    }
                } else "number" == typeof O ? O &= 255 : "boolean" == typeof O && (O = Number(O));
                if (W < 0 || this.length < W || this.length < ke) throw new RangeError("Out of range index");
                if (ke <= W) return this;
                let Qe;
                if (W >>>= 0, ke = void 0 === ke ? this.length : ke >>> 0, O || (O = 0), "number" == typeof O)
                    for (Qe = W; Qe < ke; ++Qe) this[Qe] = O;
                else {
                    const st = C.isBuffer(O) ? O : C.from(O, je),
                        tn = st.length;
                    if (0 === tn) throw new TypeError('The value "' + O + '" is invalid for argument "value"');
                    for (Qe = 0; Qe < ke - W; ++Qe) this[Qe + W] = st[Qe % tn]
                }
                return this
            };
            const Fe = {};

            function Ge(pe, O, W) {
                Fe[pe] = class extends W {
                    constructor() {
                        super(), Object.defineProperty(this, "message", {
                            value: O.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${pe}]`, delete this.name
                    }
                    get code() {
                        return pe
                    }
                    set code(je) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: je,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${pe}]: ${this.message}`
                    }
                }
            }

            function wt(pe) {
                let O = "",
                    W = pe.length;
                const ke = "-" === pe[0] ? 1 : 0;
                for (; W >= ke + 4; W -= 3) O = `_${pe.slice(W-3,W)}${O}`;
                return `${pe.slice(0,W)}${O}`
            }

            function Mt(pe, O, W, ke, je, Qe) {
                if (pe > W || pe < O) {
                    const st = "bigint" == typeof O ? "n" : "";
                    let tn;
                    throw tn = Qe > 3 ? 0 === O || O === BigInt(0) ? `>= 0${st} and < 2${st} ** ${8*(Qe+1)}${st}` : `>= -(2${st} ** ${8*(Qe+1)-1}${st}) and < 2 ** ${8*(Qe+1)-1}${st}` : `>= ${O}${st} and <= ${W}${st}`, new Fe.ERR_OUT_OF_RANGE("value", tn, pe)
                }! function Vt(pe, O, W) {
                    sn(O, "offset"), (void 0 === pe[O] || void 0 === pe[O + W]) && ei(O, pe.length - (W + 1))
                }(ke, je, Qe)
            }

            function sn(pe, O) {
                if ("number" != typeof pe) throw new Fe.ERR_INVALID_ARG_TYPE(O, "number", pe)
            }

            function ei(pe, O, W) {
                throw Math.floor(pe) !== pe ? (sn(pe, W), new Fe.ERR_OUT_OF_RANGE(W || "offset", "an integer", pe)) : O < 0 ? new Fe.ERR_BUFFER_OUT_OF_BOUNDS : new Fe.ERR_OUT_OF_RANGE(W || "offset", `>= ${W?1:0} and <= ${O}`, pe)
            }
            Ge("ERR_BUFFER_OUT_OF_BOUNDS", function(pe) {
                return pe ? `${pe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }, RangeError), Ge("ERR_INVALID_ARG_TYPE", function(pe, O) {
                return `The "${pe}" argument must be of type number. Received type ${typeof O}`
            }, TypeError), Ge("ERR_OUT_OF_RANGE", function(pe, O, W) {
                let ke = `The value of "${pe}" is out of range.`,
                    je = W;
                return Number.isInteger(W) && Math.abs(W) > 2 ** 32 ? je = wt(String(W)) : "bigint" == typeof W && (je = String(W), (W > BigInt(2) ** BigInt(32) || W < -(BigInt(2) ** BigInt(32))) && (je = wt(je)), je += "n"), ke += ` It must be ${O}. Received ${je}`, ke
            }, RangeError);
            const ai = /[^+/0-9A-Za-z-_]/g;

            function An(pe, O) {
                let W;
                O = O || 1 / 0;
                const ke = pe.length;
                let je = null;
                const Qe = [];
                for (let st = 0; st < ke; ++st) {
                    if (W = pe.charCodeAt(st), W > 55295 && W < 57344) {
                        if (!je) {
                            if (W > 56319) {
                                (O -= 3) > -1 && Qe.push(239, 191, 189);
                                continue
                            }
                            if (st + 1 === ke) {
                                (O -= 3) > -1 && Qe.push(239, 191, 189);
                                continue
                            }
                            je = W;
                            continue
                        }
                        if (W < 56320) {
                            (O -= 3) > -1 && Qe.push(239, 191, 189), je = W;
                            continue
                        }
                        W = 65536 + (je - 55296 << 10 | W - 56320)
                    } else je && (O -= 3) > -1 && Qe.push(239, 191, 189);
                    if (je = null, W < 128) {
                        if ((O -= 1) < 0) break;
                        Qe.push(W)
                    } else if (W < 2048) {
                        if ((O -= 2) < 0) break;
                        Qe.push(W >> 6 | 192, 63 & W | 128)
                    } else if (W < 65536) {
                        if ((O -= 3) < 0) break;
                        Qe.push(W >> 12 | 224, W >> 6 & 63 | 128, 63 & W | 128)
                    } else {
                        if (!(W < 1114112)) throw new Error("Invalid code point");
                        if ((O -= 4) < 0) break;
                        Qe.push(W >> 18 | 240, W >> 12 & 63 | 128, W >> 6 & 63 | 128, 63 & W | 128)
                    }
                }
                return Qe
            }

            function ji(pe) {
                return F.toByteArray(function jn(pe) {
                    if ((pe = (pe = pe.split("=")[0]).trim().replace(ai, "")).length < 2) return "";
                    for (; pe.length % 4 != 0;) pe += "=";
                    return pe
                }(pe))
            }

            function Wn(pe, O, W, ke) {
                let je;
                for (je = 0; je < ke && !(je + W >= O.length || je >= pe.length); ++je) O[je + W] = pe[je];
                return je
            }

            function kn(pe, O) {
                return pe instanceof O || null != pe && null != pe.constructor && null != pe.constructor.name && pe.constructor.name === O.name
            }

            function Bi(pe) {
                return pe != pe
            }
            const ci = function() {
                const pe = "0123456789abcdef",
                    O = new Array(256);
                for (let W = 0; W < 16; ++W) {
                    const ke = 16 * W;
                    for (let je = 0; je < 16; ++je) O[ke + je] = pe[W] + pe[je]
                }
                return O
            }();

            function en(pe) {
                return typeof BigInt > "u" ? Ii : pe
            }

            function Ii() {
                throw new Error("BigInt not supported")
            }
        },
        63241: et => {
            "use strict";
            const I = /[\p{Lu}]/u,
                T = /[\p{Ll}]/u,
                F = /^[\p{Lu}](?![\p{Lu}])/gu,
                K = /([\p{Alpha}\p{N}_]|$)/u,
                q = /[_.\- ]+/,
                ne = new RegExp("^" + q.source),
                S = new RegExp(q.source + K.source, "gu"),
                j = new RegExp("\\d+" + K.source, "gu"),
                Y = (Z, le) => {
                    if ("string" != typeof Z && !Array.isArray(Z)) throw new TypeError("Expected the input to be `string | string[]`");
                    if (le = {
                            pascalCase: !1,
                            preserveConsecutiveUppercase: !1,
                            ...le
                        }, 0 === (Z = Array.isArray(Z) ? Z.map(me => me.trim()).filter(me => me.length).join("-") : Z.trim()).length) return "";
                    const re = !1 === le.locale ? me => me.toLowerCase() : me => me.toLocaleLowerCase(le.locale),
                        de = !1 === le.locale ? me => me.toUpperCase() : me => me.toLocaleUpperCase(le.locale);
                    return 1 === Z.length ? le.pascalCase ? de(Z) : re(Z) : (Z !== re(Z) && (Z = ((Z, le, re) => {
                        let de = !1,
                            Se = !1,
                            me = !1;
                        for (let Ce = 0; Ce < Z.length; Ce++) {
                            const we = Z[Ce];
                            de && I.test(we) ? (Z = Z.slice(0, Ce) + "-" + Z.slice(Ce), de = !1, me = Se, Se = !0, Ce++) : Se && me && T.test(we) ? (Z = Z.slice(0, Ce - 1) + "-" + Z.slice(Ce - 1), me = Se, Se = !1, de = !0) : (de = le(we) === we && re(we) !== we, me = Se, Se = re(we) === we && le(we) !== we)
                        }
                        return Z
                    })(Z, re, de)), Z = Z.replace(ne, ""), Z = le.preserveConsecutiveUppercase ? ((Z, le) => (F.lastIndex = 0, Z.replace(F, re => le(re))))(Z, re) : re(Z), le.pascalCase && (Z = de(Z.charAt(0)) + Z.slice(1)), ((Z, le) => (S.lastIndex = 0, j.lastIndex = 0, Z.replace(S, (re, de) => le(de)).replace(j, re => le(re))))(Z, de))
                };
            et.exports = Y, et.exports.default = Y
        },
        34989: et => {
            "use strict";
            var I = "%[a-f0-9]{2}",
                T = new RegExp("(" + I + ")|([^%]+?)", "gi"),
                F = new RegExp("(" + I + ")+", "gi");

            function K(S, j) {
                try {
                    return [decodeURIComponent(S.join(""))]
                } catch {}
                if (1 === S.length) return S;
                var C = S.slice(0, j = j || 1),
                    z = S.slice(j);
                return Array.prototype.concat.call([], K(C), K(z))
            }

            function q(S) {
                try {
                    return decodeURIComponent(S)
                } catch {
                    for (var j = S.match(T) || [], C = 1; C < j.length; C++) j = (S = K(j, C).join("")).match(T) || [];
                    return S
                }
            }
            et.exports = function(S) {
                if ("string" != typeof S) throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof S + "`");
                try {
                    return S = S.replace(/\+/g, " "), decodeURIComponent(S)
                } catch {
                    return function ne(S) {
                        for (var j = {
                                "%FE%FF": "\ufffd\ufffd",
                                "%FF%FE": "\ufffd\ufffd"
                            }, C = F.exec(S); C;) {
                            try {
                                j[C[0]] = decodeURIComponent(C[0])
                            } catch {
                                var z = q(C[0]);
                                z !== C[0] && (j[C[0]] = z)
                            }
                            C = F.exec(S)
                        }
                        j["%C2"] = "\ufffd";
                        for (var H = Object.keys(j), Y = 0; Y < H.length; Y++) {
                            var Z = H[Y];
                            S = S.replace(new RegExp(Z, "g"), j[Z])
                        }
                        return S
                    }(S)
                }
            }
        },
        81472: et => {
            "use strict";
            var I = Object.prototype.hasOwnProperty,
                T = "~";

            function F() {}

            function K(j, C, z) {
                this.fn = j, this.context = C, this.once = z || !1
            }

            function q(j, C, z, H, Y) {
                if ("function" != typeof z) throw new TypeError("The listener must be a function");
                var Z = new K(z, H || j, Y),
                    le = T ? T + C : C;
                return j._events[le] ? j._events[le].fn ? j._events[le] = [j._events[le], Z] : j._events[le].push(Z) : (j._events[le] = Z, j._eventsCount++), j
            }

            function ne(j, C) {
                0 == --j._eventsCount ? j._events = new F : delete j._events[C]
            }

            function S() {
                this._events = new F, this._eventsCount = 0
            }
            Object.create && (F.prototype = Object.create(null), (new F).__proto__ || (T = !1)), S.prototype.eventNames = function() {
                var z, H, C = [];
                if (0 === this._eventsCount) return C;
                for (H in z = this._events) I.call(z, H) && C.push(T ? H.slice(1) : H);
                return Object.getOwnPropertySymbols ? C.concat(Object.getOwnPropertySymbols(z)) : C
            }, S.prototype.listeners = function(C) {
                var H = this._events[T ? T + C : C];
                if (!H) return [];
                if (H.fn) return [H.fn];
                for (var Y = 0, Z = H.length, le = new Array(Z); Y < Z; Y++) le[Y] = H[Y].fn;
                return le
            }, S.prototype.listenerCount = function(C) {
                var H = this._events[T ? T + C : C];
                return H ? H.fn ? 1 : H.length : 0
            }, S.prototype.emit = function(C, z, H, Y, Z, le) {
                var re = T ? T + C : C;
                if (!this._events[re]) return !1;
                var me, Ce, de = this._events[re],
                    Se = arguments.length;
                if (de.fn) {
                    switch (de.once && this.removeListener(C, de.fn, void 0, !0), Se) {
                        case 1:
                            return de.fn.call(de.context), !0;
                        case 2:
                            return de.fn.call(de.context, z), !0;
                        case 3:
                            return de.fn.call(de.context, z, H), !0;
                        case 4:
                            return de.fn.call(de.context, z, H, Y), !0;
                        case 5:
                            return de.fn.call(de.context, z, H, Y, Z), !0;
                        case 6:
                            return de.fn.call(de.context, z, H, Y, Z, le), !0
                    }
                    for (Ce = 1, me = new Array(Se - 1); Ce < Se; Ce++) me[Ce - 1] = arguments[Ce];
                    de.fn.apply(de.context, me)
                } else {
                    var ve, we = de.length;
                    for (Ce = 0; Ce < we; Ce++) switch (de[Ce].once && this.removeListener(C, de[Ce].fn, void 0, !0), Se) {
                        case 1:
                            de[Ce].fn.call(de[Ce].context);
                            break;
                        case 2:
                            de[Ce].fn.call(de[Ce].context, z);
                            break;
                        case 3:
                            de[Ce].fn.call(de[Ce].context, z, H);
                            break;
                        case 4:
                            de[Ce].fn.call(de[Ce].context, z, H, Y);
                            break;
                        default:
                            if (!me)
                                for (ve = 1, me = new Array(Se - 1); ve < Se; ve++) me[ve - 1] = arguments[ve];
                            de[Ce].fn.apply(de[Ce].context, me)
                    }
                }
                return !0
            }, S.prototype.on = function(C, z, H) {
                return q(this, C, z, H, !1)
            }, S.prototype.once = function(C, z, H) {
                return q(this, C, z, H, !0)
            }, S.prototype.removeListener = function(C, z, H, Y) {
                var Z = T ? T + C : C;
                if (!this._events[Z]) return this;
                if (!z) return ne(this, Z), this;
                var le = this._events[Z];
                if (le.fn) le.fn === z && (!Y || le.once) && (!H || le.context === H) && ne(this, Z);
                else {
                    for (var re = 0, de = [], Se = le.length; re < Se; re++)(le[re].fn !== z || Y && !le[re].once || H && le[re].context !== H) && de.push(le[re]);
                    de.length ? this._events[Z] = 1 === de.length ? de[0] : de : ne(this, Z)
                }
                return this
            }, S.prototype.removeAllListeners = function(C) {
                var z;
                return C ? this._events[z = T ? T + C : C] && ne(this, z) : (this._events = new F, this._eventsCount = 0), this
            }, S.prototype.off = S.prototype.removeListener, S.prototype.addListener = S.prototype.on, S.prefixed = T, S.EventEmitter = S, et.exports = S
        },
        80220: et => {
            "use strict";
            et.exports = function(I, T) {
                for (var F = {}, K = Object.keys(I), q = Array.isArray(T), ne = 0; ne < K.length; ne++) {
                    var S = K[ne],
                        j = I[S];
                    (q ? -1 !== T.indexOf(S) : T(S, j, I)) && (F[S] = j)
                }
                return F
            }
        },
        22601: (et, I) => {
            I.read = function(T, F, K, q, ne) {
                var S, j, C = 8 * ne - q - 1,
                    z = (1 << C) - 1,
                    H = z >> 1,
                    Y = -7,
                    Z = K ? ne - 1 : 0,
                    le = K ? -1 : 1,
                    re = T[F + Z];
                for (Z += le, S = re & (1 << -Y) - 1, re >>= -Y, Y += C; Y > 0; S = 256 * S + T[F + Z], Z += le, Y -= 8);
                for (j = S & (1 << -Y) - 1, S >>= -Y, Y += q; Y > 0; j = 256 * j + T[F + Z], Z += le, Y -= 8);
                if (0 === S) S = 1 - H;
                else {
                    if (S === z) return j ? NaN : 1 / 0 * (re ? -1 : 1);
                    j += Math.pow(2, q), S -= H
                }
                return (re ? -1 : 1) * j * Math.pow(2, S - q)
            }, I.write = function(T, F, K, q, ne, S) {
                var j, C, z, H = 8 * S - ne - 1,
                    Y = (1 << H) - 1,
                    Z = Y >> 1,
                    le = 23 === ne ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    re = q ? 0 : S - 1,
                    de = q ? 1 : -1,
                    Se = F < 0 || 0 === F && 1 / F < 0 ? 1 : 0;
                for (F = Math.abs(F), isNaN(F) || F === 1 / 0 ? (C = isNaN(F) ? 1 : 0, j = Y) : (j = Math.floor(Math.log(F) / Math.LN2), F * (z = Math.pow(2, -j)) < 1 && (j--, z *= 2), (F += j + Z >= 1 ? le / z : le * Math.pow(2, 1 - Z)) * z >= 2 && (j++, z /= 2), j + Z >= Y ? (C = 0, j = Y) : j + Z >= 1 ? (C = (F * z - 1) * Math.pow(2, ne), j += Z) : (C = F * Math.pow(2, Z - 1) * Math.pow(2, ne), j = 0)); ne >= 8; T[K + re] = 255 & C, re += de, C /= 256, ne -= 8);
                for (j = j << ne | C, H += ne; H > 0; T[K + re] = 255 & j, re += de, j /= 256, H -= 8);
                T[K + re - de] |= 128 * Se
            }
        },
        8508: (et, I, T) => {
            "use strict";
            const F = T(31656).v4,
                K = T(56305),
                q = function(ne, S) {
                    if (!(this instanceof q)) return new q(ne, S);
                    S || (S = {}), this.options = {
                        reviver: typeof S.reviver < "u" ? S.reviver : null,
                        replacer: typeof S.replacer < "u" ? S.replacer : null,
                        generator: typeof S.generator < "u" ? S.generator : function() {
                            return F()
                        },
                        version: typeof S.version < "u" ? S.version : 2,
                        notificationIdNull: "boolean" == typeof S.notificationIdNull && S.notificationIdNull
                    }, this.callServer = ne
                };
            et.exports = q, q.prototype.request = function(ne, S, j, C) {
                const z = this;
                let H = null;
                const Y = Array.isArray(ne) && "function" == typeof S;
                if (1 === this.options.version && Y) throw new TypeError("JSON-RPC 1.0 does not support batching");
                if (Y || !Y && ne && "object" == typeof ne && "function" == typeof S) C = S, H = ne;
                else {
                    "function" == typeof j && (C = j, j = void 0);
                    const re = "function" == typeof C;
                    try {
                        H = K(ne, S, j, {
                            generator: this.options.generator,
                            version: this.options.version,
                            notificationIdNull: this.options.notificationIdNull
                        })
                    } catch (de) {
                        if (re) return C(de);
                        throw de
                    }
                    if (!re) return H
                }
                let le;
                try {
                    le = JSON.stringify(H, this.options.replacer)
                } catch (re) {
                    return C(re)
                }
                return this.callServer(le, function(re, de) {
                    z._parseResponse(re, de, C)
                }), H
            }, q.prototype._parseResponse = function(ne, S, j) {
                if (ne) return void j(ne);
                if (!S) return j();
                let C;
                try {
                    C = JSON.parse(S, this.options.reviver)
                } catch (z) {
                    return j(z)
                }
                if (3 === j.length) {
                    if (Array.isArray(C)) {
                        const z = function(Y) {
                                return typeof Y.error < "u"
                            },
                            H = function(Y) {
                                return !z(Y)
                            };
                        return j(null, C.filter(z), C.filter(H))
                    }
                    return j(null, C.error, C.result)
                }
                j(null, C)
            }
        },
        56305: (et, I, T) => {
            "use strict";
            const F = T(31656).v4;
            et.exports = function(q, ne, S, j) {
                if ("string" != typeof q) throw new TypeError(q + " must be a string");
                const C = "number" == typeof(j = j || {}).version ? j.version : 2;
                if (1 !== C && 2 !== C) throw new TypeError(C + " must be 1 or 2");
                const z = {
                    method: q
                };
                if (2 === C && (z.jsonrpc = "2.0"), ne) {
                    if ("object" != typeof ne && !Array.isArray(ne)) throw new TypeError(ne + " must be an object, array or omitted");
                    z.params = ne
                }
                return typeof S > "u" ? z.id = ("function" == typeof j.generator ? j.generator : function() {
                    return F()
                })(z, j) : 2 === C && null === S ? j.notificationIdNull && (z.id = null) : z.id = S, z
            }
        },
        31656: (et, I, T) => {
            "use strict";
            T.d(I, {
                v4: () => le
            });
            var F, K = new Uint8Array(16);

            function q() {
                if (!F && !(F = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return F(K)
            }
            const ne = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
            for (var C = [], z = 0; z < 256; ++z) C.push((z + 256).toString(16).substr(1));
            const Y = function H(re) {
                    var de = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        Se = (C[re[de + 0]] + C[re[de + 1]] + C[re[de + 2]] + C[re[de + 3]] + "-" + C[re[de + 4]] + C[re[de + 5]] + "-" + C[re[de + 6]] + C[re[de + 7]] + "-" + C[re[de + 8]] + C[re[de + 9]] + "-" + C[re[de + 10]] + C[re[de + 11]] + C[re[de + 12]] + C[re[de + 13]] + C[re[de + 14]] + C[re[de + 15]]).toLowerCase();
                    if (! function S(re) {
                            return "string" == typeof re && ne.test(re)
                        }(Se)) throw TypeError("Stringified UUID is invalid");
                    return Se
                },
                le = function Z(re, de, Se) {
                    var me = (re = re || {}).random || (re.rng || q)();
                    if (me[6] = 15 & me[6] | 64, me[8] = 63 & me[8] | 128, de) {
                        Se = Se || 0;
                        for (var Ce = 0; Ce < 16; ++Ce) de[Se + Ce] = me[Ce];
                        return de
                    }
                    return Y(me)
                }
        },
        52178: et => {
            "use strict";

            function I(K) {
                return K instanceof Buffer ? Buffer.from(K) : new K.constructor(K.buffer.slice(), K.byteOffset, K.length)
            }
            et.exports = function T(K) {
                return (K = K || {}).circles ? function F(K) {
                    var q = [],
                        ne = [];
                    return K.proto ? function C(z) {
                        if ("object" != typeof z || null === z) return z;
                        if (z instanceof Date) return new Date(z);
                        if (Array.isArray(z)) return S(z, C);
                        if (z instanceof Map) return new Map(S(Array.from(z), C));
                        if (z instanceof Set) return new Set(S(Array.from(z), C));
                        var H = {};
                        for (var Y in q.push(z), ne.push(H), z) {
                            var Z = z[Y];
                            if ("object" != typeof Z || null === Z) H[Y] = Z;
                            else if (Z instanceof Date) H[Y] = new Date(Z);
                            else if (Z instanceof Map) H[Y] = new Map(S(Array.from(Z), C));
                            else if (Z instanceof Set) H[Y] = new Set(S(Array.from(Z), C));
                            else if (ArrayBuffer.isView(Z)) H[Y] = I(Z);
                            else {
                                var le = q.indexOf(Z);
                                H[Y] = -1 !== le ? ne[le] : C(Z)
                            }
                        }
                        return q.pop(), ne.pop(), H
                    } : function j(z) {
                        if ("object" != typeof z || null === z) return z;
                        if (z instanceof Date) return new Date(z);
                        if (Array.isArray(z)) return S(z, j);
                        if (z instanceof Map) return new Map(S(Array.from(z), j));
                        if (z instanceof Set) return new Set(S(Array.from(z), j));
                        var H = {};
                        for (var Y in q.push(z), ne.push(H), z)
                            if (!1 !== Object.hasOwnProperty.call(z, Y)) {
                                var Z = z[Y];
                                if ("object" != typeof Z || null === Z) H[Y] = Z;
                                else if (Z instanceof Date) H[Y] = new Date(Z);
                                else if (Z instanceof Map) H[Y] = new Map(S(Array.from(Z), j));
                                else if (Z instanceof Set) H[Y] = new Set(S(Array.from(Z), j));
                                else if (ArrayBuffer.isView(Z)) H[Y] = I(Z);
                                else {
                                    var le = q.indexOf(Z);
                                    H[Y] = -1 !== le ? ne[le] : j(Z)
                                }
                            }
                        return q.pop(), ne.pop(), H
                    };

                    function S(z, H) {
                        for (var Y = Object.keys(z), Z = new Array(Y.length), le = 0; le < Y.length; le++) {
                            var re = Y[le],
                                de = z[re];
                            if ("object" != typeof de || null === de) Z[re] = de;
                            else if (de instanceof Date) Z[re] = new Date(de);
                            else if (ArrayBuffer.isView(de)) Z[re] = I(de);
                            else {
                                var Se = q.indexOf(de);
                                Z[re] = -1 !== Se ? ne[Se] : H(de)
                            }
                        }
                        return Z
                    }
                }(K) : K.proto ? function S(j) {
                    if ("object" != typeof j || null === j) return j;
                    if (j instanceof Date) return new Date(j);
                    if (Array.isArray(j)) return q(j, S);
                    if (j instanceof Map) return new Map(q(Array.from(j), S));
                    if (j instanceof Set) return new Set(q(Array.from(j), S));
                    var C = {};
                    for (var z in j) {
                        var H = j[z];
                        C[z] = "object" != typeof H || null === H ? H : H instanceof Date ? new Date(H) : H instanceof Map ? new Map(q(Array.from(H), S)) : H instanceof Set ? new Set(q(Array.from(H), S)) : ArrayBuffer.isView(H) ? I(H) : S(H)
                    }
                    return C
                } : function ne(j) {
                    if ("object" != typeof j || null === j) return j;
                    if (j instanceof Date) return new Date(j);
                    if (Array.isArray(j)) return q(j, ne);
                    if (j instanceof Map) return new Map(q(Array.from(j), ne));
                    if (j instanceof Set) return new Set(q(Array.from(j), ne));
                    var C = {};
                    for (var z in j)
                        if (!1 !== Object.hasOwnProperty.call(j, z)) {
                            var H = j[z];
                            C[z] = "object" != typeof H || null === H ? H : H instanceof Date ? new Date(H) : H instanceof Map ? new Map(q(Array.from(H), ne)) : H instanceof Set ? new Set(q(Array.from(H), ne)) : ArrayBuffer.isView(H) ? I(H) : ne(H)
                        }
                    return C
                };

                function q(j, C) {
                    for (var z = Object.keys(j), H = new Array(z.length), Y = 0; Y < z.length; Y++) {
                        var Z = z[Y],
                            le = j[Z];
                        H[Z] = "object" != typeof le || null === le ? le : le instanceof Date ? new Date(le) : ArrayBuffer.isView(le) ? I(le) : C(le)
                    }
                    return H
                }
            }
        },
        84463: (et, I, T) => {
            "use strict";
            var K = T(17156).default;
            const q = T(81472),
                ne = T(3944);
            I.Z = class S extends q.EventEmitter {
                address;
                rpc_id;
                queue;
                options;
                autoconnect;
                ready;
                reconnect;
                reconnect_timer_id;
                reconnect_interval;
                max_reconnects;
                rest_options;
                current_reconnects;
                generate_request_id;
                socket;
                webSocketFactory;
                dataPack;
                constructor(C, z = "ws://localhost:8080", {
                    autoconnect: H = !0,
                    reconnect: Y = !0,
                    reconnect_interval: Z = 1e3,
                    max_reconnects: le = 5,
                    ...re
                } = {}, de, Se) {
                    super(), this.webSocketFactory = C, this.queue = {}, this.rpc_id = 0, this.address = z, this.autoconnect = H, this.ready = !1, this.reconnect = Y, this.reconnect_timer_id = void 0, this.reconnect_interval = Z, this.max_reconnects = le, this.rest_options = re, this.current_reconnects = 0, this.generate_request_id = de || (() => ++this.rpc_id), this.dataPack = Se || new ne.DefaultDataPack, this.autoconnect && this._connect(this.address, {
                        autoconnect: this.autoconnect,
                        reconnect: this.reconnect,
                        reconnect_interval: this.reconnect_interval,
                        max_reconnects: this.max_reconnects,
                        ...this.rest_options
                    })
                }
                connect() {
                    this.socket || this._connect(this.address, {
                        autoconnect: this.autoconnect,
                        reconnect: this.reconnect,
                        reconnect_interval: this.reconnect_interval,
                        max_reconnects: this.max_reconnects,
                        ...this.rest_options
                    })
                }
                call(C, z, H, Y) {
                    return !Y && "object" == typeof H && (Y = H, H = null), new Promise((Z, le) => {
                        if (!this.ready) return le(new Error("socket not ready"));
                        const re = this.generate_request_id(C, z);
                        this.socket.send(this.dataPack.encode({
                            jsonrpc: "2.0",
                            method: C,
                            params: z || void 0,
                            id: re
                        }), Y, Se => {
                            if (Se) return le(Se);
                            this.queue[re] = {
                                promise: [Z, le]
                            }, H && (this.queue[re].timeout = setTimeout(() => {
                                delete this.queue[re], le(new Error("reply timeout"))
                            }, H))
                        })
                    })
                }
                login(C) {
                    var z = this;
                    return K(function*() {
                        const H = yield z.call("rpc.login", C);
                        if (!H) throw new Error("authentication failed");
                        return H
                    })()
                }
                listMethods() {
                    var C = this;
                    return K(function*() {
                        return yield C.call("__listMethods")
                    })()
                }
                notify(C, z) {
                    return new Promise((H, Y) => {
                        if (!this.ready) return Y(new Error("socket not ready"));
                        this.socket.send(this.dataPack.encode({
                            jsonrpc: "2.0",
                            method: C,
                            params: z
                        }), le => {
                            if (le) return Y(le);
                            H()
                        })
                    })
                }
                subscribe(C) {
                    var z = this;
                    return K(function*() {
                        "string" == typeof C && (C = [C]);
                        const H = yield z.call("rpc.on", C);
                        if ("string" == typeof C && "ok" !== H[C]) throw new Error("Failed subscribing to an event '" + C + "' with: " + H[C]);
                        return H
                    })()
                }
                unsubscribe(C) {
                    var z = this;
                    return K(function*() {
                        "string" == typeof C && (C = [C]);
                        const H = yield z.call("rpc.off", C);
                        if ("string" == typeof C && "ok" !== H[C]) throw new Error("Failed unsubscribing from an event with: " + H);
                        return H
                    })()
                }
                close(C, z) {
                    this.socket.close(C || 1e3, z)
                }
                setAutoReconnect(C) {
                    this.reconnect = C
                }
                setReconnectInterval(C) {
                    this.reconnect_interval = C
                }
                setMaxReconnects(C) {
                    this.max_reconnects = C
                }
                _connect(C, z) {
                    clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(C, z), this.socket.addEventListener("open", () => {
                        this.ready = !0, this.emit("open"), this.current_reconnects = 0
                    }), this.socket.addEventListener("message", ({
                        data: H
                    }) => {
                        H instanceof ArrayBuffer && (H = Buffer.from(H).toString());
                        try {
                            H = this.dataPack.decode(H)
                        } catch {
                            return
                        }
                        if (H.notification && this.listeners(H.notification).length) {
                            if (!Object.keys(H.params).length) return this.emit(H.notification);
                            const Y = [H.notification];
                            if (H.params.constructor === Object) Y.push(H.params);
                            else
                                for (let Z = 0; Z < H.params.length; Z++) Y.push(H.params[Z]);
                            return Promise.resolve().then(() => {
                                this.emit.apply(this, Y)
                            })
                        }
                        if (!this.queue[H.id]) return H.method ? Promise.resolve().then(() => {
                            this.emit(H.method, H ? .params)
                        }) : void 0;
                        "error" in H == "result" in H && this.queue[H.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[H.id].timeout && clearTimeout(this.queue[H.id].timeout), H.error ? this.queue[H.id].promise[1](H.error) : this.queue[H.id].promise[0](H.result), delete this.queue[H.id]
                    }), this.socket.addEventListener("error", H => this.emit("error", H)), this.socket.addEventListener("close", ({
                        code: H,
                        reason: Y
                    }) => {
                        this.ready && setTimeout(() => this.emit("close", H, Y), 0), this.ready = !1, this.socket = void 0, 1e3 !== H && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || 0 === this.max_reconnects) && (this.reconnect_timer_id = setTimeout(() => this._connect(C, z), this.reconnect_interval)))
                    })
                }
            }
        },
        56910: (et, I, T) => {
            "use strict";
            const K = T(81472);
            class q extends K.EventEmitter {
                socket;
                constructor(j, C, z) {
                    super(), this.socket = new window.WebSocket(j, z), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = H => this.emit("message", H.data), this.socket.onerror = H => this.emit("error", H), this.socket.onclose = H => {
                        this.emit("close", H.code, H.reason)
                    }
                }
                send(j, C, z) {
                    const H = z || C;
                    try {
                        this.socket.send(j), H()
                    } catch (Y) {
                        H(Y)
                    }
                }
                close(j, C) {
                    this.socket.close(j, C)
                }
                addEventListener(j, C, z) {
                    this.socket.addEventListener(j, C, z)
                }
            }
            I.Z = function ne(S, j) {
                return new q(S, j)
            }
        },
        3944: (et, I) => {
            "use strict";
            Object.defineProperty(I, "__esModule", {
                value: !0
            }), I.createError = I.DefaultDataPack = void 0;
            const T = new Map([
                [-32e3, "Event not provided"],
                [-32600, "Invalid Request"],
                [-32601, "Method not found"],
                [-32602, "Invalid params"],
                [-32603, "Internal error"],
                [-32604, "Params not found"],
                [-32605, "Method forbidden"],
                [-32606, "Event forbidden"],
                [-32700, "Parse error"]
            ]);
            I.DefaultDataPack = class F {
                encode(ne) {
                    return JSON.stringify(ne)
                }
                decode(ne) {
                    return JSON.parse(ne)
                }
            }, I.createError = function K(q, ne) {
                const S = {
                    code: q,
                    message: T.get(q) || "Internal Server Error"
                };
                return ne && (S.data = ne), S
            }
        },
        843: (et, I, T) => {
            var F = T(39007),
                K = F.Buffer;

            function q(S, j) {
                for (var C in S) j[C] = S[C]
            }

            function ne(S, j, C) {
                return K(S, j, C)
            }
            K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? et.exports = F : (q(F, I), I.Buffer = ne), ne.prototype = Object.create(K.prototype), q(K, ne), ne.from = function(S, j, C) {
                if ("number" == typeof S) throw new TypeError("Argument must not be a number");
                return K(S, j, C)
            }, ne.alloc = function(S, j, C) {
                if ("number" != typeof S) throw new TypeError("Argument must be a number");
                var z = K(S);
                return void 0 !== j ? "string" == typeof C ? z.fill(j, C) : z.fill(j) : z.fill(0), z
            }, ne.allocUnsafe = function(S) {
                if ("number" != typeof S) throw new TypeError("Argument must be a number");
                return K(S)
            }, ne.allocUnsafeSlow = function(S) {
                if ("number" != typeof S) throw new TypeError("Argument must be a number");
                return F.SlowBuffer(S)
            }
        },
        36144: et => {
            "use strict";
            et.exports = (I, T) => {
                if ("string" != typeof I || "string" != typeof T) throw new TypeError("Expected the arguments to be of type `string`");
                if ("" === T) return [I];
                const F = I.indexOf(T);
                return -1 === F ? [I] : [I.slice(0, F), I.slice(F + T.length)]
            }
        },
        8385: et => {
            "use strict";
            et.exports = I => encodeURIComponent(I).replace(/[!'()*]/g, T => `%${T.charCodeAt(0).toString(16).toUpperCase()}`)
        },
        13519: function(et) {
            et.exports = function() {
                "use strict";

                function I(oe, w, P) {
                    if ("function" == typeof oe ? oe === w : oe.has(w)) return arguments.length < 3 ? w : P;
                    throw new TypeError("Private element is not present on this object")
                }

                function T(oe, w, P) {
                    return w = re(w),
                        function me(oe, w) {
                            if (w && ("object" == typeof w || "function" == typeof w)) return w;
                            if (void 0 !== w) throw new TypeError("Derived constructors may only return object or undefined");
                            return function Se(oe) {
                                if (void 0 === oe) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return oe
                            }(oe)
                        }(oe, ne() ? Reflect.construct(w, P || [], re(oe).constructor) : w.apply(oe, P))
                }

                function F(oe, w) {
                    return oe.get(I(oe, w))
                }

                function ne() {
                    try {
                        var oe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
                    } catch {}
                    return (ne = function() {
                        return !!oe
                    })()
                }

                function C(oe) {
                    var w = function j(oe, w) {
                        if ("object" != typeof oe || !oe) return oe;
                        var P = oe[Symbol.toPrimitive];
                        if (void 0 !== P) {
                            var ie = P.call(oe, w || "default");
                            if ("object" != typeof ie) return ie;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === w ? String : Number)(oe)
                    }(oe, "string");
                    return "symbol" == typeof w ? w : w + ""
                }

                function z(oe) {
                    return (z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(w) {
                        return typeof w
                    } : function(w) {
                        return w && "function" == typeof Symbol && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w
                    })(oe)
                }

                function H(oe, w) {
                    if (!(oe instanceof w)) throw new TypeError("Cannot call a class as a function")
                }

                function Y(oe, w) {
                    for (var P = 0; P < w.length; P++) {
                        var ie = w[P];
                        ie.enumerable = ie.enumerable || !1, ie.configurable = !0, "value" in ie && (ie.writable = !0), Object.defineProperty(oe, C(ie.key), ie)
                    }
                }

                function Z(oe, w, P) {
                    return w && Y(oe.prototype, w), P && Y(oe, P), Object.defineProperty(oe, "prototype", {
                        writable: !1
                    }), oe
                }

                function re(oe) {
                    return (re = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
                        return P.__proto__ || Object.getPrototypeOf(P)
                    })(oe)
                }

                function de(oe, w) {
                    return (de = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ie, $e) {
                        return ie.__proto__ = $e, ie
                    })(oe, w)
                }

                function we() {
                    return we = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(w, P, ie) {
                        var $e = function Ce(oe, w) {
                            for (; !Object.prototype.hasOwnProperty.call(oe, w) && null !== (oe = re(oe)););
                            return oe
                        }(w, P);
                        if ($e) {
                            var Tt = Object.getOwnPropertyDescriptor($e, P);
                            return Tt.get ? Tt.get.call(arguments.length < 3 ? w : ie) : Tt.value
                        }
                    }, we.apply(this, arguments)
                }

                function ve(oe, w) {
                    return function Me(oe) {
                        if (Array.isArray(oe)) return oe
                    }(oe) || function S(oe, w) {
                        var P = null == oe ? null : typeof Symbol < "u" && oe[Symbol.iterator] || oe["@@iterator"];
                        if (null != P) {
                            var ie, $e, Tt, En, ri = [],
                                Pi = !0,
                                lr = !1;
                            try {
                                if (Tt = (P = P.call(oe)).next, 0 === w) {
                                    if (Object(P) !== P) return;
                                    Pi = !1
                                } else
                                    for (; !(Pi = (ie = Tt.call(P)).done) && (ri.push(ie.value), ri.length !== w); Pi = !0);
                            } catch (Tu) {
                                lr = !0, $e = Tu
                            } finally {
                                try {
                                    if (!Pi && null != P.return && (En = P.return(), Object(En) !== En)) return
                                } finally {
                                    if (lr) throw $e
                                }
                            }
                            return ri
                        }
                    }(oe, w) || L(oe, w) || function xe() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function De(oe) {
                    return function ae(oe) {
                        if (Array.isArray(oe)) return ue(oe)
                    }(oe) || function Le(oe) {
                        if (typeof Symbol < "u" && null != oe[Symbol.iterator] || null != oe["@@iterator"]) return Array.from(oe)
                    }(oe) || L(oe) || function Te() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function L(oe, w) {
                    if (oe) {
                        if ("string" == typeof oe) return ue(oe, w);
                        var P = Object.prototype.toString.call(oe).slice(8, -1);
                        if ("Object" === P && oe.constructor && (P = oe.constructor.name), "Map" === P || "Set" === P) return Array.from(oe);
                        if ("Arguments" === P || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P)) return ue(oe, w)
                    }
                }

                function ue(oe, w) {
                    (null == w || w > oe.length) && (w = oe.length);
                    for (var P = 0, ie = new Array(w); P < w; P++) ie[P] = oe[P];
                    return ie
                }

                function Ie(oe, w, P) {
                    (function Ae(oe, w) {
                        if (w.has(oe)) throw new TypeError("Cannot initialize the same private elements twice on an object")
                    })(oe, w), w.set(oe, P)
                }
                var f = {},
                    M = function(w) {
                        return new Promise(function(P) {
                            if (!w) return P();
                            var ie = window.scrollX,
                                $e = window.scrollY;
                            f.restoreFocusTimeout = setTimeout(function() {
                                f.previousActiveElement instanceof HTMLElement ? (f.previousActiveElement.focus(), f.previousActiveElement = null) : document.body && document.body.focus(), P()
                            }, 100), window.scrollTo(ie, $e)
                        })
                    },
                    U = "swal2-",
                    y = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"].reduce(function(oe, w) {
                        return oe[w] = U + w, oe
                    }, {}),
                    A = ["success", "warning", "info", "question", "error"].reduce(function(oe, w) {
                        return oe[w] = U + w, oe
                    }, {}),
                    b = "SweetAlert2:",
                    N = function(w) {
                        return w.charAt(0).toUpperCase() + w.slice(1)
                    },
                    R = function(w) {
                        console.warn("".concat(b, " ").concat("object" === z(w) ? w.join(" ") : w))
                    },
                    Q = function(w) {
                        console.error("".concat(b, " ").concat(w))
                    },
                    Ee = [],
                    Ge = function(w, P) {
                        ! function(w) {
                            Ee.includes(w) || (Ee.push(w), R(w))
                        }('"'.concat(w, '" is deprecated and will be removed in the next major release. Please use "').concat(P, '" instead.'))
                    },
                    wt = function(w) {
                        return "function" == typeof w ? w() : w
                    },
                    Vt = function(w) {
                        return w && "function" == typeof w.toPromise
                    },
                    Mt = function(w) {
                        return Vt(w) ? w.toPromise() : Promise.resolve(w)
                    },
                    sn = function(w) {
                        return w && Promise.resolve(w) === w
                    },
                    ei = function() {
                        return document.body.querySelector(".".concat(y.container))
                    },
                    ai = function(w) {
                        var P = ei();
                        return P ? P.querySelector(w) : null
                    },
                    jn = function(w) {
                        return ai(".".concat(w))
                    },
                    An = function() {
                        return jn(y.popup)
                    },
                    ui = function() {
                        return jn(y.icon)
                    },
                    ji = function() {
                        return jn(y.title)
                    },
                    Wn = function() {
                        return jn(y["html-container"])
                    },
                    kn = function() {
                        return jn(y.image)
                    },
                    Bi = function() {
                        return jn(y["progress-steps"])
                    },
                    ci = function() {
                        return jn(y["validation-message"])
                    },
                    en = function() {
                        return ai(".".concat(y.actions, " .").concat(y.confirm))
                    },
                    Ii = function() {
                        return ai(".".concat(y.actions, " .").concat(y.cancel))
                    },
                    pe = function() {
                        return ai(".".concat(y.actions, " .").concat(y.deny))
                    },
                    W = function() {
                        return ai(".".concat(y.loader))
                    },
                    ke = function() {
                        return jn(y.actions)
                    },
                    je = function() {
                        return jn(y.footer)
                    },
                    Qe = function() {
                        return jn(y["timer-progress-bar"])
                    },
                    st = function() {
                        return jn(y.close)
                    },
                    Kn = function() {
                        var w = An();
                        if (!w) return [];
                        var P = w.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])'),
                            ie = Array.from(P).sort(function(En, ri) {
                                var Pi = parseInt(En.getAttribute("tabindex") || "0"),
                                    lr = parseInt(ri.getAttribute("tabindex") || "0");
                                return Pi > lr ? 1 : Pi < lr ? -1 : 0
                            }),
                            $e = w.querySelectorAll('\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n'),
                            Tt = Array.from($e).filter(function(En) {
                                return "-1" !== En.getAttribute("tabindex")
                            });
                        return De(new Set(ie.concat(Tt))).filter(function(En) {
                            return St(En)
                        })
                    },
                    mn = function() {
                        return pi(document.body, y.shown) && !pi(document.body, y["toast-shown"]) && !pi(document.body, y["no-backdrop"])
                    },
                    $n = function() {
                        var w = An();
                        return !!w && pi(w, y.toast)
                    },
                    Sn = function(w, P) {
                        if (w.textContent = "", P) {
                            var $e = (new DOMParser).parseFromString(P, "text/html"),
                                Tt = $e.querySelector("head");
                            Tt && Array.from(Tt.childNodes).forEach(function(ri) {
                                w.appendChild(ri)
                            });
                            var En = $e.querySelector("body");
                            En && Array.from(En.childNodes).forEach(function(ri) {
                                ri instanceof HTMLVideoElement || ri instanceof HTMLAudioElement ? w.appendChild(ri.cloneNode(!0)) : w.appendChild(ri)
                            })
                        }
                    },
                    pi = function(w, P) {
                        if (!P) return !1;
                        for (var ie = P.split(/\s+/), $e = 0; $e < ie.length; $e++)
                            if (!w.classList.contains(ie[$e])) return !1;
                        return !0
                    },
                    yi = function(w, P, ie) {
                        if (function(w, P) {
                                Array.from(w.classList).forEach(function(ie) {
                                    !Object.values(y).includes(ie) && !Object.values(A).includes(ie) && !Object.values(P.showClass || {}).includes(ie) && w.classList.remove(ie)
                                })
                            }(w, P), P.customClass && P.customClass[ie]) {
                            if ("string" != typeof P.customClass[ie] && !P.customClass[ie].forEach) return void R("Invalid type of customClass.".concat(ie, '! Expected string or iterable object, got "').concat(z(P.customClass[ie]), '"'));
                            Rn(w, P.customClass[ie])
                        }
                    },
                    hr = function(w, P) {
                        if (!P) return null;
                        switch (P) {
                            case "select":
                            case "textarea":
                            case "file":
                                return w.querySelector(".".concat(y.popup, " > .").concat(y[P]));
                            case "checkbox":
                                return w.querySelector(".".concat(y.popup, " > .").concat(y.checkbox, " input"));
                            case "radio":
                                return w.querySelector(".".concat(y.popup, " > .").concat(y.radio, " input:checked")) || w.querySelector(".".concat(y.popup, " > .").concat(y.radio, " input:first-child"));
                            case "range":
                                return w.querySelector(".".concat(y.popup, " > .").concat(y.range, " input"));
                            default:
                                return w.querySelector(".".concat(y.popup, " > .").concat(y.input))
                        }
                    },
                    qo = function(w) {
                        if (w.focus(), "file" !== w.type) {
                            var P = w.value;
                            w.value = "", w.value = P
                        }
                    },
                    yr = function(w, P, ie) {
                        !w || !P || ("string" == typeof P && (P = P.split(/\s+/).filter(Boolean)), P.forEach(function($e) {
                            Array.isArray(w) ? w.forEach(function(Tt) {
                                ie ? Tt.classList.add($e) : Tt.classList.remove($e)
                            }) : ie ? w.classList.add($e) : w.classList.remove($e)
                        }))
                    },
                    Rn = function(w, P) {
                        yr(w, P, !0)
                    },
                    Ti = function(w, P) {
                        yr(w, P, !1)
                    },
                    Ji = function(w, P) {
                        for (var ie = Array.from(w.children), $e = 0; $e < ie.length; $e++) {
                            var Tt = ie[$e];
                            if (Tt instanceof HTMLElement && pi(Tt, P)) return Tt
                        }
                    },
                    gn = function(w, P, ie) {
                        ie === "".concat(parseInt(ie)) && (ie = parseInt(ie)), ie || 0 === parseInt(ie) ? w.style.setProperty(P, "number" == typeof ie ? "".concat(ie, "px") : ie) : w.style.removeProperty(P)
                    },
                    Si = function(w) {
                        w && (w.style.display = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "flex")
                    },
                    qn = function(w) {
                        w && (w.style.display = "none")
                    },
                    Ve = function(w) {
                        var P = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "block";
                        w && new MutationObserver(function() {
                            pt(w, w.innerHTML, P)
                        }).observe(w, {
                            childList: !0,
                            subtree: !0
                        })
                    },
                    at = function(w, P, ie, $e) {
                        var Tt = w.querySelector(P);
                        Tt && Tt.style.setProperty(ie, $e)
                    },
                    pt = function(w, P) {
                        P ? Si(w, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "flex") : qn(w)
                    },
                    St = function(w) {
                        return !(!w || !(w.offsetWidth || w.offsetHeight || w.getClientRects().length))
                    },
                    Nn = function(w) {
                        return w.scrollHeight > w.clientHeight
                    },
                    Ut = function(w) {
                        var P = window.getComputedStyle(w),
                            ie = parseFloat(P.getPropertyValue("animation-duration") || "0"),
                            $e = parseFloat(P.getPropertyValue("transition-duration") || "0");
                        return ie > 0 || $e > 0
                    },
                    or = function(w) {
                        var P = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            ie = Qe();
                        ie && St(ie) && (P && (ie.style.transition = "none", ie.style.width = "100%"), setTimeout(function() {
                            ie.style.transition = "width ".concat(w / 1e3, "s linear"), ie.style.width = "0%"
                        }, 10))
                    },
                    qi = function() {
                        return typeof window > "u" || typeof document > "u"
                    },
                    Xs = '\n <div aria-labelledby="'.concat(y.title, '" aria-describedby="').concat(y["html-container"], '" class="').concat(y.popup, '" tabindex="-1">\n   <button type="button" class="').concat(y.close, '"></button>\n   <ul class="').concat(y["progress-steps"], '"></ul>\n   <div class="').concat(y.icon, '"></div>\n   <img class="').concat(y.image, '" />\n   <h2 class="').concat(y.title, '" id="').concat(y.title, '"></h2>\n   <div class="').concat(y["html-container"], '" id="').concat(y["html-container"], '"></div>\n   <input class="').concat(y.input, '" id="').concat(y.input, '" />\n   <input type="file" class="').concat(y.file, '" />\n   <div class="').concat(y.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(y.select, '" id="').concat(y.select, '"></select>\n   <div class="').concat(y.radio, '"></div>\n   <label class="').concat(y.checkbox, '">\n     <input type="checkbox" id="').concat(y.checkbox, '" />\n     <span class="').concat(y.label, '"></span>\n   </label>\n   <textarea class="').concat(y.textarea, '" id="').concat(y.textarea, '"></textarea>\n   <div class="').concat(y["validation-message"], '" id="').concat(y["validation-message"], '"></div>\n   <div class="').concat(y.actions, '">\n     <div class="').concat(y.loader, '"></div>\n     <button type="button" class="').concat(y.confirm, '"></button>\n     <button type="button" class="').concat(y.deny, '"></button>\n     <button type="button" class="').concat(y.cancel, '"></button>\n   </div>\n   <div class="').concat(y.footer, '"></div>\n   <div class="').concat(y["timer-progress-bar-container"], '">\n     <div class="').concat(y["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, ""),
                    an = function() {
                        f.currentInstance.resetValidationMessage()
                    },
                    mt = function(w) {
                        var P = function() {
                            var w = ei();
                            return !!w && (w.remove(), Ti([document.documentElement, document.body], [y["no-backdrop"], y["toast-shown"], y["has-column"]]), !0)
                        }();
                        if (qi()) Q("SweetAlert2 requires document to initialize");
                        else {
                            var ie = document.createElement("div");
                            ie.className = y.container, P && Rn(ie, y["no-transition"]), Sn(ie, Xs);
                            var $e = function(w) {
                                return "string" == typeof w ? document.querySelector(w) : w
                            }(w.target);
                            $e.appendChild(ie),
                                function(w) {
                                    var P = An();
                                    P.setAttribute("role", w.toast ? "alert" : "dialog"), P.setAttribute("aria-live", w.toast ? "polite" : "assertive"), w.toast || P.setAttribute("aria-modal", "true")
                                }(w),
                                function(w) {
                                    "rtl" === window.getComputedStyle(w).direction && Rn(ei(), y.rtl)
                                }($e),
                                function() {
                                    var w = An(),
                                        P = Ji(w, y.input),
                                        ie = Ji(w, y.file),
                                        $e = w.querySelector(".".concat(y.range, " input")),
                                        Tt = w.querySelector(".".concat(y.range, " output")),
                                        En = Ji(w, y.select),
                                        ri = w.querySelector(".".concat(y.checkbox, " input")),
                                        Pi = Ji(w, y.textarea);
                                    P.oninput = an, ie.onchange = an, En.onchange = an, ri.onchange = an, Pi.oninput = an, $e.oninput = function() {
                                        an(), Tt.value = $e.value
                                    }, $e.onchange = function() {
                                        an(), Tt.value = $e.value
                                    }
                                }()
                        }
                    },
                    xo = function(w, P) {
                        w instanceof HTMLElement ? P.appendChild(w) : "object" === z(w) ? Zn(w, P) : w && Sn(P, w)
                    },
                    Zn = function(w, P) {
                        w.jquery ? di(P, w) : Sn(P, w.toString())
                    },
                    di = function(w, P) {
                        if (w.textContent = "", 0 in P)
                            for (var ie = 0; ie in P; ie++) w.appendChild(P[ie].cloneNode(!0));
                        else w.appendChild(P.cloneNode(!0))
                    },
                    Nr = function() {
                        if (qi()) return !1;
                        var oe = document.createElement("div");
                        return typeof oe.style.webkitAnimation < "u" ? "webkitAnimationEnd" : typeof oe.style.animation < "u" && "animationend"
                    }(),
                    la = function(w, P) {
                        var ie = ke(),
                            $e = W();
                        !ie || !$e || (P.showConfirmButton || P.showDenyButton || P.showCancelButton ? Si(ie) : qn(ie), yi(ie, P, "actions"), function ua(oe, w, P) {
                            var ie = en(),
                                $e = pe(),
                                Tt = Ii();
                            !ie || !$e || !Tt || (Ir(ie, "confirm", P), Ir($e, "deny", P), Ir(Tt, "cancel", P), function Qs(oe, w, P, ie) {
                                ie.buttonsStyling ? (Rn([oe, w, P], y.styled), ie.confirmButtonColor && (oe.style.backgroundColor = ie.confirmButtonColor, Rn(oe, y["default-outline"])), ie.denyButtonColor && (w.style.backgroundColor = ie.denyButtonColor, Rn(w, y["default-outline"])), ie.cancelButtonColor && (P.style.backgroundColor = ie.cancelButtonColor, Rn(P, y["default-outline"]))) : Ti([oe, w, P], y.styled)
                            }(ie, $e, Tt, P), P.reverseButtons && (P.toast ? (oe.insertBefore(Tt, ie), oe.insertBefore($e, ie)) : (oe.insertBefore(Tt, w), oe.insertBefore($e, w), oe.insertBefore(ie, w))))
                        }(ie, $e, P), Sn($e, P.loaderHtml || ""), yi($e, P, "loader"))
                    };

                function Ir(oe, w, P) {
                    var ie = N(w);
                    pt(oe, P["show".concat(ie, "Button")], "inline-block"), Sn(oe, P["".concat(w, "ButtonText")] || ""), oe.setAttribute("aria-label", P["".concat(w, "ButtonAriaLabel")] || ""), oe.className = y[w], yi(oe, P, "".concat(w, "Button"))
                }
                var da = function(w, P) {
                    var ie = ei();
                    ie && (function nc(oe, w) {
                        "string" == typeof w ? oe.style.background = w : w || Rn([document.documentElement, document.body], y["no-backdrop"])
                    }(ie, P.backdrop), function xr(oe, w) {
                        w && (w in y ? Rn(oe, y[w]) : (R('The "position" parameter is not valid, defaulting to "center"'), Rn(oe, y.center)))
                    }(ie, P.position), function Js(oe, w) {
                        w && Rn(oe, y["grow-".concat(w)])
                    }(ie, P.grow), yi(ie, P, "container"))
                };
                var Zi = {
                        innerParams: new WeakMap,
                        domCache: new WeakMap
                    },
                    hd = ["input", "file", "range", "select", "radio", "checkbox", "textarea"],
                    yu = function(w) {
                        if (w.input) {
                            if (!Cr[w.input]) return void Q("Unexpected type of input! Expected ".concat(Object.keys(Cr).join(" | "), ', got "').concat(w.input, '"'));
                            var P = pd(w.input),
                                ie = Cr[w.input](P, w);
                            Si(P), w.inputAutoFocus && setTimeout(function() {
                                qo(ie)
                            })
                        }
                    },
                    kl = function(w, P) {
                        var ie = hr(An(), w);
                        if (ie)
                            for (var $e in function(w) {
                                    for (var P = 0; P < w.attributes.length; P++) {
                                        var ie = w.attributes[P].name;
                                        ["id", "type", "value", "style"].includes(ie) || w.removeAttribute(ie)
                                    }
                                }(ie), P) ie.setAttribute($e, P[$e])
                    },
                    Jc = function(w) {
                        var P = pd(w.input);
                        "object" === z(w.customClass) && Rn(P, w.customClass.input)
                    },
                    fs = function(w, P) {
                        (!w.placeholder || P.inputPlaceholder) && (w.placeholder = P.inputPlaceholder)
                    },
                    Mn = function(w, P, ie) {
                        if (ie.inputLabel) {
                            var $e = document.createElement("label"),
                                Tt = y["input-label"];
                            $e.setAttribute("for", w.id), $e.className = Tt, "object" === z(ie.customClass) && Rn($e, ie.customClass.inputLabel), $e.innerText = ie.inputLabel, P.insertAdjacentElement("beforebegin", $e)
                        }
                    },
                    pd = function(w) {
                        return Ji(An(), y[w] || y.input)
                    },
                    un = function(w, P) {
                        ["string", "number"].includes(z(P)) ? w.value = "".concat(P) : sn(P) || R('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(z(P), '"'))
                    },
                    Cr = {};
                Cr.text = Cr.email = Cr.password = Cr.number = Cr.tel = Cr.url = Cr.search = Cr.date = Cr["datetime-local"] = Cr.time = Cr.week = Cr.month = function(oe, w) {
                    return un(oe, w.inputValue), Mn(oe, oe, w), fs(oe, w), oe.type = w.input, oe
                }, Cr.file = function(oe, w) {
                    return Mn(oe, oe, w), fs(oe, w), oe
                }, Cr.range = function(oe, w) {
                    var P = oe.querySelector("input"),
                        ie = oe.querySelector("output");
                    return un(P, w.inputValue), P.type = w.input, un(ie, w.inputValue), Mn(P, oe, w), oe
                }, Cr.select = function(oe, w) {
                    if (oe.textContent = "", w.inputPlaceholder) {
                        var P = document.createElement("option");
                        Sn(P, w.inputPlaceholder), P.value = "", P.disabled = !0, P.selected = !0, oe.appendChild(P)
                    }
                    return Mn(oe, oe, w), oe
                }, Cr.radio = function(oe) {
                    return oe.textContent = "", oe
                }, Cr.checkbox = function(oe, w) {
                    var P = hr(An(), "checkbox");
                    P.value = "1", P.checked = !!w.inputValue;
                    var ie = oe.querySelector("span");
                    return Sn(ie, w.inputPlaceholder), P
                }, Cr.textarea = function(oe, w) {
                    un(oe, w.inputValue), fs(oe, w), Mn(oe, oe, w);
                    return setTimeout(function() {
                        if ("MutationObserver" in window) {
                            var ie = parseInt(window.getComputedStyle(An()).width);
                            new MutationObserver(function() {
                                if (document.body.contains(oe)) {
                                    var En = oe.offsetWidth + ($e = oe, parseInt(window.getComputedStyle($e).marginLeft) + parseInt(window.getComputedStyle($e).marginRight));
                                    En > ie ? An().style.width = "".concat(En, "px") : gn(An(), "width", w.width)
                                }
                                var $e
                            }).observe(oe, {
                                attributes: !0,
                                attributeFilter: ["style"]
                            })
                        }
                    }), oe
                };
                var Dt = function(w, P) {
                        var ie = Wn();
                        ie && (Ve(ie), yi(ie, P, "htmlContainer"), P.html ? (xo(P.html, ie), Si(ie, "block")) : P.text ? (ie.textContent = P.text, Si(ie, "block")) : qn(ie), function(w, P) {
                            var ie = An();
                            if (ie) {
                                var $e = Zi.innerParams.get(w),
                                    Tt = !$e || P.input !== $e.input;
                                hd.forEach(function(En) {
                                    var ri = Ji(ie, y[En]);
                                    ri && (kl(En, P.inputAttributes), ri.className = y[En], Tt && qn(ri))
                                }), P.input && (Tt && yu(P), Jc(P))
                            }
                        }(w, P))
                    },
                    Ac = function(w, P) {
                        for (var ie = 0, $e = Object.entries(A); ie < $e.length; ie++) {
                            var Tt = ve($e[ie], 2);
                            P.icon !== Tt[0] && Ti(w, Tt[1])
                        }
                        Rn(w, P.icon && A[P.icon]), lt(w, P), _u(), yi(w, P, "icon")
                    },
                    _u = function() {
                        var w = An();
                        if (w)
                            for (var P = window.getComputedStyle(w).getPropertyValue("background-color"), ie = w.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"), $e = 0; $e < ie.length; $e++) ie[$e].style.backgroundColor = P
                    },
                    kc = function(w, P) {
                        if (P.icon || P.iconHtml) {
                            var ie = w.innerHTML,
                                $e = "";
                            P.iconHtml ? $e = Ye(P.iconHtml) : "success" === P.icon ? ($e = '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n', ie = ie.replace(/ style=".*?"/g, "")) : "error" === P.icon ? $e = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n' : P.icon && ($e = Ye({
                                question: "?",
                                warning: "!",
                                info: "i"
                            }[P.icon])), ie.trim() !== $e.trim() && Sn(w, $e)
                        }
                    },
                    lt = function(w, P) {
                        if (P.iconColor) {
                            w.style.color = P.iconColor, w.style.borderColor = P.iconColor;
                            for (var ie = 0, $e = [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]; ie < $e.length; ie++) at(w, $e[ie], "background-color", P.iconColor);
                            at(w, ".swal2-success-ring", "border-color", P.iconColor)
                        }
                    },
                    Ye = function(w) {
                        return '<div class="'.concat(y["icon-content"], '">').concat(w, "</div>")
                    },
                    kt = function(w, P) {
                        var ie = P.showClass || {};
                        w.className = "".concat(y.popup, " ").concat(St(w) ? ie.popup : ""), P.toast ? (Rn([document.documentElement, document.body], y["toast-shown"]), Rn(w, y.toast)) : Rn(w, y.modal), yi(w, P, "popup"), "string" == typeof P.customClass && Rn(w, P.customClass), P.icon && Rn(w, y["icon-".concat(P.icon)])
                    },
                    _r = function(w) {
                        var P = document.createElement("li");
                        return Rn(P, y["progress-step"]), Sn(P, w), P
                    },
                    Ei = function(w) {
                        var P = document.createElement("li");
                        return Rn(P, y["progress-step-line"]), w.progressStepsDistance && gn(P, "width", w.progressStepsDistance), P
                    },
                    ha = function(w, P) {
                        (function(w, P) {
                            var ie = ei(),
                                $e = An();
                            if (ie && $e) {
                                if (P.toast) {
                                    gn(ie, "width", P.width), $e.style.width = "100%";
                                    var Tt = W();
                                    Tt && $e.insertBefore(Tt, ui())
                                } else gn($e, "width", P.width);
                                gn($e, "padding", P.padding), P.color && ($e.style.color = P.color), P.background && ($e.style.background = P.background), qn(ci()), kt($e, P)
                            }
                        })(0, P), da(0, P),
                            function(w, P) {
                                var ie = Bi();
                                if (ie) {
                                    var $e = P.progressSteps,
                                        Tt = P.currentProgressStep;
                                    if (!$e || 0 === $e.length || void 0 === Tt) return void qn(ie);
                                    Si(ie), ie.textContent = "", Tt >= $e.length && R("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), $e.forEach(function(En, ri) {
                                        var Pi = _r(En);
                                        if (ie.appendChild(Pi), ri === Tt && Rn(Pi, y["active-progress-step"]), ri !== $e.length - 1) {
                                            var lr = Ei(P);
                                            ie.appendChild(lr)
                                        }
                                    })
                                }
                            }(0, P),
                            function(w, P) {
                                var ie = Zi.innerParams.get(w),
                                    $e = ui();
                                if ($e) {
                                    if (ie && P.icon === ie.icon) return kc($e, P), void Ac($e, P);
                                    if (!P.icon && !P.iconHtml) return void qn($e);
                                    if (P.icon && -1 === Object.keys(A).indexOf(P.icon)) return Q('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(P.icon, '"')), void qn($e);
                                    Si($e), kc($e, P), Ac($e, P), Rn($e, P.showClass && P.showClass.icon)
                                }
                            }(w, P),
                            function(w, P) {
                                var ie = kn();
                                if (ie) {
                                    if (!P.imageUrl) return void qn(ie);
                                    Si(ie, ""), ie.setAttribute("src", P.imageUrl), ie.setAttribute("alt", P.imageAlt || ""), gn(ie, "width", P.imageWidth), gn(ie, "height", P.imageHeight), ie.className = y.image, yi(ie, P, "image")
                                }
                            }(0, P),
                            function(w, P) {
                                var ie = ji();
                                ie && (Ve(ie), pt(ie, P.title || P.titleText, "block"), P.title && xo(P.title, ie), P.titleText && (ie.innerText = P.titleText), yi(ie, P, "title"))
                            }(0, P),
                            function(w, P) {
                                var ie = st();
                                ie && (Sn(ie, P.closeButtonHtml || ""), yi(ie, P, "closeButton"), pt(ie, P.showCloseButton), ie.setAttribute("aria-label", P.closeButtonAriaLabel || ""))
                            }(0, P), Dt(w, P), la(0, P),
                            function(w, P) {
                                var ie = je();
                                ie && (Ve(ie), pt(ie, P.footer, "block"), P.footer && xo(P.footer, ie), yi(ie, P, "footer"))
                            }(0, P);
                        var ie = An();
                        "function" == typeof P.didRender && ie && P.didRender(ie)
                    },
                    Zo = function() {
                        var w;
                        return null === (w = en()) || void 0 === w ? void 0 : w.click()
                    },
                    Wi = Object.freeze({
                        cancel: "cancel",
                        backdrop: "backdrop",
                        close: "close",
                        esc: "esc",
                        timer: "timer"
                    }),
                    as = function(w) {
                        w.keydownTarget && w.keydownHandlerAdded && (w.keydownTarget.removeEventListener("keydown", w.keydownHandler, {
                            capture: w.keydownListenerCapture
                        }), w.keydownHandlerAdded = !1)
                    },
                    cs = function(w, P) {
                        var ie, $e = Kn();
                        if ($e.length) return (w += P) === $e.length ? w = 0 : -1 === w && (w = $e.length - 1), void $e[w].focus();
                        null === (ie = An()) || void 0 === ie || ie.focus()
                    },
                    co = ["ArrowRight", "ArrowDown"],
                    Ms = ["ArrowLeft", "ArrowUp"],
                    eo = function(w, P, ie) {
                        w && (P.isComposing || 229 === P.keyCode || (w.stopKeydownPropagation && P.stopPropagation(), "Enter" === P.key ? Gr(P, w) : "Tab" === P.key ? Oa(P) : [].concat(co, Ms).includes(P.key) ? Lo(P.key) : "Escape" === P.key && fa(P, w, ie)))
                    },
                    Gr = function(w, P) {
                        if (wt(P.allowEnterKey)) {
                            var ie = hr(An(), P.input);
                            if (w.target && ie && w.target instanceof HTMLElement && w.target.outerHTML === ie.outerHTML) {
                                if (["textarea", "file"].includes(P.input)) return;
                                Zo(), w.preventDefault()
                            }
                        }
                    },
                    Oa = function(w) {
                        for (var P = w.target, ie = Kn(), $e = -1, Tt = 0; Tt < ie.length; Tt++)
                            if (P === ie[Tt]) {
                                $e = Tt;
                                break
                            }
                        cs($e, w.shiftKey ? -1 : 1), w.stopPropagation(), w.preventDefault()
                    },
                    Lo = function(w) {
                        var P = ke(),
                            ie = en(),
                            $e = pe(),
                            Tt = Ii();
                        if (P && ie && $e && Tt && (!(document.activeElement instanceof HTMLElement) || [ie, $e, Tt].includes(document.activeElement))) {
                            var ri = co.includes(w) ? "nextElementSibling" : "previousElementSibling",
                                Pi = document.activeElement;
                            if (Pi) {
                                for (var lr = 0; lr < P.children.length; lr++) {
                                    if (!(Pi = Pi[ri])) return;
                                    if (Pi instanceof HTMLButtonElement && St(Pi)) break
                                }
                                Pi instanceof HTMLButtonElement && Pi.focus()
                            }
                        }
                    },
                    fa = function(w, P, ie) {
                        wt(P.allowEscapeKey) && (w.preventDefault(), ie(Wi.esc))
                    },
                    $s = {
                        swalPromiseResolve: new WeakMap,
                        swalPromiseReject: new WeakMap
                    },
                    Mc = function() {
                        Array.from(document.body.children).forEach(function(P) {
                            P.hasAttribute("data-previous-aria-hidden") ? (P.setAttribute("aria-hidden", P.getAttribute("data-previous-aria-hidden") || ""), P.removeAttribute("data-previous-aria-hidden")) : P.removeAttribute("aria-hidden")
                        })
                    },
                    ps = typeof window < "u" && !!window.GestureEvent,
                    Il = function() {
                        var P, w = ei();
                        w && (w.ontouchstart = function(ie) {
                            P = He(ie)
                        }, w.ontouchmove = function(ie) {
                            P && (ie.preventDefault(), ie.stopPropagation())
                        })
                    },
                    He = function(w) {
                        var P = w.target,
                            ie = ei(),
                            $e = Wn();
                        return !(!ie || !$e || La(w) || Ic(w) || P !== ie && (Nn(ie) || !(P instanceof HTMLElement) || "INPUT" === P.tagName || "TEXTAREA" === P.tagName || Nn($e) && $e.contains(P)))
                    },
                    La = function(w) {
                        return w.touches && w.touches.length && "stylus" === w.touches[0].touchType
                    },
                    Ic = function(w) {
                        return w.touches && w.touches.length > 1
                    },
                    _t = null,
                    ns = function(w) {
                        null === _t && (document.body.scrollHeight > window.innerHeight || "scroll" === w) && (_t = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = "".concat(_t + function() {
                            var w = document.createElement("div");
                            w.className = y["scrollbar-measure"], document.body.appendChild(w);
                            var P = w.getBoundingClientRect().width - w.clientWidth;
                            return document.body.removeChild(w), P
                        }(), "px"))
                    };

                function sc(oe, w, P, ie) {
                    $n() ? xs(oe, ie) : (M(P).then(function() {
                            return xs(oe, ie)
                        }), as(f)), ps ? (w.setAttribute("style", "display:none !important"), w.removeAttribute("class"), w.innerHTML = "") : w.remove(), mn() && (null !== _t && (document.body.style.paddingRight = "".concat(_t, "px"), _t = null), function() {
                            if (pi(document.body, y.iosfix)) {
                                var w = parseInt(document.body.style.top, 10);
                                Ti(document.body, y.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * w
                            }
                        }(), Mc()),
                        function Pc() {
                            Ti([document.documentElement, document.body], [y.shown, y["height-auto"], y["no-backdrop"], y["toast-shown"]])
                        }()
                }

                function Is(oe) {
                    oe = zs(oe);
                    var w = $s.swalPromiseResolve.get(this),
                        P = is(this);
                    this.isAwaitingPromise ? oe.isDismissed || ($t(this), w(oe)) : P && w(oe)
                }
                var is = function(w) {
                    var P = An();
                    if (!P) return !1;
                    var ie = Zi.innerParams.get(w);
                    if (!ie || pi(P, ie.hideClass.popup)) return !1;
                    Ti(P, ie.showClass.popup), Rn(P, ie.hideClass.popup);
                    var $e = ei();
                    return Ti($e, ie.showClass.backdrop), Rn($e, ie.hideClass.backdrop), pa(w, P, ie), !0
                };

                function bu(oe) {
                    var w = $s.swalPromiseReject.get(this);
                    $t(this), w && w(oe)
                }
                var $t = function(w) {
                        w.isAwaitingPromise && (delete w.isAwaitingPromise, Zi.innerParams.get(w) || w._destroy())
                    },
                    zs = function(w) {
                        return typeof w > "u" ? {
                            isConfirmed: !1,
                            isDenied: !1,
                            isDismissed: !0
                        } : Object.assign({
                            isConfirmed: !1,
                            isDenied: !1,
                            isDismissed: !1
                        }, w)
                    },
                    pa = function(w, P, ie) {
                        var $e = ei(),
                            Tt = Nr && Ut(P);
                        "function" == typeof ie.willClose && ie.willClose(P), Tt ? ls(w, P, $e, ie.returnFocus, ie.didClose) : sc(w, $e, ie.returnFocus, ie.didClose)
                    },
                    ls = function(w, P, ie, $e, Tt) {
                        Nr && (f.swalCloseEventFinishedCallback = sc.bind(null, w, ie, $e, Tt), P.addEventListener(Nr, function(En) {
                            En.target === P && (f.swalCloseEventFinishedCallback(), delete f.swalCloseEventFinishedCallback)
                        }))
                    },
                    xs = function(w, P) {
                        setTimeout(function() {
                            "function" == typeof P && P.bind(w.params)(), w._destroy && w._destroy()
                        })
                    },
                    Vn = function(w) {
                        var P = An();
                        if (P || new Cu, P = An()) {
                            var ie = W();
                            $n() ? qn(ui()) : tl(P, w), Si(ie), P.setAttribute("data-loading", "true"), P.setAttribute("aria-busy", "true"), P.focus()
                        }
                    },
                    tl = function(w, P) {
                        var ie = ke(),
                            $e = W();
                        !ie || !$e || (!P && St(en()) && (P = en()), Si(ie), P && (qn(P), $e.setAttribute("data-button-to-replace", P.className), ie.insertBefore($e, P)), Rn([w, ie], y.loading))
                    },
                    Ph = function(w) {
                        return w.checked ? 1 : 0
                    },
                    Ba = function(w) {
                        return w.checked ? w.value : null
                    },
                    Pl = function(w) {
                        return w.files && w.files.length ? null !== w.getAttribute("multiple") ? w.files : w.files[0] : null
                    },
                    Oh = function(w, P) {
                        var ie = An();
                        if (ie) {
                            var $e = function(En) {
                                "select" === P.input ? function dn(oe, w, P) {
                                    var ie = Ji(oe, y.select);
                                    if (ie) {
                                        var $e = function(En, ri, Pi) {
                                            var lr = document.createElement("option");
                                            lr.value = Pi, Sn(lr, ri), lr.selected = il(Pi, P.inputValue), En.appendChild(lr)
                                        };
                                        w.forEach(function(Tt) {
                                            var En = Tt[0],
                                                ri = Tt[1];
                                            if (Array.isArray(ri)) {
                                                var Pi = document.createElement("optgroup");
                                                Pi.label = En, Pi.disabled = !1, ie.appendChild(Pi), ri.forEach(function(lr) {
                                                    return $e(Pi, lr[1], lr[0])
                                                })
                                            } else $e(ie, ri, En)
                                        }), ie.focus()
                                    }
                                }(ie, _d(En), P) : "radio" === P.input && function Bo(oe, w, P) {
                                    var ie = Ji(oe, y.radio);
                                    if (ie) {
                                        w.forEach(function(Tt) {
                                            var En = Tt[0],
                                                ri = Tt[1],
                                                Pi = document.createElement("input"),
                                                lr = document.createElement("label");
                                            Pi.type = "radio", Pi.name = y.radio, Pi.value = En, il(En, P.inputValue) && (Pi.checked = !0);
                                            var Tu = document.createElement("span");
                                            Sn(Tu, ri), Tu.className = y.label, lr.appendChild(Pi), lr.appendChild(Tu), ie.appendChild(lr)
                                        });
                                        var $e = ie.querySelectorAll("input");
                                        $e.length && $e[0].focus()
                                    }
                                }(ie, _d(En), P)
                            };
                            Vt(P.inputOptions) || sn(P.inputOptions) ? (Vn(en()), Mt(P.inputOptions).then(function(Tt) {
                                w.hideLoading(), $e(Tt)
                            })) : "object" === z(P.inputOptions) ? $e(P.inputOptions) : Q("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(z(P.inputOptions)))
                        }
                    },
                    yd = function(w, P) {
                        var ie = w.getInput();
                        ie && (qn(ie), Mt(P.inputValue).then(function($e) {
                            ie.value = "".concat("number" === P.input ? parseFloat($e) || 0 : $e), Si(ie), ie.focus(), w.hideLoading()
                        }).catch(function($e) {
                            Q("Error in inputValue promise: ".concat($e)), ie.value = "", Si(ie), ie.focus(), w.hideLoading()
                        }))
                    };
                var _d = function oe(w) {
                        var P = [];
                        return w instanceof Map ? w.forEach(function(ie, $e) {
                            var Tt = ie;
                            "object" === z(Tt) && (Tt = oe(Tt)), P.push([$e, Tt])
                        }) : Object.keys(w).forEach(function(ie) {
                            var $e = w[ie];
                            "object" === z($e) && ($e = oe($e)), P.push([ie, $e])
                        }), P
                    },
                    il = function(w, P) {
                        return !!P && P.toString() === w.toString()
                    },
                    Ol = void 0,
                    Pr = function(w, P) {
                        var ie = Zi.innerParams.get(w);
                        if (ie.input) {
                            var $e = w.getInput(),
                                Tt = function(w, P) {
                                    var ie = w.getInput();
                                    if (!ie) return null;
                                    switch (P.input) {
                                        case "checkbox":
                                            return Ph(ie);
                                        case "radio":
                                            return Ba(ie);
                                        case "file":
                                            return Pl(ie);
                                        default:
                                            return P.inputAutoTrim ? ie.value.trim() : ie.value
                                    }
                                }(w, ie);
                            ie.inputValidator ? Bh(w, Tt, P) : $e && !$e.checkValidity() ? (w.enableButtons(), w.showValidationMessage(ie.validationMessage || $e.validationMessage)) : "deny" === P ? to(w, Tt) : Oc(w, Tt)
                        } else Q('The "input" parameter is needed to be set when using returnInputValueOn'.concat(N(P)))
                    },
                    Bh = function(w, P, ie) {
                        var $e = Zi.innerParams.get(w);
                        w.disableInput(), Promise.resolve().then(function() {
                            return Mt($e.inputValidator(P, $e.validationMessage))
                        }).then(function(En) {
                            w.enableButtons(), w.enableInput(), En ? w.showValidationMessage(En) : "deny" === ie ? to(w, P) : Oc(w, P)
                        })
                    },
                    to = function(w, P) {
                        var ie = Zi.innerParams.get(w || Ol);
                        ie.showLoaderOnDeny && Vn(pe()), ie.preDeny ? (w.isAwaitingPromise = !0, Promise.resolve().then(function() {
                            return Mt(ie.preDeny(P, ie.validationMessage))
                        }).then(function(Tt) {
                            !1 === Tt ? (w.hideLoading(), $t(w)) : w.close({
                                isDenied: !0,
                                value: typeof Tt > "u" ? P : Tt
                            })
                        }).catch(function(Tt) {
                            return ct(w || Ol, Tt)
                        })) : w.close({
                            isDenied: !0,
                            value: P
                        })
                    },
                    fn = function(w, P) {
                        w.close({
                            isConfirmed: !0,
                            value: P
                        })
                    },
                    ct = function(w, P) {
                        w.rejectPromise(P)
                    },
                    Oc = function(w, P) {
                        var ie = Zi.innerParams.get(w || Ol);
                        ie.showLoaderOnConfirm && Vn(), ie.preConfirm ? (w.resetValidationMessage(), w.isAwaitingPromise = !0, Promise.resolve().then(function() {
                            return Mt(ie.preConfirm(P, ie.validationMessage))
                        }).then(function(Tt) {
                            St(ci()) || !1 === Tt ? (w.hideLoading(), $t(w)) : fn(w, typeof Tt > "u" ? P : Tt)
                        }).catch(function(Tt) {
                            return ct(w || Ol, Tt)
                        })) : fn(w, P)
                    };

                function Yn() {
                    var oe = Zi.innerParams.get(this);
                    if (oe) {
                        var w = Zi.domCache.get(this);
                        qn(w.loader), $n() ? oe.icon && Si(ui()) : vd(w), Ti([w.popup, w.actions], y.loading), w.popup.removeAttribute("aria-busy"), w.popup.removeAttribute("data-loading"), w.confirmButton.disabled = !1, w.denyButton.disabled = !1, w.cancelButton.disabled = !1
                    }
                }
                var vd = function(w) {
                    var P = w.popup.getElementsByClassName(w.loader.getAttribute("data-button-to-replace"));
                    P.length ? Si(P[0], "inline-block") : !St(en()) && !St(pe()) && !St(Ii()) && qn(w.actions)
                };

                function Nh() {
                    var oe = Zi.innerParams.get(this),
                        w = Zi.domCache.get(this);
                    return w ? hr(w.popup, oe.input) : null
                }

                function bd(oe, w, P) {
                    var ie = Zi.domCache.get(oe);
                    w.forEach(function($e) {
                        ie[$e].disabled = P
                    })
                }

                function Jt(oe, w) {
                    var P = An();
                    if (P && oe)
                        if ("radio" === oe.type)
                            for (var ie = P.querySelectorAll('[name="'.concat(y.radio, '"]')), $e = 0; $e < ie.length; $e++) ie[$e].disabled = w;
                        else oe.disabled = w
                }

                function Rl() {
                    bd(this, ["confirmButton", "denyButton", "cancelButton"], !1)
                }

                function Ot() {
                    bd(this, ["confirmButton", "denyButton", "cancelButton"], !0)
                }

                function xn() {
                    Jt(this.getInput(), !1)
                }

                function Na() {
                    Jt(this.getInput(), !0)
                }

                function Fa(oe) {
                    var w = Zi.domCache.get(this),
                        P = Zi.innerParams.get(this);
                    Sn(w.validationMessage, oe), w.validationMessage.className = y["validation-message"], P.customClass && P.customClass.validationMessage && Rn(w.validationMessage, P.customClass.validationMessage), Si(w.validationMessage);
                    var ie = this.getInput();
                    ie && (ie.setAttribute("aria-invalid", "true"), ie.setAttribute("aria-describedby", y["validation-message"]), qo(ie), Rn(ie, y.inputerror))
                }

                function Fh() {
                    var oe = Zi.domCache.get(this);
                    oe.validationMessage && qn(oe.validationMessage);
                    var w = this.getInput();
                    w && (w.removeAttribute("aria-invalid"), w.removeAttribute("aria-describedby"), Ti(w, y.inputerror))
                }
                var _i = {
                        title: "",
                        titleText: "",
                        text: "",
                        html: "",
                        footer: "",
                        icon: void 0,
                        iconColor: void 0,
                        iconHtml: void 0,
                        template: void 0,
                        toast: !1,
                        animation: !0,
                        showClass: {
                            popup: "swal2-show",
                            backdrop: "swal2-backdrop-show",
                            icon: "swal2-icon-show"
                        },
                        hideClass: {
                            popup: "swal2-hide",
                            backdrop: "swal2-backdrop-hide",
                            icon: "swal2-icon-hide"
                        },
                        customClass: {},
                        target: "body",
                        color: void 0,
                        backdrop: !0,
                        heightAuto: !0,
                        allowOutsideClick: !0,
                        allowEscapeKey: !0,
                        allowEnterKey: !0,
                        stopKeydownPropagation: !0,
                        keydownListenerCapture: !1,
                        showConfirmButton: !0,
                        showDenyButton: !1,
                        showCancelButton: !1,
                        preConfirm: void 0,
                        preDeny: void 0,
                        confirmButtonText: "OK",
                        confirmButtonAriaLabel: "",
                        confirmButtonColor: void 0,
                        denyButtonText: "No",
                        denyButtonAriaLabel: "",
                        denyButtonColor: void 0,
                        cancelButtonText: "Cancel",
                        cancelButtonAriaLabel: "",
                        cancelButtonColor: void 0,
                        buttonsStyling: !0,
                        reverseButtons: !1,
                        focusConfirm: !0,
                        focusDeny: !1,
                        focusCancel: !1,
                        returnFocus: !0,
                        showCloseButton: !1,
                        closeButtonHtml: "&times;",
                        closeButtonAriaLabel: "Close this dialog",
                        loaderHtml: "",
                        showLoaderOnConfirm: !1,
                        showLoaderOnDeny: !1,
                        imageUrl: void 0,
                        imageWidth: void 0,
                        imageHeight: void 0,
                        imageAlt: "",
                        timer: void 0,
                        timerProgressBar: !1,
                        width: void 0,
                        padding: void 0,
                        background: void 0,
                        input: void 0,
                        inputPlaceholder: "",
                        inputLabel: "",
                        inputValue: "",
                        inputOptions: {},
                        inputAutoFocus: !0,
                        inputAutoTrim: !0,
                        inputAttributes: {},
                        inputValidator: void 0,
                        returnInputValueOnDeny: !1,
                        validationMessage: void 0,
                        grow: !1,
                        position: "center",
                        progressSteps: [],
                        currentProgressStep: void 0,
                        progressStepsDistance: void 0,
                        willOpen: void 0,
                        didOpen: void 0,
                        didRender: void 0,
                        willClose: void 0,
                        didClose: void 0,
                        didDestroy: void 0,
                        scrollbarPadding: !0
                    },
                    fp = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"],
                    Vh = {},
                    Un = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"],
                    Ps = function(w) {
                        return Object.prototype.hasOwnProperty.call(_i, w)
                    },
                    Yi = function(w) {
                        return -1 !== fp.indexOf(w)
                    },
                    Kr = function(w) {
                        return Vh[w]
                    },
                    js = function(w) {
                        Ps(w) || R('Unknown parameter "'.concat(w, '"'))
                    },
                    Va = function(w) {
                        Un.includes(w) && R('The parameter "'.concat(w, '" is incompatible with toasts'))
                    },
                    lo = function(w) {
                        var P = Kr(w);
                        P && Ge(w, P)
                    };

                function be(oe) {
                    var w = An(),
                        P = Zi.innerParams.get(this);
                    if (w && !pi(w, P.hideClass.popup)) {
                        var ie = Ue(oe),
                            $e = Object.assign({}, P, ie);
                        ha(this, $e), Zi.innerParams.set(this, $e), Object.defineProperties(this, {
                            params: {
                                value: Object.assign({}, this.params, oe),
                                writable: !1,
                                enumerable: !0
                            }
                        })
                    } else R("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.")
                }
                var Ue = function(w) {
                    var P = {};
                    return Object.keys(w).forEach(function(ie) {
                        Yi(ie) ? P[ie] = w[ie] : R("Invalid parameter to update: ".concat(ie))
                    }), P
                };

                function rt() {
                    var oe = Zi.domCache.get(this),
                        w = Zi.innerParams.get(this);
                    w ? (oe.popup && f.swalCloseEventFinishedCallback && (f.swalCloseEventFinishedCallback(), delete f.swalCloseEventFinishedCallback), "function" == typeof w.didDestroy && w.didDestroy(), At(this)) : Wt(this)
                }
                var At = function(w) {
                        Wt(w), delete w.params, delete f.keydownHandler, delete f.keydownTarget, delete f.currentInstance
                    },
                    Wt = function(w) {
                        w.isAwaitingPromise ? (Ct(Zi, w), w.isAwaitingPromise = !0) : (Ct($s, w), Ct(Zi, w), delete w.isAwaitingPromise, delete w.disableButtons, delete w.enableButtons, delete w.getInput, delete w.disableInput, delete w.enableInput, delete w.hideLoading, delete w.disableLoading, delete w.showValidationMessage, delete w.resetValidationMessage, delete w.close, delete w.closePopup, delete w.closeModal, delete w.closeToast, delete w.rejectPromise, delete w.update, delete w._destroy)
                    },
                    Ct = function(w, P) {
                        for (var ie in w) w[ie].delete(P)
                    },
                    bn = Object.freeze({
                        __proto__: null,
                        _destroy: rt,
                        close: Is,
                        closeModal: Is,
                        closePopup: Is,
                        closeToast: Is,
                        disableButtons: Ot,
                        disableInput: Na,
                        disableLoading: Yn,
                        enableButtons: Rl,
                        enableInput: xn,
                        getInput: Nh,
                        handleAwaitingPromise: $t,
                        hideLoading: Yn,
                        rejectPromise: bu,
                        resetValidationMessage: Fh,
                        showValidationMessage: Fa,
                        update: be
                    }),
                    ni = function(w, P, ie) {
                        P.popup.onclick = function() {
                            w && (fr(w) || w.timer || w.input) || ie(Wi.close)
                        }
                    },
                    fr = function(w) {
                        return !!(w.showConfirmButton || w.showDenyButton || w.showCancelButton || w.showCloseButton)
                    },
                    ii = !1,
                    no = function(w) {
                        w.popup.onmousedown = function() {
                            w.container.onmouseup = function(P) {
                                w.container.onmouseup = function() {}, P.target === w.container && (ii = !0)
                            }
                        }
                    },
                    vr = function(w) {
                        w.container.onmousedown = function(P) {
                            P.target === w.container && P.preventDefault(), w.popup.onmouseup = function(ie) {
                                w.popup.onmouseup = function() {}, (ie.target === w.popup || ie.target instanceof HTMLElement && w.popup.contains(ie.target)) && (ii = !0)
                            }
                        }
                    },
                    Zr = function(w, P, ie) {
                        P.container.onclick = function($e) {
                            ii ? ii = !1 : $e.target === P.container && wt(w.allowOutsideClick) && ie(Wi.backdrop)
                        }
                    },
                    Hn = function(w) {
                        return w instanceof Element || function(w) {
                            return "object" === z(w) && w.jquery
                        }(w)
                    };
                var No = function() {
                        if (f.timeout) return function() {
                            var w = Qe();
                            if (w) {
                                var P = parseInt(window.getComputedStyle(w).width);
                                w.style.removeProperty("transition"), w.style.width = "100%";
                                var ie = parseInt(window.getComputedStyle(w).width);
                                w.style.width = "".concat(P / ie * 100, "%")
                            }
                        }(), f.timeout.stop()
                    },
                    Xo = function() {
                        if (f.timeout) {
                            var w = f.timeout.start();
                            return or(w), w
                        }
                    },
                    Lc = !1,
                    Ua = {};
                var Bl = function(w) {
                        for (var P = w.target; P && P !== document; P = P.parentNode)
                            for (var ie in Ua) {
                                var $e = P.getAttribute(ie);
                                if ($e) return void Ua[ie].fire({
                                    template: $e
                                })
                            }
                    },
                    Ni = Object.freeze({
                        __proto__: null,
                        argsToParams: function(w) {
                            var P = {};
                            return "object" !== z(w[0]) || Hn(w[0]) ? ["title", "html", "icon"].forEach(function(ie, $e) {
                                var Tt = w[$e];
                                "string" == typeof Tt || Hn(Tt) ? P[ie] = Tt : void 0 !== Tt && Q("Unexpected type of ".concat(ie, '! Expected "string" or "Element", got ').concat(z(Tt)))
                            }) : Object.assign(P, w[0]), P
                        },
                        bindClickHandler: function xd() {
                            Ua[arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "data-swal-template"] = this, Lc || (document.body.addEventListener("click", Bl), Lc = !0)
                        },
                        clickCancel: function() {
                            var w;
                            return null === (w = Ii()) || void 0 === w ? void 0 : w.click()
                        },
                        clickConfirm: Zo,
                        clickDeny: function() {
                            var w;
                            return null === (w = pe()) || void 0 === w ? void 0 : w.click()
                        },
                        enableLoading: Vn,
                        fire: function Uh() {
                            for (var w = arguments.length, P = new Array(w), ie = 0; ie < w; ie++) P[ie] = arguments[ie];
                            return function q(oe, w, P) {
                                if (ne()) return Reflect.construct.apply(null, arguments);
                                var ie = [null];
                                ie.push.apply(ie, w);
                                var $e = new(oe.bind.apply(oe, ie));
                                return P && de($e, P.prototype), $e
                            }(this, P)
                        },
                        getActions: ke,
                        getCancelButton: Ii,
                        getCloseButton: st,
                        getConfirmButton: en,
                        getContainer: ei,
                        getDenyButton: pe,
                        getFocusableElements: Kn,
                        getFooter: je,
                        getHtmlContainer: Wn,
                        getIcon: ui,
                        getIconContent: function() {
                            return jn(y["icon-content"])
                        },
                        getImage: kn,
                        getInputLabel: function() {
                            return jn(y["input-label"])
                        },
                        getLoader: W,
                        getPopup: An,
                        getProgressSteps: Bi,
                        getTimerLeft: function() {
                            return f.timeout && f.timeout.getTimerLeft()
                        },
                        getTimerProgressBar: Qe,
                        getTitle: ji,
                        getValidationMessage: ci,
                        increaseTimer: function(w) {
                            if (f.timeout) {
                                var P = f.timeout.increase(w);
                                return or(P, !0), P
                            }
                        },
                        isDeprecatedParameter: Kr,
                        isLoading: function() {
                            var w = An();
                            return !!w && w.hasAttribute("data-loading")
                        },
                        isTimerRunning: function() {
                            return !(!f.timeout || !f.timeout.isRunning())
                        },
                        isUpdatableParameter: Yi,
                        isValidParameter: Ps,
                        isVisible: function() {
                            return St(An())
                        },
                        mixin: function sl(oe) {
                            var w = function(P) {
                                function ie() {
                                    return H(this, ie), T(this, ie, arguments)
                                }
                                return function le(oe, w) {
                                    if ("function" != typeof w && null !== w) throw new TypeError("Super expression must either be null or a function");
                                    oe.prototype = Object.create(w && w.prototype, {
                                        constructor: {
                                            value: oe,
                                            writable: !0,
                                            configurable: !0
                                        }
                                    }), Object.defineProperty(oe, "prototype", {
                                        writable: !1
                                    }), w && de(oe, w)
                                }(ie, P), Z(ie, [{
                                    key: "_main",
                                    value: function(Tt, En) {
                                        return we(re(ie.prototype), "_main", this).call(this, Tt, Object.assign({}, oe, En))
                                    }
                                }])
                            }(this);
                            return w
                        },
                        resumeTimer: Xo,
                        showLoading: Vn,
                        stopTimer: No,
                        toggleTimer: function() {
                            var w = f.timeout;
                            return w && (w.running ? No() : Xo())
                        }
                    }),
                    I_ = function() {
                        return Z(function oe(w, P) {
                            H(this, oe), this.callback = w, this.remaining = P, this.running = !1, this.start()
                        }, [{
                            key: "start",
                            value: function() {
                                return this.running || (this.running = !0, this.started = new Date, this.id = setTimeout(this.callback, this.remaining)), this.remaining
                            }
                        }, {
                            key: "stop",
                            value: function() {
                                return this.started && this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= (new Date).getTime() - this.started.getTime()), this.remaining
                            }
                        }, {
                            key: "increase",
                            value: function(P) {
                                var ie = this.running;
                                return ie && this.stop(), this.remaining += P, ie && this.start(), this.remaining
                            }
                        }, {
                            key: "getTimerLeft",
                            value: function() {
                                return this.running && (this.stop(), this.start()), this.remaining
                            }
                        }, {
                            key: "isRunning",
                            value: function() {
                                return this.running
                            }
                        }])
                    }(),
                    Cd = ["swal-title", "swal-html", "swal-footer"],
                    io = function(w) {
                        var P = {};
                        return Array.from(w.querySelectorAll("swal-param")).forEach(function($e) {
                            oc($e, ["name", "value"]);
                            var Tt = $e.getAttribute("name"),
                                En = $e.getAttribute("value");
                            P[Tt] = "boolean" == typeof _i[Tt] ? "false" !== En : "object" === z(_i[Tt]) ? JSON.parse(En) : En
                        }), P
                    },
                    Co = function(w) {
                        var P = {};
                        return Array.from(w.querySelectorAll("swal-function-param")).forEach(function($e) {
                            var Tt = $e.getAttribute("name"),
                                En = $e.getAttribute("value");
                            P[Tt] = new Function("return ".concat(En))()
                        }), P
                    },
                    Or = function(w) {
                        var P = {};
                        return Array.from(w.querySelectorAll("swal-button")).forEach(function($e) {
                            oc($e, ["type", "color", "aria-label"]);
                            var Tt = $e.getAttribute("type");
                            P["".concat(Tt, "ButtonText")] = $e.innerHTML, P["show".concat(N(Tt), "Button")] = !0, $e.hasAttribute("color") && (P["".concat(Tt, "ButtonColor")] = $e.getAttribute("color")), $e.hasAttribute("aria-label") && (P["".concat(Tt, "ButtonAriaLabel")] = $e.getAttribute("aria-label"))
                        }), P
                    },
                    Qo = function(w) {
                        var P = {},
                            ie = w.querySelector("swal-image");
                        return ie && (oc(ie, ["src", "width", "height", "alt"]), ie.hasAttribute("src") && (P.imageUrl = ie.getAttribute("src")), ie.hasAttribute("width") && (P.imageWidth = ie.getAttribute("width")), ie.hasAttribute("height") && (P.imageHeight = ie.getAttribute("height")), ie.hasAttribute("alt") && (P.imageAlt = ie.getAttribute("alt"))), P
                    },
                    ms = function(w) {
                        var P = {},
                            ie = w.querySelector("swal-icon");
                        return ie && (oc(ie, ["type", "color"]), ie.hasAttribute("type") && (P.icon = ie.getAttribute("type")), ie.hasAttribute("color") && (P.iconColor = ie.getAttribute("color")), P.iconHtml = ie.innerHTML), P
                    },
                    _g = function(w) {
                        var P = {},
                            ie = w.querySelector("swal-input");
                        ie && (oc(ie, ["type", "label", "placeholder", "value"]), P.input = ie.getAttribute("type") || "text", ie.hasAttribute("label") && (P.inputLabel = ie.getAttribute("label")), ie.hasAttribute("placeholder") && (P.inputPlaceholder = ie.getAttribute("placeholder")), ie.hasAttribute("value") && (P.inputValue = ie.getAttribute("value")));
                        var $e = Array.from(w.querySelectorAll("swal-input-option"));
                        return $e.length && (P.inputOptions = {}, $e.forEach(function(Tt) {
                            oc(Tt, ["value"]);
                            var En = Tt.getAttribute("value");
                            P.inputOptions[En] = Tt.innerHTML
                        })), P
                    },
                    To = function(w, P) {
                        var ie = {};
                        for (var $e in P) {
                            var Tt = P[$e],
                                En = w.querySelector(Tt);
                            En && (oc(En, []), ie[Tt.replace(/^swal-/, "")] = En.innerHTML.trim())
                        }
                        return ie
                    },
                    uo = function(w) {
                        var P = Cd.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
                        Array.from(w.children).forEach(function(ie) {
                            var $e = ie.tagName.toLowerCase();
                            P.includes($e) || R("Unrecognized element <".concat($e, ">"))
                        })
                    },
                    oc = function(w, P) {
                        Array.from(w.attributes).forEach(function(ie) {
                            -1 === P.indexOf(ie.name) && R(['Unrecognized attribute "'.concat(ie.name, '" on <').concat(w.tagName.toLowerCase(), ">."), "".concat(P.length ? "Allowed attributes are: ".concat(P.join(", ")) : "To set the value, use HTML within the element.")])
                        })
                    },
                    Hh = function(w) {
                        var P = ei(),
                            ie = An();
                        "function" == typeof w.willOpen && w.willOpen(ie);
                        var Tt = window.getComputedStyle(document.body).overflowY;
                        Sd(P, ie, w), setTimeout(function() {
                            $h(P, ie)
                        }, 10), mn() && (Td(P, w.scrollbarPadding, Tt), function() {
                            var w = ei();
                            Array.from(document.body.children).forEach(function(ie) {
                                ie.contains(w) || (ie.hasAttribute("aria-hidden") && ie.setAttribute("data-previous-aria-hidden", ie.getAttribute("aria-hidden") || ""), ie.setAttribute("aria-hidden", "true"))
                            })
                        }()), !$n() && !f.previousActiveElement && (f.previousActiveElement = document.activeElement), "function" == typeof w.didOpen && setTimeout(function() {
                            return w.didOpen(ie)
                        }), Ti(P, y["no-transition"])
                    },
                    ga = function oe(w) {
                        var P = An();
                        if (w.target === P && Nr) {
                            var ie = ei();
                            P.removeEventListener(Nr, oe), ie.style.overflowY = "auto"
                        }
                    },
                    $h = function(w, P) {
                        Nr && Ut(P) ? (w.style.overflowY = "hidden", P.addEventListener(Nr, ga)) : w.style.overflowY = "auto"
                    },
                    Td = function(w, P, ie) {
                        (function() {
                            if (ps && !pi(document.body, y.iosfix)) {
                                var w = document.body.scrollTop;
                                document.body.style.top = "".concat(-1 * w, "px"), Rn(document.body, y.iosfix), Il()
                            }
                        })(), P && "hidden" !== ie && ns(ie), setTimeout(function() {
                            w.scrollTop = 0
                        })
                    },
                    Sd = function(w, P, ie) {
                        Rn(w, ie.showClass.backdrop), ie.animation ? (P.style.setProperty("opacity", "0", "important"), Si(P, "grid"), setTimeout(function() {
                            Rn(P, ie.showClass.popup), P.style.removeProperty("opacity")
                        }, 10)) : Si(P, "grid"), Rn([document.documentElement, document.body], y.shown), ie.heightAuto && ie.backdrop && !ie.toast && Rn([document.documentElement, document.body], y["height-auto"])
                    },
                    mp = {
                        email: function(w, P) {
                            return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(w) ? Promise.resolve() : Promise.resolve(P || "Invalid email address")
                        },
                        url: function(w, P) {
                            return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(w) ? Promise.resolve() : Promise.resolve(P || "Invalid URL")
                        }
                    };

                function vg(oe) {
                    (function Ed(oe) {
                        oe.inputValidator || ("email" === oe.input && (oe.inputValidator = mp.email), "url" === oe.input && (oe.inputValidator = mp.url))
                    })(oe), oe.showLoaderOnConfirm && !oe.preConfirm && R("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"),
                        function gp(oe) {
                            (!oe.target || "string" == typeof oe.target && !document.querySelector(oe.target) || "string" != typeof oe.target && !oe.target.appendChild) && (R('Target parameter is not valid, defaulting to "body"'), oe.target = "body")
                        }(oe), "string" == typeof oe.title && (oe.title = oe.title.split("\n").join("<br />")), mt(oe)
                }
                var ya, ol = new WeakMap,
                    Yr = function() {
                        return Z(function oe() {
                            if (H(this, oe), Ie(this, ol, void 0), !(typeof window > "u")) {
                                ya = this;
                                for (var w = arguments.length, P = new Array(w), ie = 0; ie < w; ie++) P[ie] = arguments[ie];
                                var $e = Object.freeze(this.constructor.argsToParams(P));
                                this.params = $e, this.isAwaitingPromise = !1,
                                    function K(oe, w, P) {
                                        return oe.set(I(oe, w), P), P
                                    }(ol, this, this._main(ya.params))
                            }
                        }, [{
                            key: "_main",
                            value: function(P) {
                                var ie = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (function(w) {
                                        for (var P in !1 === w.backdrop && w.allowOutsideClick && R('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`'), w) js(P), w.toast && Va(P), lo(P)
                                    }(Object.assign({}, ie, P)), f.currentInstance) {
                                    var $e = $s.swalPromiseResolve.get(f.currentInstance),
                                        Tt = f.currentInstance.isAwaitingPromise;
                                    f.currentInstance._destroy(), Tt || $e({
                                        isDismissed: !0
                                    }), mn() && Mc()
                                }
                                f.currentInstance = ya;
                                var En = P_(P, ie);
                                vg(En), Object.freeze(En), f.timeout && (f.timeout.stop(), delete f.timeout), clearTimeout(f.restoreFocusTimeout);
                                var ri = wg(ya);
                                return ha(ya, En), Zi.innerParams.set(ya, En), bg(ya, ri, En)
                            }
                        }, {
                            key: "then",
                            value: function(P) {
                                return F(ol, this).then(P)
                            }
                        }, {
                            key: "finally",
                            value: function(P) {
                                return F(ol, this).finally(P)
                            }
                        }])
                    }(),
                    bg = function(w, P, ie) {
                        return new Promise(function($e, Tt) {
                            var En = function(Pi) {
                                w.close({
                                    isDismissed: !0,
                                    dismiss: Pi
                                })
                            };
                            $s.swalPromiseResolve.set(w, $e), $s.swalPromiseReject.set(w, Tt), P.confirmButton.onclick = function() {
                                    ! function(w) {
                                        var P = Zi.innerParams.get(w);
                                        w.disableButtons(), P.input ? Pr(w, "confirm") : Oc(w, !0)
                                    }(w)
                                }, P.denyButton.onclick = function() {
                                    ! function(w) {
                                        var P = Zi.innerParams.get(w);
                                        w.disableButtons(), P.returnInputValueOnDeny ? Pr(w, "deny") : to(w, !1)
                                    }(w)
                                }, P.cancelButton.onclick = function() {
                                    ! function(w, P) {
                                        w.disableButtons(), P(Wi.cancel)
                                    }(w, En)
                                }, P.closeButton.onclick = function() {
                                    En(Wi.close)
                                },
                                function(w, P, ie) {
                                    w.toast ? ni(w, P, ie) : (no(P), vr(P), Zr(w, P, ie))
                                }(ie, P, En),
                                function(w, P, ie) {
                                    as(w), P.toast || (w.keydownHandler = function($e) {
                                        return eo(P, $e, ie)
                                    }, w.keydownTarget = P.keydownListenerCapture ? window : An(), w.keydownListenerCapture = P.keydownListenerCapture, w.keydownTarget.addEventListener("keydown", w.keydownHandler, {
                                        capture: w.keydownListenerCapture
                                    }), w.keydownHandlerAdded = !0)
                                }(f, ie, En),
                                function(w, P) {
                                    "select" === P.input || "radio" === P.input ? Oh(w, P) : ["text", "email", "number", "tel", "textarea"].some(function(ie) {
                                        return ie === P.input
                                    }) && (Vt(P.inputValue) || sn(P.inputValue)) && (Vn(en()), yd(w, P))
                                }(w, ie), Hh(ie), yp(f, ie, En), xg(P, ie), setTimeout(function() {
                                    P.container.scrollTop = 0
                                })
                        })
                    },
                    P_ = function(w, P) {
                        var ie = function(w) {
                                var P = "string" == typeof w.template ? document.querySelector(w.template) : w.template;
                                if (!P) return {};
                                var ie = P.content;
                                return uo(ie), Object.assign(io(ie), Co(ie), Or(ie), Qo(ie), ms(ie), _g(ie), To(ie, Cd))
                            }(w),
                            $e = Object.assign({}, _i, P, ie, w);
                        return $e.showClass = Object.assign({}, _i.showClass, $e.showClass), $e.hideClass = Object.assign({}, _i.hideClass, $e.hideClass), !1 === $e.animation && ($e.showClass = {
                            backdrop: "swal2-noanimation"
                        }, $e.hideClass = {}), $e
                    },
                    wg = function(w) {
                        var P = {
                            popup: An(),
                            container: ei(),
                            actions: ke(),
                            confirmButton: en(),
                            denyButton: pe(),
                            cancelButton: Ii(),
                            loader: W(),
                            closeButton: st(),
                            validationMessage: ci(),
                            progressSteps: Bi()
                        };
                        return Zi.domCache.set(w, P), P
                    },
                    yp = function(w, P, ie) {
                        var $e = Qe();
                        qn($e), P.timer && (w.timeout = new I_(function() {
                            ie("timer"), delete w.timeout
                        }, P.timer), P.timerProgressBar && (Si($e), yi($e, P, "timerProgressBar"), setTimeout(function() {
                            w.timeout && w.timeout.running && or(P.timer)
                        })))
                    },
                    xg = function(w, P) {
                        if (!P.toast) {
                            if (!wt(P.allowEnterKey)) return void vp();
                            _p(w, P) || cs(-1, 1)
                        }
                    },
                    _p = function(w, P) {
                        return P.focusDeny && St(w.denyButton) ? (w.denyButton.focus(), !0) : P.focusCancel && St(w.cancelButton) ? (w.cancelButton.focus(), !0) : !(!P.focusConfirm || !St(w.confirmButton) || (w.confirmButton.focus(), 0))
                    },
                    vp = function() {
                        document.activeElement instanceof HTMLElement && "function" == typeof document.activeElement.blur && document.activeElement.blur()
                    };
                if (typeof window < "u" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
                    var wu = new Date,
                        xu = localStorage.getItem("swal-initiation");
                    xu ? (wu.getTime() - Date.parse(xu)) / 864e5 > 3 && setTimeout(function() {
                        document.body.style.pointerEvents = "none";
                        var oe = document.createElement("audio");
                        oe.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3", oe.loop = !0, document.body.appendChild(oe), setTimeout(function() {
                            oe.play().catch(function() {})
                        }, 2500)
                    }, 500) : localStorage.setItem("swal-initiation", "".concat(wu))
                }
                Yr.prototype.disableButtons = Ot, Yr.prototype.enableButtons = Rl, Yr.prototype.getInput = Nh, Yr.prototype.disableInput = Na, Yr.prototype.enableInput = xn, Yr.prototype.hideLoading = Yn, Yr.prototype.disableLoading = Yn, Yr.prototype.showValidationMessage = Fa, Yr.prototype.resetValidationMessage = Fh, Yr.prototype.close = Is, Yr.prototype.closePopup = Is, Yr.prototype.closeModal = Is, Yr.prototype.closeToast = Is, Yr.prototype.rejectPromise = bu, Yr.prototype.update = be, Yr.prototype._destroy = rt, Object.assign(Yr, Ni), Object.keys(bn).forEach(function(oe) {
                    Yr[oe] = function() {
                        var w;
                        return ya && ya[oe] ? (w = ya)[oe].apply(w, arguments) : null
                    }
                }), Yr.DismissReason = Wi, Yr.version = "11.10.8";
                var Cu = Yr;
                return Cu.default = Cu, Cu
            }(), typeof this < "u" && this.Sweetalert2 && (this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2), typeof document < "u" && function(I, T) {
                var F = I.createElement("style");
                if (I.getElementsByTagName("head")[0].appendChild(F), F.styleSheet) F.styleSheet.disabled || (F.styleSheet.cssText = T);
                else try {
                    F.innerHTML = T
                } catch {
                    F.innerText = T
                }
            }(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em;text-align:center}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#facea8;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#9de0f6;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#c9dae1;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}')
        },
        30004: (et, I, T) => {
            "use strict";
            T.r(I), T.d(I, {
                __assign: () => q,
                __asyncDelegator: () => we,
                __asyncGenerator: () => Ce,
                __asyncValues: () => ve,
                __await: () => me,
                __awaiter: () => z,
                __classPrivateFieldGet: () => Le,
                __classPrivateFieldSet: () => L,
                __createBinding: () => Y,
                __decorate: () => S,
                __exportStar: () => Z,
                __extends: () => K,
                __generator: () => H,
                __importDefault: () => Me,
                __importStar: () => ae,
                __makeTemplateObject: () => De,
                __metadata: () => C,
                __param: () => j,
                __read: () => re,
                __rest: () => ne,
                __spread: () => de,
                __spreadArrays: () => Se,
                __values: () => le
            });
            var F = function(ue, Te) {
                return (F = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(xe, Ae) {
                        xe.__proto__ = Ae
                    } || function(xe, Ae) {
                        for (var Ie in Ae) Ae.hasOwnProperty(Ie) && (xe[Ie] = Ae[Ie])
                    })(ue, Te)
            };

            function K(ue, Te) {
                function xe() {
                    this.constructor = ue
                }
                F(ue, Te), ue.prototype = null === Te ? Object.create(Te) : (xe.prototype = Te.prototype, new xe)
            }
            var q = function() {
                return q = Object.assign || function(Te) {
                    for (var xe, Ae = 1, Ie = arguments.length; Ae < Ie; Ae++)
                        for (var $ in xe = arguments[Ae]) Object.prototype.hasOwnProperty.call(xe, $) && (Te[$] = xe[$]);
                    return Te
                }, q.apply(this, arguments)
            };

            function ne(ue, Te) {
                var xe = {};
                for (var Ae in ue) Object.prototype.hasOwnProperty.call(ue, Ae) && Te.indexOf(Ae) < 0 && (xe[Ae] = ue[Ae]);
                if (null != ue && "function" == typeof Object.getOwnPropertySymbols) {
                    var Ie = 0;
                    for (Ae = Object.getOwnPropertySymbols(ue); Ie < Ae.length; Ie++) Te.indexOf(Ae[Ie]) < 0 && Object.prototype.propertyIsEnumerable.call(ue, Ae[Ie]) && (xe[Ae[Ie]] = ue[Ae[Ie]])
                }
                return xe
            }

            function S(ue, Te, xe, Ae) {
                var f, Ie = arguments.length,
                    $ = Ie < 3 ? Te : null === Ae ? Ae = Object.getOwnPropertyDescriptor(Te, xe) : Ae;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) $ = Reflect.decorate(ue, Te, xe, Ae);
                else
                    for (var v = ue.length - 1; v >= 0; v--)(f = ue[v]) && ($ = (Ie < 3 ? f($) : Ie > 3 ? f(Te, xe, $) : f(Te, xe)) || $);
                return Ie > 3 && $ && Object.defineProperty(Te, xe, $), $
            }

            function j(ue, Te) {
                return function(xe, Ae) {
                    Te(xe, Ae, ue)
                }
            }

            function C(ue, Te) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(ue, Te)
            }

            function z(ue, Te, xe, Ae) {
                return new(xe || (xe = Promise))(function($, f) {
                    function v(G) {
                        try {
                            U(Ae.next(G))
                        } catch (y) {
                            f(y)
                        }
                    }

                    function M(G) {
                        try {
                            U(Ae.throw(G))
                        } catch (y) {
                            f(y)
                        }
                    }

                    function U(G) {
                        G.done ? $(G.value) : function Ie($) {
                            return $ instanceof xe ? $ : new xe(function(f) {
                                f($)
                            })
                        }(G.value).then(v, M)
                    }
                    U((Ae = Ae.apply(ue, Te || [])).next())
                })
            }

            function H(ue, Te) {
                var Ae, Ie, $, f, xe = {
                    label: 0,
                    sent: function() {
                        if (1 & $[0]) throw $[1];
                        return $[1]
                    },
                    trys: [],
                    ops: []
                };
                return f = {
                    next: v(0),
                    throw: v(1),
                    return: v(2)
                }, "function" == typeof Symbol && (f[Symbol.iterator] = function() {
                    return this
                }), f;

                function v(U) {
                    return function(G) {
                        return function M(U) {
                            if (Ae) throw new TypeError("Generator is already executing.");
                            for (; xe;) try {
                                if (Ae = 1, Ie && ($ = 2 & U[0] ? Ie.return : U[0] ? Ie.throw || (($ = Ie.return) && $.call(Ie), 0) : Ie.next) && !($ = $.call(Ie, U[1])).done) return $;
                                switch (Ie = 0, $ && (U = [2 & U[0], $.value]), U[0]) {
                                    case 0:
                                    case 1:
                                        $ = U;
                                        break;
                                    case 4:
                                        return xe.label++, {
                                            value: U[1],
                                            done: !1
                                        };
                                    case 5:
                                        xe.label++, Ie = U[1], U = [0];
                                        continue;
                                    case 7:
                                        U = xe.ops.pop(), xe.trys.pop();
                                        continue;
                                    default:
                                        if (!($ = ($ = xe.trys).length > 0 && $[$.length - 1]) && (6 === U[0] || 2 === U[0])) {
                                            xe = 0;
                                            continue
                                        }
                                        if (3 === U[0] && (!$ || U[1] > $[0] && U[1] < $[3])) {
                                            xe.label = U[1];
                                            break
                                        }
                                        if (6 === U[0] && xe.label < $[1]) {
                                            xe.label = $[1], $ = U;
                                            break
                                        }
                                        if ($ && xe.label < $[2]) {
                                            xe.label = $[2], xe.ops.push(U);
                                            break
                                        }
                                        $[2] && xe.ops.pop(), xe.trys.pop();
                                        continue
                                }
                                U = Te.call(ue, xe)
                            } catch (G) {
                                U = [6, G], Ie = 0
                            } finally {
                                Ae = $ = 0
                            }
                            if (5 & U[0]) throw U[1];
                            return {
                                value: U[0] ? U[1] : void 0,
                                done: !0
                            }
                        }([U, G])
                    }
                }
            }

            function Y(ue, Te, xe, Ae) {
                void 0 === Ae && (Ae = xe), ue[Ae] = Te[xe]
            }

            function Z(ue, Te) {
                for (var xe in ue) "default" !== xe && !Te.hasOwnProperty(xe) && (Te[xe] = ue[xe])
            }

            function le(ue) {
                var Te = "function" == typeof Symbol && Symbol.iterator,
                    xe = Te && ue[Te],
                    Ae = 0;
                if (xe) return xe.call(ue);
                if (ue && "number" == typeof ue.length) return {
                    next: function() {
                        return ue && Ae >= ue.length && (ue = void 0), {
                            value: ue && ue[Ae++],
                            done: !ue
                        }
                    }
                };
                throw new TypeError(Te ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function re(ue, Te) {
                var xe = "function" == typeof Symbol && ue[Symbol.iterator];
                if (!xe) return ue;
                var Ie, f, Ae = xe.call(ue),
                    $ = [];
                try {
                    for (;
                        (void 0 === Te || Te-- > 0) && !(Ie = Ae.next()).done;) $.push(Ie.value)
                } catch (v) {
                    f = {
                        error: v
                    }
                } finally {
                    try {
                        Ie && !Ie.done && (xe = Ae.return) && xe.call(Ae)
                    } finally {
                        if (f) throw f.error
                    }
                }
                return $
            }

            function de() {
                for (var ue = [], Te = 0; Te < arguments.length; Te++) ue = ue.concat(re(arguments[Te]));
                return ue
            }

            function Se() {
                for (var ue = 0, Te = 0, xe = arguments.length; Te < xe; Te++) ue += arguments[Te].length;
                var Ae = Array(ue),
                    Ie = 0;
                for (Te = 0; Te < xe; Te++)
                    for (var $ = arguments[Te], f = 0, v = $.length; f < v; f++, Ie++) Ae[Ie] = $[f];
                return Ae
            }

            function me(ue) {
                return this instanceof me ? (this.v = ue, this) : new me(ue)
            }

            function Ce(ue, Te, xe) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var Ie, Ae = xe.apply(ue, Te || []),
                    $ = [];
                return Ie = {}, f("next"), f("throw"), f("return"), Ie[Symbol.asyncIterator] = function() {
                    return this
                }, Ie;

                function f(E) {
                    Ae[E] && (Ie[E] = function(A) {
                        return new Promise(function(b, N) {
                            $.push([E, A, b, N]) > 1 || v(E, A)
                        })
                    })
                }

                function v(E, A) {
                    try {
                        ! function M(E) {
                            E.value instanceof me ? Promise.resolve(E.value.v).then(U, G) : y($[0][2], E)
                        }(Ae[E](A))
                    } catch (b) {
                        y($[0][3], b)
                    }
                }

                function U(E) {
                    v("next", E)
                }

                function G(E) {
                    v("throw", E)
                }

                function y(E, A) {
                    E(A), $.shift(), $.length && v($[0][0], $[0][1])
                }
            }

            function we(ue) {
                var Te, xe;
                return Te = {}, Ae("next"), Ae("throw", function(Ie) {
                    throw Ie
                }), Ae("return"), Te[Symbol.iterator] = function() {
                    return this
                }, Te;

                function Ae(Ie, $) {
                    Te[Ie] = ue[Ie] ? function(f) {
                        return (xe = !xe) ? {
                            value: me(ue[Ie](f)),
                            done: "return" === Ie
                        } : $ ? $(f) : f
                    } : $
                }
            }

            function ve(ue) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var xe, Te = ue[Symbol.asyncIterator];
                return Te ? Te.call(ue) : (ue = le(ue), xe = {}, Ae("next"), Ae("throw"), Ae("return"), xe[Symbol.asyncIterator] = function() {
                    return this
                }, xe);

                function Ae($) {
                    xe[$] = ue[$] && function(f) {
                        return new Promise(function(v, M) {
                            ! function Ie($, f, v, M) {
                                Promise.resolve(M).then(function(U) {
                                    $({
                                        value: U,
                                        done: v
                                    })
                                }, f)
                            }(v, M, (f = ue[$](f)).done, f.value)
                        })
                    }
                }
            }

            function De(ue, Te) {
                return Object.defineProperty ? Object.defineProperty(ue, "raw", {
                    value: Te
                }) : ue.raw = Te, ue
            }

            function ae(ue) {
                if (ue && ue.__esModule) return ue;
                var Te = {};
                if (null != ue)
                    for (var xe in ue) Object.hasOwnProperty.call(ue, xe) && (Te[xe] = ue[xe]);
                return Te.default = ue, Te
            }

            function Me(ue) {
                return ue && ue.__esModule ? ue : {
                    default: ue
                }
            }

            function Le(ue, Te) {
                if (!Te.has(ue)) throw new TypeError("attempted to get private field on non-instance");
                return Te.get(ue)
            }

            function L(ue, Te, xe) {
                if (!Te.has(ue)) throw new TypeError("attempted to set private field on non-instance");
                return Te.set(ue, xe), xe
            }
        },
        35883: () => {},
        46601: () => {},
        17156: et => {
            function I(F, K, q, ne, S, j, C) {
                try {
                    var z = F[j](C),
                        H = z.value
                } catch (Y) {
                    return void q(Y)
                }
                z.done ? K(H) : Promise.resolve(H).then(ne, S)
            }
            et.exports = function T(F) {
                return function() {
                    var K = this,
                        q = arguments;
                    return new Promise(function(ne, S) {
                        var j = F.apply(K, q);

                        function C(H) {
                            I(j, ne, S, C, z, "next", H)
                        }

                        function z(H) {
                            I(j, ne, S, C, z, "throw", H)
                        }
                        C(void 0)
                    })
                }
            }, et.exports.__esModule = !0, et.exports.default = et.exports
        },
        93284: (et, I, T) => {
            "use strict";

            function F(Y) {
                if (!Number.isSafeInteger(Y) || Y < 0) throw new Error(`positive integer expected, not ${Y}`)
            }

            function ne(Y, ...Z) {
                if (! function q(Y) {
                        return Y instanceof Uint8Array || null != Y && "object" == typeof Y && "Uint8Array" === Y.constructor.name
                    }(Y)) throw new Error("Uint8Array expected");
                if (Z.length > 0 && !Z.includes(Y.length)) throw new Error(`Uint8Array expected of length ${Z}, not of length=${Y.length}`)
            }

            function S(Y) {
                if ("function" != typeof Y || "function" != typeof Y.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                F(Y.outputLen), F(Y.blockLen)
            }

            function j(Y, Z = !0) {
                if (Y.destroyed) throw new Error("Hash instance has been destroyed");
                if (Z && Y.finished) throw new Error("Hash#digest() has already been called")
            }

            function C(Y, Z) {
                ne(Y);
                const le = Z.outputLen;
                if (Y.length < le) throw new Error(`digestInto() expects output buffer of length at least ${le}`)
            }
            T.d(I, {
                Gg: () => j,
                J8: () => C,
                Rx: () => F,
                aI: () => ne,
                vp: () => S
            })
        },
        58165: (et, I, T) => {
            "use strict";
            T.d(I, {
                VR: () => j,
                bc: () => ne,
                l3: () => S
            });
            var F = T(93284),
                K = T(40512);
            const ne = (C, z, H) => C & z ^ ~C & H,
                S = (C, z, H) => C & z ^ C & H ^ z & H;
            class j extends K.kb {
                constructor(z, H, Y, Z) {
                    super(), this.blockLen = z, this.outputLen = H, this.padOffset = Y, this.isLE = Z, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, K.GL)(this.buffer)
                }
                update(z) {
                    (0, F.Gg)(this);
                    const {
                        view: H,
                        buffer: Y,
                        blockLen: Z
                    } = this, le = (z = (0, K.O0)(z)).length;
                    for (let re = 0; re < le;) {
                        const de = Math.min(Z - this.pos, le - re);
                        if (de !== Z) Y.set(z.subarray(re, re + de), this.pos), this.pos += de, re += de, this.pos === Z && (this.process(H, 0), this.pos = 0);
                        else {
                            const Se = (0, K.GL)(z);
                            for (; Z <= le - re; re += Z) this.process(Se, re)
                        }
                    }
                    return this.length += z.length, this.roundClean(), this
                }
                digestInto(z) {
                    (0, F.Gg)(this), (0, F.J8)(z, this), this.finished = !0;
                    const {
                        buffer: H,
                        view: Y,
                        blockLen: Z,
                        isLE: le
                    } = this;
                    let {
                        pos: re
                    } = this;
                    H[re++] = 128, this.buffer.subarray(re).fill(0), this.padOffset > Z - re && (this.process(Y, 0), re = 0);
                    for (let we = re; we < Z; we++) H[we] = 0;
                    (function q(C, z, H, Y) {
                        if ("function" == typeof C.setBigUint64) return C.setBigUint64(z, H, Y);
                        const Z = BigInt(32),
                            le = BigInt(4294967295),
                            re = Number(H >> Z & le),
                            de = Number(H & le),
                            me = Y ? 0 : 4;
                        C.setUint32(z + (Y ? 4 : 0), re, Y), C.setUint32(z + me, de, Y)
                    })(Y, Z - 8, BigInt(8 * this.length), le), this.process(Y, 0);
                    const de = (0, K.GL)(z),
                        Se = this.outputLen;
                    if (Se % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const me = Se / 4,
                        Ce = this.get();
                    if (me > Ce.length) throw new Error("_sha2: outputLen bigger than state");
                    for (let we = 0; we < me; we++) de.setUint32(4 * we, Ce[we], le)
                }
                digest() {
                    const {
                        buffer: z,
                        outputLen: H
                    } = this;
                    this.digestInto(z);
                    const Y = z.slice(0, H);
                    return this.destroy(), Y
                }
                _cloneInto(z) {
                    z || (z = new this.constructor), z.set(...this.get());
                    const {
                        blockLen: H,
                        buffer: Y,
                        length: Z,
                        finished: le,
                        destroyed: re,
                        pos: de
                    } = this;
                    return z.length = Z, z.pos = de, z.finished = le, z.destroyed = re, Z % H && z.buffer.set(Y), z
                }
            }
        },
        87501: (et, I, T) => {
            "use strict";
            T.d(I, {
                J: () => z
            });
            var F = T(58165),
                K = T(40512);
            const q = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                ne = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                S = new Uint32Array(64);
            class j extends F.VR {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | ne[0], this.B = 0 | ne[1], this.C = 0 | ne[2], this.D = 0 | ne[3], this.E = 0 | ne[4], this.F = 0 | ne[5], this.G = 0 | ne[6], this.H = 0 | ne[7]
                }
                get() {
                    const {
                        A: Z,
                        B: le,
                        C: re,
                        D: de,
                        E: Se,
                        F: me,
                        G: Ce,
                        H: we
                    } = this;
                    return [Z, le, re, de, Se, me, Ce, we]
                }
                set(Z, le, re, de, Se, me, Ce, we) {
                    this.A = 0 | Z, this.B = 0 | le, this.C = 0 | re, this.D = 0 | de, this.E = 0 | Se, this.F = 0 | me, this.G = 0 | Ce, this.H = 0 | we
                }
                process(Z, le) {
                    for (let ae = 0; ae < 16; ae++, le += 4) S[ae] = Z.getUint32(le, !1);
                    for (let ae = 16; ae < 64; ae++) {
                        const Me = S[ae - 15],
                            Le = S[ae - 2],
                            L = (0, K.np)(Me, 7) ^ (0, K.np)(Me, 18) ^ Me >>> 3,
                            ue = (0, K.np)(Le, 17) ^ (0, K.np)(Le, 19) ^ Le >>> 10;
                        S[ae] = ue + S[ae - 7] + L + S[ae - 16] | 0
                    }
                    let {
                        A: re,
                        B: de,
                        C: Se,
                        D: me,
                        E: Ce,
                        F: we,
                        G: ve,
                        H: De
                    } = this;
                    for (let ae = 0; ae < 64; ae++) {
                        const Le = De + ((0, K.np)(Ce, 6) ^ (0, K.np)(Ce, 11) ^ (0, K.np)(Ce, 25)) + (0, F.bc)(Ce, we, ve) + q[ae] + S[ae] | 0,
                            ue = ((0, K.np)(re, 2) ^ (0, K.np)(re, 13) ^ (0, K.np)(re, 22)) + (0, F.l3)(re, de, Se) | 0;
                        De = ve, ve = we, we = Ce, Ce = me + Le | 0, me = Se, Se = de, de = re, re = Le + ue | 0
                    }
                    re = re + this.A | 0, de = de + this.B | 0, Se = Se + this.C | 0, me = me + this.D | 0, Ce = Ce + this.E | 0, we = we + this.F | 0, ve = ve + this.G | 0, De = De + this.H | 0, this.set(re, de, Se, me, Ce, we, ve, De)
                }
                roundClean() {
                    S.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            }
            const z = (0, K.hE)(() => new j)
        },
        40512: (et, I, T) => {
            "use strict";
            T.d(I, {
                kb: () => L,
                l1: () => le,
                eV: () => Le,
                GL: () => j,
                iA: () => H,
                O6: () => $,
                np: () => C,
                O0: () => Me,
                Jq: () => S,
                iY: () => ae,
                hE: () => xe
            });
            const F = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0;
            var K = T(93284);
            const S = f => new Uint32Array(f.buffer, f.byteOffset, Math.floor(f.byteLength / 4)),
                j = f => new DataView(f.buffer, f.byteOffset, f.byteLength),
                C = (f, v) => f << 32 - v | f >>> v,
                H = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
                Y = f => f << 24 & 4278190080 | f << 8 & 16711680 | f >>> 8 & 65280 | f >>> 24 & 255;

            function le(f) {
                for (let v = 0; v < f.length; v++) f[v] = Y(f[v])
            }

            function ae(f) {
                if ("string" != typeof f) throw new Error("utf8ToBytes expected string, got " + typeof f);
                return new Uint8Array((new TextEncoder).encode(f))
            }

            function Me(f) {
                return "string" == typeof f && (f = ae(f)), (0, K.aI)(f), f
            }

            function Le(...f) {
                let v = 0;
                for (let U = 0; U < f.length; U++) {
                    const G = f[U];
                    (0, K.aI)(G), v += G.length
                }
                const M = new Uint8Array(v);
                for (let U = 0, G = 0; U < f.length; U++) {
                    const y = f[U];
                    M.set(y, G), G += y.length
                }
                return M
            }
            class L {
                clone() {
                    return this._cloneInto()
                }
            }

            function xe(f) {
                const v = U => f().update(Me(U)).digest(),
                    M = f();
                return v.outputLen = M.outputLen, v.blockLen = M.blockLen, v.create = () => f(), v
            }

            function $(f = 32) {
                if (F && "function" == typeof F.getRandomValues) return F.getRandomValues(new Uint8Array(f));
                throw new Error("crypto.getRandomValues must be defined")
            }
        },
        88138: (et, I, T) => {
            "use strict";

            function F(me, Ce, we) {
                return Ce <= me && me <= we
            }

            function K(me) {
                if (void 0 === me) return {};
                if (me === Object(me)) return me;
                throw TypeError("Could not convert argument to dictionary")
            }

            function j(me) {
                this.tokens = [].slice.call(me)
            }
            T.r(I), T.d(I, {
                TextDecoder: () => le,
                TextEncoder: () => re
            }), j.prototype = {
                endOfStream: function() {
                    return !this.tokens.length
                },
                read: function() {
                    return this.tokens.length ? this.tokens.shift() : -1
                },
                prepend: function(me) {
                    if (Array.isArray(me))
                        for (var Ce = me; Ce.length;) this.tokens.unshift(Ce.pop());
                    else this.tokens.unshift(me)
                },
                push: function(me) {
                    if (Array.isArray(me))
                        for (var Ce = me; Ce.length;) this.tokens.push(Ce.shift());
                    else this.tokens.push(me)
                }
            };
            var C = -1;

            function z(me, Ce) {
                if (me) throw TypeError("Decoder error");
                return Ce || 65533
            }
            var Z = "utf-8";

            function le(me, Ce) {
                if (!(this instanceof le)) return new le(me, Ce);
                if ((me = void 0 !== me ? String(me).toLowerCase() : Z) !== Z) throw new Error("Encoding not supported. Only utf-8 is supported");
                Ce = K(Ce), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!Ce.fatal, this._ignoreBOM = !!Ce.ignoreBOM, Object.defineProperty(this, "encoding", {
                    value: "utf-8"
                }), Object.defineProperty(this, "fatal", {
                    value: this._fatal
                }), Object.defineProperty(this, "ignoreBOM", {
                    value: this._ignoreBOM
                })
            }

            function re(me, Ce) {
                if (!(this instanceof re)) return new re(me, Ce);
                if ((me = void 0 !== me ? String(me).toLowerCase() : Z) !== Z) throw new Error("Encoding not supported. Only utf-8 is supported");
                Ce = K(Ce), this._streaming = !1, this._encoder = null, this._options = {
                    fatal: !!Ce.fatal
                }, Object.defineProperty(this, "encoding", {
                    value: "utf-8"
                })
            }

            function de(me) {
                var Ce = me.fatal,
                    we = 0,
                    ve = 0,
                    De = 0,
                    ae = 128,
                    Me = 191;
                this.handler = function(Le, L) {
                    if (-1 === L && 0 !== De) return De = 0, z(Ce);
                    if (-1 === L) return C;
                    if (0 === De) {
                        if (F(L, 0, 127)) return L;
                        if (F(L, 194, 223)) De = 1, we = L - 192;
                        else if (F(L, 224, 239)) 224 === L && (ae = 160), 237 === L && (Me = 159), De = 2, we = L - 224;
                        else {
                            if (!F(L, 240, 244)) return z(Ce);
                            240 === L && (ae = 144), 244 === L && (Me = 143), De = 3, we = L - 240
                        }
                        return we <<= 6 * De, null
                    }
                    if (!F(L, ae, Me)) return we = De = ve = 0, ae = 128, Me = 191, Le.prepend(L), z(Ce);
                    if (ae = 128, Me = 191, we += L - 128 << 6 * (De - (ve += 1)), ve !== De) return null;
                    var ue = we;
                    return we = De = ve = 0, ue
                }
            }

            function Se(me) {
                this.handler = function(we, ve) {
                    if (-1 === ve) return C;
                    if (F(ve, 0, 127)) return ve;
                    var De, ae;
                    F(ve, 128, 2047) ? (De = 1, ae = 192) : F(ve, 2048, 65535) ? (De = 2, ae = 224) : F(ve, 65536, 1114111) && (De = 3, ae = 240);
                    for (var Me = [(ve >> 6 * De) + ae]; De > 0;) Me.push(128 | 63 & ve >> 6 * (De - 1)), De -= 1;
                    return Me
                }
            }
            le.prototype = {
                decode: function(Ce, we) {
                    var ve;
                    ve = "object" == typeof Ce && Ce instanceof ArrayBuffer ? new Uint8Array(Ce) : "object" == typeof Ce && "buffer" in Ce && Ce.buffer instanceof ArrayBuffer ? new Uint8Array(Ce.buffer, Ce.byteOffset, Ce.byteLength) : new Uint8Array(0), we = K(we), this._streaming || (this._decoder = new de({
                        fatal: this._fatal
                    }), this._BOMseen = !1), this._streaming = !!we.stream;
                    for (var Me, De = new j(ve), ae = []; !De.endOfStream() && (Me = this._decoder.handler(De, De.read())) !== C;) null !== Me && (Array.isArray(Me) ? ae.push.apply(ae, Me) : ae.push(Me));
                    if (!this._streaming) {
                        do {
                            if ((Me = this._decoder.handler(De, De.read())) === C) break;
                            null !== Me && (Array.isArray(Me) ? ae.push.apply(ae, Me) : ae.push(Me))
                        } while (!De.endOfStream());
                        this._decoder = null
                    }
                    return ae.length && -1 !== ["utf-8"].indexOf(this.encoding) && !this._ignoreBOM && !this._BOMseen && (65279 === ae[0] ? (this._BOMseen = !0, ae.shift()) : this._BOMseen = !0),
                        function ne(me) {
                            for (var Ce = "", we = 0; we < me.length; ++we) {
                                var ve = me[we];
                                ve <= 65535 ? Ce += String.fromCharCode(ve) : (ve -= 65536, Ce += String.fromCharCode(55296 + (ve >> 10), 56320 + (1023 & ve)))
                            }
                            return Ce
                        }(ae)
                }
            }, re.prototype = {
                encode: function(Ce, we) {
                    Ce = Ce ? String(Ce) : "", we = K(we), this._streaming || (this._encoder = new Se(this._options)), this._streaming = !!we.stream;
                    for (var ae, ve = [], De = new j(function q(me) {
                            for (var Ce = String(me), we = Ce.length, ve = 0, De = []; ve < we;) {
                                var ae = Ce.charCodeAt(ve);
                                if (ae < 55296 || ae > 57343) De.push(ae);
                                else if (56320 <= ae && ae <= 57343) De.push(65533);
                                else if (55296 <= ae && ae <= 56319)
                                    if (ve === we - 1) De.push(65533);
                                    else {
                                        var Me = me.charCodeAt(ve + 1);
                                        56320 <= Me && Me <= 57343 ? (De.push(65536 + ((1023 & ae) << 10) + (1023 & Me)), ve += 1) : De.push(65533)
                                    }
                                ve += 1
                            }
                            return De
                        }(Ce)); !De.endOfStream() && (ae = this._encoder.handler(De, De.read())) !== C;) Array.isArray(ae) ? ve.push.apply(ve, ae) : ve.push(ae);
                    if (!this._streaming) {
                        for (;
                            (ae = this._encoder.handler(De, De.read())) !== C;) Array.isArray(ae) ? ve.push.apply(ve, ae) : ve.push(ae);
                        this._encoder = null
                    }
                    return new Uint8Array(ve)
                }
            }
        },
        36045: (et, I, T) => {
            "use strict";
            T.d(I, {
                E: () => q
            });
            var F = T(25242);

            function q(ne = 0) {
                return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? (0, F.P)(globalThis.Buffer.allocUnsafe(ne)) : new Uint8Array(ne)
            }
        },
        91376: (et, I, T) => {
            "use strict";
            T.d(I, {
                z: () => q
            });
            var F = T(36045),
                K = T(25242);

            function q(ne, S) {
                S || (S = ne.reduce((z, H) => z + H.length, 0));
                const j = (0, F.E)(S);
                let C = 0;
                for (const z of ne) j.set(z, C), C += z.length;
                return (0, K.P)(j)
            }
        },
        82269: (et, I, T) => {
            "use strict";
            T.d(I, {
                m: () => q
            });
            var F = T(3388),
                K = T(25242);

            function q(ne, S = "utf8") {
                const j = F.Z[S];
                if (!j) throw new Error(`Unsupported encoding "${S}"`);
                return "utf8" !== S && "utf-8" !== S || null == globalThis.Buffer || null == globalThis.Buffer.from ? j.decoder.decode(`${j.prefix}${ne}`) : (0, K.P)(globalThis.Buffer.from(ne, "utf-8"))
            }
        },
        3544: (et, I, T) => {
            "use strict";
            T.d(I, {
                BB: () => q.B,
                mL: () => K.m,
                zo: () => F.z
            });
            var F = T(91376),
                K = T(82269),
                q = T(90878)
        },
        90878: (et, I, T) => {
            "use strict";
            T.d(I, {
                B: () => K
            });
            var F = T(3388);

            function K(q, ne = "utf8") {
                const S = F.Z[ne];
                if (!S) throw new Error(`Unsupported encoding "${ne}"`);
                return "utf8" !== ne && "utf-8" !== ne || null == globalThis.Buffer || null == globalThis.Buffer.from ? S.encoder.encode(q).substring(1) : globalThis.Buffer.from(q.buffer, q.byteOffset, q.byteLength).toString("utf8")
            }
        },
        25242: (et, I, T) => {
            "use strict";

            function F(K) {
                return null != globalThis.Buffer ? new Uint8Array(K.buffer, K.byteOffset, K.byteLength) : K
            }
            T.d(I, {
                P: () => F
            })
        },
        3388: (et, I, T) => {
            "use strict";
            T.d(I, {
                Z: () => kc
            });
            var F = {};
            T.r(F), T.d(F, {
                identity: () => E
            });
            var K = {};
            T.r(K), T.d(K, {
                base2: () => A
            });
            var q = {};
            T.r(q), T.d(q, {
                base8: () => b
            });
            var ne = {};
            T.r(ne), T.d(ne, {
                base10: () => N
            });
            var S = {};
            T.r(S), T.d(S, {
                base16: () => R,
                base16upper: () => Q
            });
            var j = {};
            T.r(j), T.d(j, {
                base32: () => Ee,
                base32hex: () => Vt,
                base32hexpad: () => sn,
                base32hexpadupper: () => ei,
                base32hexupper: () => Mt,
                base32pad: () => Ge,
                base32padupper: () => wt,
                base32upper: () => Fe,
                base32z: () => ai
            });
            var C = {};
            T.r(C), T.d(C, {
                base36: () => jn,
                base36upper: () => An
            });
            var z = {};
            T.r(z), T.d(z, {
                base58btc: () => ui,
                base58flickr: () => Mi
            });
            var H = {};
            T.r(H), T.d(H, {
                base64: () => ji,
                base64pad: () => Wn,
                base64url: () => kn,
                base64urlpad: () => Bi
            });
            var Y = {};
            T.r(Y), T.d(Y, {
                base256emoji: () => W
            });
            var Z = {};
            T.r(Z), T.d(Z, {
                sha256: () => an,
                sha512: () => As
            });
            var le = {};
            T.r(le), T.d(le, {
                identity: () => xo
            });
            var re = {};
            T.r(re), T.d(re, {
                code: () => di,
                decode: () => la,
                encode: () => Nr,
                name: () => Zn
            });
            var de = {};
            T.r(de), T.d(de, {
                code: () => ao,
                decode: () => nc,
                encode: () => da,
                name: () => Ir
            });
            const Le = (new Uint8Array(0), lt => {
                if (lt instanceof Uint8Array && "Uint8Array" === lt.constructor.name) return lt;
                if (lt instanceof ArrayBuffer) return new Uint8Array(lt);
                if (ArrayBuffer.isView(lt)) return new Uint8Array(lt.buffer, lt.byteOffset, lt.byteLength);
                throw new Error("Unknown type, must be binary type")
            });
            class xe {
                constructor(Ye, ot, Kt) {
                    this.name = Ye, this.prefix = ot, this.baseEncode = Kt
                }
                encode(Ye) {
                    if (Ye instanceof Uint8Array) return `${this.prefix}${this.baseEncode(Ye)}`;
                    throw Error("Unknown type, must be binary type")
                }
            }
            class Ae {
                constructor(Ye, ot, Kt) {
                    if (this.name = Ye, this.prefix = ot, void 0 === ot.codePointAt(0)) throw new Error("Invalid prefix character");
                    this.prefixCodePoint = ot.codePointAt(0), this.baseDecode = Kt
                }
                decode(Ye) {
                    if ("string" == typeof Ye) {
                        if (Ye.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(Ye)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(Ye.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(Ye) {
                    return $(this, Ye)
                }
            }
            class Ie {
                constructor(Ye) {
                    this.decoders = Ye
                }
                or(Ye) {
                    return $(this, Ye)
                }
                decode(Ye) {
                    const Kt = this.decoders[Ye[0]];
                    if (Kt) return Kt.decode(Ye);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(Ye)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            }
            const $ = (lt, Ye) => new Ie({ ...lt.decoders || {
                    [lt.prefix]: lt
                },
                ...Ye.decoders || {
                    [Ye.prefix]: Ye
                }
            });
            class f {
                constructor(Ye, ot, Kt, kt) {
                    this.name = Ye, this.prefix = ot, this.baseEncode = Kt, this.baseDecode = kt, this.encoder = new xe(Ye, ot, Kt), this.decoder = new Ae(Ye, ot, kt)
                }
                encode(Ye) {
                    return this.encoder.encode(Ye)
                }
                decode(Ye) {
                    return this.decoder.decode(Ye)
                }
            }
            const v = ({
                    name: lt,
                    prefix: Ye,
                    encode: ot,
                    decode: Kt
                }) => new f(lt, Ye, ot, Kt),
                M = ({
                    prefix: lt,
                    name: Ye,
                    alphabet: ot
                }) => {
                    const {
                        encode: Kt,
                        decode: kt
                    } = function Se(lt, Ye) {
                        if (lt.length >= 255) throw new TypeError("Alphabet too long");
                        for (var ot = new Uint8Array(256), Kt = 0; Kt < ot.length; Kt++) ot[Kt] = 255;
                        for (var kt = 0; kt < lt.length; kt++) {
                            var Fn = lt.charAt(kt),
                                _r = Fn.charCodeAt(0);
                            if (255 !== ot[_r]) throw new TypeError(Fn + " is ambiguous");
                            ot[_r] = kt
                        }
                        var Ei = lt.length,
                            ks = lt.charAt(0),
                            ha = Math.log(Ei) / Math.log(256),
                            Di = Math.log(256) / Math.log(Ei);

                        function rc(Wi) {
                            if ("string" != typeof Wi) throw new TypeError("Expected String");
                            if (0 === Wi.length) return new Uint8Array;
                            var as = 0;
                            if (" " !== Wi[as]) {
                                for (var Yo = 0, cs = 0; Wi[as] === ks;) Yo++, as++;
                                for (var co = (Wi.length - as) * ha + 1 >>> 0, Ms = new Uint8Array(co); Wi[as];) {
                                    var eo = ot[Wi.charCodeAt(as)];
                                    if (255 === eo) return;
                                    for (var Gr = 0, Oa = co - 1;
                                        (0 !== eo || Gr < cs) && -1 !== Oa; Oa--, Gr++) Ms[Oa] = (eo += Ei * Ms[Oa] >>> 0) % 256 >>> 0, eo = eo / 256 >>> 0;
                                    if (0 !== eo) throw new Error("Non-zero carry");
                                    cs = Gr, as++
                                }
                                if (" " !== Wi[as]) {
                                    for (var Lo = co - cs; Lo !== co && 0 === Ms[Lo];) Lo++;
                                    for (var fa = new Uint8Array(Yo + (co - Lo)), $s = Yo; Lo !== co;) fa[$s++] = Ms[Lo++];
                                    return fa
                                }
                            }
                        }
                        return {
                            encode: function Zo(Wi) {
                                if (Wi instanceof Uint8Array || (ArrayBuffer.isView(Wi) ? Wi = new Uint8Array(Wi.buffer, Wi.byteOffset, Wi.byteLength) : Array.isArray(Wi) && (Wi = Uint8Array.from(Wi))), !(Wi instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
                                if (0 === Wi.length) return "";
                                for (var as = 0, Yo = 0, cs = 0, co = Wi.length; cs !== co && 0 === Wi[cs];) cs++, as++;
                                for (var Ms = (co - cs) * Di + 1 >>> 0, eo = new Uint8Array(Ms); cs !== co;) {
                                    for (var Gr = Wi[cs], Oa = 0, Lo = Ms - 1;
                                        (0 !== Gr || Oa < Yo) && -1 !== Lo; Lo--, Oa++) eo[Lo] = (Gr += 256 * eo[Lo] >>> 0) % Ei >>> 0, Gr = Gr / Ei >>> 0;
                                    if (0 !== Gr) throw new Error("Non-zero carry");
                                    Yo = Oa, cs++
                                }
                                for (var fa = Ms - Yo; fa !== Ms && 0 === eo[fa];) fa++;
                                for (var $s = ks.repeat(as); fa < Ms; ++fa) $s += lt.charAt(eo[fa]);
                                return $s
                            },
                            decodeUnsafe: rc,
                            decode: function nn(Wi) {
                                var as = rc(Wi);
                                if (as) return as;
                                throw new Error(`Non-${Ye} character`)
                            }
                        }
                    }(ot, Ye);
                    return v({
                        prefix: lt,
                        name: Ye,
                        encode: Kt,
                        decode: Fn => Le(kt(Fn))
                    })
                },
                y = ({
                    name: lt,
                    prefix: Ye,
                    bitsPerChar: ot,
                    alphabet: Kt
                }) => v({
                    prefix: Ye,
                    name: lt,
                    encode: kt => ((lt, Ye, ot) => {
                        const Kt = "=" === Ye[Ye.length - 1],
                            kt = (1 << ot) - 1;
                        let Fn = "",
                            _r = 0,
                            Ei = 0;
                        for (let ks = 0; ks < lt.length; ++ks)
                            for (Ei = Ei << 8 | lt[ks], _r += 8; _r > ot;) _r -= ot, Fn += Ye[kt & Ei >> _r];
                        if (_r && (Fn += Ye[kt & Ei << ot - _r]), Kt)
                            for (; Fn.length * ot & 7;) Fn += "=";
                        return Fn
                    })(kt, Kt, ot),
                    decode: kt => ((lt, Ye, ot, Kt) => {
                        const kt = {};
                        for (let Di = 0; Di < Ye.length; ++Di) kt[Ye[Di]] = Di;
                        let Fn = lt.length;
                        for (;
                            "=" === lt[Fn - 1];) --Fn;
                        const _r = new Uint8Array(Fn * ot / 8 | 0);
                        let Ei = 0,
                            ks = 0,
                            ha = 0;
                        for (let Di = 0; Di < Fn; ++Di) {
                            const Zo = kt[lt[Di]];
                            if (void 0 === Zo) throw new SyntaxError(`Non-${Kt} character`);
                            ks = ks << ot | Zo, Ei += ot, Ei >= 8 && (Ei -= 8, _r[ha++] = 255 & ks >> Ei)
                        }
                        if (Ei >= ot || 255 & ks << 8 - Ei) throw new SyntaxError("Unexpected end of data");
                        return _r
                    })(kt, Kt, ot, lt)
                }),
                E = v({
                    prefix: "\0",
                    name: "identity",
                    encode: lt => (lt => (new TextDecoder).decode(lt))(lt),
                    decode: lt => (lt => (new TextEncoder).encode(lt))(lt)
                }),
                A = y({
                    prefix: "0",
                    name: "base2",
                    alphabet: "01",
                    bitsPerChar: 1
                }),
                b = y({
                    prefix: "7",
                    name: "base8",
                    alphabet: "01234567",
                    bitsPerChar: 3
                }),
                N = M({
                    prefix: "9",
                    name: "base10",
                    alphabet: "0123456789"
                }),
                R = y({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                Q = y({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                }),
                Ee = y({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                Fe = y({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                Ge = y({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                wt = y({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                Vt = y({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                Mt = y({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                sn = y({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                ei = y({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                ai = y({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                }),
                jn = M({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                An = M({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                }),
                ui = M({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                Mi = M({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                }),
                ji = y({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                Wn = y({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                kn = y({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                Bi = y({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                }),
                ci = Array.from("\u{1f680}\u{1fa90}\u2604\u{1f6f0}\u{1f30c}\u{1f311}\u{1f312}\u{1f313}\u{1f314}\u{1f315}\u{1f316}\u{1f317}\u{1f318}\u{1f30d}\u{1f30f}\u{1f30e}\u{1f409}\u2600\u{1f4bb}\u{1f5a5}\u{1f4be}\u{1f4bf}\u{1f602}\u2764\u{1f60d}\u{1f923}\u{1f60a}\u{1f64f}\u{1f495}\u{1f62d}\u{1f618}\u{1f44d}\u{1f605}\u{1f44f}\u{1f601}\u{1f525}\u{1f970}\u{1f494}\u{1f496}\u{1f499}\u{1f622}\u{1f914}\u{1f606}\u{1f644}\u{1f4aa}\u{1f609}\u263a\u{1f44c}\u{1f917}\u{1f49c}\u{1f614}\u{1f60e}\u{1f607}\u{1f339}\u{1f926}\u{1f389}\u{1f49e}\u270c\u2728\u{1f937}\u{1f631}\u{1f60c}\u{1f338}\u{1f64c}\u{1f60b}\u{1f497}\u{1f49a}\u{1f60f}\u{1f49b}\u{1f642}\u{1f493}\u{1f929}\u{1f604}\u{1f600}\u{1f5a4}\u{1f603}\u{1f4af}\u{1f648}\u{1f447}\u{1f3b6}\u{1f612}\u{1f92d}\u2763\u{1f61c}\u{1f48b}\u{1f440}\u{1f62a}\u{1f611}\u{1f4a5}\u{1f64b}\u{1f61e}\u{1f629}\u{1f621}\u{1f92a}\u{1f44a}\u{1f973}\u{1f625}\u{1f924}\u{1f449}\u{1f483}\u{1f633}\u270b\u{1f61a}\u{1f61d}\u{1f634}\u{1f31f}\u{1f62c}\u{1f643}\u{1f340}\u{1f337}\u{1f63b}\u{1f613}\u2b50\u2705\u{1f97a}\u{1f308}\u{1f608}\u{1f918}\u{1f4a6}\u2714\u{1f623}\u{1f3c3}\u{1f490}\u2639\u{1f38a}\u{1f498}\u{1f620}\u261d\u{1f615}\u{1f33a}\u{1f382}\u{1f33b}\u{1f610}\u{1f595}\u{1f49d}\u{1f64a}\u{1f639}\u{1f5e3}\u{1f4ab}\u{1f480}\u{1f451}\u{1f3b5}\u{1f91e}\u{1f61b}\u{1f534}\u{1f624}\u{1f33c}\u{1f62b}\u26bd\u{1f919}\u2615\u{1f3c6}\u{1f92b}\u{1f448}\u{1f62e}\u{1f646}\u{1f37b}\u{1f343}\u{1f436}\u{1f481}\u{1f632}\u{1f33f}\u{1f9e1}\u{1f381}\u26a1\u{1f31e}\u{1f388}\u274c\u270a\u{1f44b}\u{1f630}\u{1f928}\u{1f636}\u{1f91d}\u{1f6b6}\u{1f4b0}\u{1f353}\u{1f4a2}\u{1f91f}\u{1f641}\u{1f6a8}\u{1f4a8}\u{1f92c}\u2708\u{1f380}\u{1f37a}\u{1f913}\u{1f619}\u{1f49f}\u{1f331}\u{1f616}\u{1f476}\u{1f974}\u25b6\u27a1\u2753\u{1f48e}\u{1f4b8}\u2b07\u{1f628}\u{1f31a}\u{1f98b}\u{1f637}\u{1f57a}\u26a0\u{1f645}\u{1f61f}\u{1f635}\u{1f44e}\u{1f932}\u{1f920}\u{1f927}\u{1f4cc}\u{1f535}\u{1f485}\u{1f9d0}\u{1f43e}\u{1f352}\u{1f617}\u{1f911}\u{1f30a}\u{1f92f}\u{1f437}\u260e\u{1f4a7}\u{1f62f}\u{1f486}\u{1f446}\u{1f3a4}\u{1f647}\u{1f351}\u2744\u{1f334}\u{1f4a3}\u{1f438}\u{1f48c}\u{1f4cd}\u{1f940}\u{1f922}\u{1f445}\u{1f4a1}\u{1f4a9}\u{1f450}\u{1f4f8}\u{1f47b}\u{1f910}\u{1f92e}\u{1f3bc}\u{1f975}\u{1f6a9}\u{1f34e}\u{1f34a}\u{1f47c}\u{1f48d}\u{1f4e3}\u{1f942}"),
                en = ci.reduce((lt, Ye, ot) => (lt[ot] = Ye, lt), []),
                Ii = ci.reduce((lt, Ye, ot) => (lt[Ye.codePointAt(0)] = ot, lt), []),
                W = v({
                    prefix: "\u{1f680}",
                    name: "base256emoji",
                    encode: function pe(lt) {
                        return lt.reduce((Ye, ot) => Ye + en[ot], "")
                    },
                    decode: function O(lt) {
                        const Ye = [];
                        for (const ot of lt) {
                            const Kt = Ii[ot.codePointAt(0)];
                            if (void 0 === Kt) throw new Error(`Non-base256emoji character: ${ot}`);
                            Ye.push(Kt)
                        }
                        return new Uint8Array(Ye)
                    }
                });
            var ke = T(15861),
                Qe = 128,
                tn = -128,
                Kn = Math.pow(2, 31),
                ca = Math.pow(2, 7),
                yi = Math.pow(2, 14),
                hr = Math.pow(2, 21),
                qo = Math.pow(2, 28),
                yr = Math.pow(2, 35),
                Rn = Math.pow(2, 42),
                Ti = Math.pow(2, 49),
                Ji = Math.pow(2, 56),
                gn = Math.pow(2, 63);
            const at_encode = function mn(lt, Ye, ot) {
                    Ye = Ye || [];
                    for (var Kt = ot = ot || 0; lt >= Kn;) Ye[ot++] = 255 & lt | Qe, lt /= 128;
                    for (; lt & tn;) Ye[ot++] = 255 & lt | Qe, lt >>>= 7;
                    return Ye[ot] = 0 | lt, mn.bytes = ot - Kt + 1, Ye
                },
                at_encodingLength = function(lt) {
                    return lt < ca ? 1 : lt < yi ? 2 : lt < hr ? 3 : lt < qo ? 4 : lt < yr ? 5 : lt < Rn ? 6 : lt < Ti ? 7 : lt < Ji ? 8 : lt < gn ? 9 : 10
                },
                St = (lt, Ye, ot = 0) => (at_encode(lt, Ye, ot), Ye),
                Bn = lt => at_encodingLength(lt),
                Nn = (lt, Ye) => {
                    const ot = Ye.byteLength,
                        Kt = Bn(lt),
                        kt = Kt + Bn(ot),
                        Fn = new Uint8Array(kt + ot);
                    return St(lt, Fn, 0), St(ot, Fn, Kt), Fn.set(Ye, kt), new ti(lt, ot, Ye, Fn)
                };
            class ti {
                constructor(Ye, ot, Kt, kt) {
                    this.code = Ye, this.size = ot, this.digest = Kt, this.bytes = kt
                }
            }
            const qi = ({
                name: lt,
                code: Ye,
                encode: ot
            }) => new Xs(lt, Ye, ot);
            class Xs {
                constructor(Ye, ot, Kt) {
                    this.name = Ye, this.code = ot, this.encode = Kt
                }
                digest(Ye) {
                    if (Ye instanceof Uint8Array) {
                        const ot = this.encode(Ye);
                        return ot instanceof Uint8Array ? Nn(this.code, ot) : ot.then(Kt => Nn(this.code, Kt))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            }
            const Xn = lt => function() {
                    var Ye = (0, ke.Z)(function*(ot) {
                        return new Uint8Array(yield crypto.subtle.digest(lt, ot))
                    });
                    return function(ot) {
                        return Ye.apply(this, arguments)
                    }
                }(),
                an = qi({
                    name: "sha2-256",
                    code: 18,
                    encode: Xn("SHA-256")
                }),
                As = qi({
                    name: "sha2-512",
                    code: 19,
                    encode: Xn("SHA-512")
                }),
                Wr = Le,
                xo = {
                    code: 0,
                    name: "identity",
                    encode: Wr,
                    digest: lt => Nn(0, Wr(lt))
                },
                Zn = "raw",
                di = 85,
                Nr = lt => Le(lt),
                la = lt => Le(lt),
                ua = new TextEncoder,
                Qs = new TextDecoder,
                Ir = "json",
                ao = 512,
                da = lt => ua.encode(JSON.stringify(lt)),
                nc = lt => JSON.parse(Qs.decode(lt));
            Symbol, Symbol.for("nodejs.util.inspect.custom"), Symbol.for("@ipld/js-cid/CID");
            const Cr = { ...F,
                ...K,
                ...q,
                ...ne,
                ...S,
                ...j,
                ...C,
                ...z,
                ...H,
                ...Y
            };
            var wi = T(36045);

            function Ac(lt, Ye, ot, Kt) {
                return {
                    name: lt,
                    prefix: Ye,
                    encoder: {
                        name: lt,
                        prefix: Ye,
                        encode: ot
                    },
                    decoder: {
                        decode: Kt
                    }
                }
            }
            const _u = Ac("utf8", "u", lt => "u" + new TextDecoder("utf8").decode(lt), lt => (new TextEncoder).encode(lt.substring(1))),
                el = Ac("ascii", "a", lt => {
                    let Ye = "a";
                    for (let ot = 0; ot < lt.length; ot++) Ye += String.fromCharCode(lt[ot]);
                    return Ye
                }, lt => {
                    lt = lt.substring(1);
                    const Ye = (0, wi.E)(lt.length);
                    for (let ot = 0; ot < lt.length; ot++) Ye[ot] = lt.charCodeAt(ot);
                    return Ye
                }),
                kc = {
                    utf8: _u,
                    "utf-8": _u,
                    hex: Cr.base16,
                    latin1: el,
                    ascii: el,
                    binary: el,
                    ...Cr
                }
        },
        30277: (et, I, T) => {
            "use strict";

            function F(K) {
                return "string" == typeof K ? {
                    address: K,
                    type: "json-rpc"
                } : K
            }
            T.d(I, {
                T: () => F
            })
        },
        4257: (et, I, T) => {
            "use strict";
            T.d(I, {
                O: () => re
            });
            var F = T(15861),
                K = T(17627),
                q = T(54963),
                ne = T(32490),
                S = T(91849),
                j = T(70783),
                C = T(74439),
                z = T(5276),
                H = T(68821),
                Y = T(92897),
                Z = T(14637),
                le = T(68347);

            function re(Se, me) {
                return de.apply(this, arguments)
            }

            function de() {
                return (de = (0, F.Z)(function*(Se, {
                    blockNumber: me,
                    blockTag: Ce,
                    coinType: we,
                    name: ve,
                    universalResolverAddress: De
                }) {
                    let ae = De;
                    if (!ae) {
                        if (!Se.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        ae = (0, S.L)({
                            blockNumber: me,
                            chain: Se.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    try {
                        const Me = (0, ne.R)({
                                abi: K.X$,
                                functionName: "addr",
                                ...null != we ? {
                                    args: [(0, H.V)(ve), BigInt(we)]
                                } : {
                                    args: [(0, H.V)(ve)]
                                }
                            }),
                            Le = yield(0, Z.s)(Se, le.L, "readContract")({
                                address: ae,
                                abi: K.k3,
                                functionName: "resolve",
                                args: [(0, C.NC)((0, Y.T)(ve)), Me],
                                blockNumber: me,
                                blockTag: Ce
                            });
                        if ("0x" === Le[0]) return null;
                        const L = (0, q.k)({
                            abi: K.X$,
                            args: null != we ? [(0, H.V)(ve), BigInt(we)] : void 0,
                            functionName: "addr",
                            data: Le[0]
                        });
                        return "0x" === L || "0x00" === (0, j.f)(L) ? null : L
                    } catch (Me) {
                        if ((0, z.c)(Me, "resolve")) return null;
                        throw Me
                    }
                })).apply(this, arguments)
            }
        },
        69632: (et, I, T) => {
            "use strict";
            T.d(I, {
                r: () => $
            });
            var F = T(15861),
                K = T(68347),
                q = T(32618);
            class ne extends q.G {
                constructor({
                    data: M
                }) {
                    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
                        metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(M)}`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "EnsAvatarInvalidMetadataError"
                    })
                }
            }
            class S extends q.G {
                constructor({
                    reason: M
                }) {
                    super(`ENS NFT avatar URI is invalid. ${M}`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "EnsAvatarInvalidNftUriError"
                    })
                }
            }
            class j extends q.G {
                constructor({
                    uri: M
                }) {
                    super(`Unable to resolve ENS avatar URI "${M}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "EnsAvatarUriResolutionError"
                    })
                }
            }
            class C extends q.G {
                constructor({
                    namespace: M
                }) {
                    super(`ENS NFT avatar namespace "${M}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "EnsAvatarUnsupportedNamespaceError"
                    })
                }
            }
            const z = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
                H = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
                Y = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
                Z = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;

            function re() {
                return (re = (0, F.Z)(function*(v) {
                    try {
                        const M = yield fetch(v, {
                            method: "HEAD"
                        });
                        return 200 === M.status && M.headers.get("content-type") ? .startsWith("image/")
                    } catch (M) {
                        return !("object" == typeof M && typeof M.response < "u" || !globalThis.hasOwnProperty("Image")) && new Promise(U => {
                            const G = new Image;
                            G.onload = () => {
                                U(!0)
                            }, G.onerror = () => {
                                U(!1)
                            }, G.src = v
                        })
                    }
                })).apply(this, arguments)
            }

            function de(v, M) {
                return v ? v.endsWith("/") ? v.slice(0, -1) : v : M
            }

            function Se({
                uri: v,
                gatewayUrls: M
            }) {
                const U = Y.test(v);
                if (U) return {
                    uri: v,
                    isOnChain: !0,
                    isEncoded: U
                };
                const G = de(M ? .ipfs, "https://ipfs.io"),
                    y = de(M ? .arweave, "https://arweave.net"),
                    E = v.match(z),
                    {
                        protocol: A,
                        subpath: b,
                        target: N,
                        subtarget: R = ""
                    } = E ? .groups || {},
                    Q = "ipns:/" === A || "ipns/" === b,
                    Ee = "ipfs:/" === A || "ipfs/" === b || H.test(v);
                if (v.startsWith("http") && !Q && !Ee) {
                    let Ge = v;
                    return M ? .arweave && (Ge = v.replace(/https:\/\/arweave.net/g, M ? .arweave)), {
                        uri: Ge,
                        isOnChain: !1,
                        isEncoded: !1
                    }
                }
                if ((Q || Ee) && N) return {
                    uri: `${G}/${Q?"ipns":"ipfs"}/${N}${R}`,
                    isOnChain: !1,
                    isEncoded: !1
                };
                if ("ar:/" === A && N) return {
                    uri: `${y}/${N}${R||""}`,
                    isOnChain: !1,
                    isEncoded: !1
                };
                let Fe = v.replace(Z, "");
                if (Fe.startsWith("<svg") && (Fe = `data:image/svg+xml;base64,${btoa(Fe)}`), Fe.startsWith("data:") || Fe.startsWith("{")) return {
                    uri: Fe,
                    isOnChain: !0,
                    isEncoded: !1
                };
                throw new j({
                    uri: v
                })
            }

            function me(v) {
                if ("object" != typeof v || !("image" in v) && !("image_url" in v) && !("image_data" in v)) throw new ne({
                    data: v
                });
                return v.image || v.image_url || v.image_data
            }

            function we() {
                return (we = (0, F.Z)(function*({
                    gatewayUrls: v,
                    uri: M
                }) {
                    try {
                        const U = yield fetch(M).then(y => y.json());
                        return yield ve({
                            gatewayUrls: v,
                            uri: me(U)
                        })
                    } catch {
                        throw new j({
                            uri: M
                        })
                    }
                })).apply(this, arguments)
            }

            function ve(v) {
                return De.apply(this, arguments)
            }

            function De() {
                return De = (0, F.Z)(function*({
                    gatewayUrls: v,
                    uri: M
                }) {
                    const {
                        uri: U,
                        isOnChain: G
                    } = Se({
                        uri: M,
                        gatewayUrls: v
                    });
                    if (G || (yield function le(v) {
                            return re.apply(this, arguments)
                        }(U))) return U;
                    throw new j({
                        uri: M
                    })
                }), De.apply(this, arguments)
            }

            function Le() {
                return (Le = (0, F.Z)(function*(v, {
                    nft: M
                }) {
                    if ("erc721" === M.namespace) return (0, K.L)(v, {
                        address: M.contractAddress,
                        abi: [{
                            name: "tokenURI",
                            type: "function",
                            stateMutability: "view",
                            inputs: [{
                                name: "tokenId",
                                type: "uint256"
                            }],
                            outputs: [{
                                name: "",
                                type: "string"
                            }]
                        }],
                        functionName: "tokenURI",
                        args: [BigInt(M.tokenID)]
                    });
                    if ("erc1155" === M.namespace) return (0, K.L)(v, {
                        address: M.contractAddress,
                        abi: [{
                            name: "uri",
                            type: "function",
                            stateMutability: "view",
                            inputs: [{
                                name: "_id",
                                type: "uint256"
                            }],
                            outputs: [{
                                name: "",
                                type: "string"
                            }]
                        }],
                        functionName: "uri",
                        args: [BigInt(M.tokenID)]
                    });
                    throw new C({
                        namespace: M.namespace
                    })
                })).apply(this, arguments)
            }

            function ue() {
                return ue = (0, F.Z)(function*(v, {
                    gatewayUrls: M,
                    record: U
                }) {
                    return /eip155:/i.test(U) ? function Te(v, M) {
                        return xe.apply(this, arguments)
                    }(v, {
                        gatewayUrls: M,
                        record: U
                    }) : ve({
                        uri: U,
                        gatewayUrls: M
                    })
                }), ue.apply(this, arguments)
            }

            function xe() {
                return xe = (0, F.Z)(function*(v, {
                    gatewayUrls: M,
                    record: U
                }) {
                    const G = function ae(v) {
                            let M = v;
                            M.startsWith("did:nft:") && (M = M.replace("did:nft:", "").replace(/_/g, "/"));
                            const [U, G, y] = M.split("/"), [E, A] = U.split(":"), [b, N] = G.split(":");
                            if (!E || "eip155" !== E.toLowerCase()) throw new S({
                                reason: "Only EIP-155 supported"
                            });
                            if (!A) throw new S({
                                reason: "Chain ID not found"
                            });
                            if (!N) throw new S({
                                reason: "Contract address not found"
                            });
                            if (!y) throw new S({
                                reason: "Token ID not found"
                            });
                            if (!b) throw new S({
                                reason: "ERC namespace not found"
                            });
                            return {
                                chainID: parseInt(A),
                                namespace: b.toLowerCase(),
                                contractAddress: N,
                                tokenID: y
                            }
                        }(U),
                        y = yield function Me(v, M) {
                            return Le.apply(this, arguments)
                        }(v, {
                            nft: G
                        }), {
                            uri: E,
                            isOnChain: A,
                            isEncoded: b
                        } = Se({
                            uri: y,
                            gatewayUrls: M
                        });
                    if (A && (E.includes("data:application/json;base64,") || E.startsWith("{"))) {
                        const R = b ? atob(E.replace("data:application/json;base64,", "")) : E;
                        return ve({
                            uri: me(JSON.parse(R)),
                            gatewayUrls: M
                        })
                    }
                    let N = G.tokenID;
                    return "erc1155" === G.namespace && (N = N.replace("0x", "").padStart(64, "0")),
                        function Ce(v) {
                            return we.apply(this, arguments)
                        }({
                            gatewayUrls: M,
                            uri: E.replace(/(?:0x)?{id}/, N)
                        })
                }), xe.apply(this, arguments)
            }
            var Ae = T(14637),
                Ie = T(51180);

            function $(v, M) {
                return f.apply(this, arguments)
            }

            function f() {
                return f = (0, F.Z)(function*(v, {
                    blockNumber: M,
                    blockTag: U,
                    gatewayUrls: G,
                    name: y,
                    universalResolverAddress: E
                }) {
                    const A = yield(0, Ae.s)(v, Ie.g, "getEnsText")({
                        blockNumber: M,
                        blockTag: U,
                        key: "avatar",
                        name: y,
                        universalResolverAddress: E
                    });
                    if (!A) return null;
                    try {
                        return yield function L(v, M) {
                            return ue.apply(this, arguments)
                        }(v, {
                            record: A,
                            gatewayUrls: G
                        })
                    } catch {
                        return null
                    }
                }), f.apply(this, arguments)
            }
        },
        28971: (et, I, T) => {
            "use strict";
            T.d(I, {
                w: () => H
            });
            var F = T(15861),
                K = T(17627),
                q = T(91849),
                ne = T(74439),
                S = T(5276),
                j = T(92897),
                C = T(14637),
                z = T(68347);

            function H(Z, le) {
                return Y.apply(this, arguments)
            }

            function Y() {
                return (Y = (0, F.Z)(function*(Z, {
                    address: le,
                    blockNumber: re,
                    blockTag: de,
                    universalResolverAddress: Se
                }) {
                    let me = Se;
                    if (!me) {
                        if (!Z.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        me = (0, q.L)({
                            blockNumber: re,
                            chain: Z.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    const Ce = `${le.toLowerCase().substring(2)}.addr.reverse`;
                    try {
                        const [we, ve] = yield(0, C.s)(Z, z.L, "readContract")({
                            address: me,
                            abi: K.du,
                            functionName: "reverse",
                            args: [(0, ne.NC)((0, j.T)(Ce))],
                            blockNumber: re,
                            blockTag: de
                        });
                        return le.toLowerCase() !== ve.toLowerCase() ? null : we
                    } catch (we) {
                        if ((0, S.c)(we, "reverse")) return null;
                        throw we
                    }
                })).apply(this, arguments)
            }
        },
        33069: (et, I, T) => {
            "use strict";
            T.d(I, {
                S: () => C
            });
            var F = T(15861),
                K = T(91849),
                q = T(74439),
                ne = T(92897),
                S = T(14637),
                j = T(68347);

            function C(H, Y) {
                return z.apply(this, arguments)
            }

            function z() {
                return (z = (0, F.Z)(function*(H, {
                    blockNumber: Y,
                    blockTag: Z,
                    name: le,
                    universalResolverAddress: re
                }) {
                    let de = re;
                    if (!de) {
                        if (!H.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        de = (0, K.L)({
                            blockNumber: Y,
                            chain: H.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    const [Se] = yield(0, S.s)(H, j.L, "readContract")({
                        address: de,
                        abi: [{
                            inputs: [{
                                type: "bytes"
                            }],
                            name: "findResolver",
                            outputs: [{
                                type: "address"
                            }, {
                                type: "bytes32"
                            }],
                            stateMutability: "view",
                            type: "function"
                        }],
                        functionName: "findResolver",
                        args: [(0, q.NC)((0, ne.T)(le))],
                        blockNumber: Y,
                        blockTag: Z
                    });
                    return Se
                })).apply(this, arguments)
            }
        },
        51180: (et, I, T) => {
            "use strict";
            T.d(I, {
                g: () => le
            });
            var F = T(15861),
                K = T(17627),
                q = T(54963),
                ne = T(32490),
                S = T(91849),
                j = T(74439),
                C = T(5276),
                z = T(68821),
                H = T(92897),
                Y = T(14637),
                Z = T(68347);

            function le(de, Se) {
                return re.apply(this, arguments)
            }

            function re() {
                return (re = (0, F.Z)(function*(de, {
                    blockNumber: Se,
                    blockTag: me,
                    name: Ce,
                    key: we,
                    universalResolverAddress: ve
                }) {
                    let De = ve;
                    if (!De) {
                        if (!de.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        De = (0, S.L)({
                            blockNumber: Se,
                            chain: de.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    try {
                        const ae = yield(0, Y.s)(de, Z.L, "readContract")({
                            address: De,
                            abi: K.k3,
                            functionName: "resolve",
                            args: [(0, j.NC)((0, H.T)(Ce)), (0, ne.R)({
                                abi: K.nZ,
                                functionName: "text",
                                args: [(0, z.V)(Ce), we]
                            })],
                            blockNumber: Se,
                            blockTag: me
                        });
                        if ("0x" === ae[0]) return null;
                        const Me = (0, q.k)({
                            abi: K.nZ,
                            functionName: "text",
                            data: ae[0]
                        });
                        return "" === Me ? null : Me
                    } catch (ae) {
                        if ((0, C.c)(ae, "resolve")) return null;
                        throw ae
                    }
                })).apply(this, arguments)
            }
        },
        19934: (et, I, T) => {
            "use strict";
            T.d(I, {
                R: () => ve
            });
            var F = T(15861),
                K = T(30277),
                q = T(17627);
            const ne = "0x82ad56cb";
            var S = T(32618),
                j = T(8722),
                C = T(28169),
                z = T(54963),
                H = T(32490),
                Y = T(91849),
                Z = T(74439),
                le = T(17354),
                re = T(92917),
                Se = T(77603),
                me = T(67369),
                Ce = T(87447),
                we = T(9056);

            function ve(ue, Te) {
                return De.apply(this, arguments)
            }

            function De() {
                return De = (0, F.Z)(function*(ue, Te) {
                    const {
                        account: xe = ue.account,
                        batch: Ae = !!ue.batch ? .multicall,
                        blockNumber: Ie,
                        blockTag: $ = "latest",
                        accessList: f,
                        data: v,
                        gas: M,
                        gasPrice: U,
                        maxFeePerGas: G,
                        maxPriorityFeePerGas: y,
                        nonce: E,
                        to: A,
                        value: b,
                        ...N
                    } = Te, R = xe ? (0, K.T)(xe) : void 0;
                    try {
                        (0, we.F)(Te);
                        const Ee = (Ie ? (0, Z.eC)(Ie) : void 0) || $,
                            Fe = ue.chain ? .formatters ? .transactionRequest ? .format,
                            wt = (Fe || me.tG)({ ...(0, Se.K)(N, {
                                    format: Fe
                                }),
                                from: R ? .address,
                                accessList: f,
                                data: v,
                                gas: M,
                                gasPrice: U,
                                maxFeePerGas: G,
                                maxPriorityFeePerGas: y,
                                nonce: E,
                                to: A,
                                value: b
                            });
                        if (Ae && function ae({
                                request: ue
                            }) {
                                const {
                                    data: Te,
                                    to: xe,
                                    ...Ae
                                } = ue;
                                return !(!Te || Te.startsWith(ne) || !xe || Object.values(Ae).filter(Ie => typeof Ie < "u").length > 0)
                            }({
                                request: wt
                            })) try {
                            return yield function Me(ue, Te) {
                                return Le.apply(this, arguments)
                            }(ue, { ...wt,
                                blockNumber: Ie,
                                blockTag: $
                            })
                        } catch (Mt) {
                            if (!(Mt instanceof j.pZ || Mt instanceof j.mm)) throw Mt
                        }
                        const Vt = yield ue.request({
                            method: "eth_call",
                            params: Ee ? [wt, Ee] : [wt]
                        });
                        return "0x" === Vt ? {
                            data: void 0
                        } : {
                            data: Vt
                        }
                    } catch (Q) {
                        const Ee = function L(ue) {
                                if (!(ue instanceof S.G)) return;
                                const Te = ue.walk();
                                return "object" == typeof Te.data ? Te.data.data : Te.data
                            }(Q),
                            {
                                offchainLookup: Fe,
                                offchainLookupSignature: Ge
                            } = yield T.e(959).then(T.bind(T, 76959));
                        if (Ee ? .slice(0, 10) === Ge && A) return {
                            data: yield Fe(ue, {
                                data: Ee,
                                to: A
                            })
                        };
                        throw function de(ue, {
                            docsPath: Te,
                            ...xe
                        }) {
                            const Ae = (() => {
                                const Ie = (0, re.k)(ue, xe);
                                return Ie instanceof le.cj ? ue : Ie
                            })();
                            return new C.cg(Ae, {
                                docsPath: Te,
                                ...xe
                            })
                        }(Q, { ...Te,
                            account: R,
                            chain: ue.chain
                        })
                    }
                }), De.apply(this, arguments)
            }

            function Le() {
                return Le = (0, F.Z)(function*(ue, Te) {
                    const {
                        batchSize: xe = 1024,
                        wait: Ae = 0
                    } = "object" == typeof ue.batch ? .multicall ? ue.batch.multicall : {}, {
                        blockNumber: Ie,
                        blockTag: $ = "latest",
                        data: f,
                        multicallAddress: v,
                        to: M
                    } = Te;
                    let U = v;
                    if (!U) {
                        if (!ue.chain) throw new j.pZ;
                        U = (0, Y.L)({
                            blockNumber: Ie,
                            chain: ue.chain,
                            contract: "multicall3"
                        })
                    }
                    const y = (Ie ? (0, Z.eC)(Ie) : void 0) || $,
                        {
                            schedule: E
                        } = (0, Ce.S)({
                            id: `${ue.uid}.${y}`,
                            wait: Ae,
                            shouldSplitBatch: N => N.reduce((Q, {
                                data: Ee
                            }) => Q + (Ee.length - 2), 0) > 2 * xe,
                            fn: (N = (0, F.Z)(function*(R) {
                                const Q = R.map(Ge => ({
                                        allowFailure: !0,
                                        callData: Ge.data,
                                        target: Ge.to
                                    })),
                                    Ee = (0, H.R)({
                                        abi: q.F8,
                                        args: [Q],
                                        functionName: "aggregate3"
                                    }),
                                    Fe = yield ue.request({
                                        method: "eth_call",
                                        params: [{
                                            data: Ee,
                                            to: U
                                        }, y]
                                    });
                                return (0, z.k)({
                                    abi: q.F8,
                                    args: [Q],
                                    functionName: "aggregate3",
                                    data: Fe || "0x"
                                })
                            }), function(Q) {
                                return N.apply(this, arguments)
                            })
                        }),
                        [{
                            returnData: A,
                            success: b
                        }] = yield E({
                            data: f,
                            to: M
                        });
                    var N;
                    if (!b) throw new C.VQ({
                        data: A
                    });
                    return "0x" === A ? {
                        data: void 0
                    } : {
                        data: A
                    }
                }), Le.apply(this, arguments)
            }
        },
        68347: (et, I, T) => {
            "use strict";
            T.d(I, {
                L: () => C
            });
            var F = T(15861),
                K = T(54963),
                q = T(32490),
                ne = T(50660),
                S = T(14637),
                j = T(19934);

            function C(H, Y) {
                return z.apply(this, arguments)
            }

            function z() {
                return (z = (0, F.Z)(function*(H, {
                    abi: Y,
                    address: Z,
                    args: le,
                    functionName: re,
                    ...de
                }) {
                    const Se = (0, q.R)({
                        abi: Y,
                        args: le,
                        functionName: re
                    });
                    try {
                        const {
                            data: me
                        } = yield(0, S.s)(H, j.R, "call")({
                            data: Se,
                            to: Z,
                            ...de
                        });
                        return (0, K.k)({
                            abi: Y,
                            args: le,
                            functionName: re,
                            data: me || "0x"
                        })
                    } catch (me) {
                        throw (0, ne.S)(me, {
                            abi: Y,
                            address: Z,
                            args: le,
                            docsPath: "/docs/contract/readContract",
                            functionName: re
                        })
                    }
                })).apply(this, arguments)
            }
        },
        17627: (et, I, T) => {
            "use strict";
            T.d(I, {
                $o: () => z,
                F8: () => F,
                X$: () => j,
                du: () => ne,
                k3: () => q,
                nZ: () => S
            });
            const F = [{
                    inputs: [{
                        components: [{
                            name: "target",
                            type: "address"
                        }, {
                            name: "allowFailure",
                            type: "bool"
                        }, {
                            name: "callData",
                            type: "bytes"
                        }],
                        name: "calls",
                        type: "tuple[]"
                    }],
                    name: "aggregate3",
                    outputs: [{
                        components: [{
                            name: "success",
                            type: "bool"
                        }, {
                            name: "returnData",
                            type: "bytes"
                        }],
                        name: "returnData",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                K = [{
                    inputs: [],
                    name: "ResolverNotFound",
                    type: "error"
                }, {
                    inputs: [],
                    name: "ResolverWildcardNotSupported",
                    type: "error"
                }],
                q = [...K, {
                    name: "resolve",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{
                        name: "name",
                        type: "bytes"
                    }, {
                        name: "data",
                        type: "bytes"
                    }],
                    outputs: [{
                        name: "",
                        type: "bytes"
                    }, {
                        name: "address",
                        type: "address"
                    }]
                }],
                ne = [...K, {
                    name: "reverse",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{
                        type: "bytes",
                        name: "reverseName"
                    }],
                    outputs: [{
                        type: "string",
                        name: "resolvedName"
                    }, {
                        type: "address",
                        name: "resolvedAddress"
                    }, {
                        type: "address",
                        name: "reverseResolver"
                    }, {
                        type: "address",
                        name: "resolver"
                    }]
                }],
                S = [{
                    name: "text",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{
                        name: "name",
                        type: "bytes32"
                    }, {
                        name: "key",
                        type: "string"
                    }],
                    outputs: [{
                        name: "",
                        type: "string"
                    }]
                }],
                j = [{
                    name: "addr",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{
                        name: "name",
                        type: "bytes32"
                    }],
                    outputs: [{
                        name: "",
                        type: "address"
                    }]
                }, {
                    name: "addr",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{
                        name: "name",
                        type: "bytes32"
                    }, {
                        name: "coinType",
                        type: "uint256"
                    }],
                    outputs: [{
                        name: "",
                        type: "bytes"
                    }]
                }],
                z = [{
                    inputs: [{
                        internalType: "address",
                        name: "_signer",
                        type: "address"
                    }, {
                        internalType: "bytes32",
                        name: "_hash",
                        type: "bytes32"
                    }, {
                        internalType: "bytes",
                        name: "_signature",
                        type: "bytes"
                    }],
                    stateMutability: "nonpayable",
                    type: "constructor"
                }]
        },
        66848: (et, I, T) => {
            "use strict";
            T.d(I, {
                $: () => F,
                Up: () => K,
                hZ: () => q
            });
            const F = {
                    1: "An `assert` condition failed.",
                    17: "Arithmic operation resulted in underflow or overflow.",
                    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
                    33: "Attempted to convert to an invalid type.",
                    34: "Attempted to access a storage byte array that is incorrectly encoded.",
                    49: "Performed `.pop()` on an empty array",
                    50: "Array index is out of bounds.",
                    65: "Allocated too much memory or created an array which is too large.",
                    81: "Attempted to call a zero-initialized variable of internal function type."
                },
                K = {
                    inputs: [{
                        name: "message",
                        type: "string"
                    }],
                    name: "Error",
                    type: "error"
                },
                q = {
                    inputs: [{
                        name: "reason",
                        type: "uint256"
                    }],
                    name: "Panic",
                    type: "error"
                }
        },
        99744: (et, I, T) => {
            "use strict";
            T.d(I, {
                Bd: () => q,
                Zn: () => K,
                ez: () => F
            });
            const F = {
                    gwei: 9,
                    wei: 18
                },
                K = {
                    ether: -9,
                    wei: 9
                },
                q = {
                    ether: -18,
                    gwei: -9
                }
        },
        76577: (et, I, T) => {
            "use strict";
            T.d(I, {
                CI: () => Te,
                FM: () => Se,
                Gy: () => L,
                KY: () => Me,
                M4: () => Y,
                MX: () => ve,
                S4: () => ae,
                SM: () => Le,
                cO: () => S,
                dh: () => ue,
                fM: () => ne,
                fs: () => Z,
                gr: () => H,
                hn: () => xe,
                lC: () => me,
                mv: () => Ce,
                wM: () => Ae,
                wb: () => z,
                xB: () => C,
                xL: () => we,
                yP: () => de
            });
            var F = T(16537),
                K = T(84018),
                q = T(32618);
            class ne extends q.G {
                constructor({
                    docsPath: f
                }) {
                    super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join("\n"), {
                        docsPath: f
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiConstructorNotFoundError"
                    })
                }
            }
            class S extends q.G {
                constructor({
                    docsPath: f
                }) {
                    super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join("\n"), {
                        docsPath: f
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiConstructorParamsNotFoundError"
                    })
                }
            }
            class C extends q.G {
                constructor({
                    data: f,
                    params: v,
                    size: M
                }) {
                    super([`Data size of ${M} bytes is too small for given parameters.`].join("\n"), {
                        metaMessages: [`Params: (${(0,F.h)(v,{includeName:!0})})`, `Data:   ${f} (${M} bytes)`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiDecodingDataSizeTooSmallError"
                    }), Object.defineProperty(this, "data", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "params", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "size", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.data = f, this.params = v, this.size = M
                }
            }
            class z extends q.G {
                constructor() {
                    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiDecodingZeroDataError"
                    })
                }
            }
            class H extends q.G {
                constructor({
                    expectedLength: f,
                    givenLength: v,
                    type: M
                }) {
                    super([`ABI encoding array length mismatch for type ${M}.`, `Expected length: ${f}`, `Given length: ${v}`].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEncodingArrayLengthMismatchError"
                    })
                }
            }
            class Y extends q.G {
                constructor({
                    expectedSize: f,
                    value: v
                }) {
                    super(`Size of bytes "${v}" (bytes${(0,K.d)(v)}) does not match expected size (bytes${f}).`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEncodingBytesSizeMismatchError"
                    })
                }
            }
            class Z extends q.G {
                constructor({
                    expectedLength: f,
                    givenLength: v
                }) {
                    super(["ABI encoding params/values length mismatch.", `Expected length (params): ${f}`, `Given length (values): ${v}`].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEncodingLengthMismatchError"
                    })
                }
            }
            class de extends q.G {
                constructor(f, {
                    docsPath: v
                }) {
                    super([`Encoded error signature "${f}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${f}.`].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiErrorSignatureNotFoundError"
                    }), Object.defineProperty(this, "signature", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.signature = f
                }
            }
            class Se extends q.G {
                constructor({
                    docsPath: f
                }) {
                    super("Cannot extract event signature from empty topics.", {
                        docsPath: f
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEventSignatureEmptyTopicsError"
                    })
                }
            }
            class me extends q.G {
                constructor(f, {
                    docsPath: v
                }) {
                    super([`Encoded event signature "${f}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${f}.`].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEventSignatureNotFoundError"
                    })
                }
            }
            class Ce extends q.G {
                constructor(f, {
                    docsPath: v
                } = {}) {
                    super([`Event ${f?`"${f}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiEventNotFoundError"
                    })
                }
            }
            class we extends q.G {
                constructor(f, {
                    docsPath: v
                } = {}) {
                    super([`Function ${f?`"${f}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiFunctionNotFoundError"
                    })
                }
            }
            class ve extends q.G {
                constructor(f, {
                    docsPath: v
                }) {
                    super([`Function "${f}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiFunctionOutputsNotFoundError"
                    })
                }
            }
            class ae extends q.G {
                constructor(f, v) {
                    super("Found ambiguous types in overloaded ABI items.", {
                        metaMessages: [`\`${f.type}\` in \`${(0,F.t)(f.abiItem)}\`, and`, `\`${v.type}\` in \`${(0,F.t)(v.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "AbiItemAmbiguityError"
                    })
                }
            }
            class Me extends q.G {
                constructor({
                    expectedSize: f,
                    givenSize: v
                }) {
                    super(`Expected bytes${f}, got bytes${v}.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "BytesSizeMismatchError"
                    })
                }
            }
            class Le extends q.G {
                constructor({
                    abiItem: f,
                    data: v,
                    params: M,
                    size: U
                }) {
                    super([`Data size of ${U} bytes is too small for non-indexed event parameters.`].join("\n"), {
                        metaMessages: [`Params: (${(0,F.h)(M,{includeName:!0})})`, `Data:   ${v} (${U} bytes)`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "DecodeLogDataMismatch"
                    }), Object.defineProperty(this, "abiItem", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "data", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "params", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "size", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.abiItem = f, this.data = v, this.params = M, this.size = U
                }
            }
            class L extends q.G {
                constructor({
                    abiItem: f,
                    param: v
                }) {
                    super([`Expected a topic for indexed event parameter${v.name?` "${v.name}"`:""} on event "${(0,F.t)(f,{includeName:!0})}".`].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "DecodeLogTopicsMismatch"
                    }), Object.defineProperty(this, "abiItem", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.abiItem = f
                }
            }
            class ue extends q.G {
                constructor(f, {
                    docsPath: v
                }) {
                    super([`Type "${f}" is not a valid encoding type.`, "Please provide a valid ABI type."].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidAbiEncodingType"
                    })
                }
            }
            class Te extends q.G {
                constructor(f, {
                    docsPath: v
                }) {
                    super([`Type "${f}" is not a valid decoding type.`, "Please provide a valid ABI type."].join("\n"), {
                        docsPath: v
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidAbiDecodingType"
                    })
                }
            }
            class xe extends q.G {
                constructor(f) {
                    super([`Value "${f}" is not a valid array.`].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidArrayError"
                    })
                }
            }
            class Ae extends q.G {
                constructor(f) {
                    super([`"${f}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidDefinitionTypeError"
                    })
                }
            }
        },
        78355: (et, I, T) => {
            "use strict";
            T.d(I, {
                b: () => K
            });
            var F = T(32618);
            class K extends F.G {
                constructor({
                    address: ne
                }) {
                    super(`Address "${ne}" is invalid.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidAddressError"
                    })
                }
            }
        },
        32618: (et, I, T) => {
            "use strict";
            T.d(I, {
                G: () => K
            });
            var F = T(41448);
            class K extends Error {
                constructor(S, j = {}) {
                    super(), Object.defineProperty(this, "details", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "docsPath", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "metaMessages", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "shortMessage", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ViemError"
                    }), Object.defineProperty(this, "version", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: (0, F.bo)()
                    });
                    const C = j.cause instanceof K ? j.cause.details : j.cause ? .message ? j.cause.message : j.details,
                        z = j.cause instanceof K && j.cause.docsPath || j.docsPath;
                    this.message = [S || "An error occurred.", "", ...j.metaMessages ? [...j.metaMessages, ""] : [], ...z ? [`Docs: https://viem.sh${z}.html${j.docsSlug?`#${j.docsSlug}`:""}`] : [], ...C ? [`Details: ${C}`] : [], `Version: ${this.version}`].join("\n"), j.cause && (this.cause = j.cause), this.details = C, this.docsPath = z, this.metaMessages = j.metaMessages, this.shortMessage = S
                }
                walk(S) {
                    return q(this, S)
                }
            }

            function q(ne, S) {
                return S ? .(ne) ? ne : ne && "object" == typeof ne && "cause" in ne ? q(ne.cause, S) : S ? null : ne
            }
        },
        8722: (et, I, T) => {
            "use strict";
            T.d(I, {
                Bk: () => ne,
                Yl: () => q,
                mm: () => K,
                pZ: () => S
            });
            var F = T(32618);
            class K extends F.G {
                constructor({
                    blockNumber: z,
                    chain: H,
                    contract: Y
                }) {
                    super(`Chain "${H.name}" does not support contract "${Y.name}".`, {
                        metaMessages: ["This could be due to any of the following:", ...z && Y.blockCreated && Y.blockCreated > z ? [`- The contract "${Y.name}" was not deployed until block ${Y.blockCreated} (current block ${z}).`] : [`- The chain does not have the contract "${Y.name}" configured.`]]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ChainDoesNotSupportContract"
                    })
                }
            }
            class q extends F.G {
                constructor({
                    chain: z,
                    currentChainId: H
                }) {
                    super(`The current chain of the wallet (id: ${H}) does not match the target chain for the transaction (id: ${z.id} \u2013 ${z.name}).`, {
                        metaMessages: [`Current Chain ID:  ${H}`, `Expected Chain ID: ${z.id} \u2013 ${z.name}`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ChainMismatchError"
                    })
                }
            }
            class ne extends F.G {
                constructor() {
                    super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ChainNotFoundError"
                    })
                }
            }
            class S extends F.G {
                constructor() {
                    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ClientChainNotConfiguredError"
                    })
                }
            }
        },
        28169: (et, I, T) => {
            "use strict";
            T.d(I, {
                cg: () => de,
                uq: () => Se,
                Lu: () => me,
                Dk: () => Ce,
                VQ: () => we
            });
            var F = T(30277),
                K = T(66848),
                q = T(41936),
                ne = T(16537),
                S = T(30038);

            function j({
                abiItem: ve,
                args: De,
                includeFunctionName: ae = !0,
                includeName: Me = !1
            }) {
                if ("name" in ve && "inputs" in ve && ve.inputs) return `${ae?ve.name:""}(${ve.inputs.map((Le,L)=>`${Me&&Le.name?`${Le.name}: `:""}${"object"==typeof De[L]?(0,S.P)(De[L]):De[L]}`).join(", ")})`
            }
            var C = T(30930),
                z = T(78004),
                H = T(79077),
                Y = T(76577),
                Z = T(32618),
                le = T(98284),
                re = T(41448);
            class de extends Z.G {
                constructor(De, {
                    account: ae,
                    docsPath: Me,
                    chain: Le,
                    data: L,
                    gas: ue,
                    gasPrice: Te,
                    maxFeePerGas: xe,
                    maxPriorityFeePerGas: Ae,
                    nonce: Ie,
                    to: $,
                    value: f
                }) {
                    const v = ae ? (0, F.T)(ae) : void 0,
                        M = (0, le.xr)({
                            from: v ? .address,
                            to: $,
                            value: typeof f < "u" && `${(0,z.d)(f)} ${Le?.nativeCurrency?.symbol||"ETH"}`,
                            data: L,
                            gas: ue,
                            gasPrice: typeof Te < "u" && `${(0,H.o)(Te)} gwei`,
                            maxFeePerGas: typeof xe < "u" && `${(0,H.o)(xe)} gwei`,
                            maxPriorityFeePerGas: typeof Ae < "u" && `${(0,H.o)(Ae)} gwei`,
                            nonce: Ie
                        });
                    super(De.shortMessage, {
                        cause: De,
                        docsPath: Me,
                        metaMessages: [...De.metaMessages ? [...De.metaMessages, " "] : [], "Raw Call Arguments:", M].filter(Boolean)
                    }), Object.defineProperty(this, "cause", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "CallExecutionError"
                    }), this.cause = De
                }
            }
            class Se extends Z.G {
                constructor(De, {
                    abi: ae,
                    args: Me,
                    contractAddress: Le,
                    docsPath: L,
                    functionName: ue,
                    sender: Te
                }) {
                    const xe = (0, C.mE)({
                            abi: ae,
                            args: Me,
                            name: ue
                        }),
                        Ae = xe ? j({
                            abiItem: xe,
                            args: Me,
                            includeFunctionName: !1,
                            includeName: !1
                        }) : void 0,
                        Ie = xe ? (0, ne.t)(xe, {
                            includeName: !0
                        }) : void 0,
                        $ = (0, le.xr)({
                            address: Le && (0, re.CR)(Le),
                            function: Ie,
                            args: Ae && "()" !== Ae && `${[...Array(ue?.length??0).keys()].map(()=>" ").join("")}${Ae}`,
                            sender: Te
                        });
                    super(De.shortMessage || `An unknown error occurred while executing the contract function "${ue}".`, {
                        cause: De,
                        docsPath: L,
                        metaMessages: [...De.metaMessages ? [...De.metaMessages, " "] : [], "Contract Call:", $].filter(Boolean)
                    }), Object.defineProperty(this, "abi", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "args", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "cause", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "contractAddress", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "formattedArgs", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "functionName", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "sender", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ContractFunctionExecutionError"
                    }), this.abi = ae, this.args = Me, this.cause = De, this.contractAddress = Le, this.functionName = ue, this.sender = Te
                }
            }
            class me extends Z.G {
                constructor({
                    abi: De,
                    data: ae,
                    functionName: Me,
                    message: Le
                }) {
                    let L, ue, Te, xe, Ae;
                    if (ae && "0x" !== ae) try {
                        ue = (0, q.p)({
                            abi: De,
                            data: ae
                        });
                        const {
                            abiItem: Ie,
                            errorName: $,
                            args: f
                        } = ue;
                        if ("Error" === $) xe = f[0];
                        else if ("Panic" === $) {
                            const [v] = f;
                            xe = K.$[v]
                        } else {
                            const v = Ie ? (0, ne.t)(Ie, {
                                    includeName: !0
                                }) : void 0,
                                M = Ie && f ? j({
                                    abiItem: Ie,
                                    args: f,
                                    includeFunctionName: !1,
                                    includeName: !1
                                }) : void 0;
                            Te = [v ? `Error: ${v}` : "", M && "()" !== M ? `       ${[...Array($?.length??0).keys()].map(()=>" ").join("")}${M}` : ""]
                        }
                    } catch (Ie) {
                        L = Ie
                    } else Le && (xe = Le);
                    L instanceof Y.yP && (Ae = L.signature, Te = [`Unable to decode signature "${Ae}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${Ae}.`]), super(xe && "execution reverted" !== xe || Ae ? [`The contract function "${Me}" reverted with the following ${Ae?"signature":"reason"}:`, xe || Ae].join("\n") : `The contract function "${Me}" reverted.`, {
                        cause: L,
                        metaMessages: Te
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ContractFunctionRevertedError"
                    }), Object.defineProperty(this, "data", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "reason", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "signature", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.data = ue, this.reason = xe, this.signature = Ae
                }
            }
            class Ce extends Z.G {
                constructor({
                    functionName: De
                }) {
                    super(`The contract function "${De}" returned no data ("0x").`, {
                        metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${De}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ContractFunctionZeroDataError"
                    })
                }
            }
            class we extends Z.G {
                constructor({
                    data: De,
                    message: ae
                }) {
                    super(ae || ""), Object.defineProperty(this, "code", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: 3
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "RawContractError"
                    }), Object.defineProperty(this, "data", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.data = De
                }
            }
        },
        76893: (et, I, T) => {
            "use strict";
            T.d(I, {
                $: () => q,
                m: () => K
            });
            var F = T(32618);
            class K extends F.G {
                constructor({
                    offset: S,
                    position: j,
                    size: C
                }) {
                    super(`Slice ${"start"===j?"starting":"ending"} at offset "${S}" is out-of-bounds (size: ${C}).`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "SliceOffsetOutOfBoundsError"
                    })
                }
            }
            class q extends F.G {
                constructor({
                    size: S,
                    targetSize: j,
                    type: C
                }) {
                    super(`${C.charAt(0).toUpperCase()}${C.slice(1).toLowerCase()} size (${S}) exceeds padding size (${j}).`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "SizeExceedsPaddingSizeError"
                    })
                }
            }
        },
        78866: (et, I, T) => {
            "use strict";
            T.d(I, {
                Cd: () => j,
                J5: () => ne,
                M6: () => H
            });
            var F = T(32618);
            class ne extends F.G {
                constructor({
                    max: Z,
                    min: le,
                    signed: re,
                    size: de,
                    value: Se
                }) {
                    super(`Number "${Se}" is not in safe ${de?`${8*de}-bit ${re?"signed":"unsigned"} `:""}integer range ${Z?`(${le} to ${Z})`:`(above ${le})`}`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "IntegerOutOfRangeError"
                    })
                }
            }
            class j extends F.G {
                constructor(Z) {
                    super(`Hex value "${Z}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidHexBooleanError"
                    })
                }
            }
            class H extends F.G {
                constructor({
                    givenSize: Z,
                    maxSize: le
                }) {
                    super(`Size cannot exceed ${le} bytes. Given size: ${Z} bytes.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "SizeOverflowError"
                    })
                }
            }
        },
        17354: (et, I, T) => {
            "use strict";
            T.d(I, {
                C_: () => H,
                G$: () => S,
                Hh: () => ne,
                M_: () => q,
                WF: () => Y,
                ZI: () => j,
                cj: () => de,
                cs: () => re,
                dR: () => Z,
                pZ: () => le,
                se: () => z,
                vU: () => C
            });
            var F = T(79077),
                K = T(32618);
            class q extends K.G {
                constructor({
                    cause: me,
                    message: Ce
                } = {}) {
                    const we = Ce ? .replace("execution reverted: ", "") ? .replace("execution reverted", "");
                    super(`Execution reverted ${we?`with reason: ${we}`:"for an unknown reason"}.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ExecutionRevertedError"
                    })
                }
            }
            Object.defineProperty(q, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 3
            }), Object.defineProperty(q, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /execution reverted/
            });
            class ne extends K.G {
                constructor({
                    cause: me,
                    maxFeePerGas: Ce
                } = {}) {
                    super(`The fee cap (\`maxFeePerGas\`${Ce?` = ${(0,F.o)(Ce)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "FeeCapTooHigh"
                    })
                }
            }
            Object.defineProperty(ne, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
            });
            class S extends K.G {
                constructor({
                    cause: me,
                    maxFeePerGas: Ce
                } = {}) {
                    super(`The fee cap (\`maxFeePerGas\`${Ce?` = ${(0,F.o)(Ce)}`:""} gwei) cannot be lower than the block base fee.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "FeeCapTooLow"
                    })
                }
            }
            Object.defineProperty(S, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
            });
            class j extends K.G {
                constructor({
                    cause: me,
                    nonce: Ce
                } = {}) {
                    super(`Nonce provided for the transaction ${Ce?`(${Ce}) `:""}is higher than the next one expected.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "NonceTooHighError"
                    })
                }
            }
            Object.defineProperty(j, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /nonce too high/
            });
            class C extends K.G {
                constructor({
                    cause: me,
                    nonce: Ce
                } = {}) {
                    super([`Nonce provided for the transaction ${Ce?`(${Ce}) `:""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"), {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "NonceTooLowError"
                    })
                }
            }
            Object.defineProperty(C, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /nonce too low|transaction already imported|already known/
            });
            class z extends K.G {
                constructor({
                    cause: me,
                    nonce: Ce
                } = {}) {
                    super(`Nonce provided for the transaction ${Ce?`(${Ce}) `:""}exceeds the maximum allowed nonce.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "NonceMaxValueError"
                    })
                }
            }
            Object.defineProperty(z, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /nonce has max value/
            });
            class H extends K.G {
                constructor({
                    cause: me
                } = {}) {
                    super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"), {
                        cause: me,
                        metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InsufficientFundsError"
                    })
                }
            }
            Object.defineProperty(H, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /insufficient funds/
            });
            class Y extends K.G {
                constructor({
                    cause: me,
                    gas: Ce
                } = {}) {
                    super(`The amount of gas ${Ce?`(${Ce}) `:""}provided for the transaction exceeds the limit allowed for the block.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "IntrinsicGasTooHighError"
                    })
                }
            }
            Object.defineProperty(Y, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /intrinsic gas too high|gas limit reached/
            });
            class Z extends K.G {
                constructor({
                    cause: me,
                    gas: Ce
                } = {}) {
                    super(`The amount of gas ${Ce?`(${Ce}) `:""}provided for the transaction is too low.`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "IntrinsicGasTooLowError"
                    })
                }
            }
            Object.defineProperty(Z, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /intrinsic gas too low/
            });
            class le extends K.G {
                constructor({
                    cause: me
                }) {
                    super("The transaction type is not supported for this chain.", {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TransactionTypeNotSupportedError"
                    })
                }
            }
            Object.defineProperty(le, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /transaction type not valid/
            });
            class re extends K.G {
                constructor({
                    cause: me,
                    maxPriorityFeePerGas: Ce,
                    maxFeePerGas: we
                } = {}) {
                    super([`The provided tip (\`maxPriorityFeePerGas\`${Ce?` = ${(0,F.o)(Ce)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${we?` = ${(0,F.o)(we)} gwei`:""}).`].join("\n"), {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TipAboveFeeCapError"
                    })
                }
            }
            Object.defineProperty(re, "nodeMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
            });
            class de extends K.G {
                constructor({
                    cause: me
                }) {
                    super(`An error occurred while executing: ${me?.shortMessage}`, {
                        cause: me
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "UnknownNodeError"
                    })
                }
            }
        },
        23979: (et, I, T) => {
            "use strict";
            T.d(I, {
                Gg: () => ne,
                W5: () => C,
                bs: () => j,
                c9: () => S
            });
            var F = T(30038),
                K = T(32618),
                q = T(41448);
            class ne extends K.G {
                constructor({
                    body: H,
                    details: Y,
                    headers: Z,
                    status: le,
                    url: re
                }) {
                    super("HTTP request failed.", {
                        details: Y,
                        metaMessages: [le && `Status: ${le}`, `URL: ${(0,q.Gr)(re)}`, H && `Request body: ${(0,F.P)(H)}`].filter(Boolean)
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "HttpRequestError"
                    }), Object.defineProperty(this, "body", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "headers", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "status", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "url", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.body = H, this.headers = Z, this.status = le, this.url = re
                }
            }
            class S extends K.G {
                constructor({
                    body: H,
                    details: Y,
                    url: Z
                }) {
                    super("WebSocket request failed.", {
                        details: Y,
                        metaMessages: [`URL: ${(0,q.Gr)(Z)}`, `Request body: ${(0,F.P)(H)}`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "WebSocketRequestError"
                    })
                }
            }
            class j extends K.G {
                constructor({
                    body: H,
                    error: Y,
                    url: Z
                }) {
                    super("RPC Request failed.", {
                        cause: Y,
                        details: Y.message,
                        metaMessages: [`URL: ${(0,q.Gr)(Z)}`, `Request body: ${(0,F.P)(H)}`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "RpcRequestError"
                    }), Object.defineProperty(this, "code", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.code = Y.code
                }
            }
            class C extends K.G {
                constructor({
                    body: H,
                    url: Y
                }) {
                    super("The request took too long to respond.", {
                        details: "The request timed out.",
                        metaMessages: [`URL: ${(0,q.Gr)(Y)}`, `Request body: ${(0,F.P)(H)}`]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TimeoutError"
                    })
                }
            }
        },
        59450: (et, I, T) => {
            "use strict";
            T.d(I, {
                B: () => C,
                GD: () => Ce,
                I0: () => Me,
                KB: () => de,
                LX: () => z,
                Og: () => le,
                PE: () => ve,
                Pv: () => me,
                Ts: () => De,
                XS: () => Y,
                ab: () => we,
                gS: () => Se,
                ir: () => L,
                nY: () => H,
                pT: () => re,
                s7: () => j,
                u5: () => ae,
                x3: () => Le,
                yR: () => Z
            });
            var F = T(32618),
                K = T(23979);
            class ne extends F.G {
                constructor(Te, {
                    code: xe,
                    docsPath: Ae,
                    metaMessages: Ie,
                    shortMessage: $
                }) {
                    super($, {
                        cause: Te,
                        docsPath: Ae,
                        metaMessages: Ie || Te ? .metaMessages
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "RpcError"
                    }), Object.defineProperty(this, "code", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.name = Te.name, this.code = Te instanceof K.bs ? Te.code : xe ? ? -1
                }
            }
            class S extends ne {
                constructor(Te, xe) {
                    super(Te, xe), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ProviderRpcError"
                    }), Object.defineProperty(this, "data", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), this.data = xe.data
                }
            }
            class j extends ne {
                constructor(Te) {
                    super(Te, {
                        code: j.code,
                        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ParseRpcError"
                    })
                }
            }
            Object.defineProperty(j, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32700
            });
            class C extends ne {
                constructor(Te) {
                    super(Te, {
                        code: C.code,
                        shortMessage: "JSON is not a valid request object."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidRequestRpcError"
                    })
                }
            }
            Object.defineProperty(C, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32600
            });
            class z extends ne {
                constructor(Te) {
                    super(Te, {
                        code: z.code,
                        shortMessage: "The method does not exist / is not available."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "MethodNotFoundRpcError"
                    })
                }
            }
            Object.defineProperty(z, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32601
            });
            class H extends ne {
                constructor(Te) {
                    super(Te, {
                        code: H.code,
                        shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join("\n")
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidParamsRpcError"
                    })
                }
            }
            Object.defineProperty(H, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32602
            });
            class Y extends ne {
                constructor(Te) {
                    super(Te, {
                        code: Y.code,
                        shortMessage: "An internal error was received."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InternalRpcError"
                    })
                }
            }
            Object.defineProperty(Y, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32603
            });
            class Z extends ne {
                constructor(Te) {
                    super(Te, {
                        code: Z.code,
                        shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join("\n")
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidInputRpcError"
                    })
                }
            }
            Object.defineProperty(Z, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32e3
            });
            class le extends ne {
                constructor(Te) {
                    super(Te, {
                        code: le.code,
                        shortMessage: "Requested resource not found."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ResourceNotFoundRpcError"
                    })
                }
            }
            Object.defineProperty(le, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32001
            });
            class re extends ne {
                constructor(Te) {
                    super(Te, {
                        code: re.code,
                        shortMessage: "Requested resource not available."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ResourceUnavailableRpcError"
                    })
                }
            }
            Object.defineProperty(re, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32002
            });
            class de extends ne {
                constructor(Te) {
                    super(Te, {
                        code: de.code,
                        shortMessage: "Transaction creation failed."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TransactionRejectedRpcError"
                    })
                }
            }
            Object.defineProperty(de, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32003
            });
            class Se extends ne {
                constructor(Te) {
                    super(Te, {
                        code: Se.code,
                        shortMessage: "Method is not implemented."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "MethodNotSupportedRpcError"
                    })
                }
            }
            Object.defineProperty(Se, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32004
            });
            class me extends ne {
                constructor(Te) {
                    super(Te, {
                        code: me.code,
                        shortMessage: "Request exceeds defined limit."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "LimitExceededRpcError"
                    })
                }
            }
            Object.defineProperty(me, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32005
            });
            class Ce extends ne {
                constructor(Te) {
                    super(Te, {
                        code: Ce.code,
                        shortMessage: "Version of JSON-RPC protocol is not supported."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "JsonRpcVersionUnsupportedError"
                    })
                }
            }
            Object.defineProperty(Ce, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -32006
            });
            class we extends S {
                constructor(Te) {
                    super(Te, {
                        code: we.code,
                        shortMessage: "User rejected the request."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "UserRejectedRequestError"
                    })
                }
            }
            Object.defineProperty(we, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4001
            });
            class ve extends S {
                constructor(Te) {
                    super(Te, {
                        code: ve.code,
                        shortMessage: "The requested method and/or account has not been authorized by the user."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "UnauthorizedProviderError"
                    })
                }
            }
            Object.defineProperty(ve, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4100
            });
            class De extends S {
                constructor(Te) {
                    super(Te, {
                        code: De.code,
                        shortMessage: "The Provider does not support the requested method."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "UnsupportedProviderMethodError"
                    })
                }
            }
            Object.defineProperty(De, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4200
            });
            class ae extends S {
                constructor(Te) {
                    super(Te, {
                        code: ae.code,
                        shortMessage: "The Provider is disconnected from all chains."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ProviderDisconnectedError"
                    })
                }
            }
            Object.defineProperty(ae, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4900
            });
            class Me extends S {
                constructor(Te) {
                    super(Te, {
                        code: Me.code,
                        shortMessage: "The Provider is not connected to the requested chain."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "ChainDisconnectedError"
                    })
                }
            }
            Object.defineProperty(Me, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4901
            });
            class Le extends S {
                constructor(Te) {
                    super(Te, {
                        code: Le.code,
                        shortMessage: "An error occurred when attempting to switch chain."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "SwitchChainError"
                    })
                }
            }
            Object.defineProperty(Le, "code", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 4902
            });
            class L extends ne {
                constructor(Te) {
                    super(Te, {
                        shortMessage: "An unknown RPC error occurred."
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "UnknownRpcError"
                    })
                }
            }
        },
        98284: (et, I, T) => {
            "use strict";
            T.d(I, {
                Bh: () => le,
                Yb: () => re,
                j3: () => C,
                mc: () => de,
                mk: () => Z,
                xY: () => S,
                xr: () => ne
            });
            var F = T(78004),
                K = T(79077),
                q = T(32618);

            function ne(Se) {
                const me = Object.entries(Se).map(([we, ve]) => void 0 === ve || !1 === ve ? null : [we, ve]).filter(Boolean),
                    Ce = me.reduce((we, [ve]) => Math.max(we, ve.length), 0);
                return me.map(([we, ve]) => `  ${`${we}:`.padEnd(Ce+1)}  ${ve}`).join("\n")
            }
            class S extends q.G {
                constructor() {
                    super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n")), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "FeeConflictError"
                    })
                }
            }
            class C extends q.G {
                constructor({
                    transaction: me
                }) {
                    super("Cannot infer a transaction type from provided transaction.", {
                        metaMessages: ["Provided Transaction:", "{", ne(me), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "InvalidSerializableTransactionError"
                    })
                }
            }
            class Z extends q.G {
                constructor(me, {
                    account: Ce,
                    docsPath: we,
                    chain: ve,
                    data: De,
                    gas: ae,
                    gasPrice: Me,
                    maxFeePerGas: Le,
                    maxPriorityFeePerGas: L,
                    nonce: ue,
                    to: Te,
                    value: xe
                }) {
                    const Ae = ne({
                        chain: ve && `${ve?.name} (id: ${ve?.id})`,
                        from: Ce ? .address,
                        to: Te,
                        value: typeof xe < "u" && `${(0,F.d)(xe)} ${ve?.nativeCurrency?.symbol||"ETH"}`,
                        data: De,
                        gas: ae,
                        gasPrice: typeof Me < "u" && `${(0,K.o)(Me)} gwei`,
                        maxFeePerGas: typeof Le < "u" && `${(0,K.o)(Le)} gwei`,
                        maxPriorityFeePerGas: typeof L < "u" && `${(0,K.o)(L)} gwei`,
                        nonce: ue
                    });
                    super(me.shortMessage, {
                        cause: me,
                        docsPath: we,
                        metaMessages: [...me.metaMessages ? [...me.metaMessages, " "] : [], "Request Arguments:", Ae].filter(Boolean)
                    }), Object.defineProperty(this, "cause", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: void 0
                    }), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TransactionExecutionError"
                    }), this.cause = me
                }
            }
            class le extends q.G {
                constructor({
                    blockHash: me,
                    blockNumber: Ce,
                    blockTag: we,
                    hash: ve,
                    index: De
                }) {
                    let ae = "Transaction";
                    we && void 0 !== De && (ae = `Transaction at block time "${we}" at index "${De}"`), me && void 0 !== De && (ae = `Transaction at block hash "${me}" at index "${De}"`), Ce && void 0 !== De && (ae = `Transaction at block number "${Ce}" at index "${De}"`), ve && (ae = `Transaction with hash "${ve}"`), super(`${ae} could not be found.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TransactionNotFoundError"
                    })
                }
            }
            class re extends q.G {
                constructor({
                    hash: me
                }) {
                    super(`Transaction receipt with hash "${me}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "TransactionReceiptNotFoundError"
                    })
                }
            }
            class de extends q.G {
                constructor({
                    hash: me
                }) {
                    super(`Timed out while waiting for transaction with hash "${me}" to be confirmed.`), Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: "WaitForTransactionReceiptTimeoutError"
                    })
                }
            }
        },
        41448: (et, I, T) => {
            "use strict";
            T.d(I, {
                CR: () => K,
                Gr: () => q,
                bo: () => ne
            });
            const K = S => S,
                q = S => S,
                ne = () => "viem@1.21.3"
        },
        75777: (et, I, T) => {
            "use strict";
            T.d(I, {
                r: () => z
            });
            var F = T(76577),
                K = T(46284),
                q = T(84018),
                ne = T(28544),
                S = T(70783),
                j = T(29415),
                C = T(62910);

            function z(ve, De) {
                if ("0x" === De && ve.length > 0) throw new F.wb;
                if ((0, q.d)(De) && (0, q.d)(De) < 32) throw new F.xB({
                    data: De,
                    params: ve,
                    size: (0, q.d)(De)
                });
                return function H({
                    data: ve,
                    params: De
                }) {
                    const ae = [];
                    let Me = 0;
                    for (let Le = 0; Le < De.length; Le++) {
                        if (Me >= (0, q.d)(ve)) throw new F.xB({
                            data: ve,
                            params: De,
                            size: (0, q.d)(ve)
                        });
                        const L = De[Le],
                            {
                                consumed: ue,
                                value: Te
                            } = Y({
                                data: ve,
                                param: L,
                                position: Me
                            });
                        ae.push(Te), Me += ue
                    }
                    return ae
                }({
                    data: De,
                    params: ve
                })
            }

            function Y({
                data: ve,
                param: De,
                position: ae
            }) {
                const Me = (0, C.S)(De.type);
                if (Me) {
                    const [L, ue] = Me;
                    return function le(ve, {
                        param: De,
                        length: ae,
                        position: Me
                    }) {
                        if (!ae) {
                            const ue = (0, j.ly)((0, ne.tP)(ve, Me, Me + 32, {
                                    strict: !0
                                })),
                                Te = (0, j.ly)((0, ne.tP)(ve, ue, ue + 32, {
                                    strict: !0
                                }));
                            let xe = 0;
                            const Ae = [];
                            for (let Ie = 0; Ie < Te; ++Ie) {
                                const $ = Y({
                                    data: (0, ne.tP)(ve, ue + 32),
                                    param: De,
                                    position: xe
                                });
                                xe += $.consumed, Ae.push($.value)
                            }
                            return {
                                value: Ae,
                                consumed: 32
                            }
                        }
                        if (we(De)) {
                            const Te = !(0, C.S)(De.type) ? .[0];
                            let xe = 0;
                            const Ae = [];
                            for (let Ie = 0; Ie < ae; ++Ie) {
                                const $ = (0, j.ly)((0, ne.tP)(ve, Me, Me + 32, {
                                        strict: !0
                                    })),
                                    f = Y({
                                        data: (0, ne.tP)(ve, $),
                                        param: De,
                                        position: Te ? xe : 32 * Ie
                                    });
                                xe += f.consumed, Ae.push(f.value)
                            }
                            return {
                                value: Ae,
                                consumed: 32
                            }
                        }
                        let Le = 0;
                        const L = [];
                        for (let ue = 0; ue < ae; ++ue) {
                            const Te = Y({
                                data: ve,
                                param: De,
                                position: Me + Le
                            });
                            Le += Te.consumed, L.push(Te.value)
                        }
                        return {
                            value: L,
                            consumed: Le
                        }
                    }(ve, {
                        length: L,
                        param: { ...De,
                            type: ue
                        },
                        position: ae
                    })
                }
                if ("tuple" === De.type) return function Ce(ve, {
                    param: De,
                    position: ae
                }) {
                    const Me = 0 === De.components.length || De.components.some(({
                            name: ue
                        }) => !ue),
                        Le = Me ? [] : {};
                    let L = 0;
                    if (we(De)) {
                        const ue = (0, j.ly)((0, ne.tP)(ve, ae, ae + 32, {
                            strict: !0
                        }));
                        for (let Te = 0; Te < De.components.length; ++Te) {
                            const xe = De.components[Te],
                                Ae = Y({
                                    data: (0, ne.tP)(ve, ue),
                                    param: xe,
                                    position: L
                                });
                            L += Ae.consumed, Le[Me ? Te : xe ? .name] = Ae.value
                        }
                        return {
                            consumed: 32,
                            value: Le
                        }
                    }
                    for (let ue = 0; ue < De.components.length; ++ue) {
                        const Te = De.components[ue],
                            xe = Y({
                                data: ve,
                                param: Te,
                                position: ae + L
                            });
                        L += xe.consumed, Le[Me ? ue : Te ? .name] = xe.value
                    }
                    return {
                        consumed: L,
                        value: Le
                    }
                }(ve, {
                    param: De,
                    position: ae
                });
                if ("string" === De.type) return function me(ve, {
                    position: De
                }) {
                    const ae = (0, j.ly)((0, ne.tP)(ve, De, De + 32, {
                            strict: !0
                        })),
                        Me = (0, j.ly)((0, ne.tP)(ve, ae, ae + 32, {
                            strict: !0
                        }));
                    return 0 === Me ? {
                        consumed: 32,
                        value: ""
                    } : {
                        consumed: 32,
                        value: (0, j.rR)((0, S.f)((0, ne.tP)(ve, ae + 32, ae + 32 + Me, {
                            strict: !0
                        })))
                    }
                }(ve, {
                    position: ae
                });
                if (De.type.startsWith("bytes")) return function de(ve, {
                    param: De,
                    position: ae
                }) {
                    const [Me, Le] = De.type.split("bytes");
                    if (!Le) {
                        const ue = (0, j.ly)((0, ne.tP)(ve, ae, ae + 32, {
                                strict: !0
                            })),
                            Te = (0, j.ly)((0, ne.tP)(ve, ue, ue + 32, {
                                strict: !0
                            }));
                        return 0 === Te ? {
                            consumed: 32,
                            value: "0x"
                        } : {
                            consumed: 32,
                            value: (0, ne.tP)(ve, ue + 32, ue + 32 + Te, {
                                strict: !0
                            })
                        }
                    }
                    return {
                        consumed: 32,
                        value: (0, ne.tP)(ve, ae, ae + parseInt(Le), {
                            strict: !0
                        })
                    }
                }(ve, {
                    param: De,
                    position: ae
                });
                const Le = (0, ne.tP)(ve, ae, ae + 32, {
                    strict: !0
                });
                if (De.type.startsWith("uint") || De.type.startsWith("int")) return function Se(ve, {
                    param: De
                }) {
                    const ae = De.type.startsWith("int");
                    return {
                        consumed: 32,
                        value: parseInt(De.type.split("int")[1] || "256") > 48 ? (0, j.y_)(ve, {
                            signed: ae
                        }) : (0, j.ly)(ve, {
                            signed: ae
                        })
                    }
                }(Le, {
                    param: De
                });
                if ("address" === De.type) return function Z(ve) {
                    return {
                        consumed: 32,
                        value: (0, K.x)((0, ne.tP)(ve, -20))
                    }
                }(Le);
                if ("bool" === De.type) return function re(ve) {
                    return {
                        consumed: 32,
                        value: (0, j.XA)(ve)
                    }
                }(Le);
                throw new F.CI(De.type, {
                    docsPath: "/docs/contract/decodeAbiParameters"
                })
            }

            function we(ve) {
                const {
                    type: De
                } = ve;
                if ("string" === De || "bytes" === De || De.endsWith("[]")) return !0;
                if ("tuple" === De) return ve.components ? .some(we);
                const ae = (0, C.S)(ve.type);
                return !(!ae || !we({ ...ve,
                    type: ae[1]
                }))
            }
        },
        41936: (et, I, T) => {
            "use strict";
            T.d(I, {
                p: () => C
            });
            var F = T(66848),
                K = T(76577),
                q = T(28544),
                ne = T(65360),
                S = T(75777),
                j = T(16537);

            function C({
                abi: z,
                data: H
            }) {
                const Y = (0, q.tP)(H, 0, 4);
                if ("0x" === Y) throw new K.wb;
                const le = [...z || [], F.Up, F.hZ].find(re => "error" === re.type && Y === (0, ne.o)((0, j.t)(re)));
                if (!le) throw new K.yP(Y, {
                    docsPath: "/docs/contract/decodeErrorResult"
                });
                return {
                    abiItem: le,
                    args: "inputs" in le && le.inputs && le.inputs.length > 0 ? (0, S.r)(le.inputs, (0, q.tP)(H, 4)) : void 0,
                    errorName: le.name
                }
            }
        },
        54963: (et, I, T) => {
            "use strict";
            T.d(I, {
                k: () => S
            });
            var F = T(76577),
                K = T(75777),
                q = T(30930);
            const ne = "/docs/contract/decodeFunctionResult";

            function S({
                abi: j,
                args: C,
                functionName: z,
                data: H
            }) {
                let Y = j[0];
                if (z && (Y = (0, q.mE)({
                        abi: j,
                        args: C,
                        name: z
                    }), !Y)) throw new F.xL(z, {
                    docsPath: ne
                });
                if ("function" !== Y.type) throw new F.xL(void 0, {
                    docsPath: ne
                });
                if (!Y.outputs) throw new F.MX(Y.name, {
                    docsPath: ne
                });
                const Z = (0, K.r)(Y.outputs, H);
                return Z && Z.length > 1 ? Z : Z && 1 === Z.length ? Z[0] : void 0
            }
        },
        62910: (et, I, T) => {
            "use strict";
            T.d(I, {
                E: () => H,
                S: () => De
            });
            var F = T(76577),
                K = T(78355),
                q = T(32099),
                ne = T(80770),
                S = T(31587),
                j = T(84018),
                C = T(28544),
                z = T(74439);

            function H(ae, Me) {
                if (ae.length !== Me.length) throw new F.fs({
                    expectedLength: ae.length,
                    givenLength: Me.length
                });
                const Le = function Y({
                        params: ae,
                        values: Me
                    }) {
                        const Le = [];
                        for (let L = 0; L < ae.length; L++) Le.push(Z({
                            param: ae[L],
                            value: Me[L]
                        }));
                        return Le
                    }({
                        params: ae,
                        values: Me
                    }),
                    L = le(Le);
                return 0 === L.length ? "0x" : L
            }

            function Z({
                param: ae,
                value: Me
            }) {
                const Le = De(ae.type);
                if (Le) {
                    const [L, ue] = Le;
                    return function de(ae, {
                        length: Me,
                        param: Le
                    }) {
                        const L = null === Me;
                        if (!Array.isArray(ae)) throw new F.hn(ae);
                        if (!L && ae.length !== Me) throw new F.gr({
                            expectedLength: Me,
                            givenLength: ae.length,
                            type: `${Le.type}[${Me}]`
                        });
                        let ue = !1;
                        const Te = [];
                        for (let xe = 0; xe < ae.length; xe++) {
                            const Ae = Z({
                                param: Le,
                                value: ae[xe]
                            });
                            Ae.dynamic && (ue = !0), Te.push(Ae)
                        }
                        if (L || ue) {
                            const xe = le(Te);
                            if (L) {
                                const Ae = (0, z.eC)(Te.length, {
                                    size: 32
                                });
                                return {
                                    dynamic: !0,
                                    encoded: Te.length > 0 ? (0, ne.zo)([Ae, xe]) : Ae
                                }
                            }
                            if (ue) return {
                                dynamic: !0,
                                encoded: xe
                            }
                        }
                        return {
                            dynamic: !1,
                            encoded: (0, ne.zo)(Te.map(({
                                encoded: xe
                            }) => xe))
                        }
                    }(Me, {
                        length: L,
                        param: { ...ae,
                            type: ue
                        }
                    })
                }
                if ("tuple" === ae.type) return function ve(ae, {
                    param: Me
                }) {
                    let Le = !1;
                    const L = [];
                    for (let ue = 0; ue < Me.components.length; ue++) {
                        const Te = Me.components[ue],
                            Ae = Z({
                                param: Te,
                                value: ae[Array.isArray(ae) ? ue : Te.name]
                            });
                        L.push(Ae), Ae.dynamic && (Le = !0)
                    }
                    return {
                        dynamic: Le,
                        encoded: Le ? le(L) : (0, ne.zo)(L.map(({
                            encoded: ue
                        }) => ue))
                    }
                }(Me, {
                    param: ae
                });
                if ("address" === ae.type) return function re(ae) {
                    if (!(0, q.U)(ae)) throw new K.b({
                        address: ae
                    });
                    return {
                        dynamic: !1,
                        encoded: (0, S.gc)(ae.toLowerCase())
                    }
                }(Me);
                if ("bool" === ae.type) return function me(ae) {
                    return {
                        dynamic: !1,
                        encoded: (0, S.gc)((0, z.C4)(ae))
                    }
                }(Me);
                if (ae.type.startsWith("uint") || ae.type.startsWith("int")) return function Ce(ae, {
                    signed: Me
                }) {
                    return {
                        dynamic: !1,
                        encoded: (0, z.eC)(ae, {
                            size: 32,
                            signed: Me
                        })
                    }
                }(Me, {
                    signed: ae.type.startsWith("int")
                });
                if (ae.type.startsWith("bytes")) return function Se(ae, {
                    param: Me
                }) {
                    const [, Le] = Me.type.split("bytes"), L = (0, j.d)(ae);
                    if (!Le) {
                        let ue = ae;
                        return L % 32 != 0 && (ue = (0, S.gc)(ue, {
                            dir: "right",
                            size: 32 * Math.ceil((ae.length - 2) / 2 / 32)
                        })), {
                            dynamic: !0,
                            encoded: (0, ne.zo)([(0, S.gc)((0, z.eC)(L, {
                                size: 32
                            })), ue])
                        }
                    }
                    if (L !== parseInt(Le)) throw new F.M4({
                        expectedSize: parseInt(Le),
                        value: ae
                    });
                    return {
                        dynamic: !1,
                        encoded: (0, S.gc)(ae, {
                            dir: "right"
                        })
                    }
                }(Me, {
                    param: ae
                });
                if ("string" === ae.type) return function we(ae) {
                    const Me = (0, z.$G)(ae),
                        Le = Math.ceil((0, j.d)(Me) / 32),
                        L = [];
                    for (let ue = 0; ue < Le; ue++) L.push((0, S.gc)((0, C.tP)(Me, 32 * ue, 32 * (ue + 1)), {
                        dir: "right"
                    }));
                    return {
                        dynamic: !0,
                        encoded: (0, ne.zo)([(0, S.gc)((0, z.eC)((0, j.d)(Me), {
                            size: 32
                        })), ...L])
                    }
                }(Me);
                throw new F.dh(ae.type, {
                    docsPath: "/docs/contract/encodeAbiParameters"
                })
            }

            function le(ae) {
                let Me = 0;
                for (let Te = 0; Te < ae.length; Te++) {
                    const {
                        dynamic: xe,
                        encoded: Ae
                    } = ae[Te];
                    Me += xe ? 32 : (0, j.d)(Ae)
                }
                const Le = [],
                    L = [];
                let ue = 0;
                for (let Te = 0; Te < ae.length; Te++) {
                    const {
                        dynamic: xe,
                        encoded: Ae
                    } = ae[Te];
                    xe ? (Le.push((0, z.eC)(Me + ue, {
                        size: 32
                    })), L.push(Ae), ue += (0, j.d)(Ae)) : Le.push(Ae)
                }
                return (0, ne.zo)([...Le, ...L])
            }

            function De(ae) {
                const Me = ae.match(/^(.*)\[(\d+)?\]$/);
                return Me ? [Me[2] ? Number(Me[2]) : null, Me[1]] : void 0
            }
        },
        32490: (et, I, T) => {
            "use strict";
            T.d(I, {
                R: () => C
            });
            var F = T(76577),
                K = T(80770),
                q = T(65360),
                ne = T(62910),
                S = T(16537),
                j = T(30930);

            function C({
                abi: z,
                args: H,
                functionName: Y
            }) {
                let Z = z[0];
                if (Y && (Z = (0, j.mE)({
                        abi: z,
                        args: H,
                        name: Y
                    }), !Z)) throw new F.xL(Y, {
                    docsPath: "/docs/contract/encodeFunctionData"
                });
                if ("function" !== Z.type) throw new F.xL(void 0, {
                    docsPath: "/docs/contract/encodeFunctionData"
                });
                const le = (0, S.t)(Z),
                    re = (0, q.o)(le),
                    de = "inputs" in Z && Z.inputs ? (0, ne.E)(Z.inputs, H ? ? []) : void 0;
                return (0, K.SM)([re, de ? ? "0x"])
            }
        },
        16537: (et, I, T) => {
            "use strict";
            T.d(I, {
                h: () => q,
                t: () => K
            });
            var F = T(76577);

            function K(S, {
                includeName: j = !1
            } = {}) {
                if ("function" !== S.type && "event" !== S.type && "error" !== S.type) throw new F.wM(S.type);
                return `${S.name}(${q(S.inputs,{includeName:j})})`
            }

            function q(S, {
                includeName: j = !1
            } = {}) {
                return S ? S.map(C => function ne(S, {
                    includeName: j
                }) {
                    return S.type.startsWith("tuple") ? `(${q(S.components,{includeName:j})})${S.type.slice(5)}` : S.type + (j && S.name ? ` ${S.name}` : "")
                }(C, {
                    includeName: j
                })).join(j ? ", " : ",") : ""
            }
        },
        30930: (et, I, T) => {
            "use strict";
            T.d(I, {
                mE: () => j
            });
            var F = T(76577),
                K = T(37812),
                q = T(77467),
                ne = T(65360),
                S = T(32099);

            function j({
                abi: H,
                args: Y = [],
                name: Z
            }) {
                const le = (0, K.v)(Z, {
                        strict: !1
                    }),
                    re = H.filter(Se => le ? "function" === Se.type ? (0, ne.o)(Se) === Z : "event" === Se.type && (0, q.e)(Se) === Z : "name" in Se && Se.name === Z);
                if (0 === re.length) return;
                if (1 === re.length) return re[0];
                let de;
                for (const Se of re)
                    if ("inputs" in Se)
                        if (Y && 0 !== Y.length) {
                            if (Se.inputs && 0 !== Se.inputs.length && Se.inputs.length === Y.length && Y.every((Ce, we) => {
                                    const ve = "inputs" in Se && Se.inputs[we];
                                    return !!ve && C(Ce, ve)
                                })) {
                                if (de && "inputs" in de && de.inputs) {
                                    const Ce = z(Se.inputs, de.inputs, Y);
                                    if (Ce) throw new F.S4({
                                        abiItem: Se,
                                        type: Ce[0]
                                    }, {
                                        abiItem: de,
                                        type: Ce[1]
                                    })
                                }
                                de = Se
                            }
                        } else if (!Se.inputs || 0 === Se.inputs.length) return Se;
                return de || re[0]
            }

            function C(H, Y) {
                const Z = typeof H,
                    le = Y.type;
                switch (le) {
                    case "address":
                        return (0, S.U)(H);
                    case "bool":
                        return "boolean" === Z;
                    case "function":
                    case "string":
                        return "string" === Z;
                    default:
                        return "tuple" === le && "components" in Y ? Object.values(Y.components).every((re, de) => C(Object.values(H)[de], re)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(le) ? "number" === Z || "bigint" === Z : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(le) ? "string" === Z || H instanceof Uint8Array : !!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(le) && Array.isArray(H) && H.every(re => C(re, { ...Y,
                            type: le.replace(/(\[[0-9]{0,}\])$/, "")
                        }))
                }
            }

            function z(H, Y, Z) {
                for (const le in H) {
                    const re = H[le],
                        de = Y[le];
                    if ("tuple" === re.type && "tuple" === de.type && "components" in re && "components" in de) return z(re.components, de.components, Z[le]);
                    const Se = [re.type, de.type];
                    if (Se.includes("address") && Se.includes("bytes20") || (Se.includes("address") && Se.includes("string") || Se.includes("address") && Se.includes("bytes")) && (0, S.U)(Z[le])) return Se
                }
            }
        },
        46284: (et, I, T) => {
            "use strict";
            T.d(I, {
                K: () => j,
                x: () => S
            });
            var F = T(78355),
                K = T(9427),
                q = T(71201),
                ne = T(32099);

            function S(C, z) {
                const H = z ? `${z}${C.toLowerCase()}` : C.substring(2).toLowerCase(),
                    Y = (0, q.w)((0, K.qX)(H), "bytes"),
                    Z = (z ? H.substring(`${z}0x`.length) : H).split("");
                for (let le = 0; le < 40; le += 2) Y[le >> 1] >> 4 >= 8 && Z[le] && (Z[le] = Z[le].toUpperCase()), (15 & Y[le >> 1]) >= 8 && Z[le + 1] && (Z[le + 1] = Z[le + 1].toUpperCase());
                return `0x${Z.join("")}`
            }

            function j(C, z) {
                if (!(0, ne.U)(C)) throw new F.b({
                    address: C
                });
                return S(C, z)
            }
        },
        32099: (et, I, T) => {
            "use strict";
            T.d(I, {
                U: () => K
            });
            const F = /^0x[a-fA-F0-9]{40}$/;

            function K(q) {
                return F.test(q)
            }
        },
        91849: (et, I, T) => {
            "use strict";
            T.d(I, {
                L: () => K
            });
            var F = T(8722);

            function K({
                blockNumber: q,
                chain: ne,
                contract: S
            }) {
                const j = ne ? .contracts ? .[S];
                if (!j) throw new F.mm({
                    chain: ne,
                    contract: {
                        name: S
                    }
                });
                if (q && j.blockCreated && j.blockCreated > q) throw new F.mm({
                    blockNumber: q,
                    chain: ne,
                    contract: {
                        name: S,
                        blockCreated: j.blockCreated
                    }
                });
                return j.address
            }
        },
        80770: (et, I, T) => {
            "use strict";

            function F(ne) {
                return "string" == typeof ne[0] ? q(ne) : function K(ne) {
                    let S = 0;
                    for (const z of ne) S += z.length;
                    const j = new Uint8Array(S);
                    let C = 0;
                    for (const z of ne) j.set(z, C), C += z.length;
                    return j
                }(ne)
            }

            function q(ne) {
                return `0x${ne.reduce((S,j)=>S+j.replace("0x",""),"")}`
            }
            T.d(I, {
                SM: () => q,
                zo: () => F
            })
        },
        37812: (et, I, T) => {
            "use strict";

            function F(K, {
                strict: q = !0
            } = {}) {
                return !(!K || "string" != typeof K) && (q ? /^0x[0-9a-fA-F]*$/.test(K) : K.startsWith("0x"))
            }
            T.d(I, {
                v: () => F
            })
        },
        31587: (et, I, T) => {
            "use strict";
            T.d(I, {
                gc: () => q,
                vk: () => K
            });
            var F = T(76893);

            function K(S, {
                dir: j,
                size: C = 32
            } = {}) {
                return "string" == typeof S ? q(S, {
                    dir: j,
                    size: C
                }) : function ne(S, {
                    dir: j,
                    size: C = 32
                } = {}) {
                    if (null === C) return S;
                    if (S.length > C) throw new F.$({
                        size: S.length,
                        targetSize: C,
                        type: "bytes"
                    });
                    const z = new Uint8Array(C);
                    for (let H = 0; H < C; H++) {
                        const Y = "right" === j;
                        z[Y ? H : C - H - 1] = S[Y ? H : S.length - H - 1]
                    }
                    return z
                }(S, {
                    dir: j,
                    size: C
                })
            }

            function q(S, {
                dir: j,
                size: C = 32
            } = {}) {
                if (null === C) return S;
                const z = S.replace("0x", "");
                if (z.length > 2 * C) throw new F.$({
                    size: Math.ceil(z.length / 2),
                    targetSize: C,
                    type: "hex"
                });
                return `0x${z["right"===j?"padEnd":"padStart"](2*C,"0")}`
            }
        },
        84018: (et, I, T) => {
            "use strict";
            T.d(I, {
                d: () => K
            });
            var F = T(37812);

            function K(q) {
                return (0, F.v)(q, {
                    strict: !1
                }) ? Math.ceil((q.length - 2) / 2) : q.length
            }
        },
        28544: (et, I, T) => {
            "use strict";
            T.d(I, {
                tP: () => ne
            });
            var F = T(76893),
                K = T(37812),
                q = T(84018);

            function ne(H, Y, Z, {
                strict: le
            } = {}) {
                return (0, K.v)(H, {
                    strict: !1
                }) ? function z(H, Y, Z, {
                    strict: le
                } = {}) {
                    S(H, Y);
                    const re = `0x${H.replace("0x","").slice(2*(Y??0),2*(Z??H.length))}`;
                    return le && j(re, Y, Z), re
                }(H, Y, Z, {
                    strict: le
                }) : function C(H, Y, Z, {
                    strict: le
                } = {}) {
                    S(H, Y);
                    const re = H.slice(Y, Z);
                    return le && j(re, Y, Z), re
                }(H, Y, Z, {
                    strict: le
                })
            }

            function S(H, Y) {
                if ("number" == typeof Y && Y > 0 && Y > (0, q.d)(H) - 1) throw new F.m({
                    offset: Y,
                    position: "start",
                    size: (0, q.d)(H)
                })
            }

            function j(H, Y, Z) {
                if ("number" == typeof Y && "number" == typeof Z && (0, q.d)(H) !== Z - Y) throw new F.m({
                    offset: Z,
                    position: "end",
                    size: (0, q.d)(H)
                })
            }
        },
        70783: (et, I, T) => {
            "use strict";

            function F(K, {
                dir: q = "left"
            } = {}) {
                let ne = "string" == typeof K ? K.replace("0x", "") : K,
                    S = 0;
                for (let j = 0; j < ne.length - 1 && "0" === ne["left" === q ? j : ne.length - j - 1].toString(); j++) S++;
                return ne = "left" === q ? ne.slice(S) : ne.slice(0, ne.length - S), "string" == typeof K ? (1 === ne.length && "right" === q && (ne = `${ne}0`), `0x${ne.length%2==1?`0${ne}`:ne}`) : ne
            }
            T.d(I, {
                f: () => F
            })
        },
        29415: (et, I, T) => {
            "use strict";
            T.d(I, {
                XA: () => z,
                Yf: () => S,
                ly: () => H,
                rR: () => Y,
                y_: () => C
            });
            var F = T(78866),
                K = T(84018),
                q = T(70783),
                ne = T(9427);

            function S(Z, {
                size: le
            }) {
                if ((0, K.d)(Z) > le) throw new F.M6({
                    givenSize: (0, K.d)(Z),
                    maxSize: le
                })
            }

            function C(Z, le = {}) {
                const {
                    signed: re
                } = le;
                le.size && S(Z, {
                    size: le.size
                });
                const de = BigInt(Z);
                if (!re) return de;
                const Se = (Z.length - 2) / 2;
                return de <= (1 n << 8 n * BigInt(Se) - 1 n) - 1 n ? de : de - BigInt(`0x${"f".padStart(2*Se,"f")}`) - 1 n
            }

            function z(Z, le = {}) {
                let re = Z;
                if (le.size && (S(re, {
                        size: le.size
                    }), re = (0, q.f)(re)), "0x00" === (0, q.f)(re)) return !1;
                if ("0x01" === (0, q.f)(re)) return !0;
                throw new F.Cd(re)
            }

            function H(Z, le = {}) {
                return Number(C(Z, le))
            }

            function Y(Z, le = {}) {
                let re = (0, ne.nr)(Z);
                return le.size && (S(re, {
                    size: le.size
                }), re = (0, q.f)(re, {
                    dir: "right"
                })), (new TextDecoder).decode(re)
            }
        },
        9427: (et, I, T) => {
            "use strict";
            T.d(I, {
                O0: () => C,
                nr: () => Z,
                qX: () => re
            });
            var F = T(32618),
                K = T(37812),
                q = T(31587),
                ne = T(29415),
                S = T(74439);
            const j = new TextEncoder;

            function C(de, Se = {}) {
                return "number" == typeof de || "bigint" == typeof de ? function le(de, Se) {
                    return Z((0, S.eC)(de, Se))
                }(de, Se) : "boolean" == typeof de ? function z(de, Se = {}) {
                    const me = new Uint8Array(1);
                    return me[0] = Number(de), "number" == typeof Se.size ? ((0, ne.Yf)(me, {
                        size: Se.size
                    }), (0, q.vk)(me, {
                        size: Se.size
                    })) : me
                }(de, Se) : (0, K.v)(de) ? Z(de, Se) : re(de, Se)
            }
            const H = {
                zero: 48,
                nine: 57,
                A: 65,
                F: 70,
                a: 97,
                f: 102
            };

            function Y(de) {
                return de >= H.zero && de <= H.nine ? de - H.zero : de >= H.A && de <= H.F ? de - (H.A - 10) : de >= H.a && de <= H.f ? de - (H.a - 10) : void 0
            }

            function Z(de, Se = {}) {
                let me = de;
                Se.size && ((0, ne.Yf)(me, {
                    size: Se.size
                }), me = (0, q.vk)(me, {
                    dir: "right",
                    size: Se.size
                }));
                let Ce = me.slice(2);
                Ce.length % 2 && (Ce = `0${Ce}`);
                const we = Ce.length / 2,
                    ve = new Uint8Array(we);
                for (let De = 0, ae = 0; De < we; De++) {
                    const Me = Y(Ce.charCodeAt(ae++)),
                        Le = Y(Ce.charCodeAt(ae++));
                    if (void 0 === Me || void 0 === Le) throw new F.G(`Invalid byte sequence ("${Ce[ae-2]}${Ce[ae-1]}" in "${Ce}").`);
                    ve[De] = 16 * Me + Le
                }
                return ve
            }

            function re(de, Se = {}) {
                const me = j.encode(de);
                return "number" == typeof Se.size ? ((0, ne.Yf)(me, {
                    size: Se.size
                }), (0, q.vk)(me, {
                    dir: "right",
                    size: Se.size
                })) : me
            }
        },
        74439: (et, I, T) => {
            "use strict";
            T.d(I, {
                $G: () => Y,
                C4: () => j,
                NC: () => S,
                ci: () => C,
                eC: () => z
            });
            var F = T(78866),
                K = T(31587),
                q = T(29415);
            const ne = Array.from({
                length: 256
            }, (Z, le) => le.toString(16).padStart(2, "0"));

            function S(Z, le = {}) {
                return "number" == typeof Z || "bigint" == typeof Z ? z(Z, le) : "string" == typeof Z ? Y(Z, le) : "boolean" == typeof Z ? j(Z, le) : C(Z, le)
            }

            function j(Z, le = {}) {
                const re = `0x${Number(Z)}`;
                return "number" == typeof le.size ? ((0, q.Yf)(re, {
                    size: le.size
                }), (0, K.vk)(re, {
                    size: le.size
                })) : re
            }

            function C(Z, le = {}) {
                let re = "";
                for (let Se = 0; Se < Z.length; Se++) re += ne[Z[Se]];
                const de = `0x${re}`;
                return "number" == typeof le.size ? ((0, q.Yf)(de, {
                    size: le.size
                }), (0, K.vk)(de, {
                    dir: "right",
                    size: le.size
                })) : de
            }

            function z(Z, le = {}) {
                const {
                    signed: re,
                    size: de
                } = le, Se = BigInt(Z);
                let me;
                de ? me = re ? (1 n << 8 n * BigInt(de) - 1 n) - 1 n : 2 n ** (8 n * BigInt(de)) - 1 n : "number" == typeof Z && (me = BigInt(Number.MAX_SAFE_INTEGER));
                const Ce = "bigint" == typeof me && re ? -me - 1 n : 0;
                if (me && Se > me || Se < Ce) {
                    const ve = "bigint" == typeof Z ? "n" : "";
                    throw new F.J5({
                        max: me ? `${me}${ve}` : void 0,
                        min: `${Ce}${ve}`,
                        signed: re,
                        size: de,
                        value: `${Z}${ve}`
                    })
                }
                const we = `0x${(re&&Se<0?(1n<<BigInt(8*de))+BigInt(Se):Se).toString(16)}`;
                return de ? (0, K.vk)(we, {
                    size: de
                }) : we
            }
            const H = new TextEncoder;

            function Y(Z, le = {}) {
                return C(H.encode(Z), le)
            }
        },
        19766: (et, I, T) => {
            "use strict";
            T.d(I, {
                i: () => K
            });
            var F = T(37812);

            function K(q) {
                if (66 !== q.length || 0 !== q.indexOf("[") || 65 !== q.indexOf("]")) return null;
                const ne = `0x${q.slice(1,65)}`;
                return (0, F.v)(ne) ? ne : null
            }
        },
        5276: (et, I, T) => {
            "use strict";
            T.d(I, {
                c: () => ne
            });
            var F = T(66848),
                K = T(32618),
                q = T(28169);

            function ne(S, j) {
                if (!(S instanceof K.G)) return !1;
                const C = S.walk(z => z instanceof q.Lu);
                return C instanceof q.Lu && !!("ResolverNotFound" === C.data ? .errorName || "ResolverWildcardNotSupported" === C.data ? .errorName || C.reason ? .includes("Wildcard on non-extended resolvers is not supported") || "reverse" === j && C.reason === F.$[50])
            }
        },
        81435: (et, I, T) => {
            "use strict";
            T.d(I, {
                d: () => S
            });
            var F = T(9427),
                K = T(74439),
                q = T(71201),
                ne = T(19766);

            function S(j) {
                const C = new Uint8Array(32).fill(0);
                return j ? (0, ne.i)(j) || (0, q.w)((0, F.qX)(j)) : (0, K.ci)(C)
            }
        },
        68821: (et, I, T) => {
            "use strict";
            T.d(I, {
                V: () => j
            });
            var F = T(80770),
                K = T(9427),
                q = T(74439),
                ne = T(71201),
                S = T(19766);

            function j(C) {
                let z = new Uint8Array(32).fill(0);
                if (!C) return (0, q.ci)(z);
                const H = C.split(".");
                for (let Y = H.length - 1; Y >= 0; Y -= 1) {
                    const Z = (0, S.i)(H[Y]),
                        le = Z ? (0, K.O0)(Z) : (0, ne.w)((0, K.qX)(H[Y]), "bytes");
                    z = (0, ne.w)((0, F.zo)([z, le]), "bytes")
                }
                return (0, q.ci)(z)
            }
        },
        92897: (et, I, T) => {
            "use strict";
            T.d(I, {
                T: () => ne
            });
            var F = T(9427);

            function K(S) {
                return `[${S.slice(2)}]`
            }
            var q = T(81435);

            function ne(S) {
                const j = S.replace(/^\.|\.$/gm, "");
                if (0 === j.length) return new Uint8Array(1);
                const C = new Uint8Array((0, F.qX)(j).byteLength + 2);
                let z = 0;
                const H = j.split(".");
                for (let Y = 0; Y < H.length; Y++) {
                    let Z = (0, F.qX)(H[Y]);
                    Z.byteLength > 255 && (Z = (0, F.qX)(K((0, q.d)(H[Y])))), C[z] = Z.length, C.set(Z, z + 1), z += Z.length + 1
                }
                return C.byteLength !== z + 1 ? C.slice(0, z + 1) : C
            }
        },
        50660: (et, I, T) => {
            "use strict";
            T.d(I, {
                S: () => j
            });
            var F = T(76577),
                K = T(32618),
                q = T(28169),
                ne = T(59450);
            const S = 3;

            function j(C, {
                abi: z,
                address: H,
                args: Y,
                docsPath: Z,
                functionName: le,
                sender: re
            }) {
                const {
                    code: de,
                    data: Se,
                    message: me,
                    shortMessage: Ce
                } = C instanceof q.VQ ? C : C instanceof K.G ? C.walk(ve => "data" in ve) || C.walk() : {}, we = C instanceof F.wb ? new q.Dk({
                    functionName: le
                }) : [S, ne.XS.code].includes(de) && (Se || me || Ce) ? new q.Lu({
                    abi: z,
                    data: "object" == typeof Se ? Se.data : Se,
                    functionName: le,
                    message: Ce ? ? me
                }) : C;
                return new q.uq(we, {
                    abi: z,
                    args: Y,
                    contractAddress: H,
                    docsPath: Z,
                    functionName: le,
                    sender: re
                })
            }
        },
        92917: (et, I, T) => {
            "use strict";
            T.d(I, {
                k: () => ne
            });
            var F = T(32618),
                K = T(17354);

            function ne(S, j) {
                const C = (S.details || "").toLowerCase(),
                    z = S.walk(H => H.code === K.M_.code);
                return z instanceof F.G ? new K.M_({
                    cause: S,
                    message: z.details
                }) : K.M_.nodeMessage.test(C) ? new K.M_({
                    cause: S,
                    message: S.details
                }) : K.Hh.nodeMessage.test(C) ? new K.Hh({
                    cause: S,
                    maxFeePerGas: j ? .maxFeePerGas
                }) : K.G$.nodeMessage.test(C) ? new K.G$({
                    cause: S,
                    maxFeePerGas: j ? .maxFeePerGas
                }) : K.ZI.nodeMessage.test(C) ? new K.ZI({
                    cause: S,
                    nonce: j ? .nonce
                }) : K.vU.nodeMessage.test(C) ? new K.vU({
                    cause: S,
                    nonce: j ? .nonce
                }) : K.se.nodeMessage.test(C) ? new K.se({
                    cause: S,
                    nonce: j ? .nonce
                }) : K.C_.nodeMessage.test(C) ? new K.C_({
                    cause: S
                }) : K.WF.nodeMessage.test(C) ? new K.WF({
                    cause: S,
                    gas: j ? .gas
                }) : K.dR.nodeMessage.test(C) ? new K.dR({
                    cause: S,
                    gas: j ? .gas
                }) : K.pZ.nodeMessage.test(C) ? new K.pZ({
                    cause: S
                }) : K.cs.nodeMessage.test(C) ? new K.cs({
                    cause: S,
                    maxFeePerGas: j ? .maxFeePerGas,
                    maxPriorityFeePerGas: j ? .maxPriorityFeePerGas
                }) : new K.cj({
                    cause: S
                })
            }
        },
        77603: (et, I, T) => {
            "use strict";

            function F(K, {
                format: q
            }) {
                if (!q) return {};
                const ne = {};
                return function S(C) {
                    const z = Object.keys(C);
                    for (const H of z) H in K && (ne[H] = K[H]), C[H] && "object" == typeof C[H] && !Array.isArray(C[H]) && S(C[H])
                }(q(K || {})), ne
            }
            T.d(I, {
                K: () => F
            })
        },
        67369: (et, I, T) => {
            "use strict";
            T.d(I, {
                tG: () => q
            });
            var F = T(74439);
            const K = {
                legacy: "0x0",
                eip2930: "0x1",
                eip1559: "0x2"
            };

            function q(S) {
                return { ...S,
                    gas: typeof S.gas < "u" ? (0, F.eC)(S.gas) : void 0,
                    gasPrice: typeof S.gasPrice < "u" ? (0, F.eC)(S.gasPrice) : void 0,
                    maxFeePerGas: typeof S.maxFeePerGas < "u" ? (0, F.eC)(S.maxFeePerGas) : void 0,
                    maxPriorityFeePerGas: typeof S.maxPriorityFeePerGas < "u" ? (0, F.eC)(S.maxPriorityFeePerGas) : void 0,
                    nonce: typeof S.nonce < "u" ? (0, F.eC)(S.nonce) : void 0,
                    type: typeof S.type < "u" ? K[S.type] : void 0,
                    value: typeof S.value < "u" ? (0, F.eC)(S.value) : void 0
                }
            }
        },
        14637: (et, I, T) => {
            "use strict";

            function F(K, q, ne) {
                return S => K[q.name || ne] ? .(S) ? ? q(K, S)
            }
            T.d(I, {
                s: () => F
            })
        },
        77467: (et, I, T) => {
            "use strict";
            T.d(I, {
                e: () => j
            });
            var F = T(9427),
                K = T(88045),
                ne = T(71201);
            const j = C => (C => (0, ne.w)((0, F.O0)(C)))((C => (0, K.r)(C))(C))
        },
        65360: (et, I, T) => {
            "use strict";
            T.d(I, {
                o: () => j
            });
            var F = T(28544),
                K = T(9427),
                q = T(88045),
                ne = T(71201);
            const j = C => (0, F.tP)((C => (0, ne.w)((0, K.O0)(C)))((0, q.r)(C)), 0, 4)
        },
        88045: (et, I, T) => {
            "use strict";
            T.d(I, {
                r: () => Z
            });
            const S = /^tuple(?<array>(\[(\d*)\])*)$/;

            function j(le) {
                let re = le.type;
                if (S.test(le.type) && "components" in le) {
                    re = "(";
                    const de = le.components.length;
                    for (let me = 0; me < de; me++) re += j(le.components[me]), me < de - 1 && (re += ", ");
                    const Se = function F(le, re) {
                        return le.exec(re) ? .groups
                    }(S, le.type);
                    return re += `)${Se?.array??""}`, j({ ...le,
                        type: re
                    })
                }
                return "indexed" in le && le.indexed && (re = `${re} indexed`), le.name ? `${re} ${le.name}` : re
            }

            function C(le) {
                let re = "";
                const de = le.length;
                for (let Se = 0; Se < de; Se++) re += j(le[Se]), Se !== de - 1 && (re += ", ");
                return re
            }
            var H = T(32618);
            const Z = le => {
                const re = "string" == typeof le ? le : function z(le) {
                    return "function" === le.type ? `function ${le.name}(${C(le.inputs)})${le.stateMutability&&"nonpayable"!==le.stateMutability?` ${le.stateMutability}`:""}${le.outputs.length?` returns (${C(le.outputs)})`:""}` : "event" === le.type ? `event ${le.name}(${C(le.inputs)})` : "error" === le.type ? `error ${le.name}(${C(le.inputs)})` : "constructor" === le.type ? `constructor(${C(le.inputs)})${"payable"===le.stateMutability?" payable":""}` : "fallback" === le.type ? "fallback()" : "receive() external payable"
                }(le);
                return function Y(le) {
                    let re = !0,
                        de = "",
                        Se = 0,
                        me = "",
                        Ce = !1;
                    for (let we = 0; we < le.length; we++) {
                        const ve = le[we];
                        if (["(", ")", ","].includes(ve) && (re = !0), "(" === ve && Se++, ")" === ve && Se--, re) {
                            if (0 === Se) {
                                if (" " === ve && ["event", "function", ""].includes(me)) me = "";
                                else if (me += ve, ")" === ve) {
                                    Ce = !0;
                                    break
                                }
                                continue
                            }
                            if (" " === ve) {
                                "," !== le[we - 1] && "," !== de && ",(" !== de && (de = "", re = !1);
                                continue
                            }
                            me += ve, de += ve
                        }
                    }
                    if (!Ce) throw new H.G("Unable to normalize signature.");
                    return me
                }(re)
            }
        },
        71201: (et, I, T) => {
            "use strict";

            function F(Ve) {
                if (!Number.isSafeInteger(Ve) || Ve < 0) throw new Error(`Wrong positive integer: ${Ve}`)
            }

            function q(Ve, ...at) {
                if (!(Ve instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                if (at.length > 0 && !at.includes(Ve.length)) throw new Error(`Expected Uint8Array of length ${at}, not of length=${Ve.length}`)
            }

            function S(Ve, at = !0) {
                if (Ve.destroyed) throw new Error("Hash instance has been destroyed");
                if (at && Ve.finished) throw new Error("Hash#digest() has already been called")
            }
            T.d(I, {
                w: () => qn
            });
            const H = BigInt(2 ** 32 - 1),
                Y = BigInt(32);

            function Z(Ve, at = !1) {
                return at ? {
                    h: Number(Ve & H),
                    l: Number(Ve >> Y & H)
                } : {
                    h: 0 | Number(Ve >> Y & H),
                    l: 0 | Number(Ve & H)
                }
            }

            function le(Ve, at = !1) {
                let pt = new Uint32Array(Ve.length),
                    St = new Uint32Array(Ve.length);
                for (let Bn = 0; Bn < Ve.length; Bn++) {
                    const {
                        h: Nn,
                        l: Ut
                    } = Z(Ve[Bn], at);
                    [pt[Bn], St[Bn]] = [Nn, Ut]
                }
                return [pt, St]
            }
            if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");

            function Mt(Ve) {
                if ("string" == typeof Ve && (Ve = function Vt(Ve) {
                        if ("string" != typeof Ve) throw new Error("utf8ToBytes expected string, got " + typeof Ve);
                        return new Uint8Array((new TextEncoder).encode(Ve))
                    }(Ve)), !(Ve => Ve instanceof Uint8Array)(Ve)) throw new Error("expected Uint8Array, got " + typeof Ve);
                return Ve
            }
            class ei {
                clone() {
                    return this._cloneInto()
                }
            }
            const [Wn, kn, Bi] = [
                [],
                [],
                []
            ], ci = BigInt(0), en = BigInt(1), Ii = BigInt(2), pe = BigInt(7), O = BigInt(256), W = BigInt(113);
            for (let Ve = 0, at = en, pt = 1, St = 0; Ve < 24; Ve++) {
                [pt, St] = [St, (2 * pt + 3 * St) % 5], Wn.push(2 * (5 * St + pt)), kn.push((Ve + 1) * (Ve + 2) / 2 % 64);
                let Bn = ci;
                for (let Nn = 0; Nn < 7; Nn++) at = (at << en ^ (at >> pe) * W) % O, at & Ii && (Bn ^= en << (en << BigInt(Nn)) - en);
                Bi.push(Bn)
            }
            const [ke, je] = le(Bi, !0), Qe = (Ve, at, pt) => pt > 32 ? ((Ve, at, pt) => at << pt - 32 | Ve >>> 64 - pt)(Ve, at, pt) : ((Ve, at, pt) => Ve << pt | at >>> 32 - pt)(Ve, at, pt), st = (Ve, at, pt) => pt > 32 ? ((Ve, at, pt) => Ve << pt - 32 | at >>> 64 - pt)(Ve, at, pt) : ((Ve, at, pt) => at << pt | Ve >>> 32 - pt)(Ve, at, pt);
            class Kn extends ei {
                constructor(at, pt, St, Bn = !1, Nn = 24) {
                    if (super(), this.blockLen = at, this.suffix = pt, this.outputLen = St, this.enableXOF = Bn, this.rounds = Nn, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, F(St), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                    var Ve;
                    this.state = new Uint8Array(200), this.state32 = (Ve = this.state, new Uint32Array(Ve.buffer, Ve.byteOffset, Math.floor(Ve.byteLength / 4)))
                }
                keccak() {
                    (function tn(Ve, at = 24) {
                        const pt = new Uint32Array(10);
                        for (let St = 24 - at; St < 24; St++) {
                            for (let Ut = 0; Ut < 10; Ut++) pt[Ut] = Ve[Ut] ^ Ve[Ut + 10] ^ Ve[Ut + 20] ^ Ve[Ut + 30] ^ Ve[Ut + 40];
                            for (let Ut = 0; Ut < 10; Ut += 2) {
                                const or = (Ut + 8) % 10,
                                    ti = (Ut + 2) % 10,
                                    qi = pt[ti],
                                    Xs = pt[ti + 1],
                                    Xn = Qe(qi, Xs, 1) ^ pt[or],
                                    an = st(qi, Xs, 1) ^ pt[or + 1];
                                for (let As = 0; As < 50; As += 10) Ve[Ut + As] ^= Xn, Ve[Ut + As + 1] ^= an
                            }
                            let Bn = Ve[2],
                                Nn = Ve[3];
                            for (let Ut = 0; Ut < 24; Ut++) {
                                const or = kn[Ut],
                                    ti = Qe(Bn, Nn, or),
                                    qi = st(Bn, Nn, or),
                                    Xs = Wn[Ut];
                                Bn = Ve[Xs], Nn = Ve[Xs + 1], Ve[Xs] = ti, Ve[Xs + 1] = qi
                            }
                            for (let Ut = 0; Ut < 50; Ut += 10) {
                                for (let or = 0; or < 10; or++) pt[or] = Ve[Ut + or];
                                for (let or = 0; or < 10; or++) Ve[Ut + or] ^= ~pt[(or + 2) % 10] & pt[(or + 4) % 10]
                            }
                            Ve[0] ^= ke[St], Ve[1] ^= je[St]
                        }
                        pt.fill(0)
                    })(this.state32, this.rounds), this.posOut = 0, this.pos = 0
                }
                update(at) {
                    S(this);
                    const {
                        blockLen: pt,
                        state: St
                    } = this, Bn = (at = Mt(at)).length;
                    for (let Nn = 0; Nn < Bn;) {
                        const Ut = Math.min(pt - this.pos, Bn - Nn);
                        for (let or = 0; or < Ut; or++) St[this.pos++] ^= at[Nn++];
                        this.pos === pt && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished) return;
                    this.finished = !0;
                    const {
                        state: at,
                        suffix: pt,
                        pos: St,
                        blockLen: Bn
                    } = this;
                    at[St] ^= pt, 128 & pt && St === Bn - 1 && this.keccak(), at[Bn - 1] ^= 128, this.keccak()
                }
                writeInto(at) {
                    S(this, !1), q(at), this.finish();
                    const pt = this.state,
                        {
                            blockLen: St
                        } = this;
                    for (let Bn = 0, Nn = at.length; Bn < Nn;) {
                        this.posOut >= St && this.keccak();
                        const Ut = Math.min(St - this.posOut, Nn - Bn);
                        at.set(pt.subarray(this.posOut, this.posOut + Ut), Bn), this.posOut += Ut, Bn += Ut
                    }
                    return at
                }
                xofInto(at) {
                    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                    return this.writeInto(at)
                }
                xof(at) {
                    return F(at), this.xofInto(new Uint8Array(at))
                }
                digestInto(at) {
                    if (function j(Ve, at) {
                            q(Ve);
                            const pt = at.outputLen;
                            if (Ve.length < pt) throw new Error(`digestInto() expects output buffer of length at least ${pt}`)
                        }(at, this), this.finished) throw new Error("digest() was already called");
                    return this.writeInto(at), this.destroy(), at
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0, this.state.fill(0)
                }
                _cloneInto(at) {
                    const {
                        blockLen: pt,
                        suffix: St,
                        outputLen: Bn,
                        rounds: Nn,
                        enableXOF: Ut
                    } = this;
                    return at || (at = new Kn(pt, St, Bn, Ut, Nn)), at.state32.set(this.state32), at.pos = this.pos, at.posOut = this.posOut, at.finished = this.finished, at.rounds = Nn, at.suffix = St, at.outputLen = Bn, at.enableXOF = Ut, at.destroyed = this.destroyed, at
                }
            }
            const yi = ((Ve, at, pt) => function An(Ve) {
                const at = St => Ve().update(Mt(St)).digest(),
                    pt = Ve();
                return at.outputLen = pt.outputLen, at.blockLen = pt.blockLen, at.create = () => Ve(), at
            }(() => new Kn(136, 1, 32)))();
            var Ji = T(37812),
                gn = T(9427),
                Si = T(74439);

            function qn(Ve, at) {
                const pt = at || "hex",
                    St = yi((0, Ji.v)(Ve, {
                        strict: !1
                    }) ? (0, gn.O0)(Ve) : Ve);
                return "bytes" === pt ? St : (0, Si.NC)(St)
            }
        },
        87447: (et, I, T) => {
            "use strict";
            T.d(I, {
                S: () => q
            });
            var F = T(15861);
            const K = new Map;

            function q({
                fn: ne,
                id: S,
                shouldSplitBatch: j,
                wait: C = 0,
                sort: z
            }) {
                const H = function() {
                        var de = (0, F.Z)(function*() {
                            const Se = le();
                            Y();
                            const me = Se.map(({
                                args: Ce
                            }) => Ce);
                            0 !== me.length && ne(me).then(Ce => {
                                z && Array.isArray(Ce) && Ce.sort(z);
                                for (let we = 0; we < Se.length; we++) {
                                    const {
                                        pendingPromise: ve
                                    } = Se[we];
                                    ve.resolve ? .([Ce[we], Ce])
                                }
                            }).catch(Ce => {
                                for (let we = 0; we < Se.length; we++) {
                                    const {
                                        pendingPromise: ve
                                    } = Se[we];
                                    ve.reject ? .(Ce)
                                }
                            })
                        });
                        return function() {
                            return de.apply(this, arguments)
                        }
                    }(),
                    Y = () => K.delete(S),
                    le = () => K.get(S) || [],
                    re = de => K.set(S, [...le(), de]);
                return {
                    flush: Y,
                    schedule: de => (0, F.Z)(function*() {
                        const Se = {},
                            me = new Promise((ve, De) => {
                                Se.resolve = ve, Se.reject = De
                            });
                        return j ? .([...le().map(({
                            args: de
                        }) => de), de]) && H(), le().length > 0 ? (re({
                            args: de,
                            pendingPromise: Se
                        }), me) : (re({
                            args: de,
                            pendingPromise: Se
                        }), setTimeout(H, C), me)
                    })()
                }
            }
        },
        30038: (et, I, T) => {
            "use strict";
            T.d(I, {
                P: () => F
            });
            const F = (K, q, ne) => JSON.stringify(K, (S, j) => {
                const C = "bigint" == typeof j ? j.toString() : j;
                return "function" == typeof q ? q(S, C) : C
            }, ne)
        },
        9056: (et, I, T) => {
            "use strict";
            T.d(I, {
                F: () => j
            });
            var F = T(30277),
                K = T(78355),
                q = T(17354),
                ne = T(98284),
                S = T(32099);

            function j(C) {
                const {
                    account: z,
                    gasPrice: H,
                    maxFeePerGas: Y,
                    maxPriorityFeePerGas: Z,
                    to: le
                } = C, re = z ? (0, F.T)(z) : void 0;
                if (re && !(0, S.U)(re.address)) throw new K.b({
                    address: re.address
                });
                if (le && !(0, S.U)(le)) throw new K.b({
                    address: le
                });
                if (typeof H < "u" && (typeof Y < "u" || typeof Z < "u")) throw new ne.xY;
                if (Y && Y > 2 n ** 256 n - 1 n) throw new q.Hh({
                    maxFeePerGas: Y
                });
                if (Z && Y && Z > Y) throw new q.cs({
                    maxFeePerGas: Y,
                    maxPriorityFeePerGas: Z
                })
            }
        },
        78004: (et, I, T) => {
            "use strict";
            T.d(I, {
                d: () => q
            });
            var F = T(99744),
                K = T(24102);

            function q(ne, S = "wei") {
                return (0, K.b)(ne, F.ez[S])
            }
        },
        79077: (et, I, T) => {
            "use strict";
            T.d(I, {
                o: () => q
            });
            var F = T(99744),
                K = T(24102);

            function q(ne, S = "wei") {
                return (0, K.b)(ne, F.Zn[S])
            }
        },
        24102: (et, I, T) => {
            "use strict";

            function F(K, q) {
                let ne = K.toString();
                const S = ne.startsWith("-");
                S && (ne = ne.slice(1)), ne = ne.padStart(q, "0");
                let [j, C] = [ne.slice(0, ne.length - q), ne.slice(ne.length - q)];
                return C = C.replace(/(0+)$/, ""), `${S?"-":""}${j||"0"}${C?`.${C}`:""}`
            }
            T.d(I, {
                b: () => F
            })
        },
        15861: (et, I, T) => {
            "use strict";

            function F(q, ne, S, j, C, z, H) {
                try {
                    var Y = q[z](H),
                        Z = Y.value
                } catch (le) {
                    return void S(le)
                }
                Y.done ? ne(Z) : Promise.resolve(Z).then(j, C)
            }

            function K(q) {
                return function() {
                    var ne = this,
                        S = arguments;
                    return new Promise(function(j, C) {
                        var z = q.apply(ne, S);

                        function H(Z) {
                            F(z, j, C, H, Y, "next", Z)
                        }

                        function Y(Z) {
                            F(z, j, C, H, Y, "throw", Z)
                        }
                        H(void 0)
                    })
                }
            }
            T.d(I, {
                Z: () => K
            })
        },
        97582: (et, I, T) => {
            "use strict";
            T.r(I), T.d(I, {
                __addDisposableResource: () => v,
                __assign: () => q,
                __asyncDelegator: () => Le,
                __asyncGenerator: () => Me,
                __asyncValues: () => L,
                __await: () => ae,
                __awaiter: () => le,
                __classPrivateFieldGet: () => Ie,
                __classPrivateFieldIn: () => f,
                __classPrivateFieldSet: () => $,
                __createBinding: () => de,
                __decorate: () => S,
                __disposeResources: () => U,
                __esDecorate: () => C,
                __exportStar: () => Se,
                __extends: () => K,
                __generator: () => re,
                __importDefault: () => Ae,
                __importStar: () => xe,
                __makeTemplateObject: () => ue,
                __metadata: () => Z,
                __param: () => j,
                __propKey: () => H,
                __read: () => Ce,
                __rest: () => ne,
                __runInitializers: () => z,
                __setFunctionName: () => Y,
                __spread: () => we,
                __spreadArray: () => De,
                __spreadArrays: () => ve,
                __values: () => me,
                default: () => G
            });
            var F = function(y, E) {
                return (F = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(A, b) {
                        A.__proto__ = b
                    } || function(A, b) {
                        for (var N in b) Object.prototype.hasOwnProperty.call(b, N) && (A[N] = b[N])
                    })(y, E)
            };

            function K(y, E) {
                if ("function" != typeof E && null !== E) throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");

                function A() {
                    this.constructor = y
                }
                F(y, E), y.prototype = null === E ? Object.create(E) : (A.prototype = E.prototype, new A)
            }
            var q = function() {
                return q = Object.assign || function(E) {
                    for (var A, b = 1, N = arguments.length; b < N; b++)
                        for (var R in A = arguments[b]) Object.prototype.hasOwnProperty.call(A, R) && (E[R] = A[R]);
                    return E
                }, q.apply(this, arguments)
            };

            function ne(y, E) {
                var A = {};
                for (var b in y) Object.prototype.hasOwnProperty.call(y, b) && E.indexOf(b) < 0 && (A[b] = y[b]);
                if (null != y && "function" == typeof Object.getOwnPropertySymbols) {
                    var N = 0;
                    for (b = Object.getOwnPropertySymbols(y); N < b.length; N++) E.indexOf(b[N]) < 0 && Object.prototype.propertyIsEnumerable.call(y, b[N]) && (A[b[N]] = y[b[N]])
                }
                return A
            }

            function S(y, E, A, b) {
                var Q, N = arguments.length,
                    R = N < 3 ? E : null === b ? b = Object.getOwnPropertyDescriptor(E, A) : b;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) R = Reflect.decorate(y, E, A, b);
                else
                    for (var Ee = y.length - 1; Ee >= 0; Ee--)(Q = y[Ee]) && (R = (N < 3 ? Q(R) : N > 3 ? Q(E, A, R) : Q(E, A)) || R);
                return N > 3 && R && Object.defineProperty(E, A, R), R
            }

            function j(y, E) {
                return function(A, b) {
                    E(A, b, y)
                }
            }

            function C(y, E, A, b, N, R) {
                function Q(An) {
                    if (void 0 !== An && "function" != typeof An) throw new TypeError("Function expected");
                    return An
                }
                for (var Vt, Ee = b.kind, Fe = "getter" === Ee ? "get" : "setter" === Ee ? "set" : "value", Ge = !E && y ? b.static ? y : y.prototype : null, wt = E || (Ge ? Object.getOwnPropertyDescriptor(Ge, b.name) : {}), Mt = !1, sn = A.length - 1; sn >= 0; sn--) {
                    var ei = {};
                    for (var ai in b) ei[ai] = "access" === ai ? {} : b[ai];
                    for (var ai in b.access) ei.access[ai] = b.access[ai];
                    ei.addInitializer = function(An) {
                        if (Mt) throw new TypeError("Cannot add initializers after decoration has completed");
                        R.push(Q(An || null))
                    };
                    var jn = (0, A[sn])("accessor" === Ee ? {
                        get: wt.get,
                        set: wt.set
                    } : wt[Fe], ei);
                    if ("accessor" === Ee) {
                        if (void 0 === jn) continue;
                        if (null === jn || "object" != typeof jn) throw new TypeError("Object expected");
                        (Vt = Q(jn.get)) && (wt.get = Vt), (Vt = Q(jn.set)) && (wt.set = Vt), (Vt = Q(jn.init)) && N.unshift(Vt)
                    } else(Vt = Q(jn)) && ("field" === Ee ? N.unshift(Vt) : wt[Fe] = Vt)
                }
                Ge && Object.defineProperty(Ge, b.name, wt), Mt = !0
            }

            function z(y, E, A) {
                for (var b = arguments.length > 2, N = 0; N < E.length; N++) A = b ? E[N].call(y, A) : E[N].call(y);
                return b ? A : void 0
            }

            function H(y) {
                return "symbol" == typeof y ? y : "".concat(y)
            }

            function Y(y, E, A) {
                return "symbol" == typeof E && (E = E.description ? "[".concat(E.description, "]") : ""), Object.defineProperty(y, "name", {
                    configurable: !0,
                    value: A ? "".concat(A, " ", E) : E
                })
            }

            function Z(y, E) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(y, E)
            }

            function le(y, E, A, b) {
                return new(A || (A = Promise))(function(R, Q) {
                    function Ee(wt) {
                        try {
                            Ge(b.next(wt))
                        } catch (Vt) {
                            Q(Vt)
                        }
                    }

                    function Fe(wt) {
                        try {
                            Ge(b.throw(wt))
                        } catch (Vt) {
                            Q(Vt)
                        }
                    }

                    function Ge(wt) {
                        wt.done ? R(wt.value) : function N(R) {
                            return R instanceof A ? R : new A(function(Q) {
                                Q(R)
                            })
                        }(wt.value).then(Ee, Fe)
                    }
                    Ge((b = b.apply(y, E || [])).next())
                })
            }

            function re(y, E) {
                var b, N, R, Q, A = {
                    label: 0,
                    sent: function() {
                        if (1 & R[0]) throw R[1];
                        return R[1]
                    },
                    trys: [],
                    ops: []
                };
                return Q = {
                    next: Ee(0),
                    throw: Ee(1),
                    return: Ee(2)
                }, "function" == typeof Symbol && (Q[Symbol.iterator] = function() {
                    return this
                }), Q;

                function Ee(Ge) {
                    return function(wt) {
                        return function Fe(Ge) {
                            if (b) throw new TypeError("Generator is already executing.");
                            for (; Q && (Q = 0, Ge[0] && (A = 0)), A;) try {
                                if (b = 1, N && (R = 2 & Ge[0] ? N.return : Ge[0] ? N.throw || ((R = N.return) && R.call(N), 0) : N.next) && !(R = R.call(N, Ge[1])).done) return R;
                                switch (N = 0, R && (Ge = [2 & Ge[0], R.value]), Ge[0]) {
                                    case 0:
                                    case 1:
                                        R = Ge;
                                        break;
                                    case 4:
                                        return A.label++, {
                                            value: Ge[1],
                                            done: !1
                                        };
                                    case 5:
                                        A.label++, N = Ge[1], Ge = [0];
                                        continue;
                                    case 7:
                                        Ge = A.ops.pop(), A.trys.pop();
                                        continue;
                                    default:
                                        if (!(R = (R = A.trys).length > 0 && R[R.length - 1]) && (6 === Ge[0] || 2 === Ge[0])) {
                                            A = 0;
                                            continue
                                        }
                                        if (3 === Ge[0] && (!R || Ge[1] > R[0] && Ge[1] < R[3])) {
                                            A.label = Ge[1];
                                            break
                                        }
                                        if (6 === Ge[0] && A.label < R[1]) {
                                            A.label = R[1], R = Ge;
                                            break
                                        }
                                        if (R && A.label < R[2]) {
                                            A.label = R[2], A.ops.push(Ge);
                                            break
                                        }
                                        R[2] && A.ops.pop(), A.trys.pop();
                                        continue
                                }
                                Ge = E.call(y, A)
                            } catch (wt) {
                                Ge = [6, wt], N = 0
                            } finally {
                                b = R = 0
                            }
                            if (5 & Ge[0]) throw Ge[1];
                            return {
                                value: Ge[0] ? Ge[1] : void 0,
                                done: !0
                            }
                        }([Ge, wt])
                    }
                }
            }
            var de = Object.create ? function(y, E, A, b) {
                void 0 === b && (b = A);
                var N = Object.getOwnPropertyDescriptor(E, A);
                (!N || ("get" in N ? !E.__esModule : N.writable || N.configurable)) && (N = {
                    enumerable: !0,
                    get: function() {
                        return E[A]
                    }
                }), Object.defineProperty(y, b, N)
            } : function(y, E, A, b) {
                void 0 === b && (b = A), y[b] = E[A]
            };

            function Se(y, E) {
                for (var A in y) "default" !== A && !Object.prototype.hasOwnProperty.call(E, A) && de(E, y, A)
            }

            function me(y) {
                var E = "function" == typeof Symbol && Symbol.iterator,
                    A = E && y[E],
                    b = 0;
                if (A) return A.call(y);
                if (y && "number" == typeof y.length) return {
                    next: function() {
                        return y && b >= y.length && (y = void 0), {
                            value: y && y[b++],
                            done: !y
                        }
                    }
                };
                throw new TypeError(E ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function Ce(y, E) {
                var A = "function" == typeof Symbol && y[Symbol.iterator];
                if (!A) return y;
                var N, Q, b = A.call(y),
                    R = [];
                try {
                    for (;
                        (void 0 === E || E-- > 0) && !(N = b.next()).done;) R.push(N.value)
                } catch (Ee) {
                    Q = {
                        error: Ee
                    }
                } finally {
                    try {
                        N && !N.done && (A = b.return) && A.call(b)
                    } finally {
                        if (Q) throw Q.error
                    }
                }
                return R
            }

            function we() {
                for (var y = [], E = 0; E < arguments.length; E++) y = y.concat(Ce(arguments[E]));
                return y
            }

            function ve() {
                for (var y = 0, E = 0, A = arguments.length; E < A; E++) y += arguments[E].length;
                var b = Array(y),
                    N = 0;
                for (E = 0; E < A; E++)
                    for (var R = arguments[E], Q = 0, Ee = R.length; Q < Ee; Q++, N++) b[N] = R[Q];
                return b
            }

            function De(y, E, A) {
                if (A || 2 === arguments.length)
                    for (var R, b = 0, N = E.length; b < N; b++)(R || !(b in E)) && (R || (R = Array.prototype.slice.call(E, 0, b)), R[b] = E[b]);
                return y.concat(R || Array.prototype.slice.call(E))
            }

            function ae(y) {
                return this instanceof ae ? (this.v = y, this) : new ae(y)
            }

            function Me(y, E, A) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var N, b = A.apply(y, E || []),
                    R = [];
                return N = {}, Q("next"), Q("throw"), Q("return"), N[Symbol.asyncIterator] = function() {
                    return this
                }, N;

                function Q(Mt) {
                    b[Mt] && (N[Mt] = function(sn) {
                        return new Promise(function(ei, ai) {
                            R.push([Mt, sn, ei, ai]) > 1 || Ee(Mt, sn)
                        })
                    })
                }

                function Ee(Mt, sn) {
                    try {
                        ! function Fe(Mt) {
                            Mt.value instanceof ae ? Promise.resolve(Mt.value.v).then(Ge, wt) : Vt(R[0][2], Mt)
                        }(b[Mt](sn))
                    } catch (ei) {
                        Vt(R[0][3], ei)
                    }
                }

                function Ge(Mt) {
                    Ee("next", Mt)
                }

                function wt(Mt) {
                    Ee("throw", Mt)
                }

                function Vt(Mt, sn) {
                    Mt(sn), R.shift(), R.length && Ee(R[0][0], R[0][1])
                }
            }

            function Le(y) {
                var E, A;
                return E = {}, b("next"), b("throw", function(N) {
                    throw N
                }), b("return"), E[Symbol.iterator] = function() {
                    return this
                }, E;

                function b(N, R) {
                    E[N] = y[N] ? function(Q) {
                        return (A = !A) ? {
                            value: ae(y[N](Q)),
                            done: !1
                        } : R ? R(Q) : Q
                    } : R
                }
            }

            function L(y) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var A, E = y[Symbol.asyncIterator];
                return E ? E.call(y) : (y = me(y), A = {}, b("next"), b("throw"), b("return"), A[Symbol.asyncIterator] = function() {
                    return this
                }, A);

                function b(R) {
                    A[R] = y[R] && function(Q) {
                        return new Promise(function(Ee, Fe) {
                            ! function N(R, Q, Ee, Fe) {
                                Promise.resolve(Fe).then(function(Ge) {
                                    R({
                                        value: Ge,
                                        done: Ee
                                    })
                                }, Q)
                            }(Ee, Fe, (Q = y[R](Q)).done, Q.value)
                        })
                    }
                }
            }

            function ue(y, E) {
                return Object.defineProperty ? Object.defineProperty(y, "raw", {
                    value: E
                }) : y.raw = E, y
            }
            var Te = Object.create ? function(y, E) {
                Object.defineProperty(y, "default", {
                    enumerable: !0,
                    value: E
                })
            } : function(y, E) {
                y.default = E
            };

            function xe(y) {
                if (y && y.__esModule) return y;
                var E = {};
                if (null != y)
                    for (var A in y) "default" !== A && Object.prototype.hasOwnProperty.call(y, A) && de(E, y, A);
                return Te(E, y), E
            }

            function Ae(y) {
                return y && y.__esModule ? y : {
                    default: y
                }
            }

            function Ie(y, E, A, b) {
                if ("a" === A && !b) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof E ? y !== E || !b : !E.has(y)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === A ? b : "a" === A ? b.call(y) : b ? b.value : E.get(y)
            }

            function $(y, E, A, b, N) {
                if ("m" === b) throw new TypeError("Private method is not writable");
                if ("a" === b && !N) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof E ? y !== E || !N : !E.has(y)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === b ? N.call(y, A) : N ? N.value = A : E.set(y, A), A
            }

            function f(y, E) {
                if (null === E || "object" != typeof E && "function" != typeof E) throw new TypeError("Cannot use 'in' operator on non-object");
                return "function" == typeof y ? E === y : y.has(E)
            }

            function v(y, E, A) {
                if (null != E) {
                    if ("object" != typeof E && "function" != typeof E) throw new TypeError("Object expected.");
                    var b;
                    if (A) {
                        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                        b = E[Symbol.asyncDispose]
                    }
                    if (void 0 === b) {
                        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                        b = E[Symbol.dispose]
                    }
                    if ("function" != typeof b) throw new TypeError("Object not disposable.");
                    y.stack.push({
                        value: E,
                        dispose: b,
                        async: A
                    })
                } else A && y.stack.push({
                    async: !0
                });
                return E
            }
            var M = "function" == typeof SuppressedError ? SuppressedError : function(y, E, A) {
                var b = new Error(A);
                return b.name = "SuppressedError", b.error = y, b.suppressed = E, b
            };

            function U(y) {
                function E(b) {
                    y.error = y.hasError ? new M(b, y.error, "An error was suppressed during disposal.") : b, y.hasError = !0
                }
                return function A() {
                    for (; y.stack.length;) {
                        var b = y.stack.pop();
                        try {
                            var N = b.dispose && b.dispose.call(b.value);
                            if (b.async) return Promise.resolve(N).then(A, function(R) {
                                return E(R), A()
                            })
                        } catch (R) {
                            E(R)
                        }
                    }
                    if (y.hasError) throw y.error
                }()
            }
            const G = {
                __extends: K,
                __assign: q,
                __rest: ne,
                __decorate: S,
                __param: j,
                __metadata: Z,
                __awaiter: le,
                __generator: re,
                __createBinding: de,
                __exportStar: Se,
                __values: me,
                __read: Ce,
                __spread: we,
                __spreadArrays: ve,
                __spreadArray: De,
                __await: ae,
                __asyncGenerator: Me,
                __asyncDelegator: Le,
                __asyncValues: L,
                __makeTemplateObject: ue,
                __importStar: xe,
                __importDefault: Ae,
                __classPrivateFieldGet: Ie,
                __classPrivateFieldSet: $,
                __classPrivateFieldIn: f,
                __addDisposableResource: v,
                __disposeResources: U
            }
        },
        94713: et => {
            "use strict";
            et.exports = JSON.parse('{"name":"@wert-io/widget-initializer","version":"5.2.0","description":"WertWidget helper","main":"index.js","types":"index.d.ts","repository":{"type":"git","url":"https://github.com/wert-io/widget-initializer.git"},"scripts":{"build":"tsc -p .","build-script":"rollup -c","test":"jest --ci --reporters=default --reporters=jest-junit"},"author":"@wert-io","license":"ISC","devDependencies":{"@babel/core":"^7.13.16","@babel/preset-env":"^7.13.15","@rollup/plugin-babel":"^5.3.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.1.3","@typescript-eslint/eslint-plugin":"^4.28.1","@typescript-eslint/parser":"^4.28.1","eslint":"^7.25.0","eslint-plugin-import":"^2.22.1","jest":"^27.0.5","jest-junit":"^12.0.0","rollup":"^2.45.2","typescript":"^4.3.5"},"dependencies":{},"jest-junit":{"outputDirectory":"reports","outputName":"jest-junit.xml","ancestorSeparator":" \u203a ","uniqueOutputName":"false","suiteNameTemplate":"{filepath}","classNameTemplate":"{classname}","titleTemplate":"{title}"}}')
        },
        13002: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"AVAX_USDT_Token","abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_user","type":"address"}],"name":"BlockPlaced","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_user","type":"address"}],"name":"BlockReleased","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_blockedUser","type":"address"},{"indexed":false,"internalType":"uint256","name":"_balance","type":"uint256"}],"name":"DestroyedBlockedFunds","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_destination","type":"address"},{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_contract","type":"address"}],"name":"NewPrivilegedContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"Redeem","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_contract","type":"address"}],"name":"RemovedPrivilegedContract","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_trustedDeFiContract","type":"address"}],"name":"addPrivilegedContract","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"addToBlockedList","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_blockedUser","type":"address"}],"name":"destroyBlockedFunds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"uint8","name":"_decimals","type":"uint8"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isBlocked","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isTrusted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_destination","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_recipients","type":"address[]"},{"internalType":"uint256[]","name":"_values","type":"uint256[]"}],"name":"multiTransfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"redeem","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"removeFromBlockedList","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_trustedDeFiContract","type":"address"}],"name":"removePrivilegedContract","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_recipient","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_sender","type":"address"},{"internalType":"address","name":"_recipient","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]}')
        },
        73018: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"BASE_USDT_Token","abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"authorizer","type":"address"},{"indexed":true,"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"AuthorizationCanceled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"authorizer","type":"address"},{"indexed":true,"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"AuthorizationUsed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_account","type":"address"}],"name":"Blacklisted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newBlacklister","type":"address"}],"name":"BlacklisterChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"burner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newMasterMinter","type":"address"}],"name":"MasterMinterChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"minter","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"minter","type":"address"},{"indexed":false,"internalType":"uint256","name":"minterAllowedAmount","type":"uint256"}],"name":"MinterConfigured","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldMinter","type":"address"}],"name":"MinterRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":false,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[],"name":"Pause","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAddress","type":"address"}],"name":"PauserChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newRescuer","type":"address"}],"name":"RescuerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_account","type":"address"}],"name":"UnBlacklisted","type":"event"},{"anonymous":false,"inputs":[],"name":"Unpause","type":"event"},{"inputs":[],"name":"CANCEL_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMIT_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RECEIVE_WITH_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TRANSFER_WITH_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"authorizer","type":"address"},{"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"authorizationState","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"blacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"blacklister","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"authorizer","type":"address"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"cancelAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"authorizer","type":"address"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"cancelAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"},{"internalType":"uint256","name":"minterAllowedAmount","type":"uint256"}],"name":"configureMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"currency","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"decrement","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"increment","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"tokenName","type":"string"},{"internalType":"string","name":"tokenSymbol","type":"string"},{"internalType":"string","name":"tokenCurrency","type":"string"},{"internalType":"uint8","name":"tokenDecimals","type":"uint8"},{"internalType":"address","name":"newMasterMinter","type":"address"},{"internalType":"address","name":"newPauser","type":"address"},{"internalType":"address","name":"newBlacklister","type":"address"},{"internalType":"address","name":"newOwner","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newName","type":"string"}],"name":"initializeV2","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"lostAndFound","type":"address"}],"name":"initializeV2_1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accountsToBlacklist","type":"address[]"},{"internalType":"string","name":"newSymbol","type":"string"}],"name":"initializeV2_2","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"isBlacklisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterMinter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"}],"name":"minterAllowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"receiveWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"receiveWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"}],"name":"removeMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"tokenContract","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"rescueERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rescuer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"transferWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"transferWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"unBlacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newBlacklister","type":"address"}],"name":"updateBlacklister","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newMasterMinter","type":"address"}],"name":"updateMasterMinter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPauser","type":"address"}],"name":"updatePauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newRescuer","type":"address"}],"name":"updateRescuer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"}]}')
        },
        40625: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"BSC_USDT_Token","abi":[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]}')
        },
        16530: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"ETH_USDT_Token","abi":[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_upgradedAddress","type":"address"}],"name":"deprecate","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"deprecated","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_evilUser","type":"address"}],"name":"addBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"upgradedAddress","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"balances","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"maximumFee","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"unpause","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_maker","type":"address"}],"name":"getBlackListStatus","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowed","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"paused","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"who","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"pause","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newBasisPoints","type":"uint256"},{"name":"newMaxFee","type":"uint256"}],"name":"setParams","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"}],"name":"issue","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"}],"name":"redeem","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"basisPointsRate","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"isBlackListed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_clearedUser","type":"address"}],"name":"removeBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"MAX_UINT","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_blackListedUser","type":"address"}],"name":"destroyBlackFunds","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_initialSupply","type":"uint256"},{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_decimals","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"amount","type":"uint256"}],"name":"Issue","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"amount","type":"uint256"}],"name":"Redeem","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newAddress","type":"address"}],"name":"Deprecate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"feeBasisPoints","type":"uint256"},{"indexed":false,"name":"maxFee","type":"uint256"}],"name":"Params","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_blackListedUser","type":"address"},{"indexed":false,"name":"_balance","type":"uint256"}],"name":"DestroyedBlackFunds","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_user","type":"address"}],"name":"AddedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_user","type":"address"}],"name":"RemovedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[],"name":"Pause","type":"event"},{"anonymous":false,"inputs":[],"name":"Unpause","type":"event"}]}')
        },
        83447: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"POLY _USDT_Token","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"userAddress","type":"address"},{"indexed":false,"internalType":"address payable","name":"relayerAddress","type":"address"},{"indexed":false,"internalType":"bytes","name":"functionSignature","type":"bytes"}],"name":"MetaTransactionExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"CHILD_CHAIN_ID","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"CHILD_CHAIN_ID_BYTES","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DEPOSITOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ERC712_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ROOT_CHAIN_ID","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ROOT_CHAIN_ID_BYTES","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name_","type":"string"}],"name":"changeName","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"bytes","name":"depositData","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"userAddress","type":"address"},{"internalType":"bytes","name":"functionSignature","type":"bytes"},{"internalType":"bytes32","name":"sigR","type":"bytes32"},{"internalType":"bytes32","name":"sigS","type":"bytes32"},{"internalType":"uint8","name":"sigV","type":"uint8"}],"name":"executeMetaTransaction","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getChainId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getDomainSeperator","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getNonce","outputs":[{"internalType":"uint256","name":"nonce","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"uint8","name":"decimals_","type":"uint8"},{"internalType":"address","name":"childChainManager","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}]}')
        },
        60325: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Presale","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"MaxTokensUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_start","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_end","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"USDTInterface","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"aggregatorInterface","outputs":[{"internalType":"contract Aggregator","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"avaxBuyHelper","outputs":[{"internalType":"uint256","name":"avaxAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseDecimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithAVAX","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithUSDT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"calculatePrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"}],"name":"changeMaxTokensToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPaymentWallet","type":"address"}],"name":"changePaymentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"}],"name":"changeRoundsData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"changeSaleTimes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"checkPoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"currentStep","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dynamicTimeFlag","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"endTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"incrementCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdt","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"},{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"},{"internalType":"address","name":"_paymentWallet","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"maxTokensToBuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"percentages","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"prevCheckpoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remainingTokensTracker","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_no","type":"uint256"}],"name":"roundDetails","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"rounds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_step","type":"uint256"},{"internalType":"uint256","name":"_checkpoint","type":"uint256"}],"name":"setCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_dynamicTimeFlag","type":"bool"}],"name":"setDynamicTimeFlag","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_unsoldTokens","type":"uint256[]"}],"name":"setRemainingTokensArray","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_wallets","type":"address[]"},{"internalType":"uint256[]","name":"_percentages","type":"uint256[]"}],"name":"setSplits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_timeConstant","type":"uint256"}],"name":"setTimeConstant","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timeConstant","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensSold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trackRemainingTokens","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"usdRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userDeposits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"wallets","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]}')
        },
        43771: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Presale","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"MaxTokensUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_start","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_end","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"USDCInterface","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"aggregatorInterface","outputs":[{"internalType":"contract Aggregator","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseDecimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithETH","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithUSDC","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"calculatePrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"}],"name":"changeMaxTokensToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPaymentWallet","type":"address"}],"name":"changePaymentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"}],"name":"changeRoundsData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"changeSaleTimes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"checkPoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"currentStep","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dynamicTimeFlag","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"endTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ethBuyHelper","outputs":[{"internalType":"uint256","name":"ethAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"incrementCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdc","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"},{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"},{"internalType":"address","name":"_paymentWallet","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"maxTokensToBuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"percentages","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"prevCheckpoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remainingTokensTracker","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_no","type":"uint256"}],"name":"roundDetails","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"rounds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_step","type":"uint256"},{"internalType":"uint256","name":"_checkpoint","type":"uint256"}],"name":"setCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_dynamicTimeFlag","type":"bool"}],"name":"setDynamicTimeFlag","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_unsoldTokens","type":"uint256[]"}],"name":"setRemainingTokensArray","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_wallets","type":"address[]"},{"internalType":"uint256[]","name":"_percentages","type":"uint256[]"}],"name":"setSplits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_timeConstant","type":"uint256"}],"name":"setTimeConstant","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timeConstant","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensSold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trackRemainingTokens","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"usdRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdcBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userDeposits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"wallets","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]}')
        },
        27008: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Presale","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"MaxTokensUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_start","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_end","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"USDTInterface","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"aggregatorInterface","outputs":[{"internalType":"contract Aggregator","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseDecimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"bnbBuyHelper","outputs":[{"internalType":"uint256","name":"bnbAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithBNB","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithUSDT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"calculatePrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"}],"name":"changeMaxTokensToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPaymentWallet","type":"address"}],"name":"changePaymentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"}],"name":"changeRoundsData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"changeSaleTimes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"checkPoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"currentStep","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dynamicTimeFlag","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"endTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"incrementCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdt","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"},{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"},{"internalType":"address","name":"_paymentWallet","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"maxTokensToBuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"percentages","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"prevCheckpoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remainingTokensTracker","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_no","type":"uint256"}],"name":"roundDetails","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"rounds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_step","type":"uint256"},{"internalType":"uint256","name":"_checkpoint","type":"uint256"}],"name":"setCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_dynamicTimeFlag","type":"bool"}],"name":"setDynamicTimeFlag","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_unsoldTokens","type":"uint256[]"}],"name":"setRemainingTokensArray","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_wallets","type":"address[]"},{"internalType":"uint256[]","name":"_percentages","type":"uint256[]"}],"name":"setSplits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_timeConstant","type":"uint256"}],"name":"setTimeConstant","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timeConstant","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensSold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trackRemainingTokens","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"usdRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userDeposits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"wallets","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]}')
        },
        60949: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Presale","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"ClaimStartUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"MaxTokensUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_start","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_end","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"noOfTokens","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBoughtAndStaked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensClaimedAndStaked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"USDTInterface","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"aggregatorInterface","outputs":[{"internalType":"contract Aggregator","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseDecimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_usersToBlacklist","type":"address[]"}],"name":"blacklistUsers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"bool","name":"stake","type":"bool"}],"name":"buyWithETHWert","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"stake","type":"bool"}],"name":"buyWithEth","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"stake","type":"bool"}],"name":"buyWithUSDT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"calculatePrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimStart","type":"uint256"}],"name":"changeClaimStart","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"}],"name":"changeMaxTokensToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPaymentWallet","type":"address"}],"name":"changePaymentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"}],"name":"changeRoundsData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"changeSaleTimes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"checkPoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimAndStake","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimStart","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"currentStep","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dynamicTimeFlag","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"endTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ethBuyHelper","outputs":[{"internalType":"uint256","name":"ethAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"hasClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"incrementCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdt","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"},{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"},{"internalType":"address","name":"_paymentWallet","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isBlacklisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isWhitelisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxTokensToBuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"percentages","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"prevCheckpoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remainingTokensTracker","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_userToRemoveFromBlacklist","type":"address[]"}],"name":"removeFromBlacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_userToRemoveFromWhitelist","type":"address[]"}],"name":"removeFromWhitelist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_addressesToRemoveFromWhitelist","type":"address[]"}],"name":"removeFromWhitelistForWERT","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_no","type":"uint256"}],"name":"roundDetails","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"rounds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"saleToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_status","type":"bool"}],"name":"setClaimWhitelistStatus","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_step","type":"uint256"},{"internalType":"uint256","name":"_checkpoint","type":"uint256"}],"name":"setCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_dynamicTimeFlag","type":"bool"}],"name":"setDynamicTimeFlag","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_unsoldTokens","type":"uint256[]"}],"name":"setRemainingTokensArray","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_wallets","type":"address[]"},{"internalType":"uint256[]","name":"_percentages","type":"uint256[]"}],"name":"setSplits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_status","type":"bool"}],"name":"setStakeingWhitelistStatus","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_stakingManagerAddress","type":"address"}],"name":"setStakingManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_timeConstant","type":"uint256"}],"name":"setTimeConstant","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stakeingWhitelistStatus","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"stakingManagerInterface","outputs":[{"internalType":"contract StakingManager","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimStart","type":"uint256"},{"internalType":"uint256","name":"noOfTokens","type":"uint256"},{"internalType":"address","name":"_saleToken","type":"address"},{"internalType":"address","name":"_stakingManagerAddress","type":"address"}],"name":"startClaim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timeConstant","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalBoughtAndStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensSold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trackRemainingTokens","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_users","type":"address[]"},{"internalType":"uint256[]","name":"_userDeposits","type":"uint256[]"}],"name":"updateFromBSC","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"usdRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userDeposits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"wallets","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"wertWhitelisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"whitelistClaimOnly","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_usersToWhitelist","type":"address[]"}],"name":"whitelistUsers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_addressesToWhitelist","type":"address[]"}],"name":"whitelistUsersForWERT","outputs":[],"stateMutability":"nonpayable","type":"function"}]}')
        },
        91887: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Presale","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"MaxTokensUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_start","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_end","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"SaleTimeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"usdEq","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"USDTInterface","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"aggregatorInterface","outputs":[{"internalType":"contract Aggregator","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseDecimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithMATIC","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"buyWithUSDT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"calculatePrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"}],"name":"changeMaxTokensToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPaymentWallet","type":"address"}],"name":"changePaymentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"}],"name":"changeRoundsData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"changeSaleTimes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"checkPoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"currentStep","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dynamicTimeFlag","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"endTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"incrementCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdt","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"uint256[][3]","name":"_rounds","type":"uint256[][3]"},{"internalType":"uint256","name":"_maxTokensToBuy","type":"uint256"},{"internalType":"address","name":"_paymentWallet","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"maticBuyHelper","outputs":[{"internalType":"uint256","name":"maticAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxTokensToBuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paymentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"percentages","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"prevCheckpoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remainingTokensTracker","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_no","type":"uint256"}],"name":"roundDetails","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"rounds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_step","type":"uint256"},{"internalType":"uint256","name":"_checkpoint","type":"uint256"}],"name":"setCurrentStep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_dynamicTimeFlag","type":"bool"}],"name":"setDynamicTimeFlag","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_unsoldTokens","type":"uint256[]"}],"name":"setRemainingTokensArray","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_wallets","type":"address[]"},{"internalType":"uint256[]","name":"_percentages","type":"uint256[]"}],"name":"setSplits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_timeConstant","type":"uint256"}],"name":"setTimeConstant","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timeConstant","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensSold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trackRemainingTokens","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"usdRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userDeposits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"wallets","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]}')
        },
        71612: et => {
            "use strict";
            et.exports = JSON.parse('{"version":"0.1.0","name":"presale_contract","instructions":[{"name":"initialize","accounts":[{"name":"presaleAccount","isMut":true,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"tokenMint","isMut":false,"isSigner":false},{"name":"paymentWalletUsdtAccount","isMut":false,"isSigner":false},{"name":"usdtMint","isMut":false,"isSigner":false},{"name":"paymentWallet","isMut":false,"isSigner":false},{"name":"authority","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"owner","type":"publicKey"},{"name":"admin","type":"publicKey"},{"name":"startTime","type":"i64"},{"name":"endTime","type":"i64"},{"name":"claimStartTime","type":"i64"},{"name":"maxTokensToSell","type":"u64"},{"name":"tierThresholds","type":{"vec":"u64"}},{"name":"tierPrices","type":{"vec":"u64"}},{"name":"tierEndTimes","type":{"vec":"i64"}},{"name":"currentTier","type":"u8"},{"name":"timeConstant","type":"i64"},{"name":"tokenDecimals","type":"u8"}]},{"name":"setPause","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"pause","type":"bool"}]},{"name":"setOwner","accounts":[{"name":"presaleAccount","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"owner","type":"publicKey"}]},{"name":"setAdmin","accounts":[{"name":"presaleAccount","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"admin","type":"publicKey"}]},{"name":"setEndTime","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"endTime","type":"i64"}]},{"name":"buyToken","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"userInfo","isMut":true,"isSigner":false},{"name":"pythPriceFeed","isMut":false,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"paymentWallet","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"tokenAmount","type":"u64"}]},{"name":"buyWithUsdt","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"userInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"paymentWalletUsdtAccount","isMut":true,"isSigner":false},{"name":"userUsdtAccount","isMut":true,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"tokenAmount","type":"u64"}]},{"name":"fundPresale","accounts":[{"name":"presaleAccount","isMut":true,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"presaleTokenAccount","isMut":true,"isSigner":false},{"name":"authority","isMut":true,"isSigner":true},{"name":"authorityTokenAccount","isMut":true,"isSigner":false},{"name":"tokenMint","isMut":false,"isSigner":false},{"name":"associatedTokenProgram","isMut":false,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"amount","type":"u64"}]},{"name":"claimTokens","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"userInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true},{"name":"userTokenAccount","isMut":true,"isSigner":false},{"name":"presaleTokenAccount","isMut":true,"isSigner":false},{"name":"tokenMint","isMut":false,"isSigner":false},{"name":"associatedTokenProgram","isMut":false,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[]},{"name":"modifyWhitelist","accounts":[{"name":"presaleAccount","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true}],"args":[{"name":"user","type":"publicKey"},{"name":"add","type":"bool"}]},{"name":"incrementCurrentRound","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true}],"args":[]},{"name":"setRounds","accounts":[{"name":"presaleAccount","isMut":false,"isSigner":false},{"name":"stateInfo","isMut":true,"isSigner":false},{"name":"signer","isMut":true,"isSigner":true}],"args":[{"name":"tierOriginalThresholds","type":{"vec":"u64"}},{"name":"tierThresholds","type":{"vec":"u64"}},{"name":"tierPrices","type":{"vec":"u64"}},{"name":"tierEndTimes","type":{"vec":"i64"}}]}],"accounts":[{"name":"PresaleAccount","type":{"kind":"struct","fields":[{"name":"owner","type":"publicKey"},{"name":"admin","type":"publicKey"},{"name":"paymentWallet","type":"publicKey"},{"name":"paymentWalletUsdtAccount","type":"publicKey"},{"name":"authority","type":"publicKey"},{"name":"tokenMint","type":"publicKey"},{"name":"bump","type":"u8"},{"name":"whitelist","type":{"vec":"publicKey"}}]}},{"name":"StateInfo","type":{"kind":"struct","fields":[{"name":"pause","type":"bool"},{"name":"totalUsdRaised","type":"u64"},{"name":"tokensSold","type":"u64"},{"name":"tokenPrice","type":"u64"},{"name":"tokensClaimed","type":"u64"},{"name":"tokenStock","type":"u64"},{"name":"startTime","type":"i64"},{"name":"endTime","type":"i64"},{"name":"claimStartTime","type":"i64"},{"name":"maxTokensToSell","type":"u64"},{"name":"tierOriginalThresholds","type":{"vec":"u64"}},{"name":"tierThresholds","type":{"vec":"u64"}},{"name":"tierPrices","type":{"vec":"u64"}},{"name":"tierEndTimes","type":{"vec":"i64"}},{"name":"tokensLeftUnsold","type":{"vec":"u64"}},{"name":"currentTier","type":"u8"},{"name":"timeConstant","type":"i64"},{"name":"tokenDecimals","type":"u8"}]}},{"name":"UserInfo","type":{"kind":"struct","fields":[{"name":"id","type":"publicKey"},{"name":"value","type":"u64"}]}}],"errors":[{"code":6000,"name":"Unauthorized","msg":"You are not authorized to perform this action."},{"code":6001,"name":"InvalidAmount","msg":"Amount should be greater than zero"},{"code":6002,"name":"InvalidPaymentAccount","msg":"Payment Wallet Address is not equal to Payment Wallet Address in presale_account"},{"code":6003,"name":"ContractPause","msg":"Contract is paused"},{"code":6004,"name":"CalculationError","msg":"Invalid Calculation Error"},{"code":6005,"name":"InvalidPriceFeed","msg":"Invalid Feed Address"},{"code":6006,"name":"InvalidTime","msg":"Invalid Time to buy"},{"code":6007,"name":"TierUpdateFailed","msg":"Unable to update tier, possibly already at the last tier or outside of presale period"},{"code":6008,"name":"PresaleCompleted","msg":"Presale has ended. No more token purchases allowed"},{"code":6009,"name":"MaxTokenLimit","msg":"token amount exceeds max tokens to buy in one transaction"},{"code":6010,"name":"InvalidTokenProgram","msg":"Invalid token program address."},{"code":6011,"name":"InvalidTimestamps","msg":"Invalid start and end Timestamps"}],"metadata":{"address":"BDYbC9kdQXVx7HeiUSvKJ7NjKB53v8fP8EqDJ7GERSNC"}}')
        },
        33997: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Staking","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"HarvestRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdraw","type":"event"},{"inputs":[{"internalType":"address","name":"_rewardTokenAddress","type":"address"},{"internalType":"address","name":"_presale","type":"address"},{"internalType":"uint256","name":"_rewardTokensPerBlock","type":"uint256"},{"internalType":"uint256","name":"_lockTime","type":"uint256"},{"internalType":"uint256","name":"_endBlock","type":"uint256"}],"name":"__stakingManager_init","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_usersToBlacklist","type":"address[]"}],"name":"blacklistUsers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimStart","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"depositByPresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"endBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"harvestLock","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"harvestRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isBlacklisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lockedTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"poolStakers","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"stakedTime","type":"uint256"},{"internalType":"uint256","name":"lastUpdatedBlock","type":"uint256"},{"internalType":"uint256","name":"Harvestedrewards","type":"uint256"},{"internalType":"uint256","name":"rewardDebt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"presaleContract","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_userToRemoveFromBlacklist","type":"address[]"}],"name":"removeFromBlacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rewardTokensPerBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_claimStart","type":"uint256"}],"name":"setClaimStart","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_endBlock","type":"uint256"}],"name":"setEndBlock","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_harvestlock","type":"bool"}],"name":"setHarvestLock","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_time","type":"uint256"}],"name":"setLockedTime","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_presale","type":"address"}],"name":"setPresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_stakeToken","type":"address"}],"name":"setStakeToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stakeToken","outputs":[{"internalType":"contract IERC20Upgradeable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokensStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokensStakedByPresale","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userLockedRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}]}')
        },
        75525: et => {
            "use strict";
            et.exports = JSON.parse('{"contractName":"Token","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"ecosystemFundsReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"exchangesReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"liquidityReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"marketingReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"presaleReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"projectFundsReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stakingReserve","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]}')
        }
    },
    et => {
        et(et.s = 65724)
    }
]);